<!DOCTYPE html>
<html><head><title>joekychen/linux » block › genhd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>genhd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  gendisk handling</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/kobj_map.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>

<span class="cp">#include &quot;blk.h&quot;</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">block_class_lock</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">block_depr</span><span class="p">;</span>

<span class="cm">/* for extended dynamic devt allocation, currently only one major is used */</span>
<span class="cp">#define MAX_EXT_DEVT		(1 &lt;&lt; MINORBITS)</span>

<span class="cm">/* For extended devt allocation.  ext_devt_mutex prevents look up</span>
<span class="cm"> * results from going away underneath its user.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ext_devt_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">ext_devt_idr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">disk_type</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">disk_alloc_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">disk_add_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">disk_del_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">disk_release_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * disk_get_part - get partition</span>
<span class="cm"> * @disk: disk to look partition from</span>
<span class="cm"> * @partno: partition number</span>
<span class="cm"> *</span>
<span class="cm"> * Look for partition @partno from @disk.  If found, increment</span>
<span class="cm"> * reference count and return it.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the found partition on success, NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="nf">disk_get_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">ptbl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">partno</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">ptbl</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">partno</span> <span class="o">&lt;</span> <span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="n">partno</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="p">)</span>
			<span class="n">get_device</span><span class="p">(</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">part</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">disk_get_part</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * disk_part_iter_init - initialize partition iterator</span>
<span class="cm"> * @piter: iterator to initialize</span>
<span class="cm"> * @disk: disk to iterate over</span>
<span class="cm"> * @flags: DISK_PITER_* flags</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize @piter so that it iterates over partitions of @disk.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disk_part_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="o">*</span><span class="n">piter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">ptbl</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ptbl</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">);</span>

	<span class="n">piter</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="n">disk</span><span class="p">;</span>
	<span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISK_PITER_REVERSE</span><span class="p">)</span>
		<span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DISK_PITER_INCL_PART0</span> <span class="o">|</span> <span class="n">DISK_PITER_INCL_EMPTY_PART0</span><span class="p">))</span>
		<span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">piter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">disk_part_iter_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * disk_part_iter_next - proceed iterator to the next partition and return it</span>
<span class="cm"> * @piter: iterator of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Proceed @piter to the next partition and return it.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="nf">disk_part_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="o">*</span><span class="n">piter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">ptbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inc</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/* put the last partition */</span>
	<span class="n">disk_put_part</span><span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">);</span>
	<span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* get part_tbl */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ptbl</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">);</span>

	<span class="cm">/* determine iteration parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISK_PITER_REVERSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DISK_PITER_INCL_PART0</span> <span class="o">|</span>
				    <span class="n">DISK_PITER_INCL_EMPTY_PART0</span><span class="p">))</span>
			<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* iterate to the next partition */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

		<span class="n">part</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">part</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nr_sects</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISK_PITER_INCL_EMPTY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISK_PITER_INCL_EMPTY_PART0</span> <span class="o">&amp;&amp;</span>
		      <span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">get_device</span><span class="p">(</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>
		<span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span> <span class="o">=</span> <span class="n">part</span><span class="p">;</span>
		<span class="n">piter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">disk_part_iter_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * disk_part_iter_exit - finish up partition iteration</span>
<span class="cm"> * @piter: iter of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Called when iteration is over.  Cleans up @piter.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disk_part_iter_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="o">*</span><span class="n">piter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disk_put_part</span><span class="p">(</span><span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">);</span>
	<span class="n">piter</span><span class="o">-&gt;</span><span class="n">part</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">disk_part_iter_exit</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sector_in_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">start_sect</span> <span class="o">&lt;=</span> <span class="n">sector</span> <span class="o">&amp;&amp;</span>
		<span class="n">sector</span> <span class="o">&lt;</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">start_sect</span> <span class="o">+</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">nr_sects</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disk_map_sector_rcu - map sector to partition</span>
<span class="cm"> * @disk: gendisk of interest</span>
<span class="cm"> * @sector: sector to map</span>
<span class="cm"> *</span>
<span class="cm"> * Find out which partition @sector maps to on @disk.  This is</span>
<span class="cm"> * primarily used for stats accounting.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * RCU read locked.  The returned partition pointer is valid only</span>
<span class="cm"> * while preemption is disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Found partition on success, part0 is returned if no partition matches</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="nf">disk_map_sector_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">ptbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ptbl</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">);</span>

	<span class="n">part</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">last_lookup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span> <span class="o">&amp;&amp;</span> <span class="n">sector_in_part</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">sector</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">part</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">part</span> <span class="o">&amp;&amp;</span> <span class="n">sector_in_part</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">sector</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">ptbl</span><span class="o">-&gt;</span><span class="n">last_lookup</span><span class="p">,</span> <span class="n">part</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">part</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">disk_map_sector_rcu</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Can be deleted altogether. Later.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">blk_major_name</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_major_name</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">major</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span> <span class="o">*</span><span class="n">major_names</span><span class="p">[</span><span class="n">BLKDEV_MAJOR_HASH_SIZE</span><span class="p">];</span>

<span class="cm">/* index in the above - for now: assume no multimajor ranges */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">major_to_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">major</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">major</span> <span class="o">%</span> <span class="n">BLKDEV_MAJOR_HASH_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">void</span> <span class="nf">blkdev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_major_name</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">BLKDEV_MAJOR_HASH_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dp</span> <span class="o">=</span> <span class="n">major_names</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span> <span class="n">dp</span><span class="p">;</span> <span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seqf</span><span class="p">,</span> <span class="s">&quot;%3d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * register_blkdev - register a new block device</span>
<span class="cm"> *</span>
<span class="cm"> * @major: the requested major device number [1..255]. If @major=0, try to</span>
<span class="cm"> *         allocate any unused major number.</span>
<span class="cm"> * @name: the name of the new block device as a zero terminated string</span>
<span class="cm"> *</span>
<span class="cm"> * The @name must be unique within the system.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value depends on the @major input parameter.</span>
<span class="cm"> *  - if a major device number was requested in range [1..255] then the</span>
<span class="cm"> *    function returns zero on success, or a negative error code</span>
<span class="cm"> *  - if any unused major number was requested with @major=0 parameter</span>
<span class="cm"> *    then the return value is the allocated major number in range</span>
<span class="cm"> *    [1..255] or a negative error code otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_blkdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_major_name</span> <span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>

	<span class="cm">/* temporary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">major</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">major_names</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">major_names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;register_blkdev: failed to get major for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">major</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">major</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_major_name</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">major</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">major_to_index</span><span class="p">(</span><span class="n">major</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">major_names</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">==</span> <span class="n">major</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">n</span><span class="p">)</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;register_blkdev: cannot get major %d for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">major</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_blkdev</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">unregister_blkdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_major_name</span> <span class="o">**</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_major_name</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">major_to_index</span><span class="p">(</span><span class="n">major</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">major_names</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">==</span> <span class="n">major</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">n</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">((</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_blkdev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_map</span> <span class="o">*</span><span class="n">bdev_map</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * blk_mangle_minor - scatter minor numbers apart</span>
<span class="cm"> * @minor: minor number to mangle</span>
<span class="cm"> *</span>
<span class="cm"> * Scatter consecutively allocated @minor number apart if MANGLE_DEVT</span>
<span class="cm"> * is enabled.  Mangling twice gives the original value.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Mangled value.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">blk_mangle_minor</span><span class="p">(</span><span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MINORBITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">minor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">minor</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">MINORBITS</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
		<span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">MINORBITS</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">minor</span> <span class="o">^=</span> <span class="n">low</span> <span class="o">|</span> <span class="n">high</span><span class="p">;</span>	<span class="cm">/* clear both bits */</span>
		<span class="n">low</span> <span class="o">&lt;&lt;=</span> <span class="n">distance</span><span class="p">;</span>	<span class="cm">/* swap the positions */</span>
		<span class="n">high</span> <span class="o">&gt;&gt;=</span> <span class="n">distance</span><span class="p">;</span>
		<span class="n">minor</span> <span class="o">|=</span> <span class="n">low</span> <span class="o">|</span> <span class="n">high</span><span class="p">;</span>	<span class="cm">/* and set */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">minor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_alloc_devt - allocate a dev_t for a partition</span>
<span class="cm"> * @part: partition to allocate dev_t for</span>
<span class="cm"> * @devt: out parameter for resulting dev_t</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a dev_t for block device.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, allocated dev_t is returned in *@devt.  -errno on</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_alloc_devt</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="n">dev_t</span> <span class="o">*</span><span class="n">devt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* in consecutive minor range? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span> <span class="o">&lt;</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">+</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate ext devt */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_idr</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">MAX_EXT_DEVT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_idr</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">BLOCK_EXT_MAJOR</span><span class="p">,</span> <span class="n">blk_mangle_minor</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_free_devt - free a dev_t</span>
<span class="cm"> * @devt: dev_t to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free @devt which was allocated using blk_alloc_devt().</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_free_devt</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devt</span> <span class="o">==</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_EXT_MAJOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_mutex</span><span class="p">);</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_idr</span><span class="p">,</span> <span class="n">blk_mangle_minor</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">)));</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">bdevt_str</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">tbuf</span><span class="p">[</span><span class="n">BDEVT_SIZE</span><span class="p">];</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="n">BDEVT_SIZE</span><span class="p">,</span> <span class="s">&quot;%02x%02x&quot;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">));</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BDEVT_SIZE</span><span class="p">,</span> <span class="s">&quot;%-9s&quot;</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BDEVT_SIZE</span><span class="p">,</span> <span class="s">&quot;%03x:%05x&quot;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register device numbers dev..(dev+range-1)</span>
<span class="cm"> * range must be nonzero</span>
<span class="cm"> * The hash chain is sorted on range, so that subranges can override.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_register_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobj_map</span><span class="p">(</span><span class="n">bdev_map</span><span class="p">,</span> <span class="n">devt</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_register_region</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_unregister_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobj_unmap</span><span class="p">(</span><span class="n">bdev_map</span><span class="p">,</span> <span class="n">devt</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_unregister_region</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">exact_match</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">partno</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exact_lock</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_disk</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">register_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">ddev</span> <span class="o">=</span> <span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ddev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">ddev</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>

	<span class="cm">/* delay uevents, until we scanned partition table */</span>
	<span class="n">dev_set_uevent_suppress</span><span class="p">(</span><span class="n">ddev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device_add</span><span class="p">(</span><span class="n">ddev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysfs_deprecated</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="n">block_depr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
					<span class="n">kobject_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device_del</span><span class="p">(</span><span class="n">ddev</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">holder_dir</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;holders&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">slave_dir</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;slaves&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>

	<span class="cm">/* No minors to use for partitions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk_part_scan_enabled</span><span class="p">(</span><span class="n">disk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* No such device (e.g., media were just removed) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">bdev</span> <span class="o">=</span> <span class="n">bdget_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_invalidated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">blkdev_get</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">blkdev_put</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="cm">/* announce disk after possible partitions are created */</span>
	<span class="n">dev_set_uevent_suppress</span><span class="p">(</span><span class="n">ddev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

	<span class="cm">/* announce possible partitions */</span>
	<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_disk - add partitioning information to kernel list</span>
<span class="cm"> * @disk: per-device partitioning information</span>
<span class="cm"> *</span>
<span class="cm"> * This function registers the partitioning information in @disk</span>
<span class="cm"> * with the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: error handling</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">devt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* minors == 0 indicates to use ext devt from part0 and should</span>
<span class="cm">	 * be accompanied with EXT_DEVT flag.  Make sure all</span>
<span class="cm">	 * parameters make sense.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">||</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_EXT_DEVT</span><span class="p">));</span>

	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GENHD_FL_UP</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">blk_alloc_devt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devt</span> <span class="o">=</span> <span class="n">devt</span><span class="p">;</span>

	<span class="cm">/* -&gt;major and -&gt;first_minor aren&#39;t supposed to be</span>
<span class="cm">	 * dereferenced from here on, but set them just in case.</span>
<span class="cm">	 */</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">);</span>

	<span class="n">disk_alloc_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

	<span class="cm">/* Register BDI before referencing it from bdev */</span>
	<span class="n">bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="n">bdi_register_dev</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">disk_devt</span><span class="p">(</span><span class="n">disk</span><span class="p">));</span>

	<span class="n">blk_register_region</span><span class="p">(</span><span class="n">disk_devt</span><span class="p">(</span><span class="n">disk</span><span class="p">),</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			    <span class="n">exact_match</span><span class="p">,</span> <span class="n">exact_lock</span><span class="p">,</span> <span class="n">disk</span><span class="p">);</span>
	<span class="n">register_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">blk_register_queue</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take an extra ref on queue which will be put on disk_release()</span>
<span class="cm">	 * so that it sticks around as long as @disk is there.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">blk_get_queue</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="s">&quot;bdi&quot;</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>

	<span class="n">disk_add_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">add_disk</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">del_gendisk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="n">disk_del_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

	<span class="cm">/* invalidate stuff */</span>
	<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span>
			     <span class="n">DISK_PITER_INCL_EMPTY</span> <span class="o">|</span> <span class="n">DISK_PITER_REVERSE</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">invalidate_partition</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">);</span>
		<span class="n">delete_partition</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>

	<span class="n">invalidate_partition</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">blk_free_devt</span><span class="p">(</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">);</span>
	<span class="n">set_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GENHD_FL_UP</span><span class="p">;</span>

	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;bdi&quot;</span><span class="p">);</span>
	<span class="n">bdi_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">);</span>
	<span class="n">blk_unregister_queue</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">blk_unregister_region</span><span class="p">(</span><span class="n">disk_devt</span><span class="p">(</span><span class="n">disk</span><span class="p">),</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span><span class="p">);</span>

	<span class="n">part_stat_set_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kobject_put</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">holder_dir</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">slave_dir</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysfs_deprecated</span><span class="p">)</span>
		<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="n">block_depr</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)));</span>
	<span class="n">device_del</span><span class="p">(</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">del_gendisk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * get_gendisk - get partitioning information for a given device</span>
<span class="cm"> * @devt: device to get partitioning information for</span>
<span class="cm"> * @partno: returned partition index</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets the structure containing partitioning</span>
<span class="cm"> * information for the given device @devt.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="nf">get_gendisk</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BLOCK_EXT_MAJOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>

		<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobj_lookup</span><span class="p">(</span><span class="n">bdev_map</span><span class="p">,</span> <span class="n">devt</span><span class="p">,</span> <span class="n">partno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span>
			<span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">kobj_to_dev</span><span class="p">(</span><span class="n">kobj</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_mutex</span><span class="p">);</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_idr</span><span class="p">,</span> <span class="n">blk_mangle_minor</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span> <span class="o">&amp;&amp;</span> <span class="n">get_disk</span><span class="p">(</span><span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">partno</span> <span class="o">=</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">;</span>
			<span class="n">disk</span> <span class="o">=</span> <span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ext_devt_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">disk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_gendisk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bdget_disk - do bdget() by gendisk and partition number</span>
<span class="cm"> * @disk: gendisk of interest</span>
<span class="cm"> * @partno: partition number</span>
<span class="cm"> *</span>
<span class="cm"> * Find partition @partno from @disk, do bdget() on it.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Resulting block_device on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="nf">bdget_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">part</span> <span class="o">=</span> <span class="n">disk_get_part</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">partno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="p">)</span>
		<span class="n">bdev</span> <span class="o">=</span> <span class="n">bdget</span><span class="p">(</span><span class="n">part_devt</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>
	<span class="n">disk_put_part</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bdev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdget_disk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * print a full list of all partitions - intended for places where the root</span>
<span class="cm"> * filesystem can&#39;t be mounted and thus to give the victim some idea of what</span>
<span class="cm"> * went wrong</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">printk_all_partitions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">class_dev_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_type</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">class_dev_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">name_buf</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">devt_buf</span><span class="p">[</span><span class="n">BDEVT_SIZE</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">uuid_buf</span><span class="p">[</span><span class="n">PARTITION_META_INFO_UUIDLTH</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t show empty devices or things that have been</span>
<span class="cm">		 * suppressed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_capacity</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_SUPPRESS_PARTITION_INFO</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note, unlike /proc/partitions, I am showing the</span>
<span class="cm">		 * numbers in hex - the same format as the root=</span>
<span class="cm">		 * option takes.</span>
<span class="cm">		 */</span>
		<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">DISK_PITER_INCL_PART0</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">is_part0</span> <span class="o">=</span> <span class="n">part</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">;</span>

			<span class="n">uuid_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">uuid_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_buf</span><span class="p">),</span> <span class="s">&quot;%pU&quot;</span><span class="p">,</span>
					 <span class="n">part</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%s %10llu %s %s&quot;</span><span class="p">,</span> <span class="n">is_part0</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;  &quot;</span><span class="p">,</span>
			       <span class="n">bdevt_str</span><span class="p">(</span><span class="n">part_devt</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">devt_buf</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nr_sects</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">disk_name</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">,</span> <span class="n">name_buf</span><span class="p">),</span>
			       <span class="n">uuid_buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_part0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
				    <span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot; driver: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					      <span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (driver?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">class_dev_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* iterator */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">disk_seqf_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">skip</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">seqf</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
	<span class="n">class_dev_iter_init</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_type</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">class_dev_iter_next</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">skip</span><span class="o">--</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">disk_seqf_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">class_dev_iter_next</span><span class="p">(</span><span class="n">seqf</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_seqf_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seqf</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/* stop is called even after start failed :-( */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">class_dev_iter_exit</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">show_partition_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">disk_seqf_start</span><span class="p">(</span><span class="n">seqf</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!*</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seqf</span><span class="p">,</span> <span class="s">&quot;major minor  #blocks  name</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">sgp</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="cm">/* Don&#39;t show non-partitionable removeable devices or empty devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_capacity</span><span class="p">(</span><span class="n">sgp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">disk_max_parts</span><span class="p">(</span><span class="n">sgp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_REMOVABLE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_SUPPRESS_PARTITION_INFO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* show the full disk and all non-0 size partitions of it */</span>
	<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">sgp</span><span class="p">,</span> <span class="n">DISK_PITER_INCL_PART0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seqf</span><span class="p">,</span> <span class="s">&quot;%4d  %7d %10llu %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">MAJOR</span><span class="p">(</span><span class="n">part_devt</span><span class="p">(</span><span class="n">part</span><span class="p">)),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">part_devt</span><span class="p">(</span><span class="n">part</span><span class="p">)),</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">nr_sects</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="n">disk_name</span><span class="p">(</span><span class="n">sgp</span><span class="p">,</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
	<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">partitions_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">show_partition_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">disk_seqf_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">disk_seqf_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">show_partition</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">partitions_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">partitions_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_partitions_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">partitions_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">base_probe</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">partno</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_module</span><span class="p">(</span><span class="s">&quot;block-major-%d-%d&quot;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">devt</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Make old-style 2.4 aliases work */</span>
		<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;block-major-%d&quot;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">devt</span><span class="p">));</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">genhd_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">block_class</span><span class="p">.</span><span class="n">dev_kobj</span> <span class="o">=</span> <span class="n">sysfs_dev_block_kobj</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">bdev_map</span> <span class="o">=</span> <span class="n">kobj_map_init</span><span class="p">(</span><span class="n">base_probe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_class_lock</span><span class="p">);</span>
	<span class="n">blk_dev_init</span><span class="p">();</span>

	<span class="n">register_blkdev</span><span class="p">(</span><span class="n">BLOCK_EXT_MAJOR</span><span class="p">,</span> <span class="s">&quot;blkext&quot;</span><span class="p">);</span>

	<span class="cm">/* create top-level block dir */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysfs_deprecated</span><span class="p">)</span>
		<span class="n">block_depr</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;block&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">genhd_device_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_range_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_ext_range_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">disk_max_parts</span><span class="p">(</span><span class="n">disk</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_removable_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_REMOVABLE</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_ro_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">get_disk_ro</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_capability_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_alignment_offset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue_alignment_offset</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_discard_alignment_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">queue_discard_alignment</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_range_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ext_range</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_ext_range_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">removable</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_removable_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_ro_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">part_size_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">alignment_offset</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_alignment_offset_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">discard_alignment</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_discard_alignment_show</span><span class="p">,</span>
		   <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">capability</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_capability_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">part_stat_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">inflight</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">part_inflight_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FAIL_MAKE_REQUEST</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_fail</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">make</span><span class="o">-</span><span class="n">it</span><span class="o">-</span><span class="n">fail</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">part_fail_show</span><span class="p">,</span> <span class="n">part_fail_store</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FAIL_IO_TIMEOUT</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_fail_timeout</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">io</span><span class="o">-</span><span class="n">timeout</span><span class="o">-</span><span class="n">fail</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">part_timeout_show</span><span class="p">,</span>
		<span class="n">part_timeout_store</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">disk_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_range</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_ext_range</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_removable</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_ro</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_size</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_alignment_offset</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_discard_alignment</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_capability</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_stat</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_inflight</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_FAIL_MAKE_REQUEST</span>
	<span class="o">&amp;</span><span class="n">dev_attr_fail</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FAIL_IO_TIMEOUT</span>
	<span class="o">&amp;</span><span class="n">dev_attr_fail_timeout</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">disk_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">disk_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">disk_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">disk_attr_group</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * disk_replace_part_tbl - replace disk-&gt;part_tbl in RCU-safe way</span>
<span class="cm"> * @disk: disk to replace part_tbl for</span>
<span class="cm"> * @new_ptbl: new part_tbl to install</span>
<span class="cm"> *</span>
<span class="cm"> * Replace disk-&gt;part_tbl with @new_ptbl in RCU-safe way.  The</span>
<span class="cm"> * original ptbl is freed using RCU callback.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Matching bd_mutx locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_replace_part_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">new_ptbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">old_ptbl</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">,</span> <span class="n">new_ptbl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_ptbl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">old_ptbl</span><span class="o">-&gt;</span><span class="n">last_lookup</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">old_ptbl</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disk_expand_part_tbl - expand disk-&gt;part_tbl</span>
<span class="cm"> * @disk: disk to expand part_tbl for</span>
<span class="cm"> * @partno: expand such that this partno can fit in</span>
<span class="cm"> *</span>
<span class="cm"> * Expand disk-&gt;part_tbl such that @partno can fit in.  disk-&gt;part_tbl</span>
<span class="cm"> * uses RCU to allow unlocked dereferencing for stats and other stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Matching bd_mutex locked, might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">disk_expand_part_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">old_ptbl</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="o">*</span><span class="n">new_ptbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">old_ptbl</span> <span class="o">?</span> <span class="n">old_ptbl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">partno</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* disk_max_parts() is zero during initialization, ignore if so */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk_max_parts</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">disk_max_parts</span><span class="p">(</span><span class="n">disk</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_ptbl</span><span class="p">)</span> <span class="o">+</span> <span class="n">target</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_ptbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">new_ptbl</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ptbl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">new_ptbl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">new_ptbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">old_ptbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">disk_replace_part_tbl</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">new_ptbl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">disk_release_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">random</span><span class="p">);</span>
	<span class="n">disk_replace_part_tbl</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_part_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">);</span>
	<span class="n">free_part_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span>
		<span class="n">blk_put_queue</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">class</span> <span class="n">block_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;block&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">block_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">devnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">devnode</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">disk_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;disk&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">groups</span>		<span class="o">=</span> <span class="n">disk_attr_groups</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">disk_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">devnode</span>	<span class="o">=</span> <span class="n">block_devnode</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/*</span>
<span class="cm"> * aggregate disk stat collector.  Uses the same stats that the sysfs</span>
<span class="cm"> * entries do, above, but makes them available through one seq_file.</span>
<span class="cm"> *</span>
<span class="cm"> * The output looks suspiciously like /proc/partitions with a bunch of</span>
<span class="cm"> * extra fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diskstats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seqf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gp</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">hd</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	if (&amp;disk_to_dev(gp)-&gt;kobj.entry == block_class.devices.next)</span>
<span class="cm">		seq_puts(seqf,	&quot;major minor name&quot;</span>
<span class="cm">				&quot;     rio rmerge rsect ruse wio wmerge &quot;</span>
<span class="cm">				&quot;wsect wuse running use aveq&quot;</span>
<span class="cm">				&quot;\n\n&quot;);</span>
<span class="cm">	*/</span>

	<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">DISK_PITER_INCL_EMPTY_PART0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">hd</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">part_stat_lock</span><span class="p">();</span>
		<span class="n">part_round_stats</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">hd</span><span class="p">);</span>
		<span class="n">part_stat_unlock</span><span class="p">();</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seqf</span><span class="p">,</span> <span class="s">&quot;%4d %7d %s %lu %lu %lu &quot;</span>
			   <span class="s">&quot;%u %lu %lu %lu %u %u %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">MAJOR</span><span class="p">(</span><span class="n">part_devt</span><span class="p">(</span><span class="n">hd</span><span class="p">)),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">part_devt</span><span class="p">(</span><span class="n">hd</span><span class="p">)),</span>
			   <span class="n">disk_name</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="n">hd</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span>
			   <span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">ios</span><span class="p">[</span><span class="n">READ</span><span class="p">]),</span>
			   <span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">merges</span><span class="p">[</span><span class="n">READ</span><span class="p">]),</span>
			   <span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">sectors</span><span class="p">[</span><span class="n">READ</span><span class="p">]),</span>
			   <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">ticks</span><span class="p">[</span><span class="n">READ</span><span class="p">])),</span>
			   <span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">ios</span><span class="p">[</span><span class="n">WRITE</span><span class="p">]),</span>
			   <span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">merges</span><span class="p">[</span><span class="n">WRITE</span><span class="p">]),</span>
			   <span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">sectors</span><span class="p">[</span><span class="n">WRITE</span><span class="p">]),</span>
			   <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">ticks</span><span class="p">[</span><span class="n">WRITE</span><span class="p">])),</span>
			   <span class="n">part_in_flight</span><span class="p">(</span><span class="n">hd</span><span class="p">),</span>
			   <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">io_ticks</span><span class="p">)),</span>
			   <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">part_stat_read</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="n">time_in_queue</span><span class="p">))</span>
			<span class="p">);</span>
	<span class="p">}</span>
	<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">diskstats_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">disk_seqf_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">disk_seqf_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">disk_seqf_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">diskstats_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">diskstats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">diskstats_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_diskstats_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">diskstats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">proc_genhd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;diskstats&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_diskstats_operations</span><span class="p">);</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;partitions&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_partitions_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">proc_genhd_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="n">dev_t</span> <span class="nf">blk_lookup_devt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_t</span> <span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">class_dev_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_type</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">class_dev_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">name</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">partno</span> <span class="o">&lt;</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We need to return the right devno, even</span>
<span class="cm">			 * if the partition doesn&#39;t exist yet.</span>
<span class="cm">			 */</span>
			<span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">),</span>
				     <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">)</span> <span class="o">+</span> <span class="n">partno</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">disk_get_part</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">partno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devt</span> <span class="o">=</span> <span class="n">part_devt</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="n">disk_put_part</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">disk_put_part</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">class_dev_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">devt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_lookup_devt</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="nf">alloc_disk</span><span class="p">(</span><span class="kt">int</span> <span class="n">minors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_disk_node</span><span class="p">(</span><span class="n">minors</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_disk</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="nf">alloc_disk_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">minors</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>

	<span class="n">disk</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">node_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_part_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disk_expand_part_tbl</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_part_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">;</span>

		<span class="n">hd_ref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">);</span>

		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span> <span class="o">=</span> <span class="n">minors</span><span class="p">;</span>
		<span class="n">rand_initialize_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
		<span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_class</span><span class="p">;</span>
		<span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">disk_type</span><span class="p">;</span>
		<span class="n">device_initialize</span><span class="p">(</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">disk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_disk_node</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">get_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">owner</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">kobj</span><span class="p">;</span>

<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_disk</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">put_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="p">)</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">put_disk</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_disk_ro_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ro</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">event</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;DISK_RO=1&quot;</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">event</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ro</span><span class="p">)</span>
		<span class="n">event</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="n">kobject_uevent_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">gd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_device_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_part</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_device_ro</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">set_disk_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_disk_ro_uevent</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">DISK_PITER_INCL_EMPTY</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span>
		<span class="n">part</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_disk_ro</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bdev_read_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_part</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdev_read_only</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">invalidate_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bdget_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">partno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fsync_bdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">__invalidate_device</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">bdput</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">invalidate_partition</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Disk events - monitor disk events like media change and eject request.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">disk_events</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>		<span class="cm">/* all disk_event&#39;s */</span>
	<span class="k">struct</span> <span class="n">gendisk</span>		<span class="o">*</span><span class="n">disk</span><span class="p">;</span>		<span class="cm">/* the associated disk */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">block_mutex</span><span class="p">;</span>	<span class="cm">/* protects blocking */</span>
	<span class="kt">int</span>			<span class="n">block</span><span class="p">;</span>		<span class="cm">/* event blocking depth */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pending</span><span class="p">;</span>	<span class="cm">/* events already sent out */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">clearing</span><span class="p">;</span>	<span class="cm">/* events being cleared */</span>

	<span class="kt">long</span>			<span class="n">poll_msecs</span><span class="p">;</span>	<span class="cm">/* interval, -1 for default */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">dwork</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">disk_events_strs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">ilog2</span><span class="p">(</span><span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">)]</span>	<span class="o">=</span> <span class="s">&quot;media_change&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ilog2</span><span class="p">(</span><span class="n">DISK_EVENT_EJECT_REQUEST</span><span class="p">)]</span>	<span class="o">=</span> <span class="s">&quot;eject_request&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">disk_uevents</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">ilog2</span><span class="p">(</span><span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">)]</span>	<span class="o">=</span> <span class="s">&quot;DISK_MEDIA_CHANGE=1&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ilog2</span><span class="p">(</span><span class="n">DISK_EVENT_EJECT_REQUEST</span><span class="p">)]</span>	<span class="o">=</span> <span class="s">&quot;DISK_EJECT_REQUEST=1&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* list of all disk_events */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">disk_events_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">disk_events</span><span class="p">);</span>

<span class="cm">/* disable in-kernel polling by default */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">disk_events_dfl_poll_msecs</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">disk_events_poll_jiffies</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">intv_msecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If device-specific poll interval is set, always use it.  If</span>
<span class="cm">	 * the default is being used, poll iff there are events which</span>
<span class="cm">	 * can&#39;t be monitored asynchronously.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">poll_msecs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">intv_msecs</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">poll_msecs</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">async_events</span><span class="p">)</span>
		<span class="n">intv_msecs</span> <span class="o">=</span> <span class="n">disk_events_dfl_poll_msecs</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">intv_msecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disk_block_events - block and flush disk event checking</span>
<span class="cm"> * @disk: disk to block events for</span>
<span class="cm"> *</span>
<span class="cm"> * On return from this function, it is guaranteed that event checking</span>
<span class="cm"> * isn&#39;t in progress and won&#39;t happen until unblocked by</span>
<span class="cm"> * disk_unblock_events().  Events blocking is counted and the actual</span>
<span class="cm"> * unblocking happens after the matching number of unblocks are done.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this intentionally does not block event checking from</span>
<span class="cm"> * disk_clear_events().</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disk_block_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cancel</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Outer mutex ensures that the first blocker completes canceling</span>
<span class="cm">	 * the event work before further blockers are allowed to finish.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block_mutex</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cancel</span> <span class="o">=</span> <span class="o">!</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cancel</span><span class="p">)</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__disk_unblock_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">check_now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not exactly a latency critical operation, set poll timer</span>
<span class="cm">	 * slack to 25% and kick event check.</span>
<span class="cm">	 */</span>
	<span class="n">intv</span> <span class="o">=</span> <span class="n">disk_events_poll_jiffies</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">set_timer_slack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">intv</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_now</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">intv</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="n">intv</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disk_unblock_events - unblock disk event checking</span>
<span class="cm"> * @disk: disk to unblock events for</span>
<span class="cm"> *</span>
<span class="cm"> * Undo disk_block_events().  When the block count reaches zero, it</span>
<span class="cm"> * starts events polling if configured.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t care.  Safe to call from irq context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disk_unblock_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">__disk_unblock_events</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disk_flush_events - schedule immediate event checking and flushing</span>
<span class="cm"> * @disk: disk to check and flush events for</span>
<span class="cm"> * @mask: events to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Schedule immediate event checking on @disk if not blocked.  Events in</span>
<span class="cm"> * @mask are scheduled to be cleared from the driver.  Note that this</span>
<span class="cm"> * doesn&#39;t clear the events from @disk-&gt;ev.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * If @mask is non-zero must be called with bdev-&gt;bd_mutex held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disk_flush_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">clearing</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disk_clear_events - synchronously check, clear and return pending events</span>
<span class="cm"> * @disk: disk to fetch and clear events from</span>
<span class="cm"> * @mask: mask of events to be fetched and clearted</span>
<span class="cm"> *</span>
<span class="cm"> * Disk events are synchronously checked and pending events in @mask</span>
<span class="cm"> * are cleared and returned.  This ignores the block count.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">disk_clear_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="o">*</span><span class="n">bdops</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pending</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for drivers still using the old -&gt;media_changed method */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bdops</span><span class="o">-&gt;</span><span class="n">media_changed</span> <span class="o">&amp;&amp;</span> <span class="n">bdops</span><span class="o">-&gt;</span><span class="n">media_changed</span><span class="p">(</span><span class="n">disk</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* tell the workfn about the events being cleared */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">clearing</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* uncondtionally schedule event check and wait for it to finish */</span>
	<span class="n">disk_block_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">flush_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">);</span>
	<span class="n">__disk_unblock_events</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* then, fetch and clear pending events */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">clearing</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>	<span class="cm">/* cleared by workfn */</span>
	<span class="n">pending</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pending</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_events_workfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span> <span class="o">=</span> <span class="n">to_delayed_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dwork</span><span class="p">,</span> <span class="k">struct</span> <span class="n">disk_events</span><span class="p">,</span> <span class="n">dwork</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">disk_uevents</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clearing</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">clearing</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* check events */</span>
	<span class="n">events</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">check_events</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">clearing</span><span class="p">);</span>

	<span class="cm">/* accumulate pending events and schedule next poll if necessary */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">|=</span> <span class="n">events</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">clearing</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">clearing</span><span class="p">;</span>

	<span class="n">intv</span> <span class="o">=</span> <span class="n">disk_events_poll_jiffies</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">&amp;&amp;</span> <span class="n">intv</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_nrt_freezable_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="n">intv</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell userland about new events.  Only the events listed in</span>
<span class="cm">	 * @disk-&gt;events are reported.  Unlisted events are processed the</span>
<span class="cm">	 * same internally but never get reported to userland.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">disk_uevents</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">envp</span><span class="p">[</span><span class="n">nr_events</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">disk_uevents</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_events</span><span class="p">)</span>
		<span class="n">kobject_uevent_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A disk events enabled device has the following sysfs nodes under</span>
<span class="cm"> * its /sys/block/X/ directory.</span>
<span class="cm"> *</span>
<span class="cm"> * events		: list of all supported events</span>
<span class="cm"> * events_async		: list of events which can be detected w/o polling</span>
<span class="cm"> * events_poll_msecs	: polling interval, 0: disable, -1: system default</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__disk_events_show</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">delim</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">disk_events_strs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span>
				       <span class="n">delim</span><span class="p">,</span> <span class="n">disk_events_strs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">delim</span> <span class="o">=</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_events_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__disk_events_show</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_events_async_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__disk_events_show</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">async_events</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_events_poll_msecs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">poll_msecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">disk_events_poll_msecs_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">intv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span> <span class="o">||</span> <span class="o">!</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%ld&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intv</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">intv</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">disk_block_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">poll_msecs</span> <span class="o">=</span> <span class="n">intv</span><span class="p">;</span>
	<span class="n">__disk_unblock_events</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_events_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">events_async</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">disk_events_async_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">events_poll_msecs</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span>
			 <span class="n">disk_events_poll_msecs_show</span><span class="p">,</span>
			 <span class="n">disk_events_poll_msecs_store</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">disk_events_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_events</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_events_async</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_events_poll_msecs</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The default polling interval can be specified by the kernel</span>
<span class="cm"> * parameter block.events_dfl_poll_msecs which defaults to 0</span>
<span class="cm"> * (disable).  This can also be modified runtime by writing to</span>
<span class="cm"> * /sys/module/block/events_dfl_poll_msecs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">disk_events_set_dfl_poll_msecs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">param_set_ulong</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_events_mutex</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_events</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">disk_flush_events</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_events_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">disk_events_dfl_poll_msecs_param_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set</span>	<span class="o">=</span> <span class="n">disk_events_set_dfl_poll_msecs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>	<span class="o">=</span> <span class="n">param_get_ulong</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#undef MODULE_PARAM_PREFIX</span>
<span class="cp">#define MODULE_PARAM_PREFIX	&quot;block.&quot;</span>

<span class="n">module_param_cb</span><span class="p">(</span><span class="n">events_dfl_poll_msecs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_events_dfl_poll_msecs_param_ops</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">disk_events_dfl_poll_msecs</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * disk_{alloc|add|del|release}_events - initialize and destroy disk_events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_alloc_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">check_events</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: failed to initialize events</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="n">disk</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block_mutex</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">poll_msecs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="n">disk_events_workfn</span><span class="p">);</span>

	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_add_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* FIXME: error handling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_create_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">disk_events_attrs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: failed to create sysfs files for events</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_events_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_events</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_events_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Block count is initialized to 1 and the following initial</span>
<span class="cm">	 * unblock kicks it into action.</span>
<span class="cm">	 */</span>
	<span class="n">__disk_unblock_events</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_del_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">disk_block_events</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_events_mutex</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_events_mutex</span><span class="p">);</span>

	<span class="n">sysfs_remove_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">disk_events_attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disk_release_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* the block count should be 1 from disk_del_events() */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">&amp;&amp;</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
