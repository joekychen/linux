<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › endpointola.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>endpointola.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2002 International Business Machines, Corp.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 Nokia, Inc.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * This abstraction represents an SCTP endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * The SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * The SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm &lt;jgrimm@austin.ibm.com&gt;</span>
<span class="cm"> *    Daisy Chang &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Dajiang Zhang &lt;dajiang.zhang@nokia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;	</span><span class="cm">/* get_random_bytes() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="cm">/* Forward declarations for internal helpers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_endpoint_bh_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the base fields of the endpoint structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="nf">sctp_endpoint_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hmac_algo_param</span> <span class="o">*</span><span class="n">auth_hmacs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunks_param</span> <span class="o">*</span><span class="n">auth_chunks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_shared_key</span> <span class="o">*</span><span class="n">null_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">digest</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SCTP_SIGNATURE_SIZE</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Allocate space for HMACS and CHUNKS authentication</span>
<span class="cm">		 * variables.  There are arrays that we encode directly</span>
<span class="cm">		 * into parameters to make the rest of the operations easier.</span>
<span class="cm">		 */</span>
		<span class="n">auth_hmacs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_hmac_algo_param_t</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">SCTP_AUTH_NUM_HMACS</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">auth_hmacs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="n">auth_chunks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunks_param_t</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">SCTP_NUM_CHUNK_TYPES</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">auth_chunks</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="cm">/* Initialize the HMACS parameter.</span>
<span class="cm">		 * SCTP-AUTH: Section 3.3</span>
<span class="cm">		 *    Every endpoint supporting SCTP chunk authentication MUST</span>
<span class="cm">		 *    support the HMAC based on the SHA-1 algorithm.</span>
<span class="cm">		 */</span>
		<span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_HMAC_ALGO</span><span class="p">;</span>
		<span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
					<span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">hmac_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SCTP_AUTH_HMAC_ID_SHA1</span><span class="p">);</span>

		<span class="cm">/* Initialize the CHUNKS parameter */</span>
		<span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_CHUNKS</span><span class="p">;</span>
		<span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">));</span>

		<span class="cm">/* If the Add-IP functionality is enabled, we must</span>
<span class="cm">		 * authenticate, ASCONF and ASCONF-ACK chunks</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_ASCONF</span><span class="p">;</span>
			<span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_ASCONF_ACK</span><span class="p">;</span>
			<span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
					<span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the base structure. */</span>
	<span class="cm">/* What type of endpoint are we?  */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_EP_TYPE_SOCKET</span><span class="p">;</span>

	<span class="cm">/* Initialize the basic object fields. */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Create an input queue.  */</span>
	<span class="n">sctp_inq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">);</span>

	<span class="cm">/* Set its top-half handler */</span>
	<span class="n">sctp_inq_set_th_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">,</span> <span class="n">sctp_endpoint_bh_rcv</span><span class="p">);</span>

	<span class="cm">/* Initialize the bind addr area */</span>
	<span class="n">sctp_bind_addr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Remember who we are attached to.  */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Create the lists of associations.  */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">);</span>

	<span class="cm">/* Use SCTP specific send buffer space queues.  */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">sndbuf_policy</span> <span class="o">=</span> <span class="n">sctp_sndbuf_policy</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">sctp_data_ready</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">sctp_write_space</span><span class="p">;</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_USE_WRITE_QUEUE</span><span class="p">);</span>

	<span class="cm">/* Get the receive buffer policy for this endpoint */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rcvbuf_policy</span> <span class="o">=</span> <span class="n">sctp_rcvbuf_policy</span><span class="p">;</span>

	<span class="cm">/* Initialize the secret key used with cookie. */</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">secret_key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SCTP_SECRET_SIZE</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">last_key</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">current_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">key_changed_at</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH extensions*/</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">endpoint_shared_keys</span><span class="p">);</span>
	<span class="n">null_key</span> <span class="o">=</span> <span class="n">sctp_auth_shkey_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">null_key</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">null_key</span><span class="o">-&gt;</span><span class="n">key_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">endpoint_shared_keys</span><span class="p">);</span>

	<span class="cm">/* Allocate and initialize transorms arrays for suported HMACs. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_auth_init_hmacs</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_hmacs</span><span class="p">;</span>

	<span class="cm">/* Add the null key to the endpoint shared keys list and</span>
<span class="cm">	 * set the hmcas and chunks pointers.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs_list</span> <span class="o">=</span> <span class="n">auth_hmacs</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_chunk_list</span> <span class="o">=</span> <span class="n">auth_chunks</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>

<span class="nl">nomem_hmacs:</span>
	<span class="n">sctp_auth_destroy_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">endpoint_shared_keys</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="cm">/* Free all allocations */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">auth_hmacs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">auth_chunks</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* Create a sctp_endpoint with all that boring stuff initialized.</span>
<span class="cm"> * Returns NULL if there isn&#39;t enough memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="nf">sctp_endpoint_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* Build a local endpoint. */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">t_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_endpoint_init</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">SCTP_DBG_OBJCNT_INC</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>

<span class="nl">fail_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add an association to an endpoint.  */</span>
<span class="kt">void</span> <span class="nf">sctp_endpoint_add_asoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* If this is a temporary association, don&#39;t bother</span>
<span class="cm">	 * since we&#39;ll be removing it shortly and don&#39;t</span>
<span class="cm">	 * want anyone to find it anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Now just add it to our list of asocs */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">);</span>

	<span class="cm">/* Increment the backlog value for a TCP-style listening socket. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free the endpoint structure.  Delay cleanup until</span>
<span class="cm"> * all users have released their reference count on this structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_endpoint_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_CLOSED</span><span class="p">;</span>

	<span class="cm">/* Unlink this endpoint, so we can&#39;t find it again! */</span>
	<span class="n">sctp_unhash_endpoint</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Final destructor for endpoint.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_endpoint_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">,</span> <span class="s">&quot;Endpoint is not dead&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>

	<span class="cm">/* Free up the HMAC transform. */</span>
	<span class="n">crypto_free_hash</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span><span class="p">);</span>

	<span class="cm">/* Free the digest buffer */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">);</span>

	<span class="cm">/* SCTP-AUTH: Free up AUTH releated data such as shared keys</span>
<span class="cm">	 * chunks and hmacs arrays that were allocated</span>
<span class="cm">	 */</span>
	<span class="n">sctp_auth_destroy_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">endpoint_shared_keys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_chunk_list</span><span class="p">);</span>

	<span class="cm">/* AUTH - Free any allocated HMAC transform containers */</span>
	<span class="n">sctp_auth_destroy_hmacs</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs</span><span class="p">);</span>

	<span class="cm">/* Cleanup. */</span>
	<span class="n">sctp_inq_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">);</span>
	<span class="n">sctp_bind_addr_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">);</span>

	<span class="cm">/* Remove and free the port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span><span class="p">)</span>
		<span class="n">sctp_put_port</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Give up our hold on the sock. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Finally, free up our memory. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">malloced</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">SCTP_DBG_OBJCNT_DEC</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Hold a reference to an endpoint. */</span>
<span class="kt">void</span> <span class="nf">sctp_endpoint_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Release a reference to an endpoint and clean up if there are</span>
<span class="cm"> * no more references.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_endpoint_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">sctp_endpoint_destroy</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Is this the endpoint we are looking for?  */</span>
<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="nf">sctp_endpoint_is_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					       <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">htons</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_bind_addr_match</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span>
					 <span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find the association that goes with this chunk.</span>
<span class="cm"> * We do a linear search of the associations for this endpoint.</span>
<span class="cm"> * We return the matching transport address too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_endpoint_lookup_assoc</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rport</span><span class="p">;</span>

	<span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If the local port is not set, there can&#39;t be any associations</span>
<span class="cm">	 * on this endpoint.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rport</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">paddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">sctp_assoc_hashfn</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">rport</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_assoc_hashtable</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sctp_for_each_hentry</span><span class="p">(</span><span class="n">epb</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">sctp_assoc</span><span class="p">(</span><span class="n">epb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">!=</span> <span class="n">ep</span> <span class="o">||</span> <span class="n">rport</span> <span class="o">!=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lookup association on an endpoint based on a peer address.  BH-safe.  */</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_endpoint_lookup_assoc</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_endpoint_lookup_assoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look for any peeled off association from the endpoint that matches the</span>
<span class="cm"> * given peer address.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_endpoint_is_peeled_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="cm">/* This function is called with the socket lock held,</span>
<span class="cm">	 * so the address_list can not change.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_has_association</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">paddr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do delayed input processing.  This is scheduled by sctp_rcv().</span>
<span class="cm"> * This may be called on BH or task time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_endpoint_bh_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span><span class="p">,</span>
			     <span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">.</span><span class="n">immediate</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="n">inqueue</span><span class="p">;</span>
	<span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* is this the first time through the loop */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inqueue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_inq_pop</span><span class="p">(</span><span class="n">inqueue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">subtype</span> <span class="o">=</span> <span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

		<span class="cm">/* If the first chunk in the packet is AUTH, do special</span>
<span class="cm">		 * processing specified in Section 6.3 of SCTP-AUTH spec</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">SCTP_CID_AUTH</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sctp_chunkhdr</span> <span class="o">*</span><span class="n">next_hdr</span><span class="p">;</span>

			<span class="n">next_hdr</span> <span class="o">=</span> <span class="n">sctp_inq_peek</span><span class="p">(</span><span class="n">inqueue</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_hdr</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">normal</span><span class="p">;</span>

			<span class="cm">/* If the next chunk is COOKIE-ECHO, skip the AUTH</span>
<span class="cm">			 * chunk while saving a pointer to it so we can do</span>
<span class="cm">			 * Authentication later (during cookie-echo</span>
<span class="cm">			 * processing).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_CID_COOKIE_ECHO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth_chunk</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
								<span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">normal:</span>
		<span class="cm">/* We might have grown an association since last we</span>
<span class="cm">		 * looked, so try again.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This happens when we&#39;ve just processed our</span>
<span class="cm">		 * COOKIE-ECHO chunk.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_endpoint_lookup_assoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span>
							  <span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span>
							  <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">asoc</span><span class="p">;</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">state</span> <span class="o">=</span> <span class="n">asoc</span> <span class="o">?</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">:</span> <span class="n">SCTP_STATE_CLOSED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_recv_cid</span><span class="p">(</span><span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Remember where the last DATA chunk came from so we</span>
<span class="cm">		 * know where to send the SACK.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_chunk_is_data</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">last_data_from</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_INCTRLCHUNKS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">last_time_heard</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_CHUNK</span><span class="p">,</span> <span class="n">subtype</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
				   <span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">pdiscard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Check to see if the endpoint is freed in response to</span>
<span class="cm">		 * the incoming chunk. If so, get out of the while loop.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span><span class="p">)</span>
			<span class="n">first_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
