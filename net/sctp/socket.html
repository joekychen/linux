<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › socket.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>socket.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2003 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001-2002 Nokia, Inc.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * These functions interface with the sockets layer to implement the</span>
<span class="cm"> * SCTP Extensions for the Sockets API.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the descriptions from the specification are USER level</span>
<span class="cm"> * functions--this file is the functions which populate the struct proto</span>
<span class="cm"> * for SCTP which is the BOTTOM of the sockets interface.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Narasimha Budihal     &lt;narsi@refcode.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Xingang Guo           &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Daisy Chang           &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala     &lt;samudrala@us.ibm.com&gt;</span>
<span class="cm"> *    Inaky Perez-Gonzalez  &lt;inaky.gonzalez@intel.com&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *    Ryan Layer	    &lt;rmlayer@us.ibm.com&gt;</span>
<span class="cm"> *    Anup Pemmaiah         &lt;pemmaiah@cc.usu.edu&gt;</span>
<span class="cm"> *    Kevin Gao             &lt;kevin.gao@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/icmp.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/inet_common.h&gt;</span>

<span class="cp">#include &lt;linux/socket.h&gt; </span><span class="cm">/* for sa_family_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="cm">/* WARNING:  Please do not remove the SCTP_STATIC attribute to</span>
<span class="cm"> * any of the functions below as they are used to export functions</span>
<span class="cm"> * used by a project regression testsuite.</span>
<span class="cm"> */</span>

<span class="cm">/* Forward declarations for internal helper functions. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_writeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_wfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_wait_for_sndbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">msg_len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_wait_for_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span> <span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_wait_for_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_wait_for_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_wait_for_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">sctp_sockaddr_af</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_bindx_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_bindx_rem</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_send_asconf_add_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_send_asconf_del_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_send_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_do_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_autobind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_sock_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="n">sctp_socket_type_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sctp_hmac_alg</span> <span class="o">=</span> <span class="n">SCTP_COOKIE_HMAC_ALG</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sctp_bucket_cachep</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_sctp_rmem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_sctp_wmem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_memory_pressure</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">sctp_memory_allocated</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">sctp_sockets_allocated</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_enter_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_memory_pressure</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Get the sndbuf space available at the time on the association.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_wspace</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">amt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">sndbuf_policy</span><span class="p">)</span>
		<span class="n">amt</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sndbuf_used</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">amt</span> <span class="o">=</span> <span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amt</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_SNDBUF_LOCK</span><span class="p">)</span>
			<span class="n">amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">amt</span> <span class="o">=</span> <span class="n">sk_stream_wspace</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">amt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">amt</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="n">amt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">amt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Increment the used sndbuf space count of the corresponding association by</span>
<span class="cm"> * the size of the outgoing data chunk.</span>
<span class="cm"> * Also, set the skb destructor for sndbuf accounting later.</span>
<span class="cm"> *</span>
<span class="cm"> * Since it is always 1-1 between chunk and skb, and also a new skb is always</span>
<span class="cm"> * allocated for chunk bundling in sctp_packet_transmit(), we can use the</span>
<span class="cm"> * destructor in the data chunk skb for the purpose of the sndbuf space</span>
<span class="cm"> * tracking.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_set_owner_w</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* The sndbuf space is tracked per association.  */</span>
	<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">sctp_wfree</span><span class="p">;</span>
	<span class="cm">/* Save the chunk pointer in skb for sctp_wfree to use later.  */</span>
	<span class="o">*</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="p">)(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">))</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sndbuf_used</span> <span class="o">+=</span> <span class="n">SCTP_DATA_SNDSIZE</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">);</span>

	<span class="n">atomic_add</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Verify that this is a valid address. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_verify_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="cm">/* Verify basic sockaddr. */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_sockaddr_af</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Is this a valid SCTP address?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">send_verify</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="p">(</span><span class="n">addr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look up the association by its id.  If this is not a UDP-style</span>
<span class="cm"> * socket, the ID field is always ignored.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_id2assoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">sctp_assoc_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If this is not a UDP-style socket, assoc id should be ignored. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Return NULL if the socket state is not ESTABLISHED. It</span>
<span class="cm">		 * could be a TCP-style listening socket or a socket which</span>
<span class="cm">		 * hasn&#39;t yet called connect() to establish an association.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Get the first and the only association from the list. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">))</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span> <span class="n">asocs</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Otherwise this is a UDP-style socket. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span> <span class="o">||</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="p">(</span><span class="n">sctp_assoc_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">id</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">||</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span> <span class="o">!=</span> <span class="n">sk</span><span class="p">)</span> <span class="o">||</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look up the transport from an address and an assoc id. If both address and</span>
<span class="cm"> * id are specified, the associations matching the address and the id should be</span>
<span class="cm"> * the same.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_addr_id2transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					      <span class="n">sctp_assoc_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">addr_asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">id_asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">addr_asoc</span> <span class="o">=</span> <span class="n">sctp_endpoint_lookup_assoc</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span>
					       <span class="n">laddr</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr_asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">id_asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id_asoc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">id_asoc</span> <span class="o">!=</span> <span class="n">addr_asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
						<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">transport</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* API 3.1.2 bind() - UDP Style Syntax</span>
<span class="cm"> * The syntax of bind() is,</span>
<span class="cm"> *</span>
<span class="cm"> *   ret = bind(int sd, struct sockaddr *addr, int addrlen);</span>
<span class="cm"> *</span>
<span class="cm"> *   sd      - the socket descriptor returned by socket().</span>
<span class="cm"> *   addr    - the address structure (struct sockaddr_in or struct</span>
<span class="cm"> *             sockaddr_in6 [RFC 2553]),</span>
<span class="cm"> *   addr_len - the size of the address structure.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_bind(sk: %p, addr: %p, addr_len: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/* Disallow binding twice. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_do_bind</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span>
				      <span class="n">addr_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">sctp_get_port_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Verify this is a valid sockaddr. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="nf">sctp_sockaddr_af</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="cm">/* Check minimum size.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* V4 mapped address are really of AF_INET family */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ipv6_addr_v4mapped</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af_supported</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">opt</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Does this PF support this AF? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af_supported</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">,</span> <span class="n">opt</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we get this far, af is valid. */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">af</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Bind a local address either to an endpoint or to an association.  */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_do_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Common sockaddr verification. */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_sockaddr_af</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_do_bind(sk: %p, newaddr: %p, len: %d) EINVAL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_do_bind(sk: %p, new addr: &quot;</span><span class="p">,</span>
				 <span class="s">&quot;, port: %d, new port: %d, len: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">sk</span><span class="p">,</span>
				 <span class="n">addr</span><span class="p">,</span>
				 <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">snum</span><span class="p">,</span>
				 <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* PF specific bind() address verification. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">bind_verify</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="cm">/* We must either be unbound, or bind to the same port.</span>
<span class="cm">	 * It&#39;s OK to allow 0 ports if we are already bound.</span>
<span class="cm">	 * We&#39;ll just inhert an already bound port in this case</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snum</span><span class="p">)</span>
			<span class="n">snum</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">snum</span> <span class="o">!=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_do_bind:&quot;</span>
				  <span class="s">&quot; New port %d does not match existing port &quot;</span>
				  <span class="s">&quot;%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">snum</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snum</span> <span class="o">&amp;&amp;</span> <span class="n">snum</span> <span class="o">&lt;</span> <span class="n">PROT_SOCK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_BIND_SERVICE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="cm">/* See if the address matches any of the addresses we may have</span>
<span class="cm">	 * already bound before checking against other endpoints.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_bind_addr_match</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Make sure we are allowed to bind here.</span>
<span class="cm">	 * The function sctp_get_port_local() does duplicate address</span>
<span class="cm">	 * detection.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">snum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">sctp_get_port_local</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Refresh ephemeral port.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">;</span>

	<span class="cm">/* Add the address to the bind address list.</span>
<span class="cm">	 * Use GFP_ATOMIC since BHs will be disabled.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sctp_add_bind_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">SCTP_ADDR_SRC</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/* Copy back into socket for getsockname() use. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_sport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">);</span>
		<span class="n">af</span><span class="o">-&gt;</span><span class="n">to_sk_saddr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks</span>
<span class="cm"> *</span>
<span class="cm"> * R1) One and only one ASCONF Chunk MAY be in transit and unacknowledged</span>
<span class="cm"> * at any one time.  If a sender, after sending an ASCONF chunk, decides</span>
<span class="cm"> * it needs to transfer another ASCONF Chunk, it MUST wait until the</span>
<span class="cm"> * ASCONF-ACK Chunk returns from the previous ASCONF Chunk before sending a</span>
<span class="cm"> * subsequent ASCONF. Note this restriction binds each side, so at any</span>
<span class="cm"> * time two ASCONF may be in-transit on any given association (one sent</span>
<span class="cm"> * from each endpoint).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_send_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If there is an outstanding ASCONF chunk, queue it for later</span>
<span class="cm">	 * transmission.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_chunk_list</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Hold the chunk until an ASCONF_ACK is received. */</span>
	<span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_primitive_ASCONF</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add a list of addresses as bind addresses to local endpoint or</span>
<span class="cm"> * association.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically run through each address specified in the addrs/addrcnt</span>
<span class="cm"> * array/length pair, determine if it is IPv6 or IPv4 and call</span>
<span class="cm"> * sctp_do_bind() on it.</span>
<span class="cm"> *</span>
<span class="cm"> * If any of them fails, then the operation will be reversed and the</span>
<span class="cm"> * ones that were added will be removed.</span>
<span class="cm"> *</span>
<span class="cm"> * Only sctp_setsockopt_bindx() is supposed to call this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_bindx_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_bindx_add (sk: %p, addrs: %p, addrcnt: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>

	<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The list may contain either IPv4 or IPv6 address;</span>
<span class="cm">		 * determine the address length for walking thru the list.</span>
<span class="cm">		 */</span>
		<span class="n">sa_addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_bindx_add</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_do_bind</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">sa_addr</span><span class="p">,</span>
				      <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>

		<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>

<span class="nl">err_bindx_add:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Failed. Cleanup the ones that have been added */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sctp_bindx_rem</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send an ASCONF chunk with Add IP address parameters to all the peers of the</span>
<span class="cm"> * associations that are part of the endpoint indicating that a list of local</span>
<span class="cm"> * addresses are added to the endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * If any of the addresses is already in the bind address list of the</span>
<span class="cm"> * association, we do not send the chunk for that association.  But it will not</span>
<span class="cm"> * affect other associations.</span>
<span class="cm"> *</span>
<span class="cm"> * Only sctp_setsockopt_bindx() is supposed to call this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_send_asconf_add_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sockaddr</span>	<span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
				   <span class="kt">int</span> 			<span class="n">addrcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>		<span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span>		<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span>		<span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>		<span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span>	<span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span>			<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span>			<span class="n">saveaddr</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span>			<span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> 				<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> 				<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: (sk: %p, addrs: %p, addrcnt: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">,</span> <span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_disabled_mask</span> <span class="o">&amp;</span> <span class="n">SCTP_PARAM_ADD_IP</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check if any address in the packed array of addresses is</span>
<span class="cm">		 * in the bind address list of the association. If so,</span>
<span class="cm">		 * do not send the asconf chunk to its peer, but continue with</span>
<span class="cm">		 * other associations.</span>
<span class="cm">		 */</span>
		<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
			<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_assoc_lookup_laddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Use the first valid address in bind addr list of</span>
<span class="cm">		 * association as Address Parameter of ASCONF CHUNK.</span>
<span class="cm">		 */</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">laddr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_make_asconf_update_ip</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span>
						   <span class="n">addrcnt</span><span class="p">,</span> <span class="n">SCTP_PARAM_ADD_IP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Add the new addresses to the bind address list with</span>
<span class="cm">		 * use_as_src set to 0.</span>
<span class="cm">		 */</span>
		<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
			<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saveaddr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_add_bind_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saveaddr</span><span class="p">,</span>
						    <span class="n">SCTP_ADDR_NEW</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span> <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Clear the source and route cache */</span>
				<span class="n">dst_release</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="n">max_t</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span>
				    <span class="mi">2</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="mi">4380</span><span class="p">));</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">a_rwnd</span><span class="p">;</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">sctp_transport_route</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_send_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove a list of addresses from bind addresses list.  Do not remove the</span>
<span class="cm"> * last address.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically run through each address specified in the addrs/addrcnt</span>
<span class="cm"> * array/length pair, determine if it is IPv6 or IPv4 and call</span>
<span class="cm"> * sctp_del_bind() on it.</span>
<span class="cm"> *</span>
<span class="cm"> * If any of them fails, then the operation will be reversed and the</span>
<span class="cm"> * ones that were removed will be added back.</span>
<span class="cm"> *</span>
<span class="cm"> * At least one address has to be left; if only one address is</span>
<span class="cm"> * available, the operation will return -EBUSY.</span>
<span class="cm"> *</span>
<span class="cm"> * Only sctp_setsockopt_bindx() is supposed to call this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_bindx_rem</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">sa_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>

	<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the bind address list is empty or if there is only one</span>
<span class="cm">		 * bind address, there is nothing more to be removed (we need</span>
<span class="cm">		 * at least one address here).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sctp_list_single_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_bindx_rem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sa_addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_bindx_rem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">(</span><span class="n">sa_addr</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_bindx_rem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_bindx_rem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span>
			<span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

		<span class="cm">/* FIXME - There is probably a need to check if sk-&gt;sk_saddr and</span>
<span class="cm">		 * sk-&gt;sk_rcv_addr are currently set to one of the addresses to</span>
<span class="cm">		 * be removed. This is something which needs to be looked into</span>
<span class="cm">		 * when we are fixing the outstanding issues with multi-homing</span>
<span class="cm">		 * socket routing and failover schemes. Refer to comments in</span>
<span class="cm">		 * sctp_do_bind(). -daisy</span>
<span class="cm">		 */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_del_bind_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">sa_addr</span><span class="p">);</span>

		<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
<span class="nl">err_bindx_rem:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Failed. Add the ones that has been removed back */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sctp_bindx_add</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send an ASCONF chunk with Delete IP address parameters to all the peers of</span>
<span class="cm"> * the associations that are part of the endpoint indicating that a list of</span>
<span class="cm"> * local addresses are removed from the endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * If any of the addresses is already in the bind address list of the</span>
<span class="cm"> * association, we do not send the chunk for that association.  But it will not</span>
<span class="cm"> * affect other associations.</span>
<span class="cm"> *</span>
<span class="cm"> * Only sctp_setsockopt_bindx() is supposed to call this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_send_asconf_del_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sockaddr</span>	<span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
				   <span class="kt">int</span>			<span class="n">addrcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>	<span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span>	<span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>	<span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span>		<span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span>		<span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">saddr</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">stored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: (sk: %p, addrs: %p, addrcnt: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">,</span> <span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_disabled_mask</span> <span class="o">&amp;</span> <span class="n">SCTP_PARAM_DEL_IP</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check if any address in the packed array of addresses is</span>
<span class="cm">		 * not present in the bind address list of the association.</span>
<span class="cm">		 * If so, do not send the asconf chunk to its peer, but</span>
<span class="cm">		 * continue with other associations.</span>
<span class="cm">		 */</span>
		<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">laddr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
			<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_lookup_laddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">laddr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Find one address in the association&#39;s bind address list</span>
<span class="cm">		 * that is not in the packed array of addresses. This is to</span>
<span class="cm">		 * make sure that we do not delete all the addresses in the</span>
<span class="cm">		 * association.</span>
<span class="cm">		 */</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
		<span class="n">laddr</span> <span class="o">=</span> <span class="n">sctp_find_unmatch_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">addrs</span><span class="p">,</span>
					       <span class="n">addrcnt</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">laddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addrcnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">=</span>
			    <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span>
				    <span class="n">addrs</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span>
				    <span class="n">htons</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addrs</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span><span class="p">;</span>

				<span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">addrs</span><span class="p">;</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addrs</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sin6</span><span class="p">;</span>

				<span class="n">sin6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">addrs</span><span class="p">;</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="o">-&gt;</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span> <span class="o">=</span> <span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;send_asconf_del_ip: keep the last address asoc: %p &quot;</span><span class="p">,</span>
			    <span class="s">&quot; at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">,</span>
			    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">);</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">stored</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">skip_mkasconf</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We do not need RCU protection throughout this loop</span>
<span class="cm">		 * because this is done under a socket lock from the</span>
<span class="cm">		 * setsockopt call.</span>
<span class="cm">		 */</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_make_asconf_update_ip</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">,</span>
						   <span class="n">SCTP_PARAM_DEL_IP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">skip_mkasconf:</span>
		<span class="cm">/* Reset use_as_src flag for the addresses in the bind address</span>
<span class="cm">		 * list that are to be deleted.</span>
<span class="cm">		 */</span>
		<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">laddr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
			<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">laddr</span><span class="p">))</span>
					<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCTP_ADDR_DEL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Update the route and saddr entries for all the transports</span>
<span class="cm">		 * as some of the addresses in the bind address list are</span>
<span class="cm">		 * about to be deleted and cannot be used as source addresses.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
					<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dst_release</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
			<span class="n">sctp_transport_route</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					     <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stored</span><span class="p">)</span>
			<span class="cm">/* We don&#39;t need to transmit ASCONF */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_send_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set addr events to assocs in the endpoint.  ep and addr_wq must be locked */</span>
<span class="kt">int</span> <span class="nf">sctp_asconf_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addrw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sctp_opt2sk</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="cm">/* It is safe to write port space in caller. */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_verify_addr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ADDR_NEW</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_send_asconf_add_ip</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sctp_send_asconf_del_ip</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Helper for tunneling sctp_bindx() requests through sctp_setsockopt()</span>
<span class="cm"> *</span>
<span class="cm"> * API 8.1</span>
<span class="cm"> * int sctp_bindx(int sd, struct sockaddr *addrs, int addrcnt,</span>
<span class="cm"> *                int flags);</span>
<span class="cm"> *</span>
<span class="cm"> * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.</span>
<span class="cm"> * If the sd is an IPv6 socket, the addresses passed can either be IPv4</span>
<span class="cm"> * or IPv6 addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see</span>
<span class="cm"> * Section 3.1.2 for this usage.</span>
<span class="cm"> *</span>
<span class="cm"> * addrs is a pointer to an array of one or more socket addresses. Each</span>
<span class="cm"> * address is contained in its appropriate structure (i.e. struct</span>
<span class="cm"> * sockaddr_in or struct sockaddr_in6) the family of the address type</span>
<span class="cm"> * must be used to distinguish the address length (note that this</span>
<span class="cm"> * representation is termed a &quot;packed array&quot; of addresses). The caller</span>
<span class="cm"> * specifies the number of addresses in the array with addrcnt.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns</span>
<span class="cm"> * -1, and sets errno to the appropriate error code.</span>
<span class="cm"> *</span>
<span class="cm"> * For SCTP, the port given in each socket address must be the same, or</span>
<span class="cm"> * sctp_bindx() will fail, setting errno to EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> * The flags parameter is formed from the bitwise OR of zero or more of</span>
<span class="cm"> * the following currently defined flags:</span>
<span class="cm"> *</span>
<span class="cm"> * SCTP_BINDX_ADD_ADDR</span>
<span class="cm"> *</span>
<span class="cm"> * SCTP_BINDX_REM_ADDR</span>
<span class="cm"> *</span>
<span class="cm"> * SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the</span>
<span class="cm"> * association, and SCTP_BINDX_REM_ADDR directs SCTP to remove the given</span>
<span class="cm"> * addresses from the association. The two flags are mutually exclusive;</span>
<span class="cm"> * if both are given, sctp_bindx() will fail with EINVAL. A caller may</span>
<span class="cm"> * not remove all addresses from an association; sctp_bindx() will</span>
<span class="cm"> * reject such an attempt with EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> * An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate</span>
<span class="cm"> * additional addresses with an endpoint after calling bind().  Or use</span>
<span class="cm"> * sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses a listening</span>
<span class="cm"> * socket is associated with so that no new association accepted will be</span>
<span class="cm"> * associated with those addresses. If the endpoint supports dynamic</span>
<span class="cm"> * address a SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause a</span>
<span class="cm"> * endpoint to send the appropriate message to the peer to change the</span>
<span class="cm"> * peers address lists.</span>
<span class="cm"> *</span>
<span class="cm"> * Adding and removing addresses from a connected association is</span>
<span class="cm"> * optional functionality. Implementations that do not support this</span>
<span class="cm"> * functionality should return EOPNOTSUPP.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically do nothing but copying the addresses from user to kernel</span>
<span class="cm"> * land and invoking either sctp_bindx_add() or sctp_bindx_rem() on the sk.</span>
<span class="cm"> * This is used for tunneling the sctp_bindx() request through sctp_setsockopt()</span>
<span class="cm"> * from userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t use copy_from_user() for optimization: we first do the</span>
<span class="cm"> * sanity checks (buffer size -fast- and access check-healthy</span>
<span class="cm"> * pointer); if all of those succeed, then we can alloc the memory</span>
<span class="cm"> * (expensive operation) needed to copy the data to kernel. Then we do</span>
<span class="cm"> * the copying without checking the user space area</span>
<span class="cm"> * (__copy_from_user()).</span>
<span class="cm"> *</span>
<span class="cm"> * On exit there is no need to do sockfd_put(), sys_setsockopt() does</span>
<span class="cm"> * it.</span>
<span class="cm"> *</span>
<span class="cm"> * sk        The sk of the socket</span>
<span class="cm"> * addrs     The pointer to the addresses in user land</span>
<span class="cm"> * addrssize Size of the addrs buffer</span>
<span class="cm"> * op        Operation to perform (add or remove, see the flags of</span>
<span class="cm"> *           sctp_bindx)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if ok, &lt;0 errno code on error.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_bindx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">addrs_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">kaddrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addrcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">walk_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_setsocktopt_bindx: sk %p addrs %p&quot;</span>
			  <span class="s">&quot; addrs_size %d opt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">addrs_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Check the user passed a healthy pointer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Alloc space for the address array in kernel memory.  */</span>
	<span class="n">kaddrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">addrs_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">kaddrs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Walk through the addrs buffer and count the number of addresses. */</span>
	<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">kaddrs</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">walk_size</span> <span class="o">&lt;</span> <span class="n">addrs_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">walk_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa_family_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">addrs_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sa_addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">);</span>

		<span class="cm">/* If the address family is not supported or if this address</span>
<span class="cm">		 * causes the address buffer to overflow return EINVAL.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span> <span class="o">||</span> <span class="p">(</span><span class="n">walk_size</span> <span class="o">+</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">addrs_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addrcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="n">walk_size</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do the work. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_BINDX_ADD_ADDR</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_bindx_add</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_send_asconf_add_ip</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_BINDX_REM_ADDR</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_bindx_rem</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_send_asconf_del_ip</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrcnt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* __sctp_connect(struct sock* sk, struct sockaddr *kaddrs, int addrs_size)</span>
<span class="cm"> *</span>
<span class="cm"> * Common routine for handling connect() and sctp_connectx().</span>
<span class="cm"> * Connect will come in with just a single address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sctp_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">kaddrs</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">addrs_size</span><span class="p">,</span>
			  <span class="n">sctp_assoc_t</span> <span class="o">*</span><span class="n">assoc_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addrcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">walk_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">sa_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* connect() cannot be done on a socket that is already in ESTABLISHED</span>
<span class="cm">	 * state - UDP-style peeled off socket or a TCP-style socket that</span>
<span class="cm">	 * is already connected.</span>
<span class="cm">	 * It cannot be done even on a TCP-style listening socket.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Walk through the addrs buffer and count the number of addresses. */</span>
	<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">kaddrs</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">walk_size</span> <span class="o">&lt;</span> <span class="n">addrs_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">walk_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa_family_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">addrs_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sa_addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>

		<span class="cm">/* If the address family is not supported or if this address</span>
<span class="cm">		 * causes the address buffer to overflow return EINVAL.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span> <span class="o">||</span> <span class="p">(</span><span class="n">walk_size</span> <span class="o">+</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">addrs_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>

		<span class="cm">/* Save current address so we can work with it */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">sa_addr</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_verify_addr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="cm">/* Make sure the destination port is correctly set</span>
<span class="cm">		 * in all addresses.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span> <span class="o">!=</span> <span class="n">port</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>


		<span class="cm">/* Check if there already is a matching association on the</span>
<span class="cm">		 * endpoint (other than the one created here).</span>
<span class="cm">		 */</span>
		<span class="n">asoc2</span> <span class="o">=</span> <span class="n">sctp_endpoint_lookup_assoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc2</span> <span class="o">&amp;&amp;</span> <span class="n">asoc2</span> <span class="o">!=</span> <span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc2</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we could not find a matching association on the endpoint,</span>
<span class="cm">		 * make sure that there is no peeled-off association matching</span>
<span class="cm">		 * the peer address even on another socket.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_endpoint_is_peeled_off</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If a bind() or sctp_bindx() is not called prior to</span>
<span class="cm">			 * an sctp_connectx() call, the system picks an</span>
<span class="cm">			 * ephemeral port and will choose an address set</span>
<span class="cm">			 * equivalent to binding with a wildcard address.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sctp_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If an unprivileged user inherits a 1-many</span>
<span class="cm">				 * style socket with open associations on a</span>
<span class="cm">				 * privileged port, it MAY be permitted to</span>
<span class="cm">				 * accept new associations, but it SHOULD NOT</span>
<span class="cm">				 * be permitted to open new associations.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span> <span class="o">&lt;</span> <span class="n">PROT_SOCK</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_BIND_SERVICE</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">scope</span> <span class="o">=</span> <span class="n">sctp_scope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_association_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_assoc_set_bind_addr_from_ep</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span>
							      <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>

		<span class="cm">/* Prime the peer&#39;s transport structures.  */</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
						<span class="n">SCTP_UNKNOWN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">addrcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="n">walk_size</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In case the user of sctp_connectx() wants an association</span>
<span class="cm">	 * id back, assign one now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">assoc_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_assoc_set_id</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_primitive_ASSOCIATE</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize sk&#39;s dport and daddr for getpeername() */</span>
	<span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_dport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">to_sk_daddr</span><span class="p">(</span><span class="n">sa_addr</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* in-kernel sockets don&#39;t generally have a file allocated to them</span>
<span class="cm">	 * if all they do is call sock_create_kern().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span>
		<span class="n">f_flags</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">;</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_wait_for_connect</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">assoc_id</span><span class="p">)</span>
		<span class="o">*</span><span class="n">assoc_id</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t free association on exit. */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out_free:</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;About to exit __sctp_connect() free asoc: %p&quot;</span>
			  <span class="s">&quot; kaddrs: %p err: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">asoc</span><span class="p">,</span> <span class="n">kaddrs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper for tunneling sctp_connectx() requests through sctp_setsockopt()</span>
<span class="cm"> *</span>
<span class="cm"> * API 8.9</span>
<span class="cm"> * int sctp_connectx(int sd, struct sockaddr *addrs, int addrcnt,</span>
<span class="cm"> * 			sctp_assoc_t *asoc);</span>
<span class="cm"> *</span>
<span class="cm"> * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.</span>
<span class="cm"> * If the sd is an IPv6 socket, the addresses passed can either be IPv4</span>
<span class="cm"> * or IPv6 addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see</span>
<span class="cm"> * Section 3.1.2 for this usage.</span>
<span class="cm"> *</span>
<span class="cm"> * addrs is a pointer to an array of one or more socket addresses. Each</span>
<span class="cm"> * address is contained in its appropriate structure (i.e. struct</span>
<span class="cm"> * sockaddr_in or struct sockaddr_in6) the family of the address type</span>
<span class="cm"> * must be used to distengish the address length (note that this</span>
<span class="cm"> * representation is termed a &quot;packed array&quot; of addresses). The caller</span>
<span class="cm"> * specifies the number of addresses in the array with addrcnt.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, sctp_connectx() returns 0. It also sets the assoc_id to</span>
<span class="cm"> * the association id of the new association.  On failure, sctp_connectx()</span>
<span class="cm"> * returns -1, and sets errno to the appropriate error code.  The assoc_id</span>
<span class="cm"> * is not touched by the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * For SCTP, the port given in each socket address must be the same, or</span>
<span class="cm"> * sctp_connectx() will fail, setting errno to EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> * An application can use sctp_connectx to initiate an association with</span>
<span class="cm"> * an endpoint that is multi-homed.  Much like sctp_bindx() this call</span>
<span class="cm"> * allows a caller to specify multiple addresses at which a peer can be</span>
<span class="cm"> * reached.  The way the SCTP stack uses the list of addresses to set up</span>
<span class="cm"> * the association is implementation dependent.  This function only</span>
<span class="cm"> * specifies that the stack will try to make use of all the addresses in</span>
<span class="cm"> * the list when needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the list of addresses passed in is only used for setting up</span>
<span class="cm"> * the association.  It does not necessarily equal the set of addresses</span>
<span class="cm"> * the peer uses for the resulting association.  If the caller wants to</span>
<span class="cm"> * find out the set of peer addresses, it must use sctp_getpaddrs() to</span>
<span class="cm"> * retrieve them after the association has been set up.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically do nothing but copying the addresses from user to kernel</span>
<span class="cm"> * land and invoking either sctp_connectx(). This is used for tunneling</span>
<span class="cm"> * the sctp_connectx() request through sctp_setsockopt() from userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t use copy_from_user() for optimization: we first do the</span>
<span class="cm"> * sanity checks (buffer size -fast- and access check-healthy</span>
<span class="cm"> * pointer); if all of those succeed, then we can alloc the memory</span>
<span class="cm"> * (expensive operation) needed to copy the data to kernel. Then we do</span>
<span class="cm"> * the copying without checking the user space area</span>
<span class="cm"> * (__copy_from_user()).</span>
<span class="cm"> *</span>
<span class="cm"> * On exit there is no need to do sockfd_put(), sys_setsockopt() does</span>
<span class="cm"> * it.</span>
<span class="cm"> *</span>
<span class="cm"> * sk        The sk of the socket</span>
<span class="cm"> * addrs     The pointer to the addresses in user land</span>
<span class="cm"> * addrssize Size of the addrs buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;=0 if ok, &lt;0 errno code on error.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">__sctp_setsockopt_connectx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">addrs_size</span><span class="p">,</span>
				      <span class="n">sctp_assoc_t</span> <span class="o">*</span><span class="n">assoc_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">kaddrs</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s - sk %p addrs %p addrs_size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">addrs_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Check the user passed a healthy pointer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Alloc space for the address array in kernel memory.  */</span>
	<span class="n">kaddrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">addrs_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">kaddrs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__sctp_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">kaddrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">,</span> <span class="n">assoc_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">kaddrs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is an older interface.  It&#39;s kept for backward compatibility</span>
<span class="cm"> * to the option that doesn&#39;t provide association id.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_connectx_old</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">addrs_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sctp_setsockopt_connectx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * New interface for the API.  The since the API is done with a socket</span>
<span class="cm"> * option, to make it simple we feed back the association id is as a return</span>
<span class="cm"> * indication to the call.  Error is always negative and association id is</span>
<span class="cm"> * always positive.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_connectx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">addrs_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_assoc_t</span> <span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__sctp_setsockopt_connectx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">addrs_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assoc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">assoc_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * New (hopefully final) interface for the API.</span>
<span class="cm"> * We use the sctp_getaddrs_old structure so that use-space library</span>
<span class="cm"> * can avoid any unnecessary allocations.   The only defferent part</span>
<span class="cm"> * is that we store the actual length of the address buffer into the</span>
<span class="cm"> * addrs_num structure member.  That way we can re-use the existing</span>
<span class="cm"> * code.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_connectx3</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_getaddrs_old</span> <span class="n">param</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__sctp_setsockopt_connectx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">param</span><span class="p">.</span><span class="n">addrs</span><span class="p">,</span>
			<span class="n">param</span><span class="p">.</span><span class="n">addr_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assoc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assoc_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">assoc_id</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">assoc_id</span><span class="p">),</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* API 3.1.4 close() - UDP Style Syntax</span>
<span class="cm"> * Applications use close() to perform graceful shutdown (as described in</span>
<span class="cm"> * Section 10.1 of [SCTP]) on ALL the associations currently represented</span>
<span class="cm"> * by a UDP-style socket.</span>
<span class="cm"> *</span>
<span class="cm"> * The syntax is</span>
<span class="cm"> *</span>
<span class="cm"> *   ret = close(int sd);</span>
<span class="cm"> *</span>
<span class="cm"> *   sd      - the socket descriptor of the associations to be closed.</span>
<span class="cm"> *</span>
<span class="cm"> * To gracefully shutdown a specific association represented by the</span>
<span class="cm"> * UDP-style socket, an application should use the sendmsg() call,</span>
<span class="cm"> * passing no user data, but including the appropriate flag in the</span>
<span class="cm"> * ancillary data (see Section xxxx).</span>
<span class="cm"> *</span>
<span class="cm"> * If sd in the close() call is a branched-off socket representing only</span>
<span class="cm"> * one association, the shutdown is performed on that association only.</span>
<span class="cm"> *</span>
<span class="cm"> * 4.1.6 close() - TCP Style Syntax</span>
<span class="cm"> *</span>
<span class="cm"> * Applications use close() to gracefully close down an association.</span>
<span class="cm"> *</span>
<span class="cm"> * The syntax is:</span>
<span class="cm"> *</span>
<span class="cm"> *    int close(int sd);</span>
<span class="cm"> *</span>
<span class="cm"> *      sd      - the socket descriptor of the association to be closed.</span>
<span class="cm"> *</span>
<span class="cm"> * After an application calls close() on a socket descriptor, no further</span>
<span class="cm"> * socket operations will succeed on that descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * API 7.1.4 SO_LINGER</span>
<span class="cm"> *</span>
<span class="cm"> * An application using the TCP-style socket can use this option to</span>
<span class="cm"> * perform the SCTP ABORT primitive.  The linger option structure is:</span>
<span class="cm"> *</span>
<span class="cm"> *  struct  linger {</span>
<span class="cm"> *     int     l_onoff;                // option on/off</span>
<span class="cm"> *     int     l_linger;               // linger time</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * To enable the option, set l_onoff to 1.  If the l_linger value is set</span>
<span class="cm"> * to 0, calling close() is the same as the ABORT primitive.  If the</span>
<span class="cm"> * value is set to a negative value, the setsockopt() call will return</span>
<span class="cm"> * an error.  If the value is set to a positive value linger_time, the</span>
<span class="cm"> * close() can be blocked for at most linger_time ms.  If the graceful</span>
<span class="cm"> * shutdown phase does not finish during this period, close() will</span>
<span class="cm"> * return but the graceful shutdown phase continues in the system.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">void</span> <span class="nf">sctp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_was_unread</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_close(sk: 0x%p, timeout:%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_CLOSING</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* Clean up any skbs sitting on the receive queue.  */</span>
	<span class="n">data_was_unread</span> <span class="o">=</span> <span class="n">sctp_queue_purge_ulpevents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">data_was_unread</span> <span class="o">+=</span> <span class="n">sctp_queue_purge_ulpevents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">);</span>

	<span class="cm">/* Walk all associations on an endpoint.  */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span> <span class="n">asocs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* A closed association can still be in the list if</span>
<span class="cm">			 * it belongs to a TCP-style listening socket that is</span>
<span class="cm">			 * not yet accepted. If so, free it. If not, send an</span>
<span class="cm">			 * ABORT or SHUTDOWN based on the linger options.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sctp_unhash_established</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
				<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data_was_unread</span> <span class="o">||</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">lobby</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">reasm</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>

			<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_make_abort_user</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
				<span class="n">sctp_primitive_ABORT</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sctp_primitive_SHUTDOWN</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* On a TCP-style socket, block for at most linger_time if set. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="p">)</span>
		<span class="n">sctp_wait_for_close</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="cm">/* This will run the backlog queue.  */</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Supposedly, no process has access to the socket, but</span>
<span class="cm">	 * the net layers still may.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Hold the sock, since sk_common_release() will put sock_put()</span>
<span class="cm">	 * and we have just a little more cleanup.</span>
<span class="cm">	 */</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk_common_release</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>

	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">SCTP_DBG_OBJCNT_DEC</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle EPIPE error. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPIPE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_NOSIGNAL</span><span class="p">))</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* API 3.1.3 sendmsg() - UDP Style Syntax</span>
<span class="cm"> *</span>
<span class="cm"> * An application uses sendmsg() and recvmsg() calls to transmit data to</span>
<span class="cm"> * and receive data from its peer.</span>
<span class="cm"> *</span>
<span class="cm"> *  ssize_t sendmsg(int socket, const struct msghdr *message,</span>
<span class="cm"> *                  int flags);</span>
<span class="cm"> *</span>
<span class="cm"> *  socket  - the socket descriptor of the endpoint.</span>
<span class="cm"> *  message - pointer to the msghdr structure which contains a single</span>
<span class="cm"> *            user message and possibly some ancillary data.</span>
<span class="cm"> *</span>
<span class="cm"> *            See Section 5 for complete description of the data</span>
<span class="cm"> *            structures.</span>
<span class="cm"> *</span>
<span class="cm"> *  flags   - flags sent or received with the user message, see Section</span>
<span class="cm"> *            5 for complete description of the flags.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  This function could use a rewrite especially when explicit</span>
<span class="cm"> * connect support comes in.</span>
<span class="cm"> */</span>
<span class="cm">/* BUG:  We do not implement the equivalent of sk_stream_wait_memory(). */</span>

<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="n">sctp_msghdr_parse</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="n">sctp_cmsgs_t</span> <span class="o">*</span><span class="p">);</span>

<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msg_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">asoc</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk_tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="n">default_sinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_initmsg</span> <span class="o">*</span><span class="n">sinit</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">associd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sctp_cmsgs_t</span> <span class="n">cmsgs</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinfo_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="n">datamsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msg_flags</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_sendmsg(sk: %p, msg: %p, msg_len: %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Using endpoint: %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* We cannot send a message over a TCP-style listening socket. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nounlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Parse out the SCTP CMSGs.  */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_msghdr_parse</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmsgs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;msghdr parse err = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nounlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fetch the destination address for this packet.  This</span>
<span class="cm">	 * address only selects the association--it is not necessarily</span>
<span class="cm">	 * the address we will send to.</span>
<span class="cm">	 * For a peeled-off socket, msg_name is ignored.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP_HIGH_BANDWIDTH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_verify_addr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span>
				       <span class="n">msg_namelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg_namelen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">to</span><span class="p">))</span>
			<span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span> <span class="n">msg_namelen</span><span class="p">);</span>
		<span class="n">msg_name</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sinfo</span> <span class="o">=</span> <span class="n">cmsgs</span><span class="p">.</span><span class="n">info</span><span class="p">;</span>
	<span class="n">sinit</span> <span class="o">=</span> <span class="n">cmsgs</span><span class="p">.</span><span class="n">init</span><span class="p">;</span>

	<span class="cm">/* Did the user specify SNDRCVINFO?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sinfo_flags</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_flags</span><span class="p">;</span>
		<span class="n">associd</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_assoc_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;msg_len: %zu, sinfo_flags: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">msg_len</span><span class="p">,</span> <span class="n">sinfo_flags</span><span class="p">);</span>

	<span class="cm">/* SCTP_EOF or SCTP_ABORT cannot be set on a TCP-style socket. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCTP_EOF</span> <span class="o">|</span> <span class="n">SCTP_ABORT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nounlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If SCTP_EOF is set, no data can be sent. Disallow sending zero</span>
<span class="cm">	 * length messages when SCTP_EOF|SCTP_ABORT is not set.</span>
<span class="cm">	 * If SCTP_ABORT is set, the message length could be non zero with</span>
<span class="cm">	 * the msg_iov set to the user abort reason.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_EOF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCTP_EOF</span><span class="o">|</span><span class="n">SCTP_ABORT</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nounlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If SCTP_ADDR_OVER is set, there must be an address</span>
<span class="cm">	 * specified in msg_name.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_ADDR_OVER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nounlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;About to look up association.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* If a msg_name has been specified, assume this is to be used.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look for a matching association on the endpoint. */</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_endpoint_lookup_assoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we could not find a matching association on the</span>
<span class="cm">			 * endpoint, make sure that it is not a TCP-style</span>
<span class="cm">			 * socket that already has an association or there is</span>
<span class="cm">			 * no peeled-off association on another socket.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span> <span class="o">||</span>
			    <span class="n">sctp_endpoint_is_peeled_off</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">associd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Just looked up association: %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

		<span class="cm">/* We cannot send a message on a TCP-style SCTP_SS_ESTABLISHED</span>
<span class="cm">		 * socket that has an association in CLOSED state. This can</span>
<span class="cm">		 * happen when an accepted socket has an association that is</span>
<span class="cm">		 * already CLOSED.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_EOF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Shutting down association: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">asoc</span><span class="p">);</span>
			<span class="n">sctp_primitive_SHUTDOWN</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_ABORT</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_make_abort_user</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Aborting association: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="n">sctp_primitive_ABORT</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Do we need to create the association?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;There is no association yet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCTP_EOF</span> <span class="o">|</span> <span class="n">SCTP_ABORT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check for invalid stream against the stream counts,</span>
<span class="cm">		 * either the default or the user specified stream counts.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sinit</span> <span class="o">||</span> <span class="p">(</span><span class="n">sinit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_num_ostreams</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Check against the defaults. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_stream</span> <span class="o">&gt;=</span>
				    <span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Check against the requested.  */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_stream</span> <span class="o">&gt;=</span>
				    <span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_num_ostreams</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * API 3.1.2 bind() - UDP Style Syntax</span>
<span class="cm">		 * If a bind() or sctp_bindx() is not called prior to a</span>
<span class="cm">		 * sendmsg() call that initiates a new association, the</span>
<span class="cm">		 * system picks an ephemeral port and will choose an address</span>
<span class="cm">		 * set equivalent to binding with a wildcard address.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If an unprivileged user inherits a one-to-many</span>
<span class="cm">			 * style socket with open associations on a privileged</span>
<span class="cm">			 * port, it MAY be permitted to accept new associations,</span>
<span class="cm">			 * but it SHOULD NOT be permitted to open new</span>
<span class="cm">			 * associations.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span> <span class="o">&lt;</span> <span class="n">PROT_SOCK</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_BIND_SERVICE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">scope</span> <span class="o">=</span> <span class="n">sctp_scope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
		<span class="n">new_asoc</span> <span class="o">=</span> <span class="n">sctp_association_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">new_asoc</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_assoc_set_bind_addr_from_ep</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If the SCTP_INIT ancillary data is specified, set all</span>
<span class="cm">		 * the association init values accordingly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_num_ostreams</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span> <span class="o">=</span>
					<span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_num_ostreams</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_max_instreams</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span> <span class="o">=</span>
					<span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_max_instreams</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_max_attempts</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span>
					<span class="o">=</span> <span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_max_attempts</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_max_init_timeo</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_timeo</span> <span class="o">=</span>
				 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sinit</span><span class="o">-&gt;</span><span class="n">sinit_max_init_timeo</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Prime the peer&#39;s transport structures.  */</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">SCTP_UNKNOWN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* ASSERT: we have a valid association at this point.  */</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;We have a valid association.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the user didn&#39;t specify SNDRCVINFO, make up one with</span>
<span class="cm">		 * some defaults.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">default_sinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">default_sinfo</span><span class="p">));</span>
		<span class="n">default_sinfo</span><span class="p">.</span><span class="n">sinfo_stream</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_stream</span><span class="p">;</span>
		<span class="n">default_sinfo</span><span class="p">.</span><span class="n">sinfo_flags</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_flags</span><span class="p">;</span>
		<span class="n">default_sinfo</span><span class="p">.</span><span class="n">sinfo_ppid</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_ppid</span><span class="p">;</span>
		<span class="n">default_sinfo</span><span class="p">.</span><span class="n">sinfo_context</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_context</span><span class="p">;</span>
		<span class="n">default_sinfo</span><span class="p">.</span><span class="n">sinfo_timetolive</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_timetolive</span><span class="p">;</span>
		<span class="n">default_sinfo</span><span class="p">.</span><span class="n">sinfo_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="n">sinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_sinfo</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* API 7.1.7, the sndbuf size per association bounds the</span>
<span class="cm">	 * maximum size of data that can be sent in a single send call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_len</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pmtu_pending</span><span class="p">)</span>
		<span class="n">sctp_assoc_pending_pmtu</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* If fragmentation is disabled and the message length exceeds the</span>
<span class="cm">	 * association fragmentation point, return EMSGSIZE.  The I-D</span>
<span class="cm">	 * does not specify what this error is, but this looks like</span>
<span class="cm">	 * a great fit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disable_fragments</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg_len</span> <span class="o">&gt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for invalid stream. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_stream</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_wspace</span><span class="p">(</span><span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_wait_for_sndbuf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If an address is passed with the sendto/sendmsg call, it is used</span>
<span class="cm">	 * to override the primary destination address in the TCP model, or</span>
<span class="cm">	 * when SCTP_ADDR_OVER flag is set in the UDP model.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">msg_name</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_ADDR_OVER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chunk_tp</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk_tp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">chunk_tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Auto-connect, if we aren&#39;t connected already. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_primitive_ASSOCIATE</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;We associated primitively.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Break the message into multiple chunks of maximum size. */</span>
	<span class="n">datamsg</span> <span class="o">=</span> <span class="n">sctp_datamsg_from_user</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">sinfo</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">datamsg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now send the (possibly) fragmented message. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">datamsg</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">,</span> <span class="n">frag_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

		<span class="cm">/* Do accounting for the write space.  */</span>
		<span class="n">sctp_set_owner_w</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk_tp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send it to the lower layers.  Note:  all chunks</span>
<span class="cm">	 * must either fail or succeed.   The lower layer</span>
<span class="cm">	 * works that way today.  Keep it that way or this</span>
<span class="cm">	 * breaks.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_primitive_SEND</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">datamsg</span><span class="p">);</span>
	<span class="cm">/* Did the lower layer accept the chunk? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">sctp_datamsg_free</span><span class="p">(</span><span class="n">datamsg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sctp_datamsg_put</span><span class="p">(</span><span class="n">datamsg</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;We sent primitively.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">msg_len</span><span class="p">;</span>

	<span class="cm">/* If we are already past ASSOCIATE, the lower</span>
<span class="cm">	 * layers are responsible for association cleanup.</span>
<span class="cm">	 */</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_asoc</span><span class="p">)</span>
		<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">out_nounlock:</span>
	<span class="k">return</span> <span class="n">sctp_error</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg_flags</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">do_sock_err:</span>
<span class="c">	if (msg_len)</span>
<span class="c">		err = msg_len;</span>
<span class="c">	else</span>
<span class="c">		err = sock_error(sk);</span>
<span class="c">	goto out;</span>

<span class="c">do_interrupted:</span>
<span class="c">	if (msg_len)</span>
<span class="c">		err = msg_len;</span>
<span class="c">	goto out;</span>
<span class="cp">#endif /* 0 */</span>
<span class="p">}</span>

<span class="cm">/* This is an extended version of skb_pull() that removes the data from the</span>
<span class="cm"> * start of a skb even when data is spread across the list of skb&#39;s in the</span>
<span class="cm"> * frag_list. len specifies the total amount of data that needs to be removed.</span>
<span class="cm"> * when &#39;len&#39; bytes could be removed from the skb, it returns 0.</span>
<span class="cm"> * If &#39;len&#39; exceeds the total skb length,  it returns the no. of bytes that</span>
<span class="cm"> * could not be removed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_skb_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">skb_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="n">skb_len</span><span class="p">;</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rlen</span> <span class="o">=</span> <span class="n">sctp_skb_pull</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="n">rlen</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="n">rlen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rlen</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* API 3.1.3  recvmsg() - UDP Style Syntax</span>
<span class="cm"> *</span>
<span class="cm"> *  ssize_t recvmsg(int socket, struct msghdr *message,</span>
<span class="cm"> *                    int flags);</span>
<span class="cm"> *</span>
<span class="cm"> *  socket  - the socket descriptor of the endpoint.</span>
<span class="cm"> *  message - pointer to the msghdr structure which contains a single</span>
<span class="cm"> *            user message and possibly some ancillary data.</span>
<span class="cm"> *</span>
<span class="cm"> *            See Section 5 for complete description of the data</span>
<span class="cm"> *            structures.</span>
<span class="cm"> *</span>
<span class="cm"> *  flags   - flags sent or received with the user message, see Section</span>
<span class="cm"> *            5 for complete description of the flags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sctp_skb_recv_datagram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_len</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_recvmsg(%s: %p, %s: %p, %s: %zd, %s: %d, %s: &quot;</span>
			  <span class="s">&quot;0x%x, %s: %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;sk&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="s">&quot;msghdr&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
			  <span class="s">&quot;len&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;knoblauch&quot;</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span>
			  <span class="s">&quot;flags&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="s">&quot;addr_len&quot;</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Get the total length of the skb including any skb&#39;s in the</span>
<span class="cm">	 * frag_list.</span>
<span class="cm">	 */</span>
	<span class="n">skb_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="n">skb_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">sock_recv_ts_and_drops</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_ulpevent_is_notification</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_NOTIFICATION</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">event_msgname</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">skb_msgname</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we allow SCTP_SNDRCVINFO. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">.</span><span class="n">sctp_data_io_event</span><span class="p">)</span>
		<span class="n">sctp_ulpevent_read_sndrcvinfo</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* FIXME: we should be calling IP/IPv6 layers.  */</span>
<span class="c">	if (sk-&gt;sk_protinfo.af_inet.cmsg_flags)</span>
<span class="c">		ip_cmsg_recv(msg, skb);</span>
<span class="cp">#endif</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">copied</span><span class="p">;</span>

	<span class="cm">/* If skb&#39;s length exceeds the user&#39;s buffer, update the skb and</span>
<span class="cm">	 * push it back to the receive_queue so that the next call to</span>
<span class="cm">	 * recvmsg() will return the remaining data. Don&#39;t set MSG_EOR.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_len</span> <span class="o">&gt;</span> <span class="n">copied</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_EOR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">sctp_skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
		<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* When only partial message is copied to the user, increase</span>
<span class="cm">		 * rwnd by that amount. If all the data in the skb is read,</span>
<span class="cm">		 * rwnd is updated when the event is freed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_ulpevent_is_notification</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">sctp_assoc_rwnd_increase</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_NOTIFICATION</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_EOR</span><span class="p">))</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_EOR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_EOR</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Release the skb reference acquired after peeking the skb in</span>
<span class="cm">		 * sctp_skb_recv_datagram().</span>
<span class="cm">		 */</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Free the event which includes releasing the reference to</span>
<span class="cm">		 * the owner of the skb, freeing the skb and updating the</span>
<span class="cm">		 * rwnd.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)</span>
<span class="cm"> *</span>
<span class="cm"> * This option is a on/off flag.  If enabled no SCTP message</span>
<span class="cm"> * fragmentation will be performed.  Instead if a message being sent</span>
<span class="cm"> * exceeds the current PMTU size, the message will NOT be sent and</span>
<span class="cm"> * instead a error will be indicated to the user.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_disable_fragments</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					     <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disable_fragments</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_event_subscribe</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At the time when a user app subscribes to SCTP_SENDER_DRY_EVENT,</span>
<span class="cm">	 * if there is no data to be sent or retransmit, the stack will</span>
<span class="cm">	 * immediately send up this notification.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_ulpevent_type_enabled</span><span class="p">(</span><span class="n">SCTP_SENDER_DRY_EVENT</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_outq_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_sender_dry_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)</span>
<span class="cm"> *</span>
<span class="cm"> * This socket option is applicable to the UDP-style socket only.  When</span>
<span class="cm"> * set it will cause associations that are idle for more than the</span>
<span class="cm"> * specified number of seconds to automatically close.  An association</span>
<span class="cm"> * being idle is defined an association that has NOT sent or received</span>
<span class="cm"> * user data.  The special value of &#39;0&#39; indicates that no automatic</span>
<span class="cm"> * close of any associations should be performed.  The option expects an</span>
<span class="cm"> * integer defining the number of seconds of idle time before an</span>
<span class="cm"> * association is closed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_autoclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Applicable to UDP-style socket only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)</span>
<span class="cm"> *</span>
<span class="cm"> * Applications can enable or disable heartbeats for any peer address of</span>
<span class="cm"> * an association, modify an address&#39;s heartbeat interval, force a</span>
<span class="cm"> * heartbeat to be sent immediately, and adjust the address&#39;s maximum</span>
<span class="cm"> * number of retransmissions sent before an address is considered</span>
<span class="cm"> * unreachable.  The following structure is used to access and modify an</span>
<span class="cm"> * address&#39;s parameters:</span>
<span class="cm"> *</span>
<span class="cm"> *  struct sctp_paddrparams {</span>
<span class="cm"> *     sctp_assoc_t            spp_assoc_id;</span>
<span class="cm"> *     struct sockaddr_storage spp_address;</span>
<span class="cm"> *     uint32_t                spp_hbinterval;</span>
<span class="cm"> *     uint16_t                spp_pathmaxrxt;</span>
<span class="cm"> *     uint32_t                spp_pathmtu;</span>
<span class="cm"> *     uint32_t                spp_sackdelay;</span>
<span class="cm"> *     uint32_t                spp_flags;</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> *   spp_assoc_id    - (one-to-many style socket) This is filled in the</span>
<span class="cm"> *                     application, and identifies the association for</span>
<span class="cm"> *                     this query.</span>
<span class="cm"> *   spp_address     - This specifies which address is of interest.</span>
<span class="cm"> *   spp_hbinterval  - This contains the value of the heartbeat interval,</span>
<span class="cm"> *                     in milliseconds.  If a  value of zero</span>
<span class="cm"> *                     is present in this field then no changes are to</span>
<span class="cm"> *                     be made to this parameter.</span>
<span class="cm"> *   spp_pathmaxrxt  - This contains the maximum number of</span>
<span class="cm"> *                     retransmissions before this address shall be</span>
<span class="cm"> *                     considered unreachable. If a  value of zero</span>
<span class="cm"> *                     is present in this field then no changes are to</span>
<span class="cm"> *                     be made to this parameter.</span>
<span class="cm"> *   spp_pathmtu     - When Path MTU discovery is disabled the value</span>
<span class="cm"> *                     specified here will be the &quot;fixed&quot; path mtu.</span>
<span class="cm"> *                     Note that if the spp_address field is empty</span>
<span class="cm"> *                     then all associations on this address will</span>
<span class="cm"> *                     have this fixed path mtu set upon them.</span>
<span class="cm"> *</span>
<span class="cm"> *   spp_sackdelay   - When delayed sack is enabled, this value specifies</span>
<span class="cm"> *                     the number of milliseconds that sacks will be delayed</span>
<span class="cm"> *                     for. This value will apply to all addresses of an</span>
<span class="cm"> *                     association if the spp_address field is empty. Note</span>
<span class="cm"> *                     also, that if delayed sack is enabled and this</span>
<span class="cm"> *                     value is set to 0, no change is made to the last</span>
<span class="cm"> *                     recorded delayed sack timer value.</span>
<span class="cm"> *</span>
<span class="cm"> *   spp_flags       - These flags are used to control various features</span>
<span class="cm"> *                     on an association. The flag field may contain</span>
<span class="cm"> *                     zero or more of the following options.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_ENABLE  - Enable heartbeats on the</span>
<span class="cm"> *                     specified address. Note that if the address</span>
<span class="cm"> *                     field is empty all addresses for the association</span>
<span class="cm"> *                     have heartbeats enabled upon them.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_DISABLE - Disable heartbeats on the</span>
<span class="cm"> *                     speicifed address. Note that if the address</span>
<span class="cm"> *                     field is empty all addresses for the association</span>
<span class="cm"> *                     will have their heartbeats disabled. Note also</span>
<span class="cm"> *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are</span>
<span class="cm"> *                     mutually exclusive, only one of these two should</span>
<span class="cm"> *                     be specified. Enabling both fields will have</span>
<span class="cm"> *                     undetermined results.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_DEMAND - Request a user initiated heartbeat</span>
<span class="cm"> *                     to be made immediately.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_TIME_IS_ZERO - Specify&#39;s that the time for</span>
<span class="cm"> *                     heartbeat delayis to be set to the value of 0</span>
<span class="cm"> *                     milliseconds.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_PMTUD_ENABLE - This field will enable PMTU</span>
<span class="cm"> *                     discovery upon the specified address. Note that</span>
<span class="cm"> *                     if the address feild is empty then all addresses</span>
<span class="cm"> *                     on the association are effected.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_PMTUD_DISABLE - This field will disable PMTU</span>
<span class="cm"> *                     discovery upon the specified address. Note that</span>
<span class="cm"> *                     if the address feild is empty then all addresses</span>
<span class="cm"> *                     on the association are effected. Not also that</span>
<span class="cm"> *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually</span>
<span class="cm"> *                     exclusive. Enabling both will have undetermined</span>
<span class="cm"> *                     results.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_SACKDELAY_ENABLE - Setting this flag turns</span>
<span class="cm"> *                     on delayed sack. The time specified in spp_sackdelay</span>
<span class="cm"> *                     is used to specify the sack delay for this address. Note</span>
<span class="cm"> *                     that if spp_address is empty then all addresses will</span>
<span class="cm"> *                     enable delayed sack and take on the sack delay</span>
<span class="cm"> *                     value specified in spp_sackdelay.</span>
<span class="cm"> *                     SPP_SACKDELAY_DISABLE - Setting this flag turns</span>
<span class="cm"> *                     off delayed sack. If the spp_address field is blank then</span>
<span class="cm"> *                     delayed sack is disabled for the entire association. Note</span>
<span class="cm"> *                     also that this field is mutually exclusive to</span>
<span class="cm"> *                     SPP_SACKDELAY_ENABLE, setting both will have undefined</span>
<span class="cm"> *                     results.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_apply_peer_addr_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddrparams</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_transport</span>   <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_sock</span>        <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
				       <span class="kt">int</span>                      <span class="n">hb_change</span><span class="p">,</span>
				       <span class="kt">int</span>                      <span class="n">pmtud_change</span><span class="p">,</span>
				       <span class="kt">int</span>                      <span class="n">sackdelay_change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB_DEMAND</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_primitive_REQUESTHEARTBEAT</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Note that unless the spp_flag is set to SPP_HB_ENABLE the value of</span>
<span class="cm">	 * this field is ignored.  Note also that a value of zero indicates</span>
<span class="cm">	 * the current setting should be left unchanged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB_ENABLE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Re-zero the interval if the SPP_HB_TIME_IS_ZERO is</span>
<span class="cm">		 * set.  This lets us use 0 value when this flag</span>
<span class="cm">		 * is set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB_TIME_IS_ZERO</span><span class="p">)</span>
			<span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_hbinterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_hbinterval</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB_TIME_IS_ZERO</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">hbinterval</span> <span class="o">=</span>
				    <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_hbinterval</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">hbinterval</span> <span class="o">=</span>
				    <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_hbinterval</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">hbinterval</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_hbinterval</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hb_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_HB</span><span class="p">)</span> <span class="o">|</span> <span class="n">hb_change</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_HB</span><span class="p">)</span> <span class="o">|</span> <span class="n">hb_change</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_HB</span><span class="p">)</span> <span class="o">|</span> <span class="n">hb_change</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* When Path MTU discovery is disabled the value specified here will</span>
<span class="cm">	 * be the &quot;fixed&quot; path mtu (i.e. the value of the spp_flags field must</span>
<span class="cm">	 * include the flag SPP_PMTUD_DISABLE for this field to have any</span>
<span class="cm">	 * effect).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_DISABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmtu</span><span class="p">;</span>
			<span class="n">sctp_assoc_sync_pmtu</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmtu</span><span class="p">;</span>
			<span class="n">sctp_frag_point</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmtu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmtu</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmtud_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">update</span> <span class="o">=</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_DISABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_ENABLE</span><span class="p">);</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_PMTUD</span><span class="p">)</span> <span class="o">|</span> <span class="n">pmtud_change</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">update</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_transport_pmtu</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">sctp_opt2sk</span><span class="p">(</span><span class="n">sp</span><span class="p">));</span>
				<span class="n">sctp_assoc_sync_pmtu</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_PMTUD</span><span class="p">)</span> <span class="o">|</span> <span class="n">pmtud_change</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_PMTUD</span><span class="p">)</span> <span class="o">|</span> <span class="n">pmtud_change</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Note that unless the spp_flag is set to SPP_SACKDELAY_ENABLE the</span>
<span class="cm">	 * value of this field is ignored.  Note also that a value of zero</span>
<span class="cm">	 * indicates the current setting should be left unchanged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_sackdelay</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_sackdelay</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_sackdelay</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_sackdelay</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sackdelay_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">sackdelay_change</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">sackdelay_change</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">sackdelay_change</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Note that a value of zero indicates the current setting should be</span>
<span class="cm">	   left unchanged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmaxrxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmaxrxt</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmaxrxt</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">spp_pathmaxrxt</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_peer_addr_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_paddrparams</span>  <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>   <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>        <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hb_change</span><span class="p">,</span> <span class="n">pmtud_change</span><span class="p">,</span> <span class="n">sackdelay_change</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddrparams</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Validate flags and value parameters. */</span>
	<span class="n">hb_change</span>        <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB</span><span class="p">;</span>
	<span class="n">pmtud_change</span>     <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD</span><span class="p">;</span>
	<span class="n">sackdelay_change</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_SACKDELAY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hb_change</span>        <span class="o">==</span> <span class="n">SPP_HB</span> <span class="o">||</span>
	    <span class="n">pmtud_change</span>     <span class="o">==</span> <span class="n">SPP_PMTUD</span> <span class="o">||</span>
	    <span class="n">sackdelay_change</span> <span class="o">==</span> <span class="n">SPP_SACKDELAY</span> <span class="o">||</span>
	    <span class="n">params</span><span class="p">.</span><span class="n">spp_sackdelay</span> <span class="o">&gt;</span> <span class="mi">500</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">spp_pathmtu</span> <span class="o">&amp;&amp;</span>
	     <span class="n">params</span><span class="p">.</span><span class="n">spp_pathmtu</span> <span class="o">&lt;</span> <span class="n">SCTP_DEFAULT_MINSEGMENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* If an address other than INADDR_ANY is specified, and</span>
<span class="cm">	 * no transport is found, then the request is invalid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_is_any</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">spp_address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">sctp_addr_id2transport</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">spp_address</span><span class="p">,</span>
					       <span class="n">params</span><span class="p">.</span><span class="n">spp_assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get association, if assoc_id != 0 and the socket is a one</span>
<span class="cm">	 * to many style socket, and an association was not found, then</span>
<span class="cm">	 * the id was invalid.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Heartbeat demand can only be sent on a transport or</span>
<span class="cm">	 * association, but not a socket.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB_DEMAND</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Process parameters. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_apply_peer_addr_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
					    <span class="n">hb_change</span><span class="p">,</span> <span class="n">pmtud_change</span><span class="p">,</span>
					    <span class="n">sackdelay_change</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* If changes are for association, also apply parameters to each</span>
<span class="cm">	 * transport.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_apply_peer_addr_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
						    <span class="n">hb_change</span><span class="p">,</span> <span class="n">pmtud_change</span><span class="p">,</span>
						    <span class="n">sackdelay_change</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will effect the way delayed acks are performed.  This</span>
<span class="cm"> * option allows you to get or set the delayed ack time, in</span>
<span class="cm"> * milliseconds.  It also allows changing the delayed ack frequency.</span>
<span class="cm"> * Changing the frequency to 1 disables the delayed sack algorithm.  If</span>
<span class="cm"> * the assoc_id is 0, then this sets or gets the endpoints default</span>
<span class="cm"> * values.  If the assoc_id field is non-zero, then the set or get</span>
<span class="cm"> * effects the specified association for the one to many model (the</span>
<span class="cm"> * assoc_id field is ignored by the one to one model).  Note that if</span>
<span class="cm"> * sack_delay or sack_freq are 0 when setting this option, then the</span>
<span class="cm"> * current values will remain unchanged.</span>
<span class="cm"> *</span>
<span class="cm"> * struct sctp_sack_info {</span>
<span class="cm"> *     sctp_assoc_t            sack_assoc_id;</span>
<span class="cm"> *     uint32_t                sack_delay;</span>
<span class="cm"> *     uint32_t                sack_freq;</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * sack_assoc_id -  This parameter, indicates which association the user</span>
<span class="cm"> *    is performing an action upon.  Note that if this field&#39;s value is</span>
<span class="cm"> *    zero then the endpoints default value is changed (effecting future</span>
<span class="cm"> *    associations only).</span>
<span class="cm"> *</span>
<span class="cm"> * sack_delay -  This parameter contains the number of milliseconds that</span>
<span class="cm"> *    the user is requesting the delayed ACK timer be set to.  Note that</span>
<span class="cm"> *    this value is defined in the standard to be between 200 and 500</span>
<span class="cm"> *    milliseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * sack_freq -  This parameter contains the number of packets that must</span>
<span class="cm"> *    be received before a sack is sent without waiting for the delay</span>
<span class="cm"> *    timer to expire.  The default value for this is 2, setting this</span>
<span class="cm"> *    value to 1 will disable the delayed sack algorithm.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_delayed_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sack_info</span>    <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>   <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>        <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sack_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use of struct sctp_assoc_value in delayed_ack socket option deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use struct sctp_sack_info instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Validate value parameter. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Get association, if sack_assoc_id != 0 and the socket is a one</span>
<span class="cm">	 * to many style socket, and an association was not found, then</span>
<span class="cm">	 * the id was invalid.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span><span class="p">);</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SPP_SACKDELAY_DISABLE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SPP_SACKDELAY_DISABLE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If change is for association, also apply to each transport. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span><span class="p">);</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">SPP_SACKDELAY_DISABLE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span><span class="p">;</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPP_SACKDELAY</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.3 Initialization Parameters (SCTP_INITMSG)</span>
<span class="cm"> *</span>
<span class="cm"> * Applications can specify protocol parameters for the default association</span>
<span class="cm"> * initialization.  The option name argument to setsockopt() and getsockopt()</span>
<span class="cm"> * is SCTP_INITMSG.</span>
<span class="cm"> *</span>
<span class="cm"> * Setting initialization parameters is effective only on an unconnected</span>
<span class="cm"> * socket (for UDP-style sockets only future associations are effected</span>
<span class="cm"> * by the change).  With TCP-style sockets, this option is inherited by</span>
<span class="cm"> * sockets derived from a listener socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_initmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_initmsg</span> <span class="n">sinit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_initmsg</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinit</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_num_ostreams</span> <span class="o">=</span> <span class="n">sinit</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_instreams</span> <span class="o">=</span> <span class="n">sinit</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="p">.</span><span class="n">sinit_max_attempts</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_attempts</span> <span class="o">=</span> <span class="n">sinit</span><span class="p">.</span><span class="n">sinit_max_attempts</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinit</span><span class="p">.</span><span class="n">sinit_max_init_timeo</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_init_timeo</span> <span class="o">=</span> <span class="n">sinit</span><span class="p">.</span><span class="n">sinit_max_init_timeo</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)</span>
<span class="cm"> *</span>
<span class="cm"> *   Applications that wish to use the sendto() system call may wish to</span>
<span class="cm"> *   specify a default set of parameters that would normally be supplied</span>
<span class="cm"> *   through the inclusion of ancillary data.  This socket option allows</span>
<span class="cm"> *   such an application to set the default sctp_sndrcvinfo structure.</span>
<span class="cm"> *   The application that wishes to use this socket option simply passes</span>
<span class="cm"> *   in to this call the sctp_sndrcvinfo structure defined in Section</span>
<span class="cm"> *   5.2.2) The input parameters accepted by this call include</span>
<span class="cm"> *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,</span>
<span class="cm"> *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in</span>
<span class="cm"> *   to this call if the caller is using the UDP model.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_default_send_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_stream</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_stream</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_flags</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_flags</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_ppid</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_ppid</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_context</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_context</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_timetolive</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_timetolive</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_stream</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_stream</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_flags</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_flags</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_ppid</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_ppid</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_context</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_context</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_timetolive</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_timetolive</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> * Requests that the local SCTP stack use the enclosed peer address as</span>
<span class="cm"> * the association primary.  The enclosed address must be one of the</span>
<span class="cm"> * association peer&#39;s addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_primary_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_prim</span> <span class="n">prim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_prim</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_prim</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">sctp_addr_id2transport</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prim</span><span class="p">.</span><span class="n">ssp_addr</span><span class="p">,</span> <span class="n">prim</span><span class="p">.</span><span class="n">ssp_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.5 SCTP_NODELAY</span>
<span class="cm"> *</span>
<span class="cm"> * Turn on/off any Nagle-like algorithm.  This means that packets are</span>
<span class="cm"> * generally sent as soon as possible and no unnecessary delays are</span>
<span class="cm"> * introduced, at the cost of more packets in the network.  Expects an</span>
<span class="cm"> *  integer boolean flag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_nodelay</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nodelay</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * 7.1.1 SCTP_RTOINFO</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol parameters used to initialize and bound retransmission</span>
<span class="cm"> * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access</span>
<span class="cm"> * and modify these parameters.</span>
<span class="cm"> * All parameters are time values, in milliseconds.  A value of 0, when</span>
<span class="cm"> * modifying the parameters, indicates that the current value should not</span>
<span class="cm"> * be changed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_rtoinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_rtoinfo</span> <span class="n">rtoinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_rtoinfo</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtoinfo</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_assoc_id</span><span class="p">);</span>

	<span class="cm">/* Set the values to the specific association */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span> <span class="o">=</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_min</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If there is no association or the association-id = 0</span>
<span class="cm">		 * set the values to the endpoint.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span> <span class="o">=</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span> <span class="o">=</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span> <span class="o">=</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * 7.1.2 SCTP_ASSOCINFO</span>
<span class="cm"> *</span>
<span class="cm"> * This option is used to tune the maximum retransmission attempts</span>
<span class="cm"> * of the association.</span>
<span class="cm"> * Returns an error if the new association retransmission value is</span>
<span class="cm"> * greater than the sum of the retransmission value  of the peer.</span>
<span class="cm"> * See [SCTP] for more information.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_associnfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">sctp_assocparams</span> <span class="n">assocparams</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assocparams</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assocparams</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_assoc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Set the values to the specific association */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__u32</span> <span class="n">path_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">int</span>   <span class="n">paths</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">peer_addr</span><span class="p">;</span>

			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">peer_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
					<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path_sum</span> <span class="o">+=</span> <span class="n">peer_addr</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">;</span>
				<span class="n">paths</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Only validate asocmaxrxt if we have more than</span>
<span class="cm">			 * one path/transport.  We do this because path</span>
<span class="cm">			 * retransmissions are only counted when we have more</span>
<span class="cm">			 * then one path.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">paths</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">&gt;</span> <span class="n">path_sum</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span> <span class="o">=</span> <span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span>
					<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span>
					<span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set the values to the endpoint */</span>
		<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">=</span>
						<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">=</span>
						<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> * This socket option is a boolean flag which turns on or off mapped V4</span>
<span class="cm"> * addresses.  If this option is turned on and the socket is type</span>
<span class="cm"> * PF_INET6, then IPv4 addresses will be mapped to V6 representation.</span>
<span class="cm"> * If this option is turned off, then no mapping will be done of V4</span>
<span class="cm"> * addresses and a user will receive both PF_INET6 and PF_INET type</span>
<span class="cm"> * addresses on the socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_mappedv4</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">v4mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">v4mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)</span>
<span class="cm"> * This option will get or set the maximum size to put in any outgoing</span>
<span class="cm"> * SCTP DATA chunk.  If a message is larger than this size it will be</span>
<span class="cm"> * fragmented by SCTP into the specified size.  Note that the underlying</span>
<span class="cm"> * SCTP implementation may fragment into smaller sized chunks when the</span>
<span class="cm"> * PMTU of the underlying association is smaller than the value set by</span>
<span class="cm"> * the user.  The default value for this option is &#39;0&#39; which indicates</span>
<span class="cm"> * the user is NOT limiting fragmentation and only the PMTU will effect</span>
<span class="cm"> * SCTP&#39;s choice of DATA chunk size.  Note also that values set larger</span>
<span class="cm"> * than the maximum size of an IP datagram will effectively let SCTP</span>
<span class="cm"> * control fragmentation (i.e. the same as setting this option to 0).</span>
<span class="cm"> *</span>
<span class="cm"> * The following structure is used to access and modify this parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * struct sctp_assoc_value {</span>
<span class="cm"> *   sctp_assoc_t assoc_id;</span>
<span class="cm"> *   uint32_t assoc_value;</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * assoc_id:  This parameter is ignored for one-to-one style sockets.</span>
<span class="cm"> *    For one-to-many style sockets this parameter indicates which</span>
<span class="cm"> *    association the user is performing an action upon.  Note that if</span>
<span class="cm"> *    this field&#39;s value is zero then the endpoints default value is</span>
<span class="cm"> *    changed (effecting future associations only).</span>
<span class="cm"> * assoc_value:  This parameter specifies the maximum size in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_maxseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use of int in maxseg socket option deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use struct sctp_assoc_value instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">SCTP_MAX_CHUNK_LEN</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">-=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">net_header_len</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctphdr</span><span class="p">)</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_data_chunk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">user_frag</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span> <span class="o">=</span> <span class="n">sctp_frag_point</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">user_frag</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> *   Requests that the peer mark the enclosed address as the association</span>
<span class="cm"> *   primary. The enclosed address must be one of the association&#39;s</span>
<span class="cm"> *   locally bound addresses. The following structure is used to make a</span>
<span class="cm"> *   set primary request:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_peer_primary_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>	<span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span>	<span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_setpeerprim</span>	<span class="n">prim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span>		<span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">err</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_setpeerprim</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prim</span><span class="p">.</span><span class="n">sspp_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_disabled_mask</span> <span class="o">&amp;</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">prim</span><span class="p">.</span><span class="n">sspp_addr</span><span class="p">.</span><span class="n">ss_family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">((</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">.</span><span class="n">sspp_addr</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_lookup_laddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">.</span><span class="n">sspp_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="cm">/* Create an ASCONF chunk with SET_PRIMARY parameter	*/</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_make_asconf_set_prim</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
					  <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">.</span><span class="n">sspp_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_send_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;We set peer primary addr primitively.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_adaptation_layer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_setadaptation</span> <span class="n">adaptation</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_setadaptation</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adaptation</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="n">adaptation</span><span class="p">.</span><span class="n">ssb_adaptation_ind</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)</span>
<span class="cm"> *</span>
<span class="cm"> * The context field in the sctp_sndrcvinfo structure is normally only</span>
<span class="cm"> * used when a failed message is retrieved holding the value that was</span>
<span class="cm"> * sent down on the actual send call.  This option allows the setting of</span>
<span class="cm"> * a default context on an association basis that will be received on</span>
<span class="cm"> * reading messages from the peer.  This is especially helpful in the</span>
<span class="cm"> * one-2-many model for an application to keep some reference to an</span>
<span class="cm"> * internal state machine that is processing messages on the</span>
<span class="cm"> * association.  Note that the setting of this value only effects</span>
<span class="cm"> * received messages from the peer and does not effect the value that is</span>
<span class="cm"> * saved with outbound messages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)</span>
<span class="cm"> *</span>
<span class="cm"> * This options will at a minimum specify if the implementation is doing</span>
<span class="cm"> * fragmented interleave.  Fragmented interleave, for a one to many</span>
<span class="cm"> * socket, is when subsequent calls to receive a message may return</span>
<span class="cm"> * parts of messages from different associations.  Some implementations</span>
<span class="cm"> * may allow you to turn this value on or off.  If so, when turned off,</span>
<span class="cm"> * no fragment interleave will occur (which will cause a head of line</span>
<span class="cm"> * blocking amongst multiple associations sharing the same one to many</span>
<span class="cm"> * socket).  When this option is turned on, then each receive call may</span>
<span class="cm"> * come from a different association (thus the user must receive data</span>
<span class="cm"> * with the extended calls (e.g. sctp_recvmsg) to keep track of which</span>
<span class="cm"> * association each receive belongs to.</span>
<span class="cm"> *</span>
<span class="cm"> * This option takes a boolean value.  A non-zero value indicates that</span>
<span class="cm"> * fragmented interleave is on.  A value of zero indicates that</span>
<span class="cm"> * fragmented interleave is off.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that it is important that an implementation that allows this</span>
<span class="cm"> * option to be turned on, have it off by default.  Otherwise an unaware</span>
<span class="cm"> * application using the one to many model may become confused and act</span>
<span class="cm"> * incorrectly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_fragment_interleave</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_interleave</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.1.21.  Set or Get the SCTP Partial Delivery Point</span>
<span class="cm"> *       (SCTP_PARTIAL_DELIVERY_POINT)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will set or get the SCTP partial delivery point.  This</span>
<span class="cm"> * point is the size of a message where the partial delivery API will be</span>
<span class="cm"> * invoked to help free up rwnd space for the peer.  Setting this to a</span>
<span class="cm"> * lower value will cause partial deliveries to happen more often.  The</span>
<span class="cm"> * calls argument is an integer that sets or gets the partial delivery</span>
<span class="cm"> * point.  Note also that the call will fail if the user attempts to set</span>
<span class="cm"> * this value larger than the socket receive buffer size.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that any single message having a length smaller than or equal to</span>
<span class="cm"> * the SCTP partial delivery point will be delivered in one single read</span>
<span class="cm"> * call as long as the user provided buffer is large enough to hold the</span>
<span class="cm"> * message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_partial_delivery_point</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Note: We double the receive buffer from what the user sets</span>
<span class="cm">	 * it to be, also initial rwnd is based on rcvbuf/2.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_point</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* is this the right error code? */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will allow a user to change the maximum burst of packets</span>
<span class="cm"> * that can be emitted by this association.  Note that the default value</span>
<span class="cm"> * is 4, and some implementations may restrict this setting so that it</span>
<span class="cm"> * can only be lowered.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This text doesn&#39;t seem right.  Do this on a socket basis with</span>
<span class="cm"> * future associations inheriting the socket value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_maxburst</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use of int in max_burst socket option deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use struct sctp_assoc_value instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span><span class="p">;</span>
		<span class="n">assoc_id</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">assoc_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)</span>
<span class="cm"> *</span>
<span class="cm"> * This set option adds a chunk type that the user is requesting to be</span>
<span class="cm"> * received only in an authenticated way.  Changes to the list of chunks</span>
<span class="cm"> * will only effect future associations on the socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_auth_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authchunk</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunk</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">sauth_chunk</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_CID_INIT</span>:
	<span class="k">case</span> <span class="n">SCTP_CID_INIT_ACK</span>:
	<span class="k">case</span> <span class="n">SCTP_CID_SHUTDOWN_COMPLETE</span>:
	<span class="k">case</span> <span class="n">SCTP_CID_AUTH</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* add this chunk id to the endpoint */</span>
	<span class="k">return</span> <span class="n">sctp_auth_ep_add_chunkid</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">sauth_chunk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)</span>
<span class="cm"> *</span>
<span class="cm"> * This option gets or sets the list of HMAC algorithms that the local</span>
<span class="cm"> * endpoint requires the peer to use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_hmac_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hmacalgo</span> <span class="o">*</span><span class="n">hmacs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idents</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hmacalgo</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hmacs</span><span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hmacs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">hmacs</span><span class="p">);</span>

	<span class="n">idents</span> <span class="o">=</span> <span class="n">hmacs</span><span class="o">-&gt;</span><span class="n">shmac_num_idents</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idents</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idents</span> <span class="o">&gt;</span> <span class="n">SCTP_AUTH_NUM_HMACS</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">idents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">))</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hmacalgo</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_auth_ep_set_hmacs</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">hmacs</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hmacs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will set a shared secret key which is used to build an</span>
<span class="cm"> * association shared key.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_auth_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authkey</span> <span class="o">*</span><span class="n">authkey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkey</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">authkey</span><span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">authkey</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">authkey</span><span class="o">-&gt;</span><span class="n">sca_keylength</span> <span class="o">&gt;</span> <span class="n">optlen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkey</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">authkey</span><span class="o">-&gt;</span><span class="n">sca_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">authkey</span><span class="o">-&gt;</span><span class="n">sca_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sctp_auth_set_key</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">authkey</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">authkey</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will get or set the active shared key to be used to build</span>
<span class="cm"> * the association shared key.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_active_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authkeyid</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkeyid</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">scact_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">.</span><span class="n">scact_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_auth_set_active_key</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
					<span class="n">val</span><span class="p">.</span><span class="n">scact_keynumber</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.22.  Delete a shared key (SCTP_AUTH_DELETE_KEY)</span>
<span class="cm"> *</span>
<span class="cm"> * This set option will delete a shared secret key from use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_del_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authkeyid</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkeyid</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">scact_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">.</span><span class="n">scact_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_auth_del_key_id</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
				    <span class="n">val</span><span class="p">.</span><span class="n">scact_keynumber</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.1.23 SCTP_AUTO_ASCONF</span>
<span class="cm"> *</span>
<span class="cm"> * This option will enable or disable the use of the automatic generation of</span>
<span class="cm"> * ASCONF chunks to add and delete addresses to an existing association.  Note</span>
<span class="cm"> * that this option has two caveats namely: a) it only affects sockets that</span>
<span class="cm"> * are bound to all addresses available to the SCTP stack, and b) the system</span>
<span class="cm"> * administrator may have an overriding control that turns the ASCONF feature</span>
<span class="cm"> * off no matter what setting the socket option may have.</span>
<span class="cm"> * This option expects an integer boolean flag, where a non-zero value turns on</span>
<span class="cm"> * the option, and a zero value turns off the option.</span>
<span class="cm"> * Note. In this implementation, socket operation overrides default parameter</span>
<span class="cm"> * being set by sysctl as well as FreeBSD implementation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt_auto_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_is_ep_boundall</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">auto_asconf_list</span><span class="p">);</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">auto_asconf_list</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">sctp_auto_asconf_splist</span><span class="p">);</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* API 6.2 setsockopt(), getsockopt()</span>
<span class="cm"> *</span>
<span class="cm"> * Applications use setsockopt() and getsockopt() to set or retrieve</span>
<span class="cm"> * socket options.  Socket options are used to change the default</span>
<span class="cm"> * behavior of sockets calls.  They are described in Section 7.</span>
<span class="cm"> *</span>
<span class="cm"> * The syntax is:</span>
<span class="cm"> *</span>
<span class="cm"> *   ret = getsockopt(int sd, int level, int optname, void __user *optval,</span>
<span class="cm"> *                    int __user *optlen);</span>
<span class="cm"> *   ret = setsockopt(int sd, int level, int optname, const void __user *optval,</span>
<span class="cm"> *                    int optlen);</span>
<span class="cm"> *</span>
<span class="cm"> *   sd      - the socket descript.</span>
<span class="cm"> *   level   - set to IPPROTO_SCTP for all SCTP options.</span>
<span class="cm"> *   optname - the option name.</span>
<span class="cm"> *   optval  - the buffer to store the value of the option.</span>
<span class="cm"> *   optlen  - the size of the buffer.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_setsockopt(sk: %p... optname: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sk</span><span class="p">,</span> <span class="n">optname</span><span class="p">);</span>

	<span class="cm">/* I can hardly begin to describe how wrong this is.  This is</span>
<span class="cm">	 * so broken as to be worse than useless.  The API draft</span>
<span class="cm">	 * REALLY is NOT helpful here...  I am not convinced that the</span>
<span class="cm">	 * semantics of setsockopt() with a level OTHER THAN SOL_SCTP</span>
<span class="cm">	 * are at all well-founded.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_SCTP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nounlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_SOCKOPT_BINDX_ADD</span>:
		<span class="cm">/* &#39;optlen&#39; is the size of the addresses buffer. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_bindx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">,</span>
					       <span class="n">optlen</span><span class="p">,</span> <span class="n">SCTP_BINDX_ADD_ADDR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_SOCKOPT_BINDX_REM</span>:
		<span class="cm">/* &#39;optlen&#39; is the size of the addresses buffer. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_bindx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">,</span>
					       <span class="n">optlen</span><span class="p">,</span> <span class="n">SCTP_BINDX_REM_ADDR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_SOCKOPT_CONNECTX_OLD</span>:
		<span class="cm">/* &#39;optlen&#39; is the size of the addresses buffer. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_connectx_old</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">,</span>
					    <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_SOCKOPT_CONNECTX</span>:
		<span class="cm">/* &#39;optlen&#39; is the size of the addresses buffer. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_connectx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">,</span>
					    <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISABLE_FRAGMENTS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_disable_fragments</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_EVENTS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_events</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_AUTOCLOSE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_autoclose</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PEER_ADDR_PARAMS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_peer_addr_params</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DELAYED_SACK</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_delayed_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARTIAL_DELIVERY_POINT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_partial_delivery_point</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_INITMSG</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_initmsg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_DEFAULT_SEND_PARAM</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_default_send_param</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							    <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PRIMARY_ADDR</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_primary_addr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_SET_PEER_PRIMARY_ADDR</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_peer_primary_addr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_NODELAY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_nodelay</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_RTOINFO</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_rtoinfo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_ASSOCINFO</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_associnfo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_I_WANT_MAPPED_V4_ADDR</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_mappedv4</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_MAXSEG</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_maxseg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_ADAPTATION_LAYER</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_adaptation_layer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_CONTEXT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_context</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_FRAGMENT_INTERLEAVE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_fragment_interleave</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_MAX_BURST</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_maxburst</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTH_CHUNK</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_auth_chunk</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_HMAC_IDENT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_hmac_ident</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTH_KEY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_auth_key</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTH_ACTIVE_KEY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_active_key</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTH_DELETE_KEY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_del_key</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTO_ASCONF</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_setsockopt_auto_asconf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">out_nounlock:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* API 3.1.6 connect() - UDP Style Syntax</span>
<span class="cm"> *</span>
<span class="cm"> * An application may use the connect() call in the UDP model to initiate an</span>
<span class="cm"> * association without sending data.</span>
<span class="cm"> *</span>
<span class="cm"> * The syntax is:</span>
<span class="cm"> *</span>
<span class="cm"> * ret = connect(int sd, const struct sockaddr *nam, socklen_t len);</span>
<span class="cm"> *</span>
<span class="cm"> * sd: the socket descriptor to have a new association added to.</span>
<span class="cm"> *</span>
<span class="cm"> * nam: the address structure (either struct sockaddr_in or struct</span>
<span class="cm"> *    sockaddr_in6 defined in RFC2553 [7]).</span>
<span class="cm"> *</span>
<span class="cm"> * len: the size of the address.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s - sk: %p, sockaddr: %p, addr_len: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/* Validate addr_len before calling common connect/connectx routine. */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span> <span class="o">||</span> <span class="n">addr_len</span> <span class="o">&lt;</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Pass correct addr len to common routine (so it knows there</span>
<span class="cm">		 * is only one address being passed.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__sctp_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* FIXME: Write comments. */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span> <span class="cm">/* STUB */</span>
<span class="p">}</span>

<span class="cm">/* 4.1.4 accept() - TCP Style Syntax</span>
<span class="cm"> *</span>
<span class="cm"> * Applications use accept() call to remove an established SCTP</span>
<span class="cm"> * association from the accept queue of the endpoint.  A new socket</span>
<span class="cm"> * descriptor will be returned from accept() to represent the newly</span>
<span class="cm"> * formed association.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sctp_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_wait_for_accept</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* We treat the list of associations on the endpoint as the accept</span>
<span class="cm">	 * queue and pick the first association on the list.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span> <span class="n">asocs</span><span class="p">);</span>

	<span class="n">newsk</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">create_accept_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Populate the fields of the newsk from the oldsk and migrate the</span>
<span class="cm">	 * asoc to the newsk.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_sock_migrate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">newsk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_SOCKET_TCP</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">newsk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The SCTP ioctl handler. */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SEQPACKET-style sockets in LISTENING state are valid, for</span>
<span class="cm">	 * SCTP, so only discard TCP-style sockets in LISTENING state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCINQ</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We will only return the amount of this packet since</span>
<span class="cm">			 * that is all that will be read.</span>
<span class="cm">			 */</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is the function which gets called during socket creation to</span>
<span class="cm"> * initialized the SCTP-specific portion of the sock.</span>
<span class="cm"> * The sock structure should already be zero-filled memory.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_init_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_init_sock(sk: %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Initialize the SCTP per socket area.  */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_SOCKET_UDP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_SOCKET_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize default send parameters. These parameters can be</span>
<span class="cm">	 * modified with the SCTP_DEFAULT_SEND_PARAM socket option.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_stream</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_ppid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_timetolive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">=</span> <span class="n">sctp_max_burst</span><span class="p">;</span>

	<span class="cm">/* Initialize default setup parameters. These parameters</span>
<span class="cm">	 * can be modified with the SCTP_INITMSG socket option or</span>
<span class="cm">	 * overridden by the SCTP_INIT CMSG.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_num_ostreams</span>   <span class="o">=</span> <span class="n">sctp_max_outstreams</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_instreams</span>  <span class="o">=</span> <span class="n">sctp_max_instreams</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_attempts</span>   <span class="o">=</span> <span class="n">sctp_max_retrans_init</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_init_timeo</span> <span class="o">=</span> <span class="n">sctp_rto_max</span><span class="p">;</span>

	<span class="cm">/* Initialize default RTO related parameters.  These parameters can</span>
<span class="cm">	 * be modified for with the SCTP_RTOINFO socket option.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span> <span class="o">=</span> <span class="n">sctp_rto_initial</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span>     <span class="o">=</span> <span class="n">sctp_rto_max</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span>     <span class="o">=</span> <span class="n">sctp_rto_min</span><span class="p">;</span>

	<span class="cm">/* Initialize default association related parameters. These parameters</span>
<span class="cm">	 * can be modified with the SCTP_ASSOCINFO socket option.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">=</span> <span class="n">sctp_max_retrans_association</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_number_peer_destinations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_peer_rwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_local_rwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">=</span> <span class="n">sctp_valid_cookie_life</span><span class="p">;</span>

	<span class="cm">/* Initialize default event subscriptions. By default, all the</span>
<span class="cm">	 * options are off.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_event_subscribe</span><span class="p">));</span>

	<span class="cm">/* Default Peer Address Parameters.  These defaults can</span>
<span class="cm">	 * be modified via SCTP_PEER_ADDR_PARAMS</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">hbinterval</span>  <span class="o">=</span> <span class="n">sctp_hb_interval</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span>  <span class="o">=</span> <span class="n">sctp_max_retrans_path</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmtu</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// allow default discovery</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackdelay</span>   <span class="o">=</span> <span class="n">sctp_sack_timeout</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackfreq</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span> <span class="n">SPP_HB_ENABLE</span> <span class="o">|</span>
			  <span class="n">SPP_PMTUD_ENABLE</span> <span class="o">|</span>
			  <span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>

	<span class="cm">/* If enabled no SCTP message fragmentation will be performed.</span>
<span class="cm">	 * Configure through SCTP_DISABLE_FRAGMENTS socket option.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">disable_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable Nagle algorithm by default.  */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">nodelay</span>           <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable by default. */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">v4mapped</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Auto-close idle associations after the configured</span>
<span class="cm">	 * number of seconds.  A value of 0 disables this</span>
<span class="cm">	 * feature.  Configure through the SCTP_AUTOCLOSE socket option,</span>
<span class="cm">	 * for UDP-style sockets only.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">autoclose</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* User specified fragmentation limit. */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">user_frag</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span> <span class="o">=</span> <span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">);</span>

	<span class="cm">/* Control variables for partial data delivery. */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">frag_interleave</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Create a per socket endpoint structure.  Even if we</span>
<span class="cm">	 * change the data structure relationships, this may still</span>
<span class="cm">	 * be useful for storing pre-connect address information.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_endpoint_new</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">hmac</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">SCTP_DBG_OBJCNT_INC</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">percpu_counter_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">);</span>
	<span class="n">sock_prot_inuse_add</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_default_auto_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">auto_asconf_list</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">sctp_auto_asconf_splist</span><span class="p">);</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cleanup any SCTP per socket resources.  */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">void</span> <span class="nf">sctp_destroy_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_destroy_sock(sk: %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Release our hold on the endpoint. */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">auto_asconf_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sctp_endpoint_free</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">percpu_counter_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">);</span>
	<span class="n">sock_prot_inuse_add</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* API 4.1.7 shutdown() - TCP Style Syntax</span>
<span class="cm"> *     int shutdown(int socket, int how);</span>
<span class="cm"> *</span>
<span class="cm"> *     sd      - the socket descriptor of the association to be closed.</span>
<span class="cm"> *     how     - Specifies the type of shutdown.  The  values  are</span>
<span class="cm"> *               as follows:</span>
<span class="cm"> *               SHUT_RD</span>
<span class="cm"> *                     Disables further receive operations. No SCTP</span>
<span class="cm"> *                     protocol action is taken.</span>
<span class="cm"> *               SHUT_WR</span>
<span class="cm"> *                     Disables further send operations, and initiates</span>
<span class="cm"> *                     the SCTP shutdown sequence.</span>
<span class="cm"> *               SHUT_RDWR</span>
<span class="cm"> *                     Disables further send  and  receive  operations</span>
<span class="cm"> *                     and initiates the SCTP shutdown sequence.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">void</span> <span class="nf">sctp_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">how</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span> <span class="n">asocs</span><span class="p">);</span>
			<span class="n">sctp_primitive_SHUTDOWN</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 7.2.1 Association Status (SCTP_STATUS)</span>

<span class="cm"> * Applications can retrieve current status information about an</span>
<span class="cm"> * association, including association state, peer receiver window size,</span>
<span class="cm"> * number of unacked data chunks, and number of data chunks pending</span>
<span class="cm"> * receipt.  This information is read-only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_sctp_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">associd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">associd</span> <span class="o">=</span> <span class="n">status</span><span class="p">.</span><span class="n">sstat_assoc_id</span><span class="p">;</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">associd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>

	<span class="n">status</span><span class="p">.</span><span class="n">sstat_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_state</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_rwnd</span> <span class="o">=</span>  <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_unackdata</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">unack_data</span><span class="p">;</span>

	<span class="n">status</span><span class="p">.</span><span class="n">sstat_penddata</span> <span class="o">=</span> <span class="n">sctp_tsnmap_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_instrms</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_outstrms</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_fragmentation_point</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>
	<span class="cm">/* Map ipv4 address into v4-mapped-on-v6 address.  */</span>
	<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
		<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_address</span><span class="p">);</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_state</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_cwnd</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_srtt</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">;</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_rto</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">);</span>
	<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_mtu</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">)</span>
		<span class="n">status</span><span class="p">.</span><span class="n">sstat_primary</span><span class="p">.</span><span class="n">spinfo_state</span> <span class="o">=</span> <span class="n">SCTP_ACTIVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_getsockopt_sctp_status(%d): %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">len</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">sstat_state</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">sstat_rwnd</span><span class="p">,</span>
			  <span class="n">status</span><span class="p">.</span><span class="n">sstat_assoc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* 7.2.2 Peer Address Information (SCTP_GET_PEER_ADDR_INFO)</span>
<span class="cm"> *</span>
<span class="cm"> * Applications can retrieve information about a specific peer address</span>
<span class="cm"> * of an association, including its reachability state, congestion</span>
<span class="cm"> * window, and retransmission timer values.  This information is</span>
<span class="cm"> * read-only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_peer_addr_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_paddrinfo</span> <span class="n">pinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pinfo</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinfo</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_addr_id2transport</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_address</span><span class="p">,</span>
					   <span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_state</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_cwnd</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">;</span>
	<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_srtt</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">;</span>
	<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_rto</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">);</span>
	<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_mtu</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">)</span>
		<span class="n">pinfo</span><span class="p">.</span><span class="n">spinfo_state</span> <span class="o">=</span> <span class="n">SCTP_ACTIVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinfo</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)</span>
<span class="cm"> *</span>
<span class="cm"> * This option is a on/off flag.  If enabled no SCTP message</span>
<span class="cm"> * fragmentation will be performed.  Instead if a message being sent</span>
<span class="cm"> * exceeds the current PMTU size, the message will NOT be sent and</span>
<span class="cm"> * instead a error will be indicated to the user.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_disable_fragments</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disable_fragments</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.15 Set notification and ancillary events (SCTP_EVENTS)</span>
<span class="cm"> *</span>
<span class="cm"> * This socket option is used to specify various notifications and</span>
<span class="cm"> * ancillary data the user wishes to receive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_event_subscribe</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_event_subscribe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)</span>
<span class="cm"> *</span>
<span class="cm"> * This socket option is applicable to the UDP-style socket only.  When</span>
<span class="cm"> * set it will cause associations that are idle for more than the</span>
<span class="cm"> * specified number of seconds to automatically close.  An association</span>
<span class="cm"> * being idle is defined an association that has NOT sent or received</span>
<span class="cm"> * user data.  The special value of &#39;0&#39; indicates that no automatic</span>
<span class="cm"> * close of any associations should be performed.  The option expects an</span>
<span class="cm"> * integer defining the number of seconds of idle time before an</span>
<span class="cm"> * association is closed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_autoclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Applicable to UDP-style socket only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper routine to branch off an association to a new socket.  */</span>
<span class="kt">int</span> <span class="nf">sctp_do_peeloff</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">sctp_assoc_t</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">sockp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* An association cannot be branched off from an already peeled-off</span>
<span class="cm">	 * socket, nor is this supported for tcp style sockets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Create a new socket.  */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span> <span class="n">SOCK_SEQPACKET</span><span class="p">,</span> <span class="n">IPPROTO_SCTP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sctp_copy_sock</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Make peeled-off sockets more like 1-1 accepted sockets.</span>
<span class="cm">	 * Set the daddr and initialize id to something more random</span>
<span class="cm">	 */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_addr</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">to_sk_daddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_addr</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Populate the fields of the newsk from the oldsk and migrate the</span>
<span class="cm">	 * asoc to the newsk.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_sock_migrate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_SOCKET_UDP_HIGH_BANDWIDTH</span><span class="p">);</span>

	<span class="o">*</span><span class="n">sockp</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sctp_do_peeloff</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_peeloff</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_peeloff_arg_t</span> <span class="n">peeloff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_peeloff_arg_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_peeloff_arg_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peeloff</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_do_peeloff</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">peeloff</span><span class="p">.</span><span class="n">associd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Map the socket to an unused fd that can be returned to the user.  */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sock_map_fd</span><span class="p">(</span><span class="n">newsock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">newsock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: sk: %p newsk: %p sd: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">newsock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="cm">/* Return the fd mapped to the new socket.  */</span>
	<span class="n">peeloff</span><span class="p">.</span><span class="n">sd</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peeloff</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)</span>
<span class="cm"> *</span>
<span class="cm"> * Applications can enable or disable heartbeats for any peer address of</span>
<span class="cm"> * an association, modify an address&#39;s heartbeat interval, force a</span>
<span class="cm"> * heartbeat to be sent immediately, and adjust the address&#39;s maximum</span>
<span class="cm"> * number of retransmissions sent before an address is considered</span>
<span class="cm"> * unreachable.  The following structure is used to access and modify an</span>
<span class="cm"> * address&#39;s parameters:</span>
<span class="cm"> *</span>
<span class="cm"> *  struct sctp_paddrparams {</span>
<span class="cm"> *     sctp_assoc_t            spp_assoc_id;</span>
<span class="cm"> *     struct sockaddr_storage spp_address;</span>
<span class="cm"> *     uint32_t                spp_hbinterval;</span>
<span class="cm"> *     uint16_t                spp_pathmaxrxt;</span>
<span class="cm"> *     uint32_t                spp_pathmtu;</span>
<span class="cm"> *     uint32_t                spp_sackdelay;</span>
<span class="cm"> *     uint32_t                spp_flags;</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> *   spp_assoc_id    - (one-to-many style socket) This is filled in the</span>
<span class="cm"> *                     application, and identifies the association for</span>
<span class="cm"> *                     this query.</span>
<span class="cm"> *   spp_address     - This specifies which address is of interest.</span>
<span class="cm"> *   spp_hbinterval  - This contains the value of the heartbeat interval,</span>
<span class="cm"> *                     in milliseconds.  If a  value of zero</span>
<span class="cm"> *                     is present in this field then no changes are to</span>
<span class="cm"> *                     be made to this parameter.</span>
<span class="cm"> *   spp_pathmaxrxt  - This contains the maximum number of</span>
<span class="cm"> *                     retransmissions before this address shall be</span>
<span class="cm"> *                     considered unreachable. If a  value of zero</span>
<span class="cm"> *                     is present in this field then no changes are to</span>
<span class="cm"> *                     be made to this parameter.</span>
<span class="cm"> *   spp_pathmtu     - When Path MTU discovery is disabled the value</span>
<span class="cm"> *                     specified here will be the &quot;fixed&quot; path mtu.</span>
<span class="cm"> *                     Note that if the spp_address field is empty</span>
<span class="cm"> *                     then all associations on this address will</span>
<span class="cm"> *                     have this fixed path mtu set upon them.</span>
<span class="cm"> *</span>
<span class="cm"> *   spp_sackdelay   - When delayed sack is enabled, this value specifies</span>
<span class="cm"> *                     the number of milliseconds that sacks will be delayed</span>
<span class="cm"> *                     for. This value will apply to all addresses of an</span>
<span class="cm"> *                     association if the spp_address field is empty. Note</span>
<span class="cm"> *                     also, that if delayed sack is enabled and this</span>
<span class="cm"> *                     value is set to 0, no change is made to the last</span>
<span class="cm"> *                     recorded delayed sack timer value.</span>
<span class="cm"> *</span>
<span class="cm"> *   spp_flags       - These flags are used to control various features</span>
<span class="cm"> *                     on an association. The flag field may contain</span>
<span class="cm"> *                     zero or more of the following options.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_ENABLE  - Enable heartbeats on the</span>
<span class="cm"> *                     specified address. Note that if the address</span>
<span class="cm"> *                     field is empty all addresses for the association</span>
<span class="cm"> *                     have heartbeats enabled upon them.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_DISABLE - Disable heartbeats on the</span>
<span class="cm"> *                     speicifed address. Note that if the address</span>
<span class="cm"> *                     field is empty all addresses for the association</span>
<span class="cm"> *                     will have their heartbeats disabled. Note also</span>
<span class="cm"> *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are</span>
<span class="cm"> *                     mutually exclusive, only one of these two should</span>
<span class="cm"> *                     be specified. Enabling both fields will have</span>
<span class="cm"> *                     undetermined results.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_HB_DEMAND - Request a user initiated heartbeat</span>
<span class="cm"> *                     to be made immediately.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_PMTUD_ENABLE - This field will enable PMTU</span>
<span class="cm"> *                     discovery upon the specified address. Note that</span>
<span class="cm"> *                     if the address feild is empty then all addresses</span>
<span class="cm"> *                     on the association are effected.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_PMTUD_DISABLE - This field will disable PMTU</span>
<span class="cm"> *                     discovery upon the specified address. Note that</span>
<span class="cm"> *                     if the address feild is empty then all addresses</span>
<span class="cm"> *                     on the association are effected. Not also that</span>
<span class="cm"> *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually</span>
<span class="cm"> *                     exclusive. Enabling both will have undetermined</span>
<span class="cm"> *                     results.</span>
<span class="cm"> *</span>
<span class="cm"> *                     SPP_SACKDELAY_ENABLE - Setting this flag turns</span>
<span class="cm"> *                     on delayed sack. The time specified in spp_sackdelay</span>
<span class="cm"> *                     is used to specify the sack delay for this address. Note</span>
<span class="cm"> *                     that if spp_address is empty then all addresses will</span>
<span class="cm"> *                     enable delayed sack and take on the sack delay</span>
<span class="cm"> *                     value specified in spp_sackdelay.</span>
<span class="cm"> *                     SPP_SACKDELAY_DISABLE - Setting this flag turns</span>
<span class="cm"> *                     off delayed sack. If the spp_address field is blank then</span>
<span class="cm"> *                     delayed sack is disabled for the entire association. Note</span>
<span class="cm"> *                     also that this field is mutually exclusive to</span>
<span class="cm"> *                     SPP_SACKDELAY_ENABLE, setting both will have undefined</span>
<span class="cm"> *                     results.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_peer_addr_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_paddrparams</span>  <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>   <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>        <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddrparams</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddrparams</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* If an address other than INADDR_ANY is specified, and</span>
<span class="cm">	 * no transport is found, then the request is invalid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_is_any</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">spp_address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">sctp_addr_id2transport</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">spp_address</span><span class="p">,</span>
					       <span class="n">params</span><span class="p">.</span><span class="n">spp_assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Failed no transport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Get association, if assoc_id != 0 and the socket is a one</span>
<span class="cm">	 * to many style socket, and an association was not found, then</span>
<span class="cm">	 * the id was invalid.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">spp_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Failed no association</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fetch transport values. */</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_hbinterval</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">hbinterval</span><span class="p">);</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_pathmtu</span>    <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_pathmaxrxt</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_sackdelay</span>  <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">);</span>

		<span class="cm">/*draft-11 doesn&#39;t say what to return in spp_flags*/</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span>      <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fetch association values. */</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_hbinterval</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">hbinterval</span><span class="p">);</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_pathmtu</span>    <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_pathmaxrxt</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_sackdelay</span>  <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">);</span>

		<span class="cm">/*draft-11 doesn&#39;t say what to return in spp_flags*/</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span>      <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Fetch socket values. */</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_hbinterval</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">hbinterval</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_pathmtu</span>    <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_sackdelay</span>  <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_pathmaxrxt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">;</span>

		<span class="cm">/*draft-11 doesn&#39;t say what to return in spp_flags*/</span>
		<span class="n">params</span><span class="p">.</span><span class="n">spp_flags</span>      <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will effect the way delayed acks are performed.  This</span>
<span class="cm"> * option allows you to get or set the delayed ack time, in</span>
<span class="cm"> * milliseconds.  It also allows changing the delayed ack frequency.</span>
<span class="cm"> * Changing the frequency to 1 disables the delayed sack algorithm.  If</span>
<span class="cm"> * the assoc_id is 0, then this sets or gets the endpoints default</span>
<span class="cm"> * values.  If the assoc_id field is non-zero, then the set or get</span>
<span class="cm"> * effects the specified association for the one to many model (the</span>
<span class="cm"> * assoc_id field is ignored by the one to one model).  Note that if</span>
<span class="cm"> * sack_delay or sack_freq are 0 when setting this option, then the</span>
<span class="cm"> * current values will remain unchanged.</span>
<span class="cm"> *</span>
<span class="cm"> * struct sctp_sack_info {</span>
<span class="cm"> *     sctp_assoc_t            sack_assoc_id;</span>
<span class="cm"> *     uint32_t                sack_delay;</span>
<span class="cm"> *     uint32_t                sack_freq;</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * sack_assoc_id -  This parameter, indicates which association the user</span>
<span class="cm"> *    is performing an action upon.  Note that if this field&#39;s value is</span>
<span class="cm"> *    zero then the endpoints default value is changed (effecting future</span>
<span class="cm"> *    associations only).</span>
<span class="cm"> *</span>
<span class="cm"> * sack_delay -  This parameter contains the number of milliseconds that</span>
<span class="cm"> *    the user is requesting the delayed ACK timer be set to.  Note that</span>
<span class="cm"> *    this value is defined in the standard to be between 200 and 500</span>
<span class="cm"> *    milliseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * sack_freq -  This parameter contains the number of packets that must</span>
<span class="cm"> *    be received before a sack is sent without waiting for the delay</span>
<span class="cm"> *    timer to expire.  The default value for this is 2, setting this</span>
<span class="cm"> *    value to 1 will disable the delayed sack algorithm.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_delayed_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sack_info</span>    <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span>        <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sack_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sack_info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use of struct sctp_assoc_value in delayed_ack socket option deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use struct sctp_sack_info instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Get association, if sack_assoc_id != 0 and the socket is a one</span>
<span class="cm">	 * to many style socket, and an association was not found, then</span>
<span class="cm">	 * the id was invalid.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">sack_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fetch association values. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">);</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackfreq</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Fetch socket values. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span>  <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">;</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackfreq</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_delay</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">params</span><span class="p">.</span><span class="n">sack_freq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.3 Initialization Parameters (SCTP_INITMSG)</span>
<span class="cm"> *</span>
<span class="cm"> * Applications can specify protocol parameters for the default association</span>
<span class="cm"> * initialization.  The option name argument to setsockopt() and getsockopt()</span>
<span class="cm"> * is SCTP_INITMSG.</span>
<span class="cm"> *</span>
<span class="cm"> * Setting initialization parameters is effective only on an unconnected</span>
<span class="cm"> * socket (for UDP-style sockets only future associations are effected</span>
<span class="cm"> * by the change).  With TCP-style sockets, this option is inherited by</span>
<span class="cm"> * sockets derived from a listener socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_initmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_initmsg</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_initmsg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_peer_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_getaddrs</span> <span class="n">getaddrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">addrlen</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">space_left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_copied</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getaddrs</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* For UDP-style sockets, id specifies the association to query.  */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">getaddrs</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">optval</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">,</span><span class="n">addrs</span><span class="p">);</span>
	<span class="n">space_left</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">,</span><span class="n">addrs</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
		<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space_left</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">to</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">space_left</span> <span class="o">-=</span> <span class="n">addrlen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_num</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">bytes_copied</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">)</span> <span class="o">-</span> <span class="n">optval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">bytes_copied</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_copy_laddrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">space_left</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bytes_copied</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addrlen</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">PF_INET</span> <span class="o">==</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">AF_INET6</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">PF_INET6</span> <span class="o">==</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inet_v6_ipv6only</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">AF_INET</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">temp</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span>
			<span class="n">temp</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

		<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
								<span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space_left</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnt</span> <span class="o">=</span>  <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>

		<span class="n">to</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">space_left</span> <span class="o">-=</span> <span class="n">addrlen</span><span class="p">;</span>
		<span class="o">*</span><span class="n">bytes_copied</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_local_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_getaddrs</span> <span class="n">getaddrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">addrlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">space_left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getaddrs</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  For UDP-style sockets, id specifies the association to query.</span>
<span class="cm">	 *  If the id field is set to the value &#39;0&#39; then the locally bound</span>
<span class="cm">	 *  addresses are returned without regard to any particular</span>
<span class="cm">	 *  association.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">getaddrs</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">getaddrs</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">optval</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">,</span><span class="n">addrs</span><span class="p">);</span>
	<span class="n">space_left</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span><span class="p">,</span><span class="n">addrs</span><span class="p">);</span>

	<span class="n">addrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">space_left</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addrs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* If the endpoint is bound to 0.0.0.0 or ::0, get the valid</span>
<span class="cm">	 * addresses from the global local address list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_list_single_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_is_any</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="n">sctp_copy_laddrs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span>
						<span class="n">space_left</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_copied</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">copy_getaddrs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="cm">/* Protection on the bound address list is not needed since</span>
<span class="cm">	 * in the socket option context we hold a socket lock and</span>
<span class="cm">	 * thus the bound address list can&#39;t change.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>
		<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space_left</span> <span class="o">&lt;</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span>  <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span> <span class="cm">/*fixme: right error?*/</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>
		<span class="n">bytes_copied</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">space_left</span> <span class="o">-=</span> <span class="n">addrlen</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">copy_getaddrs:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">addrs</span><span class="p">,</span> <span class="n">bytes_copied</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_getaddrs</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_num</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">bytes_copied</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> * Requests that the local SCTP stack use the enclosed peer address as</span>
<span class="cm"> * the association primary.  The enclosed address must be one of the</span>
<span class="cm"> * association peer&#39;s addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_primary_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_prim</span> <span class="n">prim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_prim</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_prim</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prim</span><span class="p">.</span><span class="n">ssp_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">.</span><span class="n">ssp_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>

	<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span>
			<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">prim</span><span class="p">.</span><span class="n">ssp_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prim</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.11  Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)</span>
<span class="cm"> *</span>
<span class="cm"> * Requests that the local endpoint set the specified Adaptation Layer</span>
<span class="cm"> * Indication parameter for all future INIT and INIT-ACK exchanges.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_adaptation_layer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_setadaptation</span> <span class="n">adaptation</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_setadaptation</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_setadaptation</span><span class="p">);</span>

	<span class="n">adaptation</span><span class="p">.</span><span class="n">ssb_adaptation_ind</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adaptation</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)</span>
<span class="cm"> *</span>
<span class="cm"> *   Applications that wish to use the sendto() system call may wish to</span>
<span class="cm"> *   specify a default set of parameters that would normally be supplied</span>
<span class="cm"> *   through the inclusion of ancillary data.  This socket option allows</span>
<span class="cm"> *   such an application to set the default sctp_sndrcvinfo structure.</span>


<span class="cm"> *   The application that wishes to use this socket option simply passes</span>
<span class="cm"> *   in to this call the sctp_sndrcvinfo structure defined in Section</span>
<span class="cm"> *   5.2.2) The input parameters accepted by this call include</span>
<span class="cm"> *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,</span>
<span class="cm"> *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in</span>
<span class="cm"> *   to this call if the caller is using the UDP model.</span>
<span class="cm"> *</span>
<span class="cm"> *   For getsockopt, it get the default sctp_sndrcvinfo structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_default_send_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="p">.</span><span class="n">sinfo_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_stream</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_stream</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_flags</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_flags</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_ppid</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_ppid</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_context</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_context</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_timetolive</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_timetolive</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_stream</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_stream</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_flags</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_flags</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_ppid</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_ppid</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_context</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_context</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">sinfo_timetolive</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_timetolive</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * 7.1.5 SCTP_NODELAY</span>
<span class="cm"> *</span>
<span class="cm"> * Turn on/off any Nagle-like algorithm.  This means that packets are</span>
<span class="cm"> * generally sent as soon as possible and no unnecessary delays are</span>
<span class="cm"> * introduced, at the cost of more packets in the network.  Expects an</span>
<span class="cm"> * integer boolean flag.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_nodelay</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nodelay</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * 7.1.1 SCTP_RTOINFO</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol parameters used to initialize and bound retransmission</span>
<span class="cm"> * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access</span>
<span class="cm"> * and modify these parameters.</span>
<span class="cm"> * All parameters are time values, in milliseconds.  A value of 0, when</span>
<span class="cm"> * modifying the parameters, indicates that the current value should not</span>
<span class="cm"> * be changed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_rtoinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_rtoinfo</span> <span class="n">rtoinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_rtoinfo</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_rtoinfo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtoinfo</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_assoc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Values corresponding to the specific association. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">);</span>
		<span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span><span class="p">);</span>
		<span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_min</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Values corresponding to the endpoint. */</span>
		<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span><span class="p">;</span>
		<span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span><span class="p">;</span>
		<span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtoinfo</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * 7.1.2 SCTP_ASSOCINFO</span>
<span class="cm"> *</span>
<span class="cm"> * This option is used to tune the maximum retransmission attempts</span>
<span class="cm"> * of the association.</span>
<span class="cm"> * Returns an error if the new association retransmission value is</span>
<span class="cm"> * greater than the sum of the retransmission value  of the peer.</span>
<span class="cm"> * See [SCTP] for more information.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_associnfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">sctp_assocparams</span> <span class="n">assocparams</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assocparams</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assocparams</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assocparams</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_assoc_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Values correspoinding to the specific association */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_peer_rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_local_rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">=</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_sec</span>
						<span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span>
						<span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_usec</span>
						<span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

		<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnt</span> <span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_number_peer_destinations</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Values corresponding to the endpoint */</span>
		<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_peer_rwnd</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_peer_rwnd</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_local_rwnd</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_local_rwnd</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">=</span>
					<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span><span class="p">;</span>
		<span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_number_peer_destinations</span> <span class="o">=</span>
					<span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span>
					<span class="n">sasoc_number_peer_destinations</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assocparams</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> * This socket option is a boolean flag which turns on or off mapped V4</span>
<span class="cm"> * addresses.  If this option is turned on and the socket is type</span>
<span class="cm"> * PF_INET6, then IPv4 addresses will be mapped to V6 representation.</span>
<span class="cm"> * If this option is turned off, then no mapping will be done of V4</span>
<span class="cm"> * addresses and a user will receive both PF_INET6 and PF_INET type</span>
<span class="cm"> * addresses on the socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_mappedv4</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">v4mapped</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)</span>
<span class="cm"> * (chapter and verse is quoted at sctp_setsockopt_context())</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)</span>
<span class="cm"> * This option will get or set the maximum size to put in any outgoing</span>
<span class="cm"> * SCTP DATA chunk.  If a message is larger than this size it will be</span>
<span class="cm"> * fragmented by SCTP into the specified size.  Note that the underlying</span>
<span class="cm"> * SCTP implementation may fragment into smaller sized chunks when the</span>
<span class="cm"> * PMTU of the underlying association is smaller than the value set by</span>
<span class="cm"> * the user.  The default value for this option is &#39;0&#39; which indicates</span>
<span class="cm"> * the user is NOT limiting fragmentation and only the PMTU will effect</span>
<span class="cm"> * SCTP&#39;s choice of DATA chunk size.  Note also that values set larger</span>
<span class="cm"> * than the maximum size of an IP datagram will effectively let SCTP</span>
<span class="cm"> * control fragmentation (i.e. the same as setting this option to 0).</span>
<span class="cm"> *</span>
<span class="cm"> * The following structure is used to access and modify this parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * struct sctp_assoc_value {</span>
<span class="cm"> *   sctp_assoc_t assoc_id;</span>
<span class="cm"> *   uint32_t assoc_value;</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * assoc_id:  This parameter is ignored for one-to-one style sockets.</span>
<span class="cm"> *    For one-to-many style sockets this parameter indicates which</span>
<span class="cm"> *    association the user is performing an action upon.  Note that if</span>
<span class="cm"> *    this field&#39;s value is zero then the endpoints default value is</span>
<span class="cm"> *    changed (effecting future associations only).</span>
<span class="cm"> * assoc_value:  This parameter specifies the maximum size in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_maxseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use of int in maxseg socket option deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use struct sctp_assoc_value instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">user_frag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)</span>
<span class="cm"> * (chapter and verse is quoted at sctp_setsockopt_fragment_interleave())</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_fragment_interleave</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_interleave</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.25.  Set or Get the sctp partial delivery point</span>
<span class="cm"> * (chapter and verse is quoted at sctp_setsockopt_partial_delivery_point())</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_partial_delivery_point</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
						  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_point</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)</span>
<span class="cm"> * (chapter and verse is quoted at sctp_setsockopt_maxburst())</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_maxburst</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use of int in max_burst socket option deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Use struct sctp_assoc_value instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">assoc_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">.</span><span class="n">assoc_value</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_hmac_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hmacalgo</span>  <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hmac_algo_param</span> <span class="o">*</span><span class="n">hmacs</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_idents</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">hmacs</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs_list</span><span class="p">;</span>
	<span class="n">data_len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hmacs</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hmacalgo</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hmacalgo</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">num_idents</span> <span class="o">=</span> <span class="n">data_len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">num_idents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">shmac_num_idents</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">shmac_idents</span><span class="p">,</span> <span class="n">hmacs</span><span class="o">-&gt;</span><span class="n">hmac_ids</span><span class="p">,</span> <span class="n">data_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_active_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authkeyid</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkeyid</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkeyid</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">scact_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">.</span><span class="n">scact_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">val</span><span class="p">.</span><span class="n">scact_keynumber</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">active_key_id</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span><span class="p">.</span><span class="n">scact_keynumber</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">active_key_id</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkeyid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_peer_auth_chunks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authchunks</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_authchunks</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunks_param</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">num_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">gauth_chunks</span><span class="p">;</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">gauth_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">num</span><span class="p">;</span>

	<span class="cm">/* See if the user provided enough room for all the data */</span>
	<span class="n">num_chunks</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">num_chunks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">num:</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_chunks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">gauth_number_of_chunks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_local_auth_chunks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authchunks</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_authchunks</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunks_param</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">num_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">gauth_chunks</span><span class="p">;</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_id2assoc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">gauth_assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">.</span><span class="n">gauth_assoc_id</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunks_param</span><span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_chunks</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_chunk_list</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">num</span><span class="p">;</span>

	<span class="n">num_chunks</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_chunks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">num:</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authchunks</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_chunks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">gauth_number_of_chunks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.2.5.  Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)</span>
<span class="cm"> * This option gets the current number of associations that are attached</span>
<span class="cm"> * to a one-to-many style socket.  The option value is an uint32_t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_assoc_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">),</span> <span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.1.23 SCTP_AUTO_ASCONF</span>
<span class="cm"> * See the corresponding setsockopt entry as description</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_auto_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_is_ep_boundall</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 8.2.6. Get the Current Identifiers of Associations</span>
<span class="cm"> *        (SCTP_GET_ASSOC_ID_LIST)</span>
<span class="cm"> *</span>
<span class="cm"> * This option gets the current list of SCTP association identifiers of</span>
<span class="cm"> * the SCTP associations handled by a one-to-many style socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt_assoc_ids</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_ids</span> <span class="o">*</span><span class="n">ids</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_ids</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">),</span> <span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_ids</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_assoc_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_ids</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_assoc_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">;</span>

	<span class="n">ids</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ids</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ids</span><span class="o">-&gt;</span><span class="n">gaids_number_of_ids</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">),</span> <span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ids</span><span class="o">-&gt;</span><span class="n">gaids_assoc_id</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">)</span> <span class="o">||</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ids</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ids</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_getsockopt(sk: %p... optname: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sk</span><span class="p">,</span> <span class="n">optname</span><span class="p">);</span>

	<span class="cm">/* I can hardly begin to describe how wrong this is.  This is</span>
<span class="cm">	 * so broken as to be worse than useless.  The API draft</span>
<span class="cm">	 * REALLY is NOT helpful here...  I am not convinced that the</span>
<span class="cm">	 * semantics of getsockopt() with a level OTHER THAN SOL_SCTP</span>
<span class="cm">	 * are at all well-founded.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_SCTP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_STATUS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_sctp_status</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_DISABLE_FRAGMENTS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_disable_fragments</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							   <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_EVENTS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_events</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTOCLOSE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_autoclose</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_SOCKOPT_PEELOFF</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_peeloff</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PEER_ADDR_PARAMS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_peer_addr_params</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							  <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_DELAYED_SACK</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_delayed_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							  <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_INITMSG</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_initmsg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_GET_PEER_ADDRS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_peer_addrs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
						    <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_GET_LOCAL_ADDRS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_local_addrs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
						     <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_SOCKOPT_CONNECTX3</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_connectx3</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_DEFAULT_SEND_PARAM</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_default_send_param</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
							    <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PRIMARY_ADDR</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_primary_addr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_NODELAY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_nodelay</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_RTOINFO</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_rtoinfo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_ASSOCINFO</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_associnfo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_I_WANT_MAPPED_V4_ADDR</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_mappedv4</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_MAXSEG</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_maxseg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_GET_PEER_ADDR_INFO</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_peer_addr_info</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							<span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_ADAPTATION_LAYER</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_adaptation_layer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							<span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_CONTEXT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_context</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_FRAGMENT_INTERLEAVE</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_fragment_interleave</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							     <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARTIAL_DELIVERY_POINT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_partial_delivery_point</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
								<span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_MAX_BURST</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_maxburst</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTH_KEY</span>:
	<span class="k">case</span> <span class="n">SCTP_AUTH_CHUNK</span>:
	<span class="k">case</span> <span class="n">SCTP_AUTH_DELETE_KEY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_HMAC_IDENT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_hmac_ident</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTH_ACTIVE_KEY</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_active_key</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PEER_AUTH_CHUNKS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_peer_auth_chunks</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							<span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_LOCAL_AUTH_CHUNKS</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_local_auth_chunks</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
							<span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_GET_ASSOC_NUMBER</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_assoc_number</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_GET_ASSOC_ID_LIST</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_assoc_ids</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_AUTO_ASCONF</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_getsockopt_auto_asconf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* STUB */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_unhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* STUB */</span>
<span class="p">}</span>

<span class="cm">/* Check if port is acceptable.  Possibly find first available port.</span>
<span class="cm"> *</span>
<span class="cm"> * The port hash table (contained in the &#39;global&#39; SCTP protocol storage</span>
<span class="cm"> * returned by struct sctp_protocol *sctp_get_protocol()). The hash</span>
<span class="cm"> * table is an array of 4096 lists (sctp_bind_hashbucket). Each</span>
<span class="cm"> * list (the list number is the port number hashed out, so as you</span>
<span class="cm"> * would expect from a hash function, all the ports in a given list have</span>
<span class="cm"> * such a number that hashes out to the same list number; you were</span>
<span class="cm"> * expecting that, right?); so each list has a set of ports, with a</span>
<span class="cm"> * link to the socket (struct sock) that uses it, the port number and</span>
<span class="cm"> * a fastreuse flag (FIXME: NPI ipg).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">sctp_bucket_create</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">sctp_get_port_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span> <span class="cm">/* hash list */</span>
	<span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span> <span class="cm">/* hash list port iterator */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">snum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_get_port() begins, snum=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">snum</span><span class="p">);</span>
	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Search for an available port. */</span>
		<span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rover</span><span class="p">;</span>

		<span class="n">inet_get_local_port_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">high</span><span class="p">);</span>
		<span class="n">remaining</span> <span class="o">=</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rover</span> <span class="o">=</span> <span class="n">net_random</span><span class="p">()</span> <span class="o">%</span> <span class="n">remaining</span> <span class="o">+</span> <span class="n">low</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">rover</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rover</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rover</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">))</span>
				<span class="n">rover</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inet_is_reserved_local_port</span><span class="p">(</span><span class="n">rover</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">sctp_phashfn</span><span class="p">(</span><span class="n">rover</span><span class="p">);</span>
			<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_port_hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">sctp_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">sctp_for_each_hentry</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">rover</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">next:</span>
			<span class="n">sctp_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Exhausted local port range during search? */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="cm">/* OK, here is the one we will use.  HEAD (the port</span>
<span class="cm">		 * hash table list entry) is non-NULL and we hold it&#39;s</span>
<span class="cm">		 * mutex.</span>
<span class="cm">		 */</span>
		<span class="n">snum</span> <span class="o">=</span> <span class="n">rover</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We are given an specific port number; we verify</span>
<span class="cm">		 * that it is not being used. If it is used, we will</span>
<span class="cm">		 * exahust the search in the hash list corresponding</span>
<span class="cm">		 * to the port number (snum) - we detect that with the</span>
<span class="cm">		 * port iterator, pp being NULL.</span>
<span class="cm">		 */</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_port_hashtable</span><span class="p">[</span><span class="n">sctp_phashfn</span><span class="p">(</span><span class="n">snum</span><span class="p">)];</span>
		<span class="n">sctp_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">sctp_for_each_hentry</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">snum</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">pp_found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">pp_not_found</span><span class="p">;</span>
<span class="nl">pp_found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We had a port hash table hit - there is an</span>
<span class="cm">		 * available port (pp != NULL) and it is being</span>
<span class="cm">		 * used by other socket (pp-&gt;owner not empty); that other</span>
<span class="cm">		 * socket is going to be sk2.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">reuse</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk2</span><span class="p">;</span>

		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_get_port() found a possible match</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">&amp;&amp;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">SCTP_SS_LISTENING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>

		<span class="cm">/* Run through the list of sockets bound to the port</span>
<span class="cm">		 * (pp-&gt;port) [via the pointers bind_next and</span>
<span class="cm">		 * bind_pprev in the struct sock *sk2 (pp-&gt;sk)]. On each one,</span>
<span class="cm">		 * we get the endpoint they describe and run through</span>
<span class="cm">		 * the endpoint&#39;s list of IP (v4 or v6) addresses,</span>
<span class="cm">		 * comparing each of the addresses with the address of</span>
<span class="cm">		 * the socket sk. If we find a match, then that means</span>
<span class="cm">		 * that this port/socket (sk) combination are already</span>
<span class="cm">		 * in an endpoint.</span>
<span class="cm">		 */</span>
		<span class="n">sk_for_each_bound</span><span class="p">(</span><span class="n">sk2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep2</span><span class="p">;</span>
			<span class="n">ep2</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="n">sk2</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">reuse</span> <span class="o">&amp;&amp;</span> <span class="n">sk2</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">&amp;&amp;</span>
			     <span class="n">sk2</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">SCTP_SS_LISTENING</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_bind_addr_conflict</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep2</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
						 <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk2</span><span class="p">),</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">sk2</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_get_port(): Found a match</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">pp_not_found:</span>
	<span class="cm">/* If there was a hash table miss, create a new port.  */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pp</span> <span class="o">=</span> <span class="n">sctp_bucket_create</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">snum</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>

	<span class="cm">/* In either case (hit or miss), make sure fastreuse is 1 only</span>
<span class="cm">	 * if sk-&gt;sk_reuse is too (that is, if the caller requested</span>
<span class="cm">	 * SO_REUSEADDR on this socket -sk-).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">SCTP_SS_LISTENING</span><span class="p">)</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">SCTP_SS_LISTENING</span><span class="p">))</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We are set, so fill up all the data in the hash table</span>
<span class="cm">	 * entry, tie the socket list information with the rest of the</span>
<span class="cm">	 * sockets FIXME: Blurry, NPI (ipg).</span>
<span class="cm">	 */</span>
<span class="nl">success:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span> <span class="o">=</span> <span class="n">snum</span><span class="p">;</span>
		<span class="n">sk_add_bind_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_unlock:</span>
	<span class="n">sctp_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Assign a &#39;snum&#39; port to the socket.  If snum == 0, an ephemeral</span>
<span class="cm"> * port is requested.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_get_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">;</span>

	<span class="cm">/* Set up a dummy address struct from the sk. */</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_sk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">addr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">snum</span><span class="p">);</span>

	<span class="cm">/* Note: sk-&gt;sk_num gets filled in if ephemeral port request. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sctp_get_port_local</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Move a socket to LISTENING state.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_listen_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">tfm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Allocate HMAC for generating cookie. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_hmac_alg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tfm</span> <span class="o">=</span> <span class="n">crypto_alloc_hash</span><span class="p">(</span><span class="n">sctp_hmac_alg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tfm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">net_info_ratelimited</span><span class="p">(</span><span class="s">&quot;failed to load transform for %s: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">sctp_hmac_alg</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tfm</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span> <span class="o">=</span> <span class="n">tfm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a bind() or sctp_bindx() is not called prior to a listen()</span>
<span class="cm">	 * call that allows new associations to be accepted, the system</span>
<span class="cm">	 * picks an ephemeral port and will choose an address set equivalent</span>
<span class="cm">	 * to binding with a wildcard address.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is not currently spelled out in the SCTP sockets</span>
<span class="cm">	 * extensions draft, but follows the practice as seen in TCP</span>
<span class="cm">	 * sockets.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_LISTENING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_get_port</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_CLOSED</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span> <span class="o">=</span> <span class="n">backlog</span><span class="p">;</span>
	<span class="n">sctp_hash_endpoint</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 4.1.3 / 5.1.3 listen()</span>
<span class="cm"> *</span>
<span class="cm"> *   By default, new associations are not accepted for UDP style sockets.</span>
<span class="cm"> *   An application uses listen() to mark a socket as being able to</span>
<span class="cm"> *   accept new associations.</span>
<span class="cm"> *</span>
<span class="cm"> *   On TCP style sockets, applications use listen() to ready the SCTP</span>
<span class="cm"> *   endpoint for accepting inbound associations.</span>
<span class="cm"> *</span>
<span class="cm"> *   On both types of endpoints a backlog of &#39;0&#39; disables listening.</span>
<span class="cm"> *</span>
<span class="cm"> *  Move a socket to LISTENING state.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_inet_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">backlog</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Peeled-off sockets are not allowed to listen().  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP_HIGH_BANDWIDTH</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* If backlog is zero, disable listening. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">backlog</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sctp_unhash_endpoint</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_CLOSED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span><span class="p">)</span>
			<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we are already listening, just update the backlog */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span> <span class="o">=</span> <span class="n">backlog</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_listen_start</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is done by modeling the current datagram_poll() and the</span>
<span class="cm"> * tcp_poll().  Note that, based on these implementations, we don&#39;t</span>
<span class="cm"> * lock the socket in this function, even though it seems that,</span>
<span class="cm"> * ideally, locking or some other mechanisms can be used to ensure</span>
<span class="cm"> * the integrity of the counters (sndbuf and wmem_alloc) used</span>
<span class="cm"> * in this place.  We assume that we don&#39;t need locks either until proven</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Another thing to note is that we include the Async I/O support</span>
<span class="cm"> * here, again, by modeling the current TCP/UDP code.  We don&#39;t have</span>
<span class="cm"> * a good way to test with it yet.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sctp_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/* A TCP-style listening socket becomes readable when the accept queue</span>
<span class="cm">	 * is not empty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">))</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Is there any exceptional events?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLRDHUP</span> <span class="o">|</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>

	<span class="cm">/* Is it readable?  Reconsider this code with TCP-style support.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="cm">/* The association is either gone or not ready.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* Is it writable?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since the socket is not locked, the buffer</span>
<span class="cm">		 * might be made available after the writeable check and</span>
<span class="cm">		 * before the bit is set.  This could cause a lost I/O</span>
<span class="cm">		 * signal.  tcp_poll() has a race breaker for this race</span>
<span class="cm">		 * condition.  Based on their implementation, we put</span>
<span class="cm">		 * in the following code to cover it as well.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * 2nd Level Abstractions</span>
<span class="cm"> ********************************************************************/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="nf">sctp_bucket_create</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

	<span class="n">pp</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sctp_bucket_cachep</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DBG_OBJCNT_INC</span><span class="p">(</span><span class="n">bind_bucket</span><span class="p">);</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">snum</span><span class="p">;</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">fastreuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold hashbucket lock for this tb with local BH disabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_bucket_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span> <span class="o">&amp;&amp;</span> <span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sctp_bucket_cachep</span><span class="p">,</span> <span class="n">pp</span><span class="p">);</span>
		<span class="n">SCTP_DBG_OBJCNT_DEC</span><span class="p">(</span><span class="n">bind_bucket</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Release this socket&#39;s reference to a local port.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sctp_put_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">sctp_port_hashtable</span><span class="p">[</span><span class="n">sctp_phashfn</span><span class="p">(</span><span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

	<span class="n">sctp_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span><span class="p">;</span>
	<span class="n">__sk_del_bind_node</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sctp_bucket_destroy</span><span class="p">(</span><span class="n">pp</span><span class="p">);</span>
	<span class="n">sctp_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_put_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">__sctp_put_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The system picks an ephemeral port and choose an address set equivalent</span>
<span class="cm"> * to binding with a wildcard address.</span>
<span class="cm"> * One of those addresses will be the primary address for the association.</span>
<span class="cm"> * This automatically enables the multihoming capability of SCTP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_autobind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">autoaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">port</span><span class="p">;</span>

	<span class="cm">/* Initialize a local sockaddr structure to INADDR_ANY. */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">);</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">inaddr_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">autoaddr</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sctp_do_bind</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">autoaddr</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.</span>
<span class="cm"> *</span>
<span class="cm"> * From RFC 2292</span>
<span class="cm"> * 4.2 The cmsghdr Structure *</span>
<span class="cm"> *</span>
<span class="cm"> * When ancillary data is sent or received, any number of ancillary data</span>
<span class="cm"> * objects can be specified by the msg_control and msg_controllen members of</span>
<span class="cm"> * the msghdr structure, because each object is preceded by</span>
<span class="cm"> * a cmsghdr structure defining the object&#39;s length (the cmsg_len member).</span>
<span class="cm"> * Historically Berkeley-derived implementations have passed only one object</span>
<span class="cm"> * at a time, but this API allows multiple objects to be</span>
<span class="cm"> * passed in a single call to sendmsg() or recvmsg(). The following example</span>
<span class="cm"> * shows two ancillary data objects in a control buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *   |&lt;--------------------------- msg_controllen --------------------------&gt;|</span>
<span class="cm"> *   |                                                                       |</span>
<span class="cm"> *</span>
<span class="cm"> *   |&lt;----- ancillary data object -----&gt;|&lt;----- ancillary data object -----&gt;|</span>
<span class="cm"> *</span>
<span class="cm"> *   |&lt;---------- CMSG_SPACE() ---------&gt;|&lt;---------- CMSG_SPACE() ---------&gt;|</span>
<span class="cm"> *   |                                   |                                   |</span>
<span class="cm"> *</span>
<span class="cm"> *   |&lt;---------- cmsg_len ----------&gt;|  |&lt;--------- cmsg_len -----------&gt;|  |</span>
<span class="cm"> *</span>
<span class="cm"> *   |&lt;--------- CMSG_LEN() ---------&gt;|  |&lt;-------- CMSG_LEN() ----------&gt;|  |</span>
<span class="cm"> *   |                                |  |                                |  |</span>
<span class="cm"> *</span>
<span class="cm"> *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+</span>
<span class="cm"> *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|</span>
<span class="cm"> *</span>
<span class="cm"> *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|</span>
<span class="cm"> *</span>
<span class="cm"> *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+</span>
<span class="cm"> *    ^</span>
<span class="cm"> *    |</span>
<span class="cm"> *</span>
<span class="cm"> * msg_control</span>
<span class="cm"> * points here</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">int</span> <span class="nf">sctp_msghdr_parse</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				  <span class="n">sctp_cmsgs_t</span> <span class="o">*</span><span class="n">cmsgs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmsghdr</span> <span class="o">*</span><span class="n">cmsg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">my_msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cmsg</span> <span class="o">=</span> <span class="n">CMSG_FIRSTHDR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	     <span class="n">cmsg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">cmsg</span> <span class="o">=</span> <span class="n">CMSG_NXTHDR</span><span class="p">(</span><span class="n">my_msg</span><span class="p">,</span> <span class="n">cmsg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CMSG_OK</span><span class="p">(</span><span class="n">my_msg</span><span class="p">,</span> <span class="n">cmsg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Should we parse this header or ignore?  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_level</span> <span class="o">!=</span> <span class="n">IPPROTO_SCTP</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Strictly check lengths following example in SCM code.  */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_INIT</span>:
			<span class="cm">/* SCTP Socket API Extension</span>
<span class="cm">			 * 5.2.1 SCTP Initiation Structure (SCTP_INIT)</span>
<span class="cm">			 *</span>
<span class="cm">			 * This cmsghdr structure provides information for</span>
<span class="cm">			 * initializing new SCTP associations with sendmsg().</span>
<span class="cm">			 * The SCTP_INITMSG socket option uses this same data</span>
<span class="cm">			 * structure.  This structure is not used for</span>
<span class="cm">			 * recvmsg().</span>
<span class="cm">			 *</span>
<span class="cm">			 * cmsg_level    cmsg_type      cmsg_data[]</span>
<span class="cm">			 * ------------  ------------   ----------------------</span>
<span class="cm">			 * IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_len</span> <span class="o">!=</span>
			    <span class="n">CMSG_LEN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_initmsg</span><span class="p">)))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">cmsgs</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_initmsg</span> <span class="o">*</span><span class="p">)</span><span class="n">CMSG_DATA</span><span class="p">(</span><span class="n">cmsg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_SNDRCV</span>:
			<span class="cm">/* SCTP Socket API Extension</span>
<span class="cm">			 * 5.2.2 SCTP Header Information Structure(SCTP_SNDRCV)</span>
<span class="cm">			 *</span>
<span class="cm">			 * This cmsghdr structure specifies SCTP options for</span>
<span class="cm">			 * sendmsg() and describes SCTP header information</span>
<span class="cm">			 * about a received message through recvmsg().</span>
<span class="cm">			 *</span>
<span class="cm">			 * cmsg_level    cmsg_type      cmsg_data[]</span>
<span class="cm">			 * ------------  ------------   ----------------------</span>
<span class="cm">			 * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_len</span> <span class="o">!=</span>
			    <span class="n">CMSG_LEN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">)))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">cmsgs</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="o">*</span><span class="p">)</span><span class="n">CMSG_DATA</span><span class="p">(</span><span class="n">cmsg</span><span class="p">);</span>

			<span class="cm">/* Minimally, validate the sinfo_flags. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmsgs</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span>
			    <span class="o">~</span><span class="p">(</span><span class="n">SCTP_UNORDERED</span> <span class="o">|</span> <span class="n">SCTP_ADDR_OVER</span> <span class="o">|</span>
			      <span class="n">SCTP_ABORT</span> <span class="o">|</span> <span class="n">SCTP_EOF</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for a packet..</span>
<span class="cm"> * Note: This function is the same function as in core/datagram.c</span>
<span class="cm"> * with a few modifications to make lksctp work.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_wait_for_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span> <span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="cm">/* Socket errors? */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ready</span><span class="p">;</span>

	<span class="cm">/* Socket shut down?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Sequenced packets can come disconnected.  If so we report the</span>
<span class="cm">	 * problem.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="cm">/* Is there a good reason to think that we may receive some data?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Handle signals.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">interrupted</span><span class="p">;</span>

	<span class="cm">/* Let another process have a go.  Since we are going to sleep</span>
<span class="cm">	 * anyway.  Note: This may cause odd behaviors if the message</span>
<span class="cm">	 * does not fit in the user&#39;s buffer, but this seems to be the</span>
<span class="cm">	 * only way to honor MSG_DONTWAIT realistically.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="o">*</span><span class="n">timeo_p</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
	<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">ready:</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">interrupted:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Receive a datagram.</span>
<span class="cm"> * Note: This is pretty much the same routine as in core/datagram.c</span>
<span class="cm"> * with a few changes to make lksctp work.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sctp_skb_recv_datagram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">noblock</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Timeout: timeo: %ld, MAX: %ld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">timeo</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Again only user level code calls this function,</span>
<span class="cm">		 * so nothing interrupt level</span>
<span class="cm">		 * will suddenly eat the receive_queue.</span>
<span class="cm">		 *</span>
<span class="cm">		 *  Look at current nfs client by the way...</span>
<span class="cm">		 *  However, this function was correct in any case. 8)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

		<span class="cm">/* Caller is allowed not to check sk-&gt;sk_err before calling. */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_packet</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* User doesn&#39;t want to wait.  */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_packet</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sctp_wait_for_packet</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">no_packet:</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If sndbuf has changed, wake up per association sndbuf waiters.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sctp_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sctp_wspace</span><span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">))</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wq</span> <span class="o">&amp;&amp;</span> <span class="n">waitqueue_active</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>

			<span class="cm">/* Note that we try to include the Async I/O support</span>
<span class="cm">			 * here by modeling from the current TCP/UDP code.</span>
<span class="cm">			 * We have not tested with it yet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span>
				<span class="n">sock_wake_async</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span>
						<span class="n">SOCK_WAKE_SPACE</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Do accounting for the sndbuf space.</span>
<span class="cm"> * Decrement the used sndbuf space of the corresponding association by the</span>
<span class="cm"> * data size which was just transmitted(freed).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_wfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* Get the saved chunk pointer.  */</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sndbuf_used</span> <span class="o">-=</span> <span class="n">SCTP_DATA_SNDSIZE</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">);</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This undoes what is done via sctp_set_owner_w and sk_mem_charge</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span>   <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_uncharge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">sock_wfree</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">__sctp_write_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do accounting for the receive space on the socket.</span>
<span class="cm"> * Accounting for the association is done in ulpevent.c</span>
<span class="cm"> * We set this as a destructor for the cloned data skbs so that</span>
<span class="cm"> * accounting is done at the correct time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_sock_rfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rmem_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mimic the behavior of sock_rfree</span>
<span class="cm">	 */</span>
	<span class="n">sk_mem_uncharge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">rmem_len</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Helper function to wait for space in the sndbuf.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_wait_for_sndbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">msg_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">current_timeo</span> <span class="o">=</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">asoc</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="o">*</span><span class="n">timeo_p</span><span class="p">),</span> <span class="n">msg_len</span><span class="p">);</span>

	<span class="cm">/* Increment the association&#39;s refcnt.  */</span>
	<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Wait on the association specific sndbuf space. */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					  <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">timeo_p</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_nonblock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span> <span class="o">||</span>
		    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_interrupted</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_len</span> <span class="o">&lt;=</span> <span class="n">sctp_wspace</span><span class="p">(</span><span class="n">asoc</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Let another process have a go.  Since we are going</span>
<span class="cm">		 * to sleep anyway.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">current_timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">current_timeo</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sk</span> <span class="o">!=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="o">*</span><span class="n">timeo_p</span> <span class="o">=</span> <span class="n">current_timeo</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="cm">/* Release the association&#39;s refcnt.  */</span>
	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">do_error:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">do_interrupted:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">do_nonblock:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">POLLIN</span> <span class="o">|</span>
						<span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLRDBAND</span><span class="p">);</span>
	<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* If socket sndbuf has changed, wake up all per association waiters.  */</span>
<span class="kt">void</span> <span class="nf">sctp_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="cm">/* Wake up the tasks in each wait queue.  */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">),</span> <span class="n">asocs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__sctp_write_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Is there any sndbuf space available on the socket?</span>
<span class="cm"> *</span>
<span class="cm"> * Note that sk_wmem_alloc is the sum of the send buffers on all of the</span>
<span class="cm"> * associations on the same socket.  For a UDP-style socket with</span>
<span class="cm"> * multiple associations, it is possible for it to be &quot;unwriteable&quot;</span>
<span class="cm"> * prematurely.  I assume that this is acceptable because</span>
<span class="cm"> * a premature &quot;unwriteable&quot; is better than an accidental &quot;writeable&quot; which</span>
<span class="cm"> * would cause an unwanted block under certain circumstances.  For the 1-1</span>
<span class="cm"> * UDP-style sockets or TCP-style sockets, this code should work.</span>
<span class="cm"> *  - Daisy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_writeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">amt</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">amt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wait for an association to go into ESTABLISHED state. If timeout is 0,</span>
<span class="cm"> * returns immediately with EINPROGRESS.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_wait_for_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">current_timeo</span> <span class="o">=</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: asoc=%p, timeo=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="o">*</span><span class="n">timeo_p</span><span class="p">));</span>

	<span class="cm">/* Increment the association&#39;s refcnt.  */</span>
	<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					  <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">timeo_p</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_nonblock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span> <span class="o">||</span>
		    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_interrupted</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Let another process have a go.  Since we are going</span>
<span class="cm">		 * to sleep anyway.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">current_timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">current_timeo</span><span class="p">);</span>
		<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="o">*</span><span class="n">timeo_p</span> <span class="o">=</span> <span class="n">current_timeo</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="cm">/* Release the association&#39;s refcnt.  */</span>
	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">do_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">do_interrupted:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">do_nonblock:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_wait_for_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					  <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
			<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_wait_for_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
		<span class="n">sctp_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_skb_set_owner_r_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t forget the fragments. */</span>
	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag</span><span class="p">)</span>
		<span class="n">sctp_skb_set_owner_r_frag</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">sctp_skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_copy_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">newinet</span><span class="p">;</span>

	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span><span class="p">;</span>

	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span> <span class="o">=</span> <span class="n">inet_sock_destruct</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span> <span class="o">=</span> <span class="n">IPPROTO_SCTP</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_backlog_rcv</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">backlog_rcv</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span><span class="p">;</span>

	<span class="n">newinet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>

	<span class="cm">/* Initialize sk&#39;s sport, dport, rcv_saddr and daddr for</span>
<span class="cm">	 * getsockname() and getpeername()</span>
<span class="cm">	 */</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">inet_sport</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">inet_saddr</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_saddr</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">inet_rcv_saddr</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_rcv_saddr</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">inet_dport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">pmtudisc</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">pmtudisc</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">inet_id</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">^</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">uc_ttl</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">uc_ttl</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">mc_loop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">mc_ttl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">mc_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">mc_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Populate the fields of the newsk from the oldsk and migrate the assoc</span>
<span class="cm"> * and its messages to the newsk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_sock_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">oldsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">assoc</span><span class="p">,</span>
			      <span class="n">sctp_socket_type_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">oldsp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">oldsk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">newsp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span> <span class="cm">/* hash list port iterator */</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">newep</span> <span class="o">=</span> <span class="n">newsp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmplist</span><span class="p">;</span>

	<span class="cm">/* Migrate socket buffer sizes and all the socket level options to the</span>
<span class="cm">	 * new socket.</span>
<span class="cm">	 */</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">oldsk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">oldsk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">;</span>
	<span class="cm">/* Brute force copy old sctp opt. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldsp</span><span class="o">-&gt;</span><span class="n">do_auto_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmplist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newsp</span><span class="o">-&gt;</span><span class="n">auto_asconf_list</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmplist</span><span class="p">));</span>
		<span class="n">inet_sk_copy_descendant</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">oldsk</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsp</span><span class="o">-&gt;</span><span class="n">auto_asconf_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmplist</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmplist</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">inet_sk_copy_descendant</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">oldsk</span><span class="p">);</span>

	<span class="cm">/* Restore the ep value that was overwritten with the above structure</span>
<span class="cm">	 * copy.</span>
<span class="cm">	 */</span>
	<span class="n">newsp</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">newep</span><span class="p">;</span>
	<span class="n">newsp</span><span class="o">-&gt;</span><span class="n">hmac</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Hook this new socket in to the bind_hash list. */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_port_hashtable</span><span class="p">[</span><span class="n">sctp_phashfn</span><span class="p">(</span><span class="n">inet_sk</span><span class="p">(</span><span class="n">oldsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">)];</span>
	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">sctp_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">oldsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span><span class="p">;</span>
	<span class="n">sk_add_bind_node</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">sctp_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind_hash</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
	<span class="n">inet_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">oldsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">;</span>
	<span class="n">sctp_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>

	<span class="cm">/* Copy the bind_addr list from the original endpoint to the new</span>
<span class="cm">	 * endpoint so that we can handle restarts properly</span>
<span class="cm">	 */</span>
	<span class="n">sctp_bind_addr_dup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">oldsp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/* Move any messages in the old socket&#39;s receive queue that are for the</span>
<span class="cm">	 * peeled off association to the new socket&#39;s receive queue.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldsk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">==</span> <span class="n">assoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldsk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">sctp_skb_set_owner_r_frag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up any messages pending delivery due to partial</span>
<span class="cm">	 * delivery.   Three cases:</span>
<span class="cm">	 * 1) No partial deliver;  no work.</span>
<span class="cm">	 * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.</span>
<span class="cm">	 * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.</span>
<span class="cm">	 */</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">,</span> <span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">pd_mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">oldsk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

		<span class="cm">/* Decide which queue to move pd_lobby skbs to. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">pd_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newsp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">;</span>

		<span class="cm">/* Walk through the pd_lobby, looking for skbs that</span>
<span class="cm">		 * need moved to the new socket.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldsp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">==</span> <span class="n">assoc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldsp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">);</span>
				<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">sctp_skb_set_owner_r_frag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Clear up any skbs waiting for the partial</span>
<span class="cm">		 * delivery to finish.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">pd_mode</span><span class="p">)</span>
			<span class="n">sctp_clear_pd</span><span class="p">(</span><span class="n">oldsk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">reasm</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="n">sctp_skb_set_owner_r_frag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>

	<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">lobby</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="n">sctp_skb_set_owner_r_frag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>

	<span class="cm">/* Set the type of socket to indicate that it is peeled off from the</span>
<span class="cm">	 * original UDP-style socket or created with the accept() call on a</span>
<span class="cm">	 * TCP-style socket..</span>
<span class="cm">	 */</span>
	<span class="n">newsp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* Mark the new socket &quot;in-use&quot; by the user so that any packets</span>
<span class="cm">	 * that may arrive on the association after we&#39;ve moved it are</span>
<span class="cm">	 * queued to the backlog.  This prevents a potential race between</span>
<span class="cm">	 * backlog processing on the old socket and new-packet processing</span>
<span class="cm">	 * on the new socket.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The caller has just allocated newsk so we can guarantee that other</span>
<span class="cm">	 * paths won&#39;t try to lock it and then oldsk.</span>
<span class="cm">	 */</span>
	<span class="n">lock_sock_nested</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="n">sctp_assoc_migrate</span><span class="p">(</span><span class="n">assoc</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>

	<span class="cm">/* If the association on the newsk is already closed before accept()</span>
<span class="cm">	 * is called, set RCV_SHUTDOWN flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">assoc</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_style</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">RCV_SHUTDOWN</span><span class="p">;</span>

	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_ESTABLISHED</span><span class="p">;</span>
	<span class="n">sctp_release_sock</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* This proto struct describes the ULP interface for SCTP.  */</span>
<span class="k">struct</span> <span class="n">proto</span> <span class="n">sctp_prot</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>        <span class="o">=</span>	<span class="s">&quot;SCTP&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>       <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>       <span class="o">=</span>	<span class="n">sctp_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>     <span class="o">=</span>	<span class="n">sctp_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span>  <span class="o">=</span>	<span class="n">sctp_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>      <span class="o">=</span>	<span class="n">sctp_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>       <span class="o">=</span>	<span class="n">sctp_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>        <span class="o">=</span>	<span class="n">sctp_init_sock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>     <span class="o">=</span>	<span class="n">sctp_destroy_sock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>    <span class="o">=</span>	<span class="n">sctp_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>  <span class="o">=</span>	<span class="n">sctp_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>  <span class="o">=</span>	<span class="n">sctp_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>     <span class="o">=</span>	<span class="n">sctp_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>     <span class="o">=</span>	<span class="n">sctp_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>        <span class="o">=</span>	<span class="n">sctp_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">backlog_rcv</span> <span class="o">=</span>	<span class="n">sctp_backlog_rcv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hash</span>        <span class="o">=</span>	<span class="n">sctp_hash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unhash</span>      <span class="o">=</span>	<span class="n">sctp_unhash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_port</span>    <span class="o">=</span>	<span class="n">sctp_get_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span>    <span class="o">=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">sysctl_mem</span>  <span class="o">=</span>  <span class="n">sysctl_sctp_mem</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysctl_rmem</span> <span class="o">=</span>  <span class="n">sysctl_sctp_rmem</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysctl_wmem</span> <span class="o">=</span>  <span class="n">sysctl_sctp_wmem</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memory_pressure</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_memory_pressure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enter_memory_pressure</span> <span class="o">=</span> <span class="n">sctp_enter_memory_pressure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memory_allocated</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_memory_allocated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sockets_allocated</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>

<span class="k">struct</span> <span class="n">proto</span> <span class="n">sctpv6_prot</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;SCTPv6&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">sctp_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	<span class="o">=</span> <span class="n">sctp_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span>	<span class="o">=</span> <span class="n">sctp_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		<span class="o">=</span> <span class="n">sctp_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">sctp_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">sctp_init_sock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>	<span class="o">=</span> <span class="n">sctp_destroy_sock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">sctp_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	<span class="o">=</span> <span class="n">sctp_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	<span class="o">=</span> <span class="n">sctp_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	<span class="o">=</span> <span class="n">sctp_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	<span class="o">=</span> <span class="n">sctp_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">sctp_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">backlog_rcv</span>	<span class="o">=</span> <span class="n">sctp_backlog_rcv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hash</span>		<span class="o">=</span> <span class="n">sctp_hash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unhash</span>		<span class="o">=</span> <span class="n">sctp_unhash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_port</span>	<span class="o">=</span> <span class="n">sctp_get_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp6_sock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">sysctl_mem</span>	<span class="o">=</span> <span class="n">sysctl_sctp_mem</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysctl_rmem</span>	<span class="o">=</span> <span class="n">sysctl_sctp_rmem</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysctl_wmem</span>	<span class="o">=</span> <span class="n">sysctl_sctp_wmem</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memory_pressure</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_memory_pressure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enter_memory_pressure</span> <span class="o">=</span> <span class="n">sctp_enter_memory_pressure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memory_allocated</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_memory_allocated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sockets_allocated</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* IS_ENABLED(CONFIG_IPV6) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
