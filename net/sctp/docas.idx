f | outqueue.c | s | 54K | 1691 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | sm_make_chunk.c | s | 100K | 2974 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | Makefile | g | 587B |  | Wei Yongjun | yjwei@cn.fujitsu.com | 1272681669 |  | sctp: implement sctp association probing module  This patch implement sctp association probing module, the module will be called sctp_probe.  This module allows for capturing the changes to SCTP association state in response to incoming packets. It is used for debugging SCTP congestion control algorithms.  Usage:   $ modprobe sctp_probe [full=n] [port=n] [bufsize=n]   $ cat /proc/net/sctpprobe    The output format is:     TIME     ASSOC     LPORT RPORT MTU    RWND  UNACK <REMOTE-ADDR   STATE  CWND   SSTHRESH  INFLIGHT  PARTIAL_BYTES_ACKED MTU> ...    The output will be like this:     9.226086 c4064c48  9000  8000  1500    53352     1 *192.168.0.19  1     4380    54784     1252        0     1500     9.287195 c4064c48  9000  8000  1500    45144     5 *192.168.0.19  1     5880    54784     6500        0     1500     9.289130 c4064c48  9000  8000  1500    42724     5 *192.168.0.19  1     7380    54784     6500        0     1500     9.620332 c4064c48  9000  8000  1500    48284     4 *192.168.0.19  1     8880    54784     5200        0     1500     ......  Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com> Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
f | ssnmap.c | s | 3.5K | 113 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | socket.c | s | 193K | 5939 | Joe Perches | joe@perches.com | 1337103903 |  | net: Convert net_ratelimit uses to net_<level>_ratelimited  Standardize the net core ratelimited logging functions.  Coalesce formats, align arguments. Change a printk then vprintk sequence to use printf extension %pV.  Signed-off-by: Joe Perches <joe@perches.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | proc.c | s | 13K | 433 | Paul Gortmaker | paul.gortmaker@windriver.com | 1320103830 |  | net: Add export.h for EXPORT_SYMBOL/THIS_MODULE to non-modules  These files are non modular, but need to export symbols using the macros now living in export.h -- call out the include so that things won't break when we remove the implicit presence of module.h from everywhere.  Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
f | debug.c | s | 4.6K | 164 | Vlad Yasevich | vladislav.yasevich@hp.com | 1303289463 |  | sctp: remove completely unsed EMPTY state  SCTP does not SCTP_STATE_EMPTY and we can never be in that state.  Remove useless code.  Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | inqueue.c | s | 7.0K | 215 | Joe Perches | joe@perches.com | 1282857108 |  | net/sctp: Use pr_fmt and pr_<level>  Change SCTP_DEBUG_PRINTK and SCTP_DEBUG_PRINTK_IPADDR to use do { print } while (0) guards. Add SCTP_DEBUG_PRINTK_CONT to fix errors in log when lines were continued. Add #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt Add a missing newline in "Failed bind hash alloc"  Signed-off-by: Joe Perches <joe@perches.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | input.c | s | 30K | 970 | Eric Dumazet | edumazet@google.com | 1335234508 |  | net: add a limit parameter to sk_add_backlog()  sk_add_backlog() & sk_rcvqueues_full() hard coded sk_rcvbuf as the memory limit. We need to make this limit a parameter for TCP use.  No functional change expected in this patch, all callers still using the old sk_rcvbuf limit.  Signed-off-by: Eric Dumazet <edumazet@google.com> Cc: Neal Cardwell <ncardwell@google.com> Cc: Tom Herbert <therbert@google.com> Cc: Maciej Żenczykowski <maze@google.com> Cc: Yuchung Cheng <ycheng@google.com> Cc: Ilpo Järvinen <ilpo.jarvinen@helsinki.fi> Cc: Rick Jones <rick.jones2@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | associola.c | s | 46K | 1388 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | command.c | s | 2.3K | 67 | Ilpo Järvinen | ilpo.jarvinen@helsinki.fi | 1206665669 |  | [SCTP]: Remove sctp_add_cmd_sf wrapper bloat  With a was number of callsites sctp_add_cmd_sf wrapper bloats kernel by some amount. Due to unlikely tracking allyesconfig, with the initial result were around ~7kB (thus caught my attention) while a non-debug config produced only ~2.3kB effect.  I (ij) proposed first a patch to uninline it but Vlad responded with a patch that removed the only sctp_add_cmd call which is wrapped by sctp_add_cmd_sf (I wasn't sure if I could do that). I did minor cleanup to Vlad's patch.  Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@helsinki.fi> Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | primitive.c | s | 7.6K | 205 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | sysctl.c | s | 7.2K | 282 | Eric W. Biederman | ebiederm@xmission.com | 1334971350 |  | net: Convert all sysctl registrations to register_net_sysctl  This results in code with less boiler plate that is a bit easier to read.  Additionally stops us from using compatibility code in the sysctl core, hastening the day when the compatibility code can be removed.  Signed-off-by: Eric W. Biederman <ebiederm@xmission.com> Acked-by: Pavel Emelyanov <xemul@parallels.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | output.c | s | 21K | 657 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ipv6.c | s | 28K | 943 | Alexey Dobriyan | adobriyan@gmail.com | 1321998212 |  | net: remove ipv6_addr_copy()  C assignment can handle struct in6_addr copying.  Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | sm_statetable.c | s | 31K | 875 | Thomas Graf | tgraf@infradead.org | 1310072924 |  | sctp: Enforce retransmission limit during shutdown  When initiating a graceful shutdown while having data chunks on the retransmission queue with a peer which is in zero window mode the shutdown is never completed because the retransmission error count is reset periodically by the following two rules:   - Do not timeout association while doing zero window probe.  - Reset overall error count when a heartbeat request has    been acknowledged.  The graceful shutdown will wait for all outstanding TSN to be acknowledged before sending the SHUTDOWN request. This never happens due to the peer's zero window not acknowledging the continuously retransmitted data chunks. Although the error counter is incremented for each failed retransmission, the receiving of the SACK announcing the zero window clears the error count again immediately. Also heartbeat requests continue to be sent periodically. The peer acknowledges these requests causing the error counter to be reset as well.  This patch changes behaviour to only reset the overall error counter for the above rules while not in shutdown. After reaching the maximum number of retransmission attempts, the T5 shutdown guard timer is scheduled to give the receiver some additional time to recover. The timer is stopped as soon as the receiver acknowledges any data.  The issue can be easily reproduced by establishing a sctp association over the loopback device, constantly queueing data at the sender while not reading any at the receiver. Wait for the window to reach zero, then initiate a shutdown by killing both processes simultaneously. The association will never be freed and the chunks on the retransmission queue will be retransmitted indefinitely.  Signed-off-by: Thomas Graf <tgraf@infradead.org> Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | sm_sideeffect.c | s | 47K | 1481 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | sm_statefuns.c | s | 192K | 5455 | Joe Perches | joe@perches.com | 1337103903 |  | net: Convert net_ratelimit uses to net_<level>_ratelimited  Standardize the net core ratelimited logging functions.  Coalesce formats, align arguments. Change a printk then vprintk sequence to use printf extension %pV.  Signed-off-by: Joe Perches <joe@perches.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | endpointola.c | s | 13K | 419 | Justin P. Mattock | justinmattock@gmail.com | 1322834251 |  | treewide: Fix typos in various parts of the kernel, and fix some comments.  The below patch fixes some typos in various parts of the kernel, as well as fixes some comments. Please let me know if I missed anything, and I will try to get it changed and resent.  Signed-off-by: Justin P. Mattock <justinmattock@gmail.com> Acked-by: Randy Dunlap <rdunlap@xenotime.net> Signed-off-by: Jiri Kosina <jkosina@suse.cz>
f | chunk.c | s | 9.7K | 306 | Joe Perches | joe@perches.com | 1282857108 |  | net/sctp: Use pr_fmt and pr_<level>  Change SCTP_DEBUG_PRINTK and SCTP_DEBUG_PRINTK_IPADDR to use do { print } while (0) guards. Add SCTP_DEBUG_PRINTK_CONT to fix errors in log when lines were continued. Add #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt Add a missing newline in "Failed bind hash alloc"  Signed-off-by: Joe Perches <joe@perches.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | transport.c | s | 19K | 559 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | protocol.c | s | 40K | 1324 | Daniel Halperin | dhalperi@cs.washington.edu | 1340090786 |  | sctp: fix warning when compiling without IPv6  net/sctp/protocol.c: In function ‘sctp_addr_wq_timeout_handler’: net/sctp/protocol.c:676: warning: label ‘free_next’ defined but not used  Signed-off-by: Daniel Halperin <dhalperi@cs.washington.edu> Signed-off-by: David S. Miller <davem@davemloft.net>
f | probe.c | s | 5.2K | 174 | Linus Torvalds | torvalds@linux-foundation.org | 1287859622 |  | Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6  * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1699 commits)   bnx2/bnx2x: Unsupported Ethtool operations should return -EINVAL.   vlan: Calling vlan_hwaccel_do_receive() is always valid.   tproxy: use the interface primary IP address as a default value for --on-ip   tproxy: added IPv6 support to the socket match   cxgb3: function namespace cleanup   tproxy: added IPv6 support to the TPROXY target   tproxy: added IPv6 socket lookup function to nf_tproxy_core   be2net: Changes to use only priority codes allowed by f/w   tproxy: allow non-local binds of IPv6 sockets if IP_TRANSPARENT is enabled   tproxy: added tproxy sockopt interface in the IPV6 layer   tproxy: added udp6_lib_lookup function   tproxy: added const specifiers to udp lookup functions   tproxy: split off ipv6 defragmentation to a separate module   l2tp: small cleanup   nf_nat: restrict ICMP translation for embedded header   can: mcp251x: fix generation of error frames   can: mcp251x: fix endless loop in interrupt handler if CANINTF_MERRF is set   can-raw: add msg_flags to distinguish local traffic   9p: client code cleanup   rds: make local functions/variables static   ...  Fix up conflicts in net/core/dev.c, drivers/net/pcmcia/smc91c92_cs.c and drivers/net/wireless/ath/ath9k/debug.c as per David
f | Kconfig | g | 3.0K |  | Wei Yongjun | yjwei@cn.fujitsu.com | 1272681669 |  | sctp: implement sctp association probing module  This patch implement sctp association probing module, the module will be called sctp_probe.  This module allows for capturing the changes to SCTP association state in response to incoming packets. It is used for debugging SCTP congestion control algorithms.  Usage:   $ modprobe sctp_probe [full=n] [port=n] [bufsize=n]   $ cat /proc/net/sctpprobe    The output format is:     TIME     ASSOC     LPORT RPORT MTU    RWND  UNACK <REMOTE-ADDR   STATE  CWND   SSTHRESH  INFLIGHT  PARTIAL_BYTES_ACKED MTU> ...    The output will be like this:     9.226086 c4064c48  9000  8000  1500    53352     1 *192.168.0.19  1     4380    54784     1252        0     1500     9.287195 c4064c48  9000  8000  1500    45144     5 *192.168.0.19  1     5880    54784     6500        0     1500     9.289130 c4064c48  9000  8000  1500    42724     5 *192.168.0.19  1     7380    54784     6500        0     1500     9.620332 c4064c48  9000  8000  1500    48284     4 *192.168.0.19  1     8880    54784     5200        0     1500     ......  Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com> Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
f | bind_addr.c | s | 14K | 487 | Joe Perches | joe@perches.com | 1308280767 |  | net: Remove casts of void *  Unnecessary casts of void * clutter the code.  These are the remainder casts after several specific patches to remove netdev_priv and dev_priv.  Done via coccinelle script:  $ cat cast_void_pointer.cocci @@ type T; T *pt; void *pv; @@  - pt = (T *)pv; + pt = pv;  Signed-off-by: Joe Perches <joe@perches.com> Acked-by: Paul Moore <paul.moore@hp.com> Signed-off-by: David S. Miller <davem@conan.davemloft.net>
f | ulpevent.c | s | 30K | 949 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | auth.c | s | 23K | 788 | Xi Wang | xi.wang@gmail.com | 1322599863 |  | sctp: better integer overflow check in sctp_auth_create_key()  The check from commit 30c2235c is incomplete and cannot prevent cases like key_len = 0x80000000 (INT_MAX + 1).  In that case, the left-hand side of the check (INT_MAX - key_len), which is unsigned, becomes 0xffffffff (UINT_MAX) and bypasses the check.  However this shouldn't be a security issue.  The function is called from the following two code paths:   1) setsockopt()   2) sctp_auth_asoc_set_secret()  In case (1), sca_keylength is never going to exceed 65535 since it's bounded by a u16 from the user API.  As such, the key length will never overflow.  In case (2), sca_keylength is computed based on the user key (1 short) and 2 * key_vector (3 shorts) for a total of 7 * USHRT_MAX, which still will not overflow.  In other words, this overflow check is not really necessary.  Just make it more correct.  Signed-off-by: Xi Wang <xi.wang@gmail.com> Cc: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | objcnt.c | s | 4.2K | 130 | Joe Perches | joe@perches.com | 1282857108 |  | net/sctp: Use pr_fmt and pr_<level>  Change SCTP_DEBUG_PRINTK and SCTP_DEBUG_PRINTK_IPADDR to use do { print } while (0) guards. Add SCTP_DEBUG_PRINTK_CONT to fix errors in log when lines were continued. Add #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt Add a missing newline in "Failed bind hash alloc"  Signed-off-by: Joe Perches <joe@perches.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ulpqueue.c | s | 27K | 919 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | tsnmap.c | s | 9.8K | 325 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
