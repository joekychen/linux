<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › ulpqueue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ulpqueue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 Nokia, Inc.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This abstraction carries sctp events to the ULP (sockets).</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/sctp/structs.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="cm">/* Forward declarations for internal helpers.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span> <span class="n">sctp_ulpq_reasm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span> <span class="n">sctp_ulpq_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_ulpq_reasm_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">);</span>

<span class="cm">/* 1st Level Abstractions */</span>

<span class="cm">/* Initialize a ULP queue from a block of memory.  */</span>
<span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="nf">sctp_ulpq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span><span class="p">));</span>

	<span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">asoc</span><span class="p">;</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">);</span>
	<span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ulpq</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Flush the reassembly and ordering queues.  */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/* Dispose of a ulpqueue.  */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_ulpq_flush</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">malloced</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Process an incoming DATA chunk.  */</span>
<span class="kt">int</span> <span class="nf">sctp_ulpq_tail_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
			<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="cm">/* Create an event from the incoming chunk. */</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_rcvmsg</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Do reassembly if needed.  */</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpq_reasm</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="cm">/* Do ordering if needed.  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">event</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_EOR</span><span class="p">)){</span>
		<span class="cm">/* Create a temporary list to collect chunks on.  */</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpq_order</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Send event to the ULP.  &#39;event&#39; is the sctp_ulpevent for</span>
<span class="cm">	 * very first SKB on the &#39;temp&#39; list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
		<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add a new event for propagation to the ULP.  */</span>
<span class="cm">/* Clear the partial delivery mode for this socket.   Note: This</span>
<span class="cm"> * assumes that no association is currently in partial delivery mode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_clear_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This means there are no other associations in PD, so</span>
<span class="cm">		 * we can go ahead and clear out the lobby in one shot</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
			<span class="n">sctp_skb_list_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="n">list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">;</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* There are other associations in PD, so we only need to</span>
<span class="cm">		 * pull stuff out of the lobby that belongs to the</span>
<span class="cm">		 * associations that is exiting PD (all of its notifications</span>
<span class="cm">		 * are posted here).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

			<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">==</span> <span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">);</span>
					<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span>
							 <span class="n">skb</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set the pd_mode on the socket and ulpq */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpq_set_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">);</span>
	<span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clear the pd_mode and restart any pending messages waiting for delivery. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_ulpq_clear_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sctp_ulpq_reasm_drain</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sctp_clear_pd</span><span class="p">(</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">,</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If the SKB of &#39;event&#39; is on a list, it is the first such member</span>
<span class="cm"> * of that list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_ulpq_tail_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="o">*</span><span class="n">skb_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">clear_pd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

	<span class="cm">/* If the socket is just going to throw this away, do not</span>
<span class="cm">	 * even try to deliver it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Check if the user wishes to receive this event.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_ulpevent_is_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* If we are in partial delivery mode, post to the lobby until</span>
<span class="cm">	 * partial delivery is cleared, unless, of course _this_ is</span>
<span class="cm">	 * the association the cause of the partial delivery.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If the association is in partial delivery, we</span>
<span class="cm">			 * need to finish delivering the partially processed</span>
<span class="cm">			 * packet before passing any other data.  This is</span>
<span class="cm">			 * because we don&#39;t truly support stream interleaving.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_NOTIFICATION</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">SCTP_DATA_NOT_FRAG</span> <span class="o">==</span>
				    <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_FRAG_MASK</span><span class="p">)))</span>
				<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">clear_pd</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_EOR</span><span class="p">;</span>
				<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If fragment interleave is enabled, we</span>
<span class="cm">			 * can queue this to the receive queue instead</span>
<span class="cm">			 * of the lobby.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_interleave</span><span class="p">)</span>
				<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_lobby</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we are harvesting multiple skbs they will be</span>
<span class="cm">	 * collected on a list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_list</span><span class="p">)</span>
		<span class="n">sctp_skb_list_tail</span><span class="p">(</span><span class="n">skb_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Did we just complete partial delivery and need to get</span>
<span class="cm">	 * rolling again?  Move pending data to the receive</span>
<span class="cm">	 * queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear_pd</span><span class="p">)</span>
		<span class="n">sctp_ulpq_clear_pd</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_list</span><span class="p">)</span>
		<span class="n">sctp_queue_purge_ulpevents</span><span class="p">(</span><span class="n">skb_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 2nd Level Abstractions */</span>

<span class="cm">/* Helper function to store chunks that need to be reassembled.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpq_store_reasm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">;</span>

	<span class="n">tsn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

	<span class="cm">/* See if it belongs at the end. */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Short circuit just dropping it at the end. */</span>
	<span class="n">cevent</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">tsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find the right place in this list. We store them by TSN.  */</span>
	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">ctsn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Insert before pos. */</span>
	<span class="n">__skb_queue_before</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

<span class="p">}</span>

<span class="cm">/* Helper function to return an event corresponding to the reassembled</span>
<span class="cm"> * datagram.</span>
<span class="cm"> * This routine creates a re-assembled skb given the first and last skb&#39;s</span>
<span class="cm"> * as stored in the reassembly queue. The skb&#39;s may be non-linear if the sctp</span>
<span class="cm"> * payload was fragmented on the way and ip had to reassemble them.</span>
<span class="cm"> * We add the rest of skb&#39;s to the first skb&#39;s fraglist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_make_reassembled_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">f_frag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">l_frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pnext</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">f_frag</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>

	<span class="cm">/* Store the pointer to the 2nd skb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_frag</span> <span class="o">==</span> <span class="n">l_frag</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">f_frag</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* Get the last skb in the f_frag&#39;s frag_list if present. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">last</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">list</span><span class="p">;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/* Add the list of remaining fragments to the first fragments</span>
<span class="cm">	 * frag_list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
		<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">f_frag</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This is a cloned skb, we can&#39;t just modify</span>
<span class="cm">			 * the frag_list.  We need a new skb to do that.</span>
<span class="cm">			 * Instead of calling skb_unshare(), we&#39;ll do it</span>
<span class="cm">			 * ourselves since we need to delay the free.</span>
<span class="cm">			 */</span>
			<span class="n">new</span> <span class="o">=</span> <span class="n">skb_copy</span><span class="p">(</span><span class="n">f_frag</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* try again later */</span>

			<span class="n">sctp_skb_set_owner_r</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">f_frag</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">f_frag</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove the first fragment from the reassembly queue.  */</span>
	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">f_frag</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* if we did unshare, then free the old skb and re-assign */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">f_frag</span><span class="p">);</span>
		<span class="n">f_frag</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">pnext</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/* Update the len and data_len fields of the first fragment. */</span>
		<span class="n">f_frag</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">f_frag</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Remove the fragment from the reassembly queue.  */</span>
		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="cm">/* Break if we have reached the last fragment.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">l_frag</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pnext</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pnext</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">f_frag</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_REASMUSRMSGS</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Helper function to check if an incoming chunk has filled up the last</span>
<span class="cm"> * missing fragment in a SCTP datagram and return the corresponding event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpq_retrieve_reassembled</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">first_frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">next_tsn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pd_first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pd_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">pd_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pd_point</span><span class="p">;</span>

	<span class="cm">/* Initialized to 0 just to avoid compiler warning message.  Will</span>
<span class="cm">	 * never be used with this value. It is referenced only after it</span>
<span class="cm">	 * is set when we find the first fragment of a message.</span>
<span class="cm">	 */</span>
	<span class="n">next_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The chunks are held in the reasm queue sorted by TSN.</span>
<span class="cm">	 * Walk through the queue sequentially and look for a sequence of</span>
<span class="cm">	 * fragmented chunks that complete a datagram.</span>
<span class="cm">	 * &#39;first_frag&#39; and next_tsn are reset when we find a chunk which</span>
<span class="cm">	 * is the first fragment of a datagram. Once these 2 fields are set</span>
<span class="cm">	 * we expect to find the remaining middle fragments and the last</span>
<span class="cm">	 * fragment in order. If not, first_frag is reset to NULL and we</span>
<span class="cm">	 * start the next pass when we find another first fragment.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is a potential to do partial delivery if user sets</span>
<span class="cm">	 * SCTP_PARTIAL_DELIVERY_POINT option. Lets count some things here</span>
<span class="cm">	 * to see if can do PD.</span>
<span class="cm">	 */</span>
	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">ctsn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cevent</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_FRAG_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_DATA_FIRST_FRAG</span>:
			<span class="cm">/* If this &quot;FIRST_FRAG&quot; is the first</span>
<span class="cm">			 * element in the queue, then count it towards</span>
<span class="cm">			 * possible PD.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			    <span class="n">pd_first</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			    <span class="n">pd_last</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			    <span class="n">pd_len</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			    <span class="n">pd_first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			    <span class="n">pd_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			    <span class="n">pd_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">first_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="n">next_tsn</span> <span class="o">=</span> <span class="n">ctsn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_DATA_MIDDLE_FRAG</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">first_frag</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctsn</span> <span class="o">==</span> <span class="n">next_tsn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">next_tsn</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pd_first</span><span class="p">)</span> <span class="p">{</span>
				    <span class="n">pd_last</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
				    <span class="n">pd_len</span> <span class="o">+=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">first_frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_DATA_LAST_FRAG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">first_frag</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctsn</span> <span class="o">==</span> <span class="n">next_tsn</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">first_frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd_first</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure we can enter partial deliver.</span>
<span class="cm">		 * We can trigger partial delivery only if framgent</span>
<span class="cm">		 * interleave is set, or the socket is not already</span>
<span class="cm">		 * in  partial delivery.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_interleave</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="n">cevent</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pd_first</span><span class="p">);</span>
		<span class="n">pd_point</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd_point</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd_point</span> <span class="o">&amp;&amp;</span> <span class="n">pd_point</span> <span class="o">&lt;=</span> <span class="n">pd_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_reassembled_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span>
							     <span class="n">pd_first</span><span class="p">,</span>
							     <span class="n">pd_last</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="n">sctp_ulpq_set_pd</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_reassembled_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">first_frag</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_EOR</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Retrieve the next set of fragments of a partial message. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpq_retrieve_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">last_frag</span><span class="p">,</span> <span class="o">*</span><span class="n">first_frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">next_tsn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* The chunks are held in the reasm queue sorted by TSN.</span>
<span class="cm">	 * Walk through the queue sequentially and look for the first</span>
<span class="cm">	 * sequence of fragmented chunks.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">last_frag</span> <span class="o">=</span> <span class="n">first_frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">next_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">is_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">ctsn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cevent</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_FRAG_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_DATA_MIDDLE_FRAG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_frag</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">first_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
				<span class="n">next_tsn</span> <span class="o">=</span> <span class="n">ctsn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">last_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">next_tsn</span> <span class="o">==</span> <span class="n">ctsn</span><span class="p">)</span>
				<span class="n">next_tsn</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_DATA_LAST_FRAG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_frag</span><span class="p">)</span>
				<span class="n">first_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctsn</span> <span class="o">!=</span> <span class="n">next_tsn</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">last_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="n">is_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We have the reassembled event. There is no need to look</span>
<span class="cm">	 * further.</span>
<span class="cm">	 */</span>
<span class="nl">done:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_reassembled_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">first_frag</span><span class="p">,</span> <span class="n">last_frag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">is_last</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_EOR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Helper function to reassemble chunks.  Hold chunks on the reasm queue that</span>
<span class="cm"> * need reassembling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpq_reasm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check if this is part of a fragmented message.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_DATA_NOT_FRAG</span> <span class="o">==</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_FRAG_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_EOR</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_ulpq_store_reasm</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_ulpq_retrieve_reassembled</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">ctsnap</span><span class="p">;</span>

		<span class="cm">/* Do not even bother unless this is the next tsn to</span>
<span class="cm">		 * be delivered.</span>
<span class="cm">		 */</span>
		<span class="n">ctsn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>
		<span class="n">ctsnap</span> <span class="o">=</span> <span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">ctsnap</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_ulpq_retrieve_partial</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Retrieve the first part (sequential fragments) for partial delivery.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpq_retrieve_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">last_frag</span><span class="p">,</span> <span class="o">*</span><span class="n">first_frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">next_tsn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* The chunks are held in the reasm queue sorted by TSN.</span>
<span class="cm">	 * Walk through the queue sequentially and look for a sequence of</span>
<span class="cm">	 * fragmented chunks that start a datagram.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">last_frag</span> <span class="o">=</span> <span class="n">first_frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">next_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">ctsn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cevent</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_FRAG_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_DATA_FIRST_FRAG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_frag</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">first_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
				<span class="n">next_tsn</span> <span class="o">=</span> <span class="n">ctsn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">last_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_DATA_MIDDLE_FRAG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_frag</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctsn</span> <span class="o">==</span> <span class="n">next_tsn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next_tsn</span><span class="o">++</span><span class="p">;</span>
				<span class="n">last_frag</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We have the reassembled event. There is no need to look</span>
<span class="cm">	 * further.</span>
<span class="cm">	 */</span>
<span class="nl">done:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_reassembled_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">first_frag</span><span class="p">,</span> <span class="n">last_frag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush out stale fragments from the reassembly queue when processing</span>
<span class="cm"> * a Forward TSN.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 3758, Section 3.6</span>
<span class="cm"> *</span>
<span class="cm"> * After receiving and processing a FORWARD TSN, the data receiver MUST</span>
<span class="cm"> * take cautions in updating its re-assembly queue.  The receiver MUST</span>
<span class="cm"> * remove any partially reassembled message, which is still missing one</span>
<span class="cm"> * or more TSNs earlier than or equal to the new cumulative TSN point.</span>
<span class="cm"> * In the event that the receiver has invoked the partial delivery API,</span>
<span class="cm"> * a notification SHOULD also be generated to inform the upper layer API</span>
<span class="cm"> * that the message being partially delivered will NOT be completed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_reasm_flushtsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">fwd_tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">tsn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

		<span class="cm">/* Since the entire message must be abandoned by the</span>
<span class="cm">		 * sender (item A3 in Section 3.5, RFC 3758), we can</span>
<span class="cm">		 * free all fragments on the list that are less then</span>
<span class="cm">		 * or equal to ctsn_point</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">fwd_tsn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">);</span>
			<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drain the reassembly queue.  If we just cleared parted delivery, it</span>
<span class="cm"> * is possible that the reassembly queue will contain already reassembled</span>
<span class="cm"> * messages.  Retrieve any such messages and give them to the user.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpq_reasm_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpq_retrieve_reassembled</span><span class="p">(</span><span class="n">ulpq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Do ordering if needed.  */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">event</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_EOR</span><span class="p">)){</span>
			<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

			<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpq_order</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Send event to the ULP.  &#39;event&#39; is the</span>
<span class="cm">		 * sctp_ulpevent for  very first SKB on the  temp&#39; list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
			<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Helper function to gather skbs that have possibly become</span>
<span class="cm"> * ordered by an an incoming chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpq_retrieve_ordered</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">event_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sid</span><span class="p">,</span> <span class="n">csid</span><span class="p">,</span> <span class="n">cssn</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">in</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>

	<span class="n">event_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="p">)</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

	<span class="cm">/* We are holding the chunks by stream, by SSN.  */</span>
	<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">)</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
		<span class="n">csid</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">cssn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>

		<span class="cm">/* Have we gone too far?  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">&gt;</span> <span class="n">sid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Have we not gone far enough?  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">&lt;</span> <span class="n">sid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cssn</span> <span class="o">!=</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Found it, so mark in the ssnmap. */</span>
		<span class="n">sctp_ssn_next</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">);</span>

		<span class="cm">/* Attach all gathered skbs to the event.  */</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">event_list</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function to store chunks needing ordering.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpq_store_ordered</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sid</span><span class="p">,</span> <span class="n">csid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ssn</span><span class="p">,</span> <span class="n">cssn</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">ssn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>

	<span class="n">cevent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">)</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">csid</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">cssn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&gt;</span> <span class="n">csid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sid</span> <span class="o">==</span> <span class="n">csid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">SSN_lt</span><span class="p">(</span><span class="n">cssn</span><span class="p">,</span> <span class="n">ssn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find the right place in this list.  We store them by</span>
<span class="cm">	 * stream ID and then by SSN.</span>
<span class="cm">	 */</span>
	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">)</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
		<span class="n">csid</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">cssn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">&gt;</span> <span class="n">sid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">==</span> <span class="n">sid</span> <span class="o">&amp;&amp;</span> <span class="n">SSN_lt</span><span class="p">(</span><span class="n">ssn</span><span class="p">,</span> <span class="n">cssn</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Insert before pos. */</span>
	<span class="n">__skb_queue_before</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpq_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sid</span><span class="p">,</span> <span class="n">ssn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>

	<span class="cm">/* Check if this message needs ordering.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_DATA_UNORDERED</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

	<span class="cm">/* Note: The stream ID must be verified before this routine.  */</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">ssn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>
	<span class="n">in</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>

	<span class="cm">/* Is this the expected SSN for this stream ID?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssn</span> <span class="o">!=</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve received something out of order, so find where it</span>
<span class="cm">		 * needs to be placed.  We order by stream and then by SSN.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_ulpq_store_ordered</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark that the next chunk has been found.  */</span>
	<span class="n">sctp_ssn_next</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

	<span class="cm">/* Go find any other chunks that were waiting for</span>
<span class="cm">	 * ordering.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpq_retrieve_ordered</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to gather skbs that have possibly become</span>
<span class="cm"> * ordered by forward tsn skipping their dependencies.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpq_reap_ordered</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">cevent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">lobby</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">csid</span><span class="p">,</span> <span class="n">cssn</span><span class="p">;</span>

	<span class="n">in</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>

	<span class="cm">/* We are holding the chunks by stream, by SSN.  */</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sctp_skb_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">lobby</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">)</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
		<span class="n">csid</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">cssn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>

		<span class="cm">/* Have we gone too far?  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">&gt;</span> <span class="n">sid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Have we not gone far enough?  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">&lt;</span> <span class="n">sid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* see if this ssn has been marked by skipping */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SSN_lt</span><span class="p">(</span><span class="n">cssn</span><span class="p">,</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">csid</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">lobby</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
			<span class="cm">/* Create a temporary list to collect chunks on.  */</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>

		<span class="cm">/* Attach all gathered skbs to the event.  */</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If we didn&#39;t reap any data, see if the next expected SSN</span>
<span class="cm">	 * is next on the queue and if so, use that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">lobby</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cevent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">)</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
		<span class="n">csid</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">cssn</span> <span class="o">=</span> <span class="n">cevent</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">csid</span> <span class="o">==</span> <span class="n">sid</span> <span class="o">&amp;&amp;</span> <span class="n">cssn</span> <span class="o">==</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">csid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_ssn_next</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">csid</span><span class="p">);</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">lobby</span><span class="p">);</span>
			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Send event to the ULP.  &#39;event&#39; is the sctp_ulpevent for</span>
<span class="cm">	 * very first SKB on the &#39;temp&#39; list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* see if we have more ordered that we can deliver */</span>
		<span class="n">sctp_ulpq_retrieve_ordered</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Skip over an SSN. This is used during the processing of</span>
<span class="cm"> * Forwared TSN chunk to skip over the abandoned ordered data</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">sid</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">ssn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>

	<span class="cm">/* Note: The stream ID must be verified before this routine.  */</span>
	<span class="n">in</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>

	<span class="cm">/* Is this an old SSN?  If so ignore. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SSN_lt</span><span class="p">(</span><span class="n">ssn</span><span class="p">,</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Mark that we are no longer expecting this SSN or lower. */</span>
	<span class="n">sctp_ssn_skip</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">ssn</span><span class="p">);</span>

	<span class="cm">/* Go find any other chunks that were waiting for</span>
<span class="cm">	 * ordering and deliver them if needed.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpq_reap_ordered</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__u16</span> <span class="nf">sctp_ulpq_renege_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_tsnmap</span> <span class="o">*</span><span class="n">tsnmap</span><span class="p">;</span>

	<span class="n">tsnmap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue_tail</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">freed</span> <span class="o">+=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tsn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>

		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">sctp_tsnmap_renege</span><span class="p">(</span><span class="n">tsnmap</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;=</span> <span class="n">needed</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Renege &#39;needed&#39; bytes from the ordering queue. */</span>
<span class="k">static</span> <span class="n">__u16</span> <span class="nf">sctp_ulpq_renege_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sctp_ulpq_renege_list</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">lobby</span><span class="p">,</span> <span class="n">needed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Renege &#39;needed&#39; bytes from the reassembly queue. */</span>
<span class="k">static</span> <span class="n">__u16</span> <span class="nf">sctp_ulpq_renege_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sctp_ulpq_renege_list</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">reasm</span><span class="p">,</span> <span class="n">needed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Partial deliver the first message as there is pressure on rwnd. */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_partial_delivery</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* If the association is already in Partial Delivery mode</span>
<span class="cm">	 * we have noting to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If the user enabled fragment interleave socket option,</span>
<span class="cm">	 * multiple associations can enter partial delivery.</span>
<span class="cm">	 * Otherwise, we can only enter partial delivery if the</span>
<span class="cm">	 * socket is not in partial deliver mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">frag_interleave</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Is partial delivery possible?  */</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpq_retrieve_first</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
		<span class="cm">/* Send event to the ULP.   */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
			<span class="n">sctp_ulpq_set_pd</span><span class="p">(</span><span class="n">ulpq</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Renege some packets to make room for an incoming chunk.  */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_renege</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
		      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">needed</span><span class="p">,</span> <span class="n">freed</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">needed</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_data_chunk_t</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXWINDOW</span><span class="p">;</span>

	<span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">freed</span> <span class="o">=</span> <span class="n">sctp_ulpq_renege_order</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">needed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">freed</span> <span class="o">+=</span> <span class="n">sctp_ulpq_renege_frags</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">needed</span> <span class="o">-</span> <span class="n">freed</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If able to free enough room, accept this chunk. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;=</span> <span class="n">needed</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>
		<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>
		<span class="n">sctp_tsnmap_mark</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">tsn</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
		<span class="n">sctp_ulpq_tail_data</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

		<span class="n">sctp_ulpq_partial_delivery</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* Notify the application if an association is aborted and in</span>
<span class="cm"> * partial delivery mode.  Send up any pending received messages.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpq_abort_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">pd_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_ulpevent_type_enabled</span><span class="p">(</span><span class="n">SCTP_PARTIAL_DELIVERY_EVENT</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">subscribe</span><span class="p">))</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_pdapi</span><span class="p">(</span><span class="n">ulpq</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span>
					      <span class="n">SCTP_PARTIAL_DELIVERY_ABORTED</span><span class="p">,</span>
					      <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>

	<span class="cm">/* If there is data waiting, send it up the socket now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_ulpq_clear_pd</span><span class="p">(</span><span class="n">ulpq</span><span class="p">)</span> <span class="o">||</span> <span class="n">ev</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
