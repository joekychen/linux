<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › sm_sideeffect.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sm_sideeffect.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * These functions work with the state functions in sctp_sm_statefuns.c</span>
<span class="cm"> * to implement that state operations.  These functions implement the</span>
<span class="cm"> * steps which require modifying existing data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@austin.ibm.com&gt;</span>
<span class="cm"> *    Hui Huang		    &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Dajiang Zhang	    &lt;dajiang.zhang@nokia.com&gt;</span>
<span class="cm"> *    Daisy Chang	    &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala	    &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_cmd_interpreter</span><span class="p">(</span><span class="n">sctp_event_t</span> <span class="n">event_type</span><span class="p">,</span>
				<span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">,</span>
				<span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">event_arg</span><span class="p">,</span>
				<span class="n">sctp_disposition_t</span> <span class="n">status</span><span class="p">,</span>
				<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_side_effects</span><span class="p">(</span><span class="n">sctp_event_t</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">,</span>
			     <span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">event_arg</span><span class="p">,</span>
			     <span class="n">sctp_disposition_t</span> <span class="n">status</span><span class="p">,</span>
			     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * Helper functions</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/* A helper function for delayed processing of INET ECN CE bit. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_do_ecn_ce_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				<span class="n">__u32</span> <span class="n">lowest_tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save the TSN away for comparison when we receive CWR */</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_ecne_tsn</span> <span class="o">=</span> <span class="n">lowest_tsn</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">need_ecne</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function for delayed processing of SCTP ECNE chunk.  */</span>
<span class="cm">/* RFC 2960 Appendix A</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 2481 details a specific bit for a sender to send in</span>
<span class="cm"> * the header of its next outbound TCP segment to indicate to</span>
<span class="cm"> * its peer that it has reduced its congestion window.  This</span>
<span class="cm"> * is termed the CWR bit.  For SCTP the same indication is made</span>
<span class="cm"> * by including the CWR chunk.  This chunk contains one data</span>
<span class="cm"> * element, i.e. the TSN number that was sent in the ECNE chunk.</span>
<span class="cm"> * This element represents the lowest TSN number in the datagram</span>
<span class="cm"> * that was originally marked with the CE bit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_do_ecn_ecne_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="n">__u32</span> <span class="n">lowest_tsn</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>

	<span class="cm">/* Our previously transmitted packet ran into some congestion</span>
<span class="cm">	 * so we should take action by reducing cwnd and ssthresh</span>
<span class="cm">	 * and then ACK our peer that we we&#39;ve done so by</span>
<span class="cm">	 * sending a CWR.</span>
<span class="cm">	 */</span>

	<span class="cm">/* First, try to determine if we want to actually lower</span>
<span class="cm">	 * our cwnd variables.  Only lower them if the ECNE looks more</span>
<span class="cm">	 * recent than the last response.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_cwr_tsn</span><span class="p">,</span> <span class="n">lowest_tsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

		<span class="cm">/* Find which transport&#39;s congestion variables</span>
<span class="cm">		 * need to be adjusted.</span>
<span class="cm">		 */</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_tsn</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">lowest_tsn</span><span class="p">);</span>

		<span class="cm">/* Update the congestion variables. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span>
			<span class="n">sctp_transport_lower_cwnd</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span>
						  <span class="n">SCTP_LOWER_CWND_ECNE</span><span class="p">);</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_cwr_tsn</span> <span class="o">=</span> <span class="n">lowest_tsn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Always try to quiet the other end.  In case of lost CWR,</span>
<span class="cm">	 * resend last_cwr_tsn.</span>
<span class="cm">	 */</span>
	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_cwr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_cwr_tsn</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="cm">/* If we run out of memory, it will look like a lost CWR.  We&#39;ll</span>
<span class="cm">	 * get back in sync eventually.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">repl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to do delayed processing of ECN CWR chunk.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_do_ecn_cwr_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="n">__u32</span> <span class="n">lowest_tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Turn off ECNE getting auto-prepended to every outgoing</span>
<span class="cm">	 * packet</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">need_ecne</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Generate SACK if necessary.  We call this at the end of a packet.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_gen_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
			 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">max_tsn_seen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">last_data_from</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_SACKDELAY_DISABLE</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_SACKDELAY_DISABLE</span><span class="p">)))</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>
	<span class="n">max_tsn_seen</span> <span class="o">=</span> <span class="n">sctp_tsnmap_get_max_tsn_seen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>

	<span class="cm">/* From 12.2 Parameters necessary per association (i.e. the TCB):</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ack State : This flag indicates if the next received packet</span>
<span class="cm">	 * 	     : is to be responded to with a SACK. ...</span>
<span class="cm">	 *	     : When DATA chunks are out of order, SACK&#39;s</span>
<span class="cm">	 *           : are not delayed (see Section 6).</span>
<span class="cm">	 *</span>
<span class="cm">	 * [This is actually not mentioned in Section 6, but we</span>
<span class="cm">	 * implement it here anyway. --piggy]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_tsn_seen</span> <span class="o">!=</span> <span class="n">ctsn</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* From 6.2  Acknowledgement on Reception of DATA Chunks:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Section 4.2 of [RFC2581] SHOULD be followed. Specifically,</span>
<span class="cm">	 * an acknowledgement SHOULD be generated for at least every</span>
<span class="cm">	 * second packet (not every second DATA chunk) received, and</span>
<span class="cm">	 * SHOULD be generated within 200 ms of the arrival of any</span>
<span class="cm">	 * unacknowledged DATA chunk. ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_cnt</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Set the SACK delay timeout based on the</span>
<span class="cm">		 * SACK delay for the last transport</span>
<span class="cm">		 * data was received from, or the default</span>
<span class="cm">		 * for the association.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We will need a SACK for the next packet.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_cnt</span> <span class="o">&gt;=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We will need a SACK for the next packet.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_cnt</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Restart the SACK timer. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">;</span>
		<span class="n">sack</span> <span class="o">=</span> <span class="n">sctp_make_sack</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sack</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">sack</span><span class="p">));</span>

		<span class="cm">/* Stop the SACK timer.  */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* When the T3-RTX timer expires, it calls this function to create the</span>
<span class="cm"> * relevant state machine event.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_generate_t3_rtx_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span> <span class="n">peer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

	<span class="cm">/* Check whether a task is in the sock.  */</span>

	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s:Sock is busy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Try again later.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">)))</span>
			<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this transport really dead and just waiting around for</span>
<span class="cm">	 * the timer to let go of the reference?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Run through the state machine.  */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_TIMEOUT</span><span class="p">,</span>
			   <span class="n">SCTP_ST_TIMEOUT</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T3_RTX</span><span class="p">),</span>
			   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
			   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
			   <span class="n">transport</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is a sa interface for producing timeout events.  It works</span>
<span class="cm"> * for timeouts which use the association as their parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_timeout_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="n">sctp_event_timeout_t</span> <span class="n">timeout_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s:Sock is busy: timer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span>
				  <span class="n">timeout_type</span><span class="p">);</span>

		<span class="cm">/* Try again later.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">timeout_type</span><span class="p">],</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">)))</span>
			<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this association really dead and just waiting around for</span>
<span class="cm">	 * the timer to let go of the reference?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Run through the state machine.  */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_TIMEOUT</span><span class="p">,</span>
			   <span class="n">SCTP_ST_TIMEOUT</span><span class="p">(</span><span class="n">timeout_type</span><span class="p">),</span>
			   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">timeout_type</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_t1_cookie_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_t1_init_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_t2_shutdown_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_t4_rto_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_t5_shutdown_guard_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">);</span>

<span class="p">}</span> <span class="cm">/* sctp_generate_t5_shutdown_guard_event() */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_autoclose_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Generate a heart beat event.  If the sock is busy, reschedule.   Make</span>
<span class="cm"> * sure that the transport is still valid.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_generate_heartbeat_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s:Sock is busy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Try again later.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">)))</span>
			<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this structure just waiting around for us to actually</span>
<span class="cm">	 * get destroyed?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_TIMEOUT</span><span class="p">,</span>
			   <span class="n">SCTP_ST_TIMEOUT</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_HEARTBEAT</span><span class="p">),</span>
			   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
			   <span class="n">transport</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	 <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the timeout of the ICMP protocol unreachable timer.  Trigger</span>
<span class="cm"> * the correct state machine transition that will close the association.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_generate_proto_unreach_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	
	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s:Sock is busy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Try again later.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">,</span>
				<span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">)))</span>
			<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this structure just waiting around for us to actually</span>
<span class="cm">	 * get destroyed?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_OTHER</span><span class="p">,</span>
		   <span class="n">SCTP_ST_OTHER</span><span class="p">(</span><span class="n">SCTP_EVENT_ICMP_PROTO_UNREACH</span><span class="p">),</span>
		   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Inject a SACK Timeout event into the state machine.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_sack_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_generate_timeout_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">sctp_timer_event_t</span> <span class="o">*</span><span class="n">sctp_timer_events</span><span class="p">[</span><span class="n">SCTP_NUM_TIMEOUT_TYPES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="nb">NULL</span><span class="p">,</span>
	<span class="n">sctp_generate_t1_cookie_event</span><span class="p">,</span>
	<span class="n">sctp_generate_t1_init_event</span><span class="p">,</span>
	<span class="n">sctp_generate_t2_shutdown_event</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
	<span class="n">sctp_generate_t4_rto_event</span><span class="p">,</span>
	<span class="n">sctp_generate_t5_shutdown_guard_event</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
	<span class="n">sctp_generate_sack_event</span><span class="p">,</span>
	<span class="n">sctp_generate_autoclose_event</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* RFC 2960 8.2 Path Failure Detection</span>
<span class="cm"> *</span>
<span class="cm"> * When its peer endpoint is multi-homed, an endpoint should keep a</span>
<span class="cm"> * error counter for each of the destination transport addresses of the</span>
<span class="cm"> * peer endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Each time the T3-rtx timer expires on any address, or when a</span>
<span class="cm"> * HEARTBEAT sent to an idle address is not acknowledged within a RTO,</span>
<span class="cm"> * the error counter of that destination address will be incremented.</span>
<span class="cm"> * When the value in the error counter exceeds the protocol parameter</span>
<span class="cm"> * &#39;Path.Max.Retrans&#39; of that destination address, the endpoint should</span>
<span class="cm"> * mark the destination transport address as inactive, and a</span>
<span class="cm"> * notification SHOULD be sent to the upper layer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_do_8_2_transport_strike</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">is_hb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The check for association&#39;s overall error counter exceeding the</span>
<span class="cm">	 * threshold is done in the state function.</span>
<span class="cm">	 */</span>
	<span class="cm">/* We are here due to a timer expiration.  If the timer was</span>
<span class="cm">	 * not a HEARTBEAT, then normal error tracking is done.</span>
<span class="cm">	 * If the timer was a heartbeat, we only increment error counts</span>
<span class="cm">	 * when we already have an outstanding HEARTBEAT that has not</span>
<span class="cm">	 * been acknowledged.</span>
<span class="cm">	 * Additionally, some tranport states inhibit error increments.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="o">++</span><span class="p">;</span>
	 <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">hb_sent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">error_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_INACTIVE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">&gt;</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;transport_strike:association %p&quot;</span><span class="p">,</span>
					 <span class="s">&quot; transport IP: port:%d failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">asoc</span><span class="p">,</span>
					 <span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">),</span>
					 <span class="n">ntohs</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
		<span class="n">sctp_assoc_control_transport</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span>
					     <span class="n">SCTP_TRANSPORT_DOWN</span><span class="p">,</span>
					     <span class="n">SCTP_FAILED_THRESHOLD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* E2) For the destination address for which the timer</span>
<span class="cm">	 * expires, set RTO &lt;- RTO * 2 (&quot;back off the timer&quot;).  The</span>
<span class="cm">	 * maximum value discussed in rule C7 above (RTO.max) may be</span>
<span class="cm">	 * used to provide an upper bound to this doubling operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Special Case:  the first HB doesn&#39;t trigger exponential backoff.</span>
<span class="cm">	 * The first unacknowledged HB triggers it.  We do this with a flag</span>
<span class="cm">	 * that indicates that we have an outstanding HB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hb</span> <span class="o">||</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">hb_sent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Worker routine to handle INIT command failure.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_init_failed</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_CANT_STR_ASSOC</span><span class="p">,</span>
						<span class="p">(</span><span class="n">__u16</span><span class="p">)</span><span class="n">error</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>

	<span class="cm">/* SEND_FAILED sent later when cleaning up the association. */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/* Worker routine to handle SCTP_CMD_ASSOC_FAILED.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_assoc_failed</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="n">sctp_event_t</span> <span class="n">event_type</span><span class="p">,</span>
				  <span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="cm">/* Cancel any partial delivery in progress. */</span>
	<span class="n">sctp_ulpq_abort_pd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">==</span> <span class="n">SCTP_EVENT_T_CHUNK</span> <span class="o">&amp;&amp;</span> <span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">SCTP_CID_ABORT</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_COMM_LOST</span><span class="p">,</span>
						<span class="p">(</span><span class="n">__u16</span><span class="p">)</span><span class="n">error</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
						<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_COMM_LOST</span><span class="p">,</span>
						<span class="p">(</span><span class="n">__u16</span><span class="p">)</span><span class="n">error</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>

	<span class="cm">/* SEND_FAILED sent later when cleaning up the association. */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/* Process an init chunk (may be real INIT/INIT-ACK or an embedded INIT</span>
<span class="cm"> * inside the cookie.  In reality, this is only used for INIT-ACK processing</span>
<span class="cm"> * since all other cases use &quot;temporary&quot; associations and can do all</span>
<span class="cm"> * their work in statefuns directly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_cmd_process_init</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				 <span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* We only process the init as a sideeffect in a single</span>
<span class="cm">	 * case.   This is when we process the INIT-ACK.   If we</span>
<span class="cm">	 * fail during INIT processing (due to malloc problems),</span>
<span class="cm">	 * just return the error and stop processing the stack.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">peer_init</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to break out starting up of heartbeat timers.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_hb_timers_start</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* Start a heartbeat timer for each transport on the association.</span>
<span class="cm">	 * hold a reference on the transport to make sure none of</span>
<span class="cm">	 * the needed data structures go away.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span> <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span> <span class="n">sctp_transport_timeout</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
			<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_hb_timers_stop</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* Stop all heartbeat timers. */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">))</span>
			<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function to stop any pending T3-RTX timers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_t3_rtx_timers_stop</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Helper function to update the heartbeat timer. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_hb_timer_update</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Update the heartbeat timer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span> <span class="n">sctp_transport_timeout</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
		<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Helper function to handle the reception of an HEARTBEAT ACK.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_transport_on</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_sender_hb_info_t</span> <span class="o">*</span><span class="n">hbinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_unconfirmed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of the</span>
<span class="cm">	 * HEARTBEAT should clear the error counter of the destination</span>
<span class="cm">	 * transport address to which the HEARTBEAT was sent.</span>
<span class="cm">	 */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Although RFC4960 specifies that the overall error count must</span>
<span class="cm">	 * be cleared when a HEARTBEAT ACK is received, we make an</span>
<span class="cm">	 * exception while in SHUTDOWN PENDING. If the peer keeps its</span>
<span class="cm">	 * window shut forever, we may never be able to transmit our</span>
<span class="cm">	 * outstanding data and rely on the retransmission limit be reached</span>
<span class="cm">	 * to shutdown the association.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear the hb_sent flag to signal that we had a good</span>
<span class="cm">	 * acknowledgement.</span>
<span class="cm">	 */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Mark the destination transport address as active if it is not so</span>
<span class="cm">	 * marked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">was_unconfirmed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sctp_assoc_control_transport</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">SCTP_TRANSPORT_UP</span><span class="p">,</span>
					     <span class="n">SCTP_HEARTBEAT_SUCCESS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The receiver of the HEARTBEAT ACK should also perform an</span>
<span class="cm">	 * RTT measurement for that destination transport address</span>
<span class="cm">	 * using the time value carried in the HEARTBEAT ACK chunk.</span>
<span class="cm">	 * If the transport&#39;s rto_pending variable has been cleared,</span>
<span class="cm">	 * it was most likely due to a retransmit.  However, we want</span>
<span class="cm">	 * to re-enable it to properly update the rto.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rto_pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rto_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hbinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_sender_hb_info_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">sctp_transport_update_rto</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">hbinfo</span><span class="o">-&gt;</span><span class="n">sent_at</span><span class="p">));</span>

	<span class="cm">/* Update the heartbeat timer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span> <span class="n">sctp_transport_timeout</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
		<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_unconfirmed</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sctp_transport_immediate_rtx</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Helper function to process the process SACK command.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_cmd_process_sack</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sackh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_outq_sack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">sackh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* There are no more TSNs awaiting SACK.  */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_OTHER</span><span class="p">,</span>
				 <span class="n">SCTP_ST_OTHER</span><span class="p">(</span><span class="n">SCTP_EVENT_NO_PENDING_TSN</span><span class="p">),</span>
				 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to set the timeout value for T2-SHUTDOWN timer and to set</span>
<span class="cm"> * the transport for a shutdown chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_setup_t2</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">sctp_assoc_choose_alter_transport</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
					      <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">shutdown_last_sent_to</span><span class="p">);</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">shutdown_last_sent_to</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to change the state of an association. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_new_state</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			       <span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_cmd_new_state: asoc %p[%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">asoc</span><span class="p">,</span> <span class="n">sctp_state_tbl</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Change the sk-&gt;sk_state of a TCP-style socket that has</span>
<span class="cm">		 * successfully completed a connect() call.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">SCTP_SS_ESTABLISHED</span><span class="p">;</span>

		<span class="cm">/* Set the RCV_SHUTDOWN flag when a SHUTDOWN is received. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SHUTDOWN_RECEIVED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">RCV_SHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">COOKIE_WAIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Reset init timeouts since they may have been</span>
<span class="cm">		 * increased due to timer expirations.</span>
<span class="cm">		 */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ESTABLISHED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SHUTDOWN_RECEIVED</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Wake up any processes waiting in the asoc&#39;s wait queue in</span>
<span class="cm">		 * sctp_wait_for_connect() or sctp_wait_for_sndbuf().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">))</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

		<span class="cm">/* Wake up any processes waiting in the sk&#39;s sleep queue of</span>
<span class="cm">		 * a TCP-style or UDP-style peeled-off socket in</span>
<span class="cm">		 * sctp_wait_for_accept() or sctp_wait_for_packet().</span>
<span class="cm">		 * For a UDP-style socket, the waiters are woken up by the</span>
<span class="cm">		 * notifications.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function to delete an association. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_delete_tcb</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* If it is a non-temporary association belonging to a TCP-style</span>
<span class="cm">	 * listening socket that is not closed, do not free it so that accept()</span>
<span class="cm">	 * can pick it up later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">!=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sctp_unhash_established</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ADDIP Section 4.1 ASCONF Chunk Procedures</span>
<span class="cm"> * A4) Start a T-4 RTO timer, using the RTO value of the selected</span>
<span class="cm"> * destination address (we use active path instead of primary path just</span>
<span class="cm"> * because primary path may be inactive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_setup_t4</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">sctp_assoc_choose_alter_transport</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process an incoming Operation Error Chunk. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_process_operr</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_errhdr</span> <span class="o">*</span><span class="n">err_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">&gt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_errhdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

		<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_remote_error</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						     <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">ev</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">err_hdr</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_ERROR_UNKNOWN_CHUNK</span>:
		<span class="p">{</span>
			<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">unk_chunk_hdr</span><span class="p">;</span>

			<span class="n">unk_chunk_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">err_hdr</span><span class="o">-&gt;</span><span class="n">variable</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">unk_chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ADDIP 4.1 A9) If the peer responds to an ASCONF with</span>
<span class="cm">			 * an ERROR chunk reporting that it did not recognized</span>
<span class="cm">			 * the ASCONF chunk type, the sender of the ASCONF MUST</span>
<span class="cm">			 * NOT send any further ASCONF chunks and MUST stop its</span>
<span class="cm">			 * T-4 timer.</span>
<span class="cm">			 */</span>
			<span class="k">case</span> <span class="n">SCTP_CID_ASCONF</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">cmds</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
					<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Process variable FWDTSN chunk information. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_process_fwdtsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="o">*</span><span class="n">ulpq</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="o">*</span><span class="n">skip</span><span class="p">;</span>
	<span class="cm">/* Walk through all the skipped SSNs */</span>
	<span class="n">sctp_walk_fwdtsn</span><span class="p">(</span><span class="n">skip</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_ulpq_skip</span><span class="p">(</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">skip</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">skip</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function to remove the association non-primary peer</span>
<span class="cm"> * transports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_del_non_primary</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_assoc_del_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function to set sk_err on a 1-1 style socket. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_set_sk_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to generate an association change event */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_assoc_change</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">,</span>
					    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">,</span>
					    <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Helper function to generate an adaptation indication event */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_adaptation_ind</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_adaptation_indication</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_t1_timer_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="n">sctp_event_timeout_t</span> <span class="n">timer</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_last_sent_to</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">init_sent_count</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_cycle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">timer</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">timer</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_timeo</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">timer</span><span class="p">]</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_timeo</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_cycle</span><span class="o">++</span><span class="p">;</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span>
			<span class="s">&quot;T1 %s Timeout adjustment&quot;</span>
			<span class="s">&quot; init_err_counter: %d&quot;</span>
			<span class="s">&quot; cycle: %d&quot;</span>
			<span class="s">&quot; timeout: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span><span class="p">,</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_cycle</span><span class="p">,</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">timer</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/* Send the whole message, chunk by chunk, to the outqueue.</span>
<span class="cm"> * This way the whole message is queued up and bundling if</span>
<span class="cm"> * encouraged for small fragments.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_cmd_send_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">,</span> <span class="n">frag_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Sent the next ASCONF packet currently stored in the association.</span>
<span class="cm"> * This happens after the ASCONF_ACK was succeffully processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_cmd_send_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Send the next asconf chunk from the addip chunk</span>
<span class="cm">	 * queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_chunk_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_chunk_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">asconf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

		<span class="cm">/* Hold the chunk until an ASCONF_ACK is received. */</span>
		<span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="n">asconf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_primitive_ASCONF</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asconf</span><span class="p">))</span>
			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">asconf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span> <span class="o">=</span> <span class="n">asconf</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* These three macros allow us to pull the debugging code out of the</span>
<span class="cm"> * main flow of sctp_do_sm() to keep attention focused on the real</span>
<span class="cm"> * functionality there.</span>
<span class="cm"> */</span>
<span class="cp">#define DEBUG_PRE \</span>
<span class="cp">	SCTP_DEBUG_PRINTK(&quot;sctp_do_sm prefn: &quot; \</span>
<span class="cp">			  &quot;ep %p, %s, %s, asoc %p[%s], %s\n&quot;, \</span>
<span class="cp">			  ep, sctp_evttype_tbl[event_type], \</span>
<span class="cp">			  (*debug_fn)(subtype), asoc, \</span>
<span class="cp">			  sctp_state_tbl[state], state_fn-&gt;name)</span>

<span class="cp">#define DEBUG_POST \</span>
<span class="cp">	SCTP_DEBUG_PRINTK(&quot;sctp_do_sm postfn: &quot; \</span>
<span class="cp">			  &quot;asoc %p, status: %s\n&quot;, \</span>
<span class="cp">			  asoc, sctp_status_tbl[status])</span>

<span class="cp">#define DEBUG_POST_SFX \</span>
<span class="cp">	SCTP_DEBUG_PRINTK(&quot;sctp_do_sm post sfx: error %d, asoc %p[%s]\n&quot;, \</span>
<span class="cp">			  error, asoc, \</span>
<span class="cp">			  sctp_state_tbl[(asoc &amp;&amp; sctp_id2assoc(ep-&gt;base.sk, \</span>
<span class="cp">			  sctp_assoc2id(asoc)))?asoc-&gt;state:SCTP_STATE_CLOSED])</span>

<span class="cm">/*</span>
<span class="cm"> * This is the master state machine processing function.</span>
<span class="cm"> *</span>
<span class="cm"> * If you want to understand all of lksctp, this is a</span>
<span class="cm"> * good place to start.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_do_sm</span><span class="p">(</span><span class="n">sctp_event_t</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">,</span>
	       <span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">event_arg</span><span class="p">,</span>
	       <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="n">commands</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">sctp_sm_table_entry_t</span> <span class="o">*</span><span class="n">state_fn</span><span class="p">;</span>
	<span class="n">sctp_disposition_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="n">printfn_t</span><span class="p">)(</span><span class="n">sctp_subtype_t</span><span class="p">);</span>

	<span class="k">static</span> <span class="n">printfn_t</span> <span class="o">*</span><span class="n">table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="n">sctp_cname</span><span class="p">,</span> <span class="n">sctp_tname</span><span class="p">,</span> <span class="n">sctp_oname</span><span class="p">,</span> <span class="n">sctp_pname</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">printfn_t</span> <span class="o">*</span><span class="n">debug_fn</span>  <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">))</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">event_type</span><span class="p">];</span>

	<span class="cm">/* Look up the state function, run it, and then process the</span>
<span class="cm">	 * side effects.  These three steps are the heart of lksctp.</span>
<span class="cm">	 */</span>
	<span class="n">state_fn</span> <span class="o">=</span> <span class="n">sctp_sm_lookup_event</span><span class="p">(</span><span class="n">event_type</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">subtype</span><span class="p">);</span>

	<span class="n">sctp_init_cmd_seq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commands</span><span class="p">);</span>

	<span class="n">DEBUG_PRE</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">state_fn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">subtype</span><span class="p">,</span> <span class="n">event_arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commands</span><span class="p">);</span>
	<span class="n">DEBUG_POST</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_side_effects</span><span class="p">(</span><span class="n">event_type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
				  <span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">event_arg</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">commands</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="n">DEBUG_POST_SFX</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef DEBUG_PRE</span>
<span class="cp">#undef DEBUG_POST</span>

<span class="cm">/*****************************************************************</span>
<span class="cm"> * This the master state function side effect processing function.</span>
<span class="cm"> *****************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_side_effects</span><span class="p">(</span><span class="n">sctp_event_t</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">,</span>
			     <span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">event_arg</span><span class="p">,</span>
			     <span class="n">sctp_disposition_t</span> <span class="n">status</span><span class="p">,</span>
			     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* FIXME - Most of the dispositions left today would be categorized</span>
<span class="cm">	 * as &quot;exceptional&quot; dispositions.  For those dispositions, it</span>
<span class="cm">	 * may not be proper to run through any of the commands at all.</span>
<span class="cm">	 * For example, the command interpreter might be run only with</span>
<span class="cm">	 * disposition SCTP_DISPOSITION_CONSUME.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">sctp_cmd_interpreter</span><span class="p">(</span><span class="n">event_type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
					       <span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
					       <span class="n">event_arg</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					       <span class="n">commands</span><span class="p">,</span> <span class="n">gfp</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_DISCARD</span>:
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Ignored sctp protocol event - state %d, &quot;</span>
				  <span class="s">&quot;event_type %d, event_id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">state</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_NOMEM</span>:
		<span class="cm">/* We ran out of memory, so we need to discard this</span>
<span class="cm">		 * packet.</span>
<span class="cm">		 */</span>
		<span class="cm">/* BUG--we should now recover some memory, probably by</span>
<span class="cm">		 * reneging...</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span>:
		<span class="cm">/* This should now be a command. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_CONSUME</span>:
	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_ABORT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We should no longer have much work to do here as the</span>
<span class="cm">		 * real work has been done as explicit commands above.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_VIOLATION</span>:
		<span class="n">net_err_ratelimited</span><span class="p">(</span><span class="s">&quot;protocol violation state %d chunkid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">state</span><span class="p">,</span> <span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_NOT_IMPL</span>:
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;unimplemented feature in state %d, event_type %d, event_id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">state</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_DISPOSITION_BUG</span>:
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;bug in state %d, event_type %d, event_id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">state</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;impossible disposition %d in state %d, event_type %d, event_id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">status</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * 2nd Level Abstractions</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/* This is the side-effect interpreter.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_cmd_interpreter</span><span class="p">(</span><span class="n">sctp_event_t</span> <span class="n">event_type</span><span class="p">,</span>
				<span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">,</span>
				<span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">event_arg</span><span class="p">,</span>
				<span class="n">sctp_disposition_t</span> <span class="n">status</span><span class="p">,</span>
				<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">force</span><span class="p">;</span>
	<span class="n">sctp_cmd_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">new_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="n">sackh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">local_cork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_EVENT_T_TIMEOUT</span> <span class="o">!=</span> <span class="n">event_type</span><span class="p">)</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">event_arg</span><span class="p">;</span>

	<span class="cm">/* Note:  This whole file is a huge candidate for rework.</span>
<span class="cm">	 * For example, each command could either have its own handler, so</span>
<span class="cm">	 * the loop would look like:</span>
<span class="cm">	 *     while (cmds)</span>
<span class="cm">	 *         cmd-&gt;handle(x, y, z)</span>
<span class="cm">	 * --jgrimm</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">sctp_next_cmd</span><span class="p">(</span><span class="n">commands</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">verb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_NOP</span>:
			<span class="cm">/* Do nothing. */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_NEW_ASOC</span>:
			<span class="cm">/* Register a new association.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">local_cork</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
				<span class="n">local_cork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
			<span class="cm">/* Register with the endpoint.  */</span>
			<span class="n">sctp_endpoint_add_asoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="n">sctp_hash_established</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_UPDATE_ASSOC</span>:
		       <span class="n">sctp_assoc_update</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
		       <span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PURGE_OUTQUEUE</span>:
		       <span class="n">sctp_outq_teardown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
		       <span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_DELETE_TCB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">local_cork</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
				<span class="n">local_cork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Delete the current association.  */</span>
			<span class="n">sctp_cmd_delete_tcb</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_NEW_STATE</span>:
			<span class="cm">/* Enter a new state.  */</span>
			<span class="n">sctp_cmd_new_state</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_REPORT_TSN</span>:
			<span class="cm">/* Record the arrival of a TSN.  */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_tsnmap_mark</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span>
						 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_REPORT_FWDTSN</span>:
			<span class="cm">/* Move the Cumulattive TSN Ack ahead. */</span>
			<span class="n">sctp_tsnmap_skip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

			<span class="cm">/* purge the fragmentation queue */</span>
			<span class="n">sctp_ulpq_reasm_flushtsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

			<span class="cm">/* Abort any in progress partial delivery. */</span>
			<span class="n">sctp_ulpq_abort_pd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PROCESS_FWDTSN</span>:
			<span class="n">sctp_cmd_process_fwdtsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_GEN_SACK</span>:
			<span class="cm">/* Generate a Selective ACK.</span>
<span class="cm">			 * The argument tells us whether to just count</span>
<span class="cm">			 * the packet and MAYBE generate a SACK, or</span>
<span class="cm">			 * force a SACK out.</span>
<span class="cm">			 */</span>
			<span class="n">force</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">i32</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_gen_sack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">force</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PROCESS_SACK</span>:
			<span class="cm">/* Process an inbound SACK.  */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_cmd_process_sack</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
						      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_GEN_INIT_ACK</span>:
			<span class="cm">/* Generate an INIT ACK chunk.  */</span>
			<span class="n">new_obj</span> <span class="o">=</span> <span class="n">sctp_make_init_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span>
						     <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_obj</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">new_obj</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PEER_INIT</span>:
			<span class="cm">/* Process a unified INIT from the peer.</span>
<span class="cm">			 * Note: Only used during INIT-ACK processing.  If</span>
<span class="cm">			 * there is an error just return to the outter</span>
<span class="cm">			 * layer which will bail.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_cmd_process_init</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
						      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_GEN_COOKIE_ECHO</span>:
			<span class="cm">/* Generate a COOKIE ECHO chunk.  */</span>
			<span class="n">new_obj</span> <span class="o">=</span> <span class="n">sctp_make_cookie_echo</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_obj</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span>
					<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">new_obj</span><span class="p">));</span>

			<span class="cm">/* If there is an ERROR chunk to be sent along with</span>
<span class="cm">			 * the COOKIE_ECHO, send it, too.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
						<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">new_obj</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_obj</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">init_sent_count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_last_sent_to</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* FIXME - Eventually come up with a cleaner way to</span>
<span class="cm">			 * enabling COOKIE-ECHO + DATA bundling during</span>
<span class="cm">			 * multihoming stale cookie scenarios, the following</span>
<span class="cm">			 * command plays with asoc-&gt;peer.retran_path to</span>
<span class="cm">			 * avoid the problem of sending the COOKIE-ECHO and</span>
<span class="cm">			 * DATA in different paths, which could result</span>
<span class="cm">			 * in the association being ABORTed if the DATA chunk</span>
<span class="cm">			 * is processed first by the server.  Checking the</span>
<span class="cm">			 * init error counter simply causes this command</span>
<span class="cm">			 * to be executed only during failed attempts of</span>
<span class="cm">			 * association establishment.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">!=</span>
			     <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span>
						<span class="n">SCTP_CMD_FORCE_PRIM_RETRAN</span><span class="p">,</span>
						<span class="n">SCTP_NULL</span><span class="p">());</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_GEN_SHUTDOWN</span>:
			<span class="cm">/* Generate SHUTDOWN when in SHUTDOWN_SENT state.</span>
<span class="cm">			 * Reset error counts.</span>
<span class="cm">			 */</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Generate a SHUTDOWN chunk.  */</span>
			<span class="n">new_obj</span> <span class="o">=</span> <span class="n">sctp_make_shutdown</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_obj</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">new_obj</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_CHUNK_ULP</span>:
			<span class="cm">/* Send a chunk to the sockets layer.  */</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sm_sideff: %s %p, %s %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="s">&quot;chunk_up:&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
					  <span class="s">&quot;ulpq:&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">);</span>
			<span class="n">sctp_ulpq_tail_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
					    <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_EVENT_ULP</span>:
			<span class="cm">/* Send a notification to the sockets layer.  */</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sm_sideff: %s %p, %s %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="s">&quot;event_up:&quot;</span><span class="p">,</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
					  <span class="s">&quot;ulpq:&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">);</span>
			<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_REPLY</span>:
			<span class="cm">/* If an caller has not already corked, do cork. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">cork</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_outq_cork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
				<span class="n">local_cork</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Send a chunk to our peer.  */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_SEND_PKT</span>:
			<span class="cm">/* Send a full packet to our peer.  */</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
			<span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
			<span class="n">sctp_ootb_pkt_free</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_T1_RETRAN</span>:
			<span class="cm">/* Mark a transport for retransmission.  */</span>
			<span class="n">sctp_retransmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">,</span>
					<span class="n">SCTP_RTXR_T1_RTX</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_RETRAN</span>:
			<span class="cm">/* Mark a transport for retransmission.  */</span>
			<span class="n">sctp_retransmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">,</span>
					<span class="n">SCTP_RTXR_T3_RTX</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_ECN_CE</span>:
			<span class="cm">/* Do delayed CE processing.   */</span>
			<span class="n">sctp_do_ecn_ce_work</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_ECN_ECNE</span>:
			<span class="cm">/* Do delayed ECNE processing. */</span>
			<span class="n">new_obj</span> <span class="o">=</span> <span class="n">sctp_do_ecn_ecne_work</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">,</span>
							<span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
						<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">new_obj</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_ECN_CWR</span>:
			<span class="cm">/* Do delayed CWR processing.  */</span>
			<span class="n">sctp_do_ecn_cwr_work</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_SETUP_T2</span>:
			<span class="n">sctp_cmd_setup_t2</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TIMER_START_ONCE</span>:
			<span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">to</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TIMER_START</span>:
			<span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">to</span><span class="p">];</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">to</span><span class="p">];</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">);</span>

			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
			<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TIMER_RESTART</span>:
			<span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">to</span><span class="p">];</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">to</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">))</span>
				<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TIMER_STOP</span>:
			<span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">to</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">del_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
				<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_INIT_CHOOSE_TRANSPORT</span>:
			<span class="n">chunk</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">sctp_assoc_choose_alter_transport</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
						<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_last_sent_to</span><span class="p">);</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_last_sent_to</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">init_sent_count</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* Set the new transport as primary */</span>
			<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_INIT_RESTART</span>:
			<span class="cm">/* Do the needed accounting and updates</span>
<span class="cm">			 * associated with restarting an initialization</span>
<span class="cm">			 * timer. Only multiply the timeout by two if</span>
<span class="cm">			 * all transports have been tried at the current</span>
<span class="cm">			 * timeout.</span>
<span class="cm">			 */</span>
			<span class="n">sctp_cmd_t1_timer_update</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
						<span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">,</span>
						<span class="s">&quot;INIT&quot;</span><span class="p">);</span>

			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
					<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_COOKIEECHO_RESTART</span>:
			<span class="cm">/* Do the needed accounting and updates</span>
<span class="cm">			 * associated with restarting an initialization</span>
<span class="cm">			 * timer. Only multiply the timeout by two if</span>
<span class="cm">			 * all transports have been tried at the current</span>
<span class="cm">			 * timeout.</span>
<span class="cm">			 */</span>
			<span class="n">sctp_cmd_t1_timer_update</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
						<span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">,</span>
						<span class="s">&quot;COOKIE&quot;</span><span class="p">);</span>

			<span class="cm">/* If we&#39;ve sent any data bundled with</span>
<span class="cm">			 * COOKIE-ECHO we need to resend.</span>
<span class="cm">			 */</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
					<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_retransmit_mark</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
					    <span class="n">SCTP_RTXR_T1_RTX</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span>
					<span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
					<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_INIT_FAILED</span>:
			<span class="n">sctp_cmd_init_failed</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">err</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span>:
			<span class="n">sctp_cmd_assoc_failed</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span>
					      <span class="n">subtype</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">err</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_INIT_COUNTER_INC</span>:
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_INIT_COUNTER_RESET</span>:
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_cycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
					    <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">init_sent_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_REPORT_DUP</span>:
			<span class="n">sctp_tsnmap_mark_dup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span>
					     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span>:
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;vtag mismatch!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_STRIKE</span>:
			<span class="cm">/* Mark one strike against a transport.  */</span>
			<span class="n">sctp_do_8_2_transport_strike</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">,</span>
						    <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TRANSPORT_IDLE</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">;</span>
			<span class="n">sctp_transport_lower_cwnd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SCTP_LOWER_CWND_INACTIVE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TRANSPORT_HB_SENT</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">;</span>
			<span class="n">sctp_do_8_2_transport_strike</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_sent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_TRANSPORT_ON</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">;</span>
			<span class="n">sctp_cmd_transport_on</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_HB_TIMERS_START</span>:
			<span class="n">sctp_cmd_hb_timers_start</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_HB_TIMER_UPDATE</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">;</span>
			<span class="n">sctp_cmd_hb_timer_update</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_HB_TIMERS_STOP</span>:
			<span class="n">sctp_cmd_hb_timers_stop</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_REPORT_ERROR</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PROCESS_CTSN</span>:
			<span class="cm">/* Dummy up a SACK for processing. */</span>
			<span class="n">sackh</span><span class="p">.</span><span class="n">cum_tsn_ack</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">be32</span><span class="p">;</span>
			<span class="n">sackh</span><span class="p">.</span><span class="n">a_rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">+</span>
					<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">outstanding_bytes</span><span class="p">;</span>
			<span class="n">sackh</span><span class="p">.</span><span class="n">num_gap_ack_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sackh</span><span class="p">.</span><span class="n">num_dup_tsns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_SACK</span><span class="p">,</span>
					<span class="n">SCTP_SACKH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sackh</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_DISCARD_PACKET</span>:
			<span class="cm">/* We need to discard the whole packet.</span>
<span class="cm">			 * Uncork the queue since there might be</span>
<span class="cm">			 * responses pending</span>
<span class="cm">			 */</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">pdiscard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
				<span class="n">local_cork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_RTO_PENDING</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">transport</span><span class="p">;</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">rto_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PART_DELIVER</span>:
			<span class="n">sctp_ulpq_partial_delivery</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
						   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_RENEGE</span>:
			<span class="n">sctp_ulpq_renege</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
					 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_SETUP_T4</span>:
			<span class="n">sctp_cmd_setup_t4</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_PROCESS_OPERR</span>:
			<span class="n">sctp_cmd_process_operr</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_CLEAR_INIT_TAG</span>:
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_DEL_NON_PRIMARY</span>:
			<span class="n">sctp_cmd_del_non_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_T3_RTX_TIMERS_STOP</span>:
			<span class="n">sctp_cmd_t3_rtx_timers_stop</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_FORCE_PRIM_RETRAN</span>:
			<span class="n">t</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
			<span class="n">local_cork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_SET_SK_ERR</span>:
			<span class="n">sctp_cmd_set_sk_err</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">error</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_ASSOC_CHANGE</span>:
			<span class="n">sctp_cmd_assoc_change</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
					      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u8</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_ADAPTATION_IND</span>:
			<span class="n">sctp_cmd_adaptation_ind</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_ASSOC_SHKEY</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_auth_asoc_init_active_key</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
						<span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_UPDATE_INITTAG</span>:
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">u32</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_SEND_MSG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">cork</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_outq_cork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
				<span class="n">local_cork</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_cmd_send_msg</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">msg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_SEND_NEXT_ASCONF</span>:
			<span class="n">sctp_cmd_send_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_CMD_PURGE_ASCONF_QUEUE</span>:
			<span class="n">sctp_asconf_queue_teardown</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CMD_SET_ASOC</span>:
			<span class="n">asoc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">asoc</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Impossible command: %u, %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">verb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* If this is in response to a received chunk, wait until</span>
<span class="cm">	 * we are done with the packet to open the queue so that we don&#39;t</span>
<span class="cm">	 * send multiple packets in response to a single request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">SCTP_EVENT_T_CHUNK</span> <span class="o">==</span> <span class="n">event_type</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">end_of_packet</span> <span class="o">||</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">singleton</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">local_cork</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
