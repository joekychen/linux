<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › input.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>input.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2003 International Business Machines, Corp.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 Nokia, Inc.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * These functions handle all input from the IP layer into SCTP.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Xingang Guo &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Jon Grimm &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Hui Huang &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Daisy Chang &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt; </span><span class="cm">/* For struct list_head */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt; </span><span class="cm">/* For struct timeval */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/icmp.h&gt;</span>
<span class="cp">#include &lt;net/snmp.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>
<span class="cp">#include &lt;net/sctp/checksum.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>

<span class="cm">/* Forward declarations for internal helpers. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_rcv_ootb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">__sctp_rcv_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">__sctp_rcv_lookup_endpoint</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">__sctp_lookup_association</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">pt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_add_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>


<span class="cm">/* Calculate the SCTP checksum of an SCTP packet.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_rcv_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">sctp_start_cksum</span><span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">sh</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">sctp_update_cksum</span><span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">list</span><span class="p">),</span>
					<span class="n">tmp</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">sctp_end_cksum</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">cmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CRC failure, dump it. */</span>
		<span class="n">SCTP_INC_STATS_BH</span><span class="p">(</span><span class="n">SCTP_MIB_CHECKSUMERRORS</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_input_cb</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_skb_parm</span>	<span class="n">h4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="k">struct</span> <span class="n">inet6_skb_parm</span>	<span class="n">h6</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define SCTP_INPUT_CB(__skb)	((struct sctp_input_cb *)&amp;((__skb)-&gt;cb[0]))</span>

<span class="cm">/*</span>
<span class="cm"> * This is the routine which IP calls when receiving an SCTP packet.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">rcvr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">src</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span><span class="o">!=</span><span class="n">PACKET_HOST</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>

	<span class="n">SCTP_INC_STATS_BH</span><span class="p">(</span><span class="n">SCTP_MIB_INSCTPPACKS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>

	<span class="n">sh</span> <span class="o">=</span> <span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Pull up the IP and SCTP headers. */</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctphdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_checksum_disable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		  <span class="n">sctp_rcv_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctphdr</span><span class="p">));</span>

	<span class="cm">/* Make sure we at least have chunk headers worth of data left. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>

	<span class="n">family</span> <span class="o">=</span> <span class="n">ipver2af</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>

	<span class="cm">/* Initialize local addresses for lookups. */</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* If the packet is to or from a non-unicast address,</span>
<span class="cm">	 * silently discard the packet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is not clearly defined in the RFC except in section</span>
<span class="cm">	 * 8.4 - OOTB handling.  However, based on the book &quot;Stream Control</span>
<span class="cm">	 * Transmission Protocol&quot; 2.1, &quot;It is important to note that the</span>
<span class="cm">	 * IP address of an SCTP transport address must be a routable</span>
<span class="cm">	 * unicast address.  In other words, IP multicast addresses and</span>
<span class="cm">	 * IP broadcast addresses cannot be used in an SCTP transport</span>
<span class="cm">	 * address.&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_rcv_lookup</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">__sctp_rcv_lookup_endpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>

	<span class="cm">/* Retrieve the common input handling substructure. */</span>
	<span class="n">rcvr</span> <span class="o">=</span> <span class="n">asoc</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a frame arrives on an interface and the receiving socket is</span>
<span class="cm">	 * bound to another interface, via SO_BINDTODEVICE, treat it as OOTB</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">!=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
			<span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">sctp_get_ctl_sock</span><span class="p">();</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
		<span class="n">sctp_endpoint_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">rcvr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * RFC 2960, 8.4 - Handle &quot;Out of the blue&quot; Packets.</span>
<span class="cm">	 * An SCTP packet is called an &quot;out of the blue&quot; (OOTB)</span>
<span class="cm">	 * packet if it is correctly formed, i.e., passed the</span>
<span class="cm">	 * receiver&#39;s checksum check, but the receiver is not</span>
<span class="cm">	 * able to identify the association to which this</span>
<span class="cm">	 * packet belongs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_rcv_ootb</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SCTP_INC_STATS_BH</span><span class="p">(</span><span class="n">SCTP_MIB_OUTOFBLUES</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">discard_release</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfrm_policy_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">XFRM_POLICY_IN</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_release</span><span class="p">;</span>
	<span class="n">nf_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_filter</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_release</span><span class="p">;</span>

	<span class="cm">/* Create an SCTP packet structure. */</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_chunkify</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">discard_release</span><span class="p">;</span>
	<span class="n">SCTP_INPUT_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>

	<span class="cm">/* Remember what endpoint is to handle this packet. */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rcvr</span> <span class="o">=</span> <span class="n">rcvr</span><span class="p">;</span>

	<span class="cm">/* Remember the SCTP header. */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span> <span class="o">=</span> <span class="n">sh</span><span class="p">;</span>

	<span class="cm">/* Set the source and destination addresses of the incoming chunk.  */</span>
	<span class="n">sctp_init_addrs</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>

	<span class="cm">/* Remember where we came from.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>

	<span class="cm">/* Acquire access to the sock lock. Note: We are safe from other</span>
<span class="cm">	 * bottom halves on this lock, but a user may be in the lock too,</span>
<span class="cm">	 * so check if it is busy.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">!=</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Our cached sk is different from the rcvr-&gt;sk.  This is</span>
<span class="cm">		 * because migrate()/accept() may have moved the association</span>
<span class="cm">		 * to a new socket and released all the sockets.  So now we</span>
<span class="cm">		 * are holding a lock on the old socket while the user may</span>
<span class="cm">		 * be doing something with the new socket.  Switch our veiw</span>
<span class="cm">		 * of the current sk.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* sctp_chunk_free already freed the skb */</span>
			<span class="k">goto</span> <span class="n">discard_release</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">SCTP_INC_STATS_BH</span><span class="p">(</span><span class="n">SCTP_MIB_IN_PKT_BACKLOG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">SCTP_INC_STATS_BH</span><span class="p">(</span><span class="n">SCTP_MIB_IN_PKT_SOFTIRQ</span><span class="p">);</span>
		<span class="n">sctp_inq_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">inqueue</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Release the asoc/ep ref we took in the lookup calls. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">discard_it:</span>
	<span class="n">SCTP_INC_STATS_BH</span><span class="p">(</span><span class="n">SCTP_MIB_IN_PKT_DISCARDS</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">discard_release:</span>
	<span class="cm">/* Release the asoc/ep ref we took in the lookup calls. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process the backlog queue of the socket.  Every skb on</span>
<span class="cm"> * the backlog holds a ref on an association or endpoint.</span>
<span class="cm"> * We hold this ref throughout the state machine to make</span>
<span class="cm"> * sure that the structure we need is still around.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_backlog_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">SCTP_INPUT_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="n">inqueue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">inqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">rcvr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">backloged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcvr</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rcvr</span><span class="p">;</span>

	<span class="cm">/* If the rcvr is dead then the association or endpoint</span>
<span class="cm">	 * has been deleted and we can safely drop the chunk</span>
<span class="cm">	 * and refs that we are holding.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">!=</span> <span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* In this case, the association moved from one socket to</span>
<span class="cm">		 * another.  We are currently sitting on the backlog of the</span>
<span class="cm">		 * old socket, so we need to move.</span>
<span class="cm">		 * However, since we are here in the process context we</span>
<span class="cm">		 * need to take make sure that the user doesn&#39;t own</span>
<span class="cm">		 * the new socket when we process the packet.</span>
<span class="cm">		 * If the new socket is user-owned, queue the chunk to the</span>
<span class="cm">		 * backlog of the new socket without dropping any refs.</span>
<span class="cm">		 * Otherwise, we can safely push the chunk on the inqueue.</span>
<span class="cm">		 */</span>

		<span class="n">sk</span> <span class="o">=</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">))</span>
				<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">backloged</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sctp_inq_push</span><span class="p">(</span><span class="n">inqueue</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* If the chunk was backloged again, don&#39;t drop refs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">backloged</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sctp_inq_push</span><span class="p">(</span><span class="n">inqueue</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="cm">/* Release the refs we took in sctp_add_backlog */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_EP_TYPE_ASSOCIATION</span> <span class="o">==</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">sctp_assoc</span><span class="p">(</span><span class="n">rcvr</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SCTP_EP_TYPE_SOCKET</span> <span class="o">==</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">sctp_ep</span><span class="p">(</span><span class="n">rcvr</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_add_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">SCTP_INPUT_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">rcvr</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rcvr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sk_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Hold the assoc/ep while hanging on the backlog queue.</span>
<span class="cm">		 * This way, we know structures we need will not disappear</span>
<span class="cm">		 * from us</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_EP_TYPE_ASSOCIATION</span> <span class="o">==</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">sctp_assoc</span><span class="p">(</span><span class="n">rcvr</span><span class="p">));</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SCTP_EP_TYPE_SOCKET</span> <span class="o">==</span> <span class="n">rcvr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="n">sctp_endpoint_hold</span><span class="p">(</span><span class="n">sctp_ep</span><span class="p">(</span><span class="n">rcvr</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* Handle icmp frag needed error. */</span>
<span class="kt">void</span> <span class="nf">sctp_icmp_frag_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">pmtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">&lt;=</span> <span class="n">pmtu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pmtu_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">pmtu_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Update transports view of the MTU */</span>
		<span class="n">sctp_transport_update_pmtu</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pmtu</span><span class="p">);</span>

		<span class="cm">/* Update association pmtu. */</span>
		<span class="n">sctp_assoc_sync_pmtu</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Retransmit with the new pmtu setting.</span>
<span class="cm">	 * Normally, if PMTU discovery is disabled, an ICMP Fragmentation</span>
<span class="cm">	 * Needed will never be sent, but if a message was sent before</span>
<span class="cm">	 * PMTU discovery was disabled that was larger than the PMTU, it</span>
<span class="cm">	 * would not be fragmented, so it must be re-transmitted fragmented.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_retransmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">SCTP_RTXR_PMTUD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SCTP Implementer&#39;s Guide, 2.37 ICMP handling procedures</span>
<span class="cm"> *</span>
<span class="cm"> * ICMP8) If the ICMP code is a &quot;Unrecognized next header type encountered&quot;</span>
<span class="cm"> *        or a &quot;Protocol Unreachable&quot; treat this message as an abort</span>
<span class="cm"> *        with the T bit set.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends an event to the state machine, which will abort the</span>
<span class="cm"> * association.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_icmp_proto_unreachable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">,</span>
						<span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">/</span><span class="mi">20</span><span class="p">)))</span>
				<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="p">}</span>
			
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">))</span>
			<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

		<span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_OTHER</span><span class="p">,</span>
			   <span class="n">SCTP_ST_OTHER</span><span class="p">(</span><span class="n">SCTP_EVENT_ICMP_PROTO_UNREACH</span><span class="p">),</span>
			   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
			   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Common lookup code for icmp/icmpv6 error handler. */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sctp_err_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sctphdr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">**</span><span class="n">app</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">tpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">saddr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_init_chunk</span> <span class="o">*</span><span class="n">chunkhdr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sctphdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sctphdr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="o">*</span><span class="n">app</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize local addresses for lookups. */</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Look for an association that matches the incoming ICMP error</span>
<span class="cm">	 * packet.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_lookup_association</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* RFC 4960, Appendix C. ICMP Handling</span>
<span class="cm">	 *</span>
<span class="cm">	 * ICMP6) An implementation MUST validate that the Verification Tag</span>
<span class="cm">	 * contained in the ICMP message matches the Verification Tag of</span>
<span class="cm">	 * the peer.  If the Verification Tag is not 0 and does NOT</span>
<span class="cm">	 * match, discard the ICMP message.  If it is 0 and the ICMP</span>
<span class="cm">	 * message contains enough bytes to verify that the chunk type is</span>
<span class="cm">	 * an INIT chunk and that the Initiate Tag matches the tag of the</span>
<span class="cm">	 * peer, continue with ICMP7.  If the ICMP message is too short</span>
<span class="cm">	 * or the chunk type or the Initiate Tag does not match, silently</span>
<span class="cm">	 * discard the packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vtag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunkhdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sctphdr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctphdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctphdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)</span>
			  <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">chunkhdr</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_CID_INIT</span> <span class="o">||</span>
		    <span class="n">ntohl</span><span class="p">(</span><span class="n">chunkhdr</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">init_tag</span><span class="p">)</span> <span class="o">!=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vtag</span> <span class="o">!=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* If too many ICMPs get dropped on busy</span>
<span class="cm">	 * servers this needs to be solved differently.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">LINUX_MIB_LOCKDROPPEDICMPS</span><span class="p">);</span>

	<span class="o">*</span><span class="n">app</span> <span class="o">=</span> <span class="n">asoc</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Common cleanup code for icmp/icmpv6 error handler. */</span>
<span class="kt">void</span> <span class="nf">sctp_err_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called by the ICMP module when it gets some</span>
<span class="cm"> * sort of error condition.  If err &lt; 0 then the socket should</span>
<span class="cm"> * be closed and the error returned to the user.  If err &gt; 0</span>
<span class="cm"> * it&#39;s just the icmp type &lt;&lt; 8 | icmp code.  After adjustment</span>
<span class="cm"> * header points to the first 8 bytes of the sctp header.  We need</span>
<span class="cm"> * to find the appropriate port.</span>
<span class="cm"> *</span>
<span class="cm"> * The locking strategy used here is very &quot;optimistic&quot;. When</span>
<span class="cm"> * someone else accesses the socket the ICMP is just dropped</span>
<span class="cm"> * and for some paths there is no check at all.</span>
<span class="cm"> * A more general error queue to queue errors for later handling</span>
<span class="cm"> * is probably better.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_v4_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">ihlen</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">icmp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="n">icmp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span><span class="p">;</span>
	<span class="n">sk_buff_data_t</span> <span class="n">saveip</span><span class="p">,</span> <span class="n">savesctp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ihlen</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ICMP_INC_STATS_BH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ICMP_MIB_INERRORS</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix up skb to look at the embedded net header. */</span>
	<span class="n">saveip</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span><span class="p">;</span>
	<span class="n">savesctp</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">;</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_set_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ihlen</span><span class="p">);</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">sctp_err_lookup</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>
	<span class="cm">/* Put back, the original values. */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">=</span> <span class="n">saveip</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="n">savesctp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ICMP_INC_STATS_BH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ICMP_MIB_INERRORS</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Warning:  The sock lock is held.  Remember to call</span>
<span class="cm">	 * sctp_err_finish!</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ICMP_PARAMETERPROB</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ICMP_DEST_UNREACH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;</span> <span class="n">NR_ICMP_UNREACH</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="cm">/* PMTU discovery (RFC1191) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ICMP_FRAG_NEEDED</span> <span class="o">==</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_icmp_frag_needed</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ICMP_PROT_UNREACH</span> <span class="o">==</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_icmp_proto_unreachable</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
							    <span class="n">transport</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">icmp_err_convert</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">errno</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ICMP_TIME_EXCEEDED</span>:
		<span class="cm">/* Ignore any time exceeded errors due to fragment reassembly</span>
<span class="cm">		 * timeouts.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ICMP_EXC_FRAGTIME</span> <span class="o">==</span> <span class="n">code</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">EHOSTUNREACH</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">recverr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="cm">/* Only an error on timeout */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err_soft</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">sctp_err_finish</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RFC 2960, 8.4 - Handle &quot;Out of the blue&quot; Packets.</span>
<span class="cm"> *</span>
<span class="cm"> * This function scans all the chunks in the OOTB packet to determine if</span>
<span class="cm"> * the packet should be discarded right away.  If a response might be needed</span>
<span class="cm"> * for this packet, or, if further processing is possible, the packet will</span>
<span class="cm"> * be queued to a proper inqueue for the next phase of handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Output:</span>
<span class="cm"> * Return 0 - If further processing is needed.</span>
<span class="cm"> * Return 1 - If the packet can be discarded right away.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_rcv_ootb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">ch_end</span><span class="p">;</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Scan through all the chunks in the packet.  */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Break out if chunk length is less then minimal. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ch_end</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span><span class="p">)</span> <span class="o">+</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch_end</span> <span class="o">&gt;</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* RFC 8.4, 2) If the OOTB packet contains an ABORT chunk, the</span>
<span class="cm">		 * receiver MUST silently discard the OOTB packet and take no</span>
<span class="cm">		 * further action.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_ABORT</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

		<span class="cm">/* RFC 8.4, 6) If the packet contains a SHUTDOWN COMPLETE</span>
<span class="cm">		 * chunk, the receiver should silently discard the packet</span>
<span class="cm">		 * and take no further action.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_SHUTDOWN_COMPLETE</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

		<span class="cm">/* RFC 4460, 2.11.2</span>
<span class="cm">		 * This will discard packets with INIT chunk bundled as</span>
<span class="cm">		 * subsequent chunks in the packet.  When INIT is first,</span>
<span class="cm">		 * the normal INIT processing will discard the chunk.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_INIT</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

		<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ch_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ch_end</span> <span class="o">&lt;</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">discard:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Insert endpoint into the hash table.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sctp_hash_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">epb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span> <span class="o">=</span> <span class="n">sctp_ep_hashfn</span><span class="p">(</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_ep_hashtable</span><span class="p">[</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span><span class="p">];</span>

	<span class="n">sctp_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
	<span class="n">sctp_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add an endpoint to the hash. Local BH-safe. */</span>
<span class="kt">void</span> <span class="nf">sctp_hash_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">__sctp_hash_endpoint</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Remove endpoint from the hash table.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sctp_unhash_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>

	<span class="n">epb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span> <span class="o">=</span> <span class="n">sctp_ep_hashfn</span><span class="p">(</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_ep_hashtable</span><span class="p">[</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span><span class="p">];</span>

	<span class="n">sctp_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">sctp_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Remove endpoint from the hash.  Local BH-safe. */</span>
<span class="kt">void</span> <span class="nf">sctp_unhash_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">__sctp_unhash_endpoint</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Look up an endpoint. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="nf">__sctp_rcv_lookup_endpoint</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">sctp_ep_hashfn</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_ep_hashtable</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sctp_for_each_hentry</span><span class="p">(</span><span class="n">epb</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_ep</span><span class="p">(</span><span class="n">epb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_endpoint_is_match</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">laddr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">hit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">((</span><span class="n">sctp_get_ctl_sock</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

<span class="nl">hit:</span>
	<span class="n">sctp_endpoint_hold</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Insert association into the hash table.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sctp_hash_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">epb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Calculate which chain this entry will belong to. */</span>
	<span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span> <span class="o">=</span> <span class="n">sctp_assoc_hashfn</span><span class="p">(</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_assoc_hashtable</span><span class="p">[</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span><span class="p">];</span>

	<span class="n">sctp_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
	<span class="n">sctp_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add an association to the hash. Local BH-safe. */</span>
<span class="kt">void</span> <span class="nf">sctp_hash_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">__sctp_hash_established</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Remove association from the hash table.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sctp_unhash_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>

	<span class="n">epb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span> <span class="o">=</span> <span class="n">sctp_assoc_hashfn</span><span class="p">(</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">,</span>
					 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_assoc_hashtable</span><span class="p">[</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">hashent</span><span class="p">];</span>

	<span class="n">sctp_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">sctp_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Remove association from the hash table.  Local BH-safe. */</span>
<span class="kt">void</span> <span class="nf">sctp_unhash_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">__sctp_unhash_established</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Look up an association. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_lookup_association</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">epb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>

	<span class="cm">/* Optimize here for direct hit, only listening connections can</span>
<span class="cm">	 * have wildcards anyways.</span>
<span class="cm">	 */</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">sctp_assoc_hashfn</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_assoc_hashtable</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sctp_for_each_hentry</span><span class="p">(</span><span class="n">epb</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_assoc</span><span class="p">(</span><span class="n">epb</span><span class="p">);</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_assoc_is_match</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">peer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">hit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">hit:</span>
	<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
	<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look up an association. BH-safe. */</span>
<span class="n">SCTP_STATIC</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_lookup_association</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
						 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">sctp_local_bh_disable</span><span class="p">();</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_lookup_association</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">transportp</span><span class="p">);</span>
	<span class="n">sctp_local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is there an association matching the given local and peer addresses? */</span>
<span class="kt">int</span> <span class="nf">sctp_has_association</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_lookup_association</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SCTP Implementors Guide, 2.18 Handling of address</span>
<span class="cm"> * parameters within the INIT or INIT-ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * D) When searching for a matching TCB upon reception of an INIT</span>
<span class="cm"> *    or INIT-ACK chunk the receiver SHOULD use not only the</span>
<span class="cm"> *    source address of the packet (containing the INIT or</span>
<span class="cm"> *    INIT-ACK) but the receiver SHOULD also use all valid</span>
<span class="cm"> *    address parameters contained within the chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.18.3 Solution description</span>
<span class="cm"> *</span>
<span class="cm"> * This new text clearly specifies to an implementor the need</span>
<span class="cm"> * to look within the INIT or INIT-ACK. Any implementation that</span>
<span class="cm"> * does not do this, may not be able to establish associations</span>
<span class="cm"> * in certain circumstances.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_rcv_init_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">params</span><span class="p">;</span>
	<span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This code will NOT touch anything inside the chunk--it is</span>
<span class="cm">	 * strictly READ-ONLY.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RFC 2960 3  SCTP packet Format</span>
<span class="cm">	 *</span>
<span class="cm">	 * Multiple chunks can be bundled into one SCTP packet up to</span>
<span class="cm">	 * the MTU size, except for the INIT, INIT ACK, and SHUTDOWN</span>
<span class="cm">	 * COMPLETE chunks.  These chunks MUST NOT be bundled with any</span>
<span class="cm">	 * other chunk in a packet.  See Section 6.10 for more details</span>
<span class="cm">	 * on chunk bundling.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Find the start of the TLVs and the end of the chunk.  This is</span>
<span class="cm">	 * the region we search for address parameters.</span>
<span class="cm">	 */</span>
	<span class="n">init</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Walk the parameters looking for embedded addresses. */</span>
	<span class="n">sctp_walk_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">init_hdr</span><span class="p">.</span><span class="n">params</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Note: Ignoring hostname addresses. */</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_lookup_association</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ADD-IP, Section 5.2</span>
<span class="cm"> * When an endpoint receives an ASCONF Chunk from the remote peer</span>
<span class="cm"> * special procedures may be needed to identify the association the</span>
<span class="cm"> * ASCONF Chunk is associated with. To properly find the association</span>
<span class="cm"> * the following procedures SHOULD be followed:</span>
<span class="cm"> *</span>
<span class="cm"> * D2) If the association is not found, use the address found in the</span>
<span class="cm"> * Address Parameter TLV combined with the port number found in the</span>
<span class="cm"> * SCTP common header. If found proceed to rule D4.</span>
<span class="cm"> *</span>
<span class="cm"> * D2-ext) If more than one ASCONF Chunks are packed together, use the</span>
<span class="cm"> * address found in the ASCONF Address Parameter TLV of each of the</span>
<span class="cm"> * subsequent ASCONF Chunks. If found, proceed to rule D4.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_rcv_asconf_lookup</span><span class="p">(</span>
					<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
					<span class="n">__be16</span> <span class="n">peer_port</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addip_chunk_t</span> <span class="o">*</span><span class="n">asconf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_addip_chunk</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">param</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="cm">/* Skip over the ADDIP header and find the Address parameter */</span>
	<span class="n">param</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">)(</span><span class="n">asconf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paddr</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">peer_port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__sctp_lookup_association</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paddr</span><span class="p">,</span> <span class="n">transportp</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* SCTP-AUTH, Section 6.3:</span>
<span class="cm">*    If the receiver does not find a STCB for a packet containing an AUTH</span>
<span class="cm">*    chunk as the first chunk and not a COOKIE-ECHO chunk as the second</span>
<span class="cm">*    chunk, it MUST use the chunks after the AUTH chunk to look up an existing</span>
<span class="cm">*    association.</span>
<span class="cm">*</span>
<span class="cm">* This means that any chunks that can help us identify the association need</span>
<span class="cm">* to be looked at to find this association.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_rcv_walk_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_auth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chunk_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">ch_end</span><span class="p">;</span>

	<span class="cm">/* Walk through the chunks looking for AUTH or ASCONF chunks</span>
<span class="cm">	 * to help us find the association.</span>
<span class="cm">	 */</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Break out if chunk length is less then minimal. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ch_end</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span><span class="p">)</span> <span class="o">+</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch_end</span> <span class="o">&gt;</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		    <span class="k">case</span> <span class="n">SCTP_CID_AUTH</span>:
			    <span class="n">have_auth</span> <span class="o">=</span> <span class="n">chunk_num</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>

		    <span class="k">case</span> <span class="n">SCTP_CID_COOKIE_ECHO</span>:
			    <span class="cm">/* If a packet arrives containing an AUTH chunk as</span>
<span class="cm">			     * a first chunk, a COOKIE-ECHO chunk as the second</span>
<span class="cm">			     * chunk, and possibly more chunks after them, and</span>
<span class="cm">			     * the receiver does not have an STCB for that</span>
<span class="cm">			     * packet, then authentication is based on</span>
<span class="cm">			     * the contents of the COOKIE- ECHO chunk.</span>
<span class="cm">			     */</span>
			    <span class="k">if</span> <span class="p">(</span><span class="n">have_auth</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">chunk_num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>

		    <span class="k">case</span> <span class="n">SCTP_CID_ASCONF</span>:
			    <span class="k">if</span> <span class="p">(</span><span class="n">have_auth</span> <span class="o">||</span> <span class="n">sctp_addip_noauth</span><span class="p">)</span>
				    <span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_rcv_asconf_lookup</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span>
							<span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span>
							<span class="n">transportp</span><span class="p">);</span>
		    <span class="nl">default:</span>
			    <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ch_end</span><span class="p">;</span>
		<span class="n">chunk_num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ch_end</span> <span class="o">&lt;</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are circumstances when we need to look inside the SCTP packet</span>
<span class="cm"> * for information to help us find the association.   Examples</span>
<span class="cm"> * include looking inside of INIT/INIT-ACK chunks or after the AUTH</span>
<span class="cm"> * chunks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_rcv_lookup_harder</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* The code below will attempt to walk the chunk and extract</span>
<span class="cm">	 * parameter information.  Before we do that, we need to verify</span>
<span class="cm">	 * that the chunk length doesn&#39;t cause overflow.  Otherwise, we&#39;ll</span>
<span class="cm">	 * walk off the end.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If this is INIT/INIT-ACK look inside the chunk too. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_CID_INIT</span>:
	<span class="k">case</span> <span class="n">SCTP_CID_INIT_ACK</span>:
		<span class="k">return</span> <span class="n">__sctp_rcv_init_lookup</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">transportp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">__sctp_rcv_walk_lookup</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">transportp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lookup an association for an inbound skb. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">__sctp_rcv_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="n">transportp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_lookup_association</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">transportp</span><span class="p">);</span>

	<span class="cm">/* Further lookup for INIT/INIT-ACK packets.</span>
<span class="cm">	 * SCTP Implementors Guide, 2.18 Handling of address</span>
<span class="cm">	 * parameters within the INIT or INIT-ACK.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">asoc</span> <span class="o">=</span> <span class="n">__sctp_rcv_lookup_harder</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">transportp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
