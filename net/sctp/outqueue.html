<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › outqueue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>outqueue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2003 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * These functions implement the sctp_outq class.   The outqueue handles</span>
<span class="cm"> * bundling and queueing of outgoing SCTP chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Perry Melange         &lt;pmelange@null.cc.uic.edu&gt;</span>
<span class="cm"> *    Xingang Guo           &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Hui Huang 	    &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;   </span><span class="cm">/* For struct list_head */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;	  </span><span class="cm">/* For skb_set_owner_w */</span><span class="cp"></span>

<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="cm">/* Declare internal functions here.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_acked</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">tsn</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_check_transmitted</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">transmitted_queue</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">,</span>
				   <span class="n">__u32</span> <span class="o">*</span><span class="n">highest_new_tsn</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_mark_missing</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">transmitted_queue</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			      <span class="n">__u32</span> <span class="n">highest_new_tsn</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">count_of_newacks</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_generate_fwdtsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">sack_ctsn</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_outq_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rtx_timeout</span><span class="p">);</span>

<span class="cm">/* Add data to the front of the queue. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_outq_head_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">out_chunk_list</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">out_qlen</span> <span class="o">+=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Take data from the front of the queue. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_outq_dequeue_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">out_chunk_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">out_chunk_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

		<span class="n">ch</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">out_qlen</span> <span class="o">-=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Add data chunk to the end of the queue. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_outq_tail_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">out_chunk_list</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">out_qlen</span> <span class="o">+=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SFR-CACC algorithm:</span>
<span class="cm"> * D) If count_of_newacks is greater than or equal to 2</span>
<span class="cm"> * and t was not sent to the current primary then the</span>
<span class="cm"> * sender MUST NOT increment missing report count for t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_cacc_skip_3_1_d</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">count_of_newacks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count_of_newacks</span> <span class="o">&gt;=</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">transport</span> <span class="o">!=</span> <span class="n">primary</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SFR-CACC algorithm:</span>
<span class="cm"> * F) If count_of_newacks is less than 2, let d be the</span>
<span class="cm"> * destination to which t was sent. If cacc_saw_newack</span>
<span class="cm"> * is 0 for destination d, then the sender MUST NOT</span>
<span class="cm"> * increment missing report count for t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_cacc_skip_3_1_f</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">count_of_newacks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count_of_newacks</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">transport</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cacc_saw_newack</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SFR-CACC algorithm:</span>
<span class="cm"> * 3.1) If CYCLING_CHANGEOVER is 0, the sender SHOULD</span>
<span class="cm"> * execute steps C, D, F.</span>
<span class="cm"> *</span>
<span class="cm"> * C has been implemented in sctp_outq_sack</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_cacc_skip_3_1</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">count_of_newacks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cycling_changeover</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cacc_skip_3_1_d</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">count_of_newacks</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cacc_skip_3_1_f</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">count_of_newacks</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SFR-CACC algorithm:</span>
<span class="cm"> * 3.2) Else if CYCLING_CHANGEOVER is 1, and t is less</span>
<span class="cm"> * than next_tsn_at_change of the current primary, then</span>
<span class="cm"> * the sender MUST NOT increment missing report count</span>
<span class="cm"> * for t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_cacc_skip_3_2</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cycling_changeover</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TSN_lt</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">next_tsn_at_change</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SFR-CACC algorithm:</span>
<span class="cm"> * 3) If the missing report count for TSN t is to be</span>
<span class="cm"> * incremented according to [RFC2960] and</span>
<span class="cm"> * [SCTP_STEWART-2002], and CHANGEOVER_ACTIVE is set,</span>
<span class="cm"> * then the sender MUST further execute steps 3.1 and</span>
<span class="cm"> * 3.2 to determine if the missing report count for</span>
<span class="cm"> * TSN t SHOULD NOT be incremented.</span>
<span class="cm"> *</span>
<span class="cm"> * 3.3) If 3.1 and 3.2 do not dictate that the missing</span>
<span class="cm"> * report count for t should not be incremented, then</span>
<span class="cm"> * the sender SHOULD increment missing report count for</span>
<span class="cm"> * t (according to [RFC2960] and [SCTP_STEWART_2002]).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_cacc_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">count_of_newacks</span><span class="p">,</span>
				 <span class="n">__u32</span> <span class="n">tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">changeover_active</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sctp_cacc_skip_3_1</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">count_of_newacks</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">sctp_cacc_skip_3_2</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="n">tsn</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize an existing sctp_outq.  This does the boring stuff.</span>
<span class="cm"> * You still need to define handlers if you really want to DO</span>
<span class="cm"> * something with this structure...</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_outq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">asoc</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">out_chunk_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">control_chunk_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">fast_rtx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">outstanding_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cork</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">out_qlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free the outqueue structure and any related pending chunks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_outq_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Throw away unacknowledged chunks. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">lchunk</span> <span class="o">=</span> <span class="n">sctp_list_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
					   <span class="n">transmitted_list</span><span class="p">);</span>
			<span class="cm">/* Mark as part of a failed message. */</span>
			<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Throw away chunks that have been gap ACKed.  */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">lchunk</span><span class="p">);</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
				   <span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Throw away any chunks in the retransmit queue. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">lchunk</span><span class="p">);</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
				   <span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Throw away any chunks that are in the abandoned queue. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">lchunk</span><span class="p">);</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
				   <span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Throw away any leftover data chunks. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_outq_dequeue_data</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Mark as send failure. */</span>
		<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Throw away any leftover control chunks. */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">control_chunk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Free the outqueue structure and any related pending chunks.  */</span>
<span class="kt">void</span> <span class="nf">sctp_outq_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Throw away leftover chunks. */</span>
	<span class="n">sctp_outq_teardown</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="cm">/* If we were kmalloc()&#39;d, free the memory.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">malloced</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Put a new chunk in an sctp_outq.  */</span>
<span class="kt">int</span> <span class="nf">sctp_outq_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_outq_tail(%p, %p[%s])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">q</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span> <span class="o">?</span>
			  <span class="n">sctp_cname</span><span class="p">(</span><span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			  <span class="o">:</span> <span class="s">&quot;Illegal Chunk&quot;</span><span class="p">);</span>

	<span class="cm">/* If it is data, queue it up, otherwise, send it</span>
<span class="cm">	 * immediately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_chunk_is_data</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Is it OK to queue data chunks?  */</span>
		<span class="cm">/* From 9. Termination of Association</span>
<span class="cm">		 *</span>
<span class="cm">		 * When either endpoint performs a shutdown, the</span>
<span class="cm">		 * association on each peer will stop accepting new</span>
<span class="cm">		 * data from its user and only deliver data in queue</span>
<span class="cm">		 * at the time of sending or receiving the SHUTDOWN</span>
<span class="cm">		 * chunk.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_STATE_CLOSED</span>:
		<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span>:
		<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_SENT</span>:
		<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_RECEIVED</span>:
		<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_ACK_SENT</span>:
			<span class="cm">/* Cannot send after transport endpoint shutdown */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;outqueueing (%p, %p[%s])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">q</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">chunk</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span> <span class="o">?</span>
			  <span class="n">sctp_cname</span><span class="p">(</span><span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			  <span class="o">:</span> <span class="s">&quot;Illegal Chunk&quot;</span><span class="p">);</span>

			<span class="n">sctp_outq_tail_data</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_UNORDERED</span><span class="p">)</span>
				<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTUNORDERCHUNKS</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTORDERCHUNKS</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">control_chunk_list</span><span class="p">);</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_flush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Insert a chunk into the sorted list based on the TSNs.  The retransmit list</span>
<span class="cm"> * and the abandoned list are in ascending order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_insert_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">nchunk</span><span class="p">,</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ntsn</span><span class="p">,</span> <span class="n">ltsn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nchunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span> <span class="n">transmitted_list</span><span class="p">);</span>
	<span class="n">ntsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">nchunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lchunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span> <span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">ltsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">lchunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ntsn</span><span class="p">,</span> <span class="n">ltsn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Mark all the eligible packets on a transport for retransmission.  */</span>
<span class="kt">void</span> <span class="nf">sctp_retransmit_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			  <span class="n">__u8</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">*</span><span class="n">ltemp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>

	<span class="cm">/* Walk through the specified transmitted queue.  */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="n">ltemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
				   <span class="n">transmitted_list</span><span class="p">);</span>

		<span class="cm">/* If the chunk is abandoned, move it to abandoned list. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_chunk_abandoned</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="n">lchunk</span><span class="p">);</span>
			<span class="n">sctp_insert_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">,</span> <span class="n">lchunk</span><span class="p">);</span>

			<span class="cm">/* If this chunk has not been previousely acked,</span>
<span class="cm">			 * stop considering it &#39;outstanding&#39;.  Our peer</span>
<span class="cm">			 * will most likely never see it since it will</span>
<span class="cm">			 * not be retransmitted</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">-=</span>
							<span class="n">sctp_data_size</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">outstanding_bytes</span> <span class="o">-=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">+=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we are doing  retransmission due to a timeout or pmtu</span>
<span class="cm">		 * discovery, only the  chunks that are not yet acked should</span>
<span class="cm">		 * be added to the retransmit queue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reason</span> <span class="o">==</span> <span class="n">SCTP_RTXR_FAST_RTX</span>  <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">==</span> <span class="n">SCTP_NEED_FRTX</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCTP_RTXR_FAST_RTX</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* RFC 2960 6.2.1 Processing a Received SACK</span>
<span class="cm">			 *</span>
<span class="cm">			 * C) Any time a DATA chunk is marked for</span>
<span class="cm">			 * retransmission (via either T3-rtx timer expiration</span>
<span class="cm">			 * (Section 6.3.3) or via fast retransmit</span>
<span class="cm">			 * (Section 7.2.4)), add the data size of those</span>
<span class="cm">			 * chunks to the rwnd.</span>
<span class="cm">			 */</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">+=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">outstanding_bytes</span> <span class="o">-=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
				<span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">-=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

			<span class="cm">/* sctpimpguide-05 Section 2.8.2</span>
<span class="cm">			 * M5) If a T3-rtx timer expires, the</span>
<span class="cm">			 * &#39;TSN.Missing.Report&#39; of all affected TSNs is set</span>
<span class="cm">			 * to 0.</span>
<span class="cm">			 */</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_missing_report</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* If a chunk that is being used for RTT measurement</span>
<span class="cm">			 * has to be retransmitted, we cannot use this chunk</span>
<span class="cm">			 * anymore for RTT measurements. Reset rto_pending so</span>
<span class="cm">			 * that a new RTT measurement is started when a new</span>
<span class="cm">			 * data chunk is sent.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rtt_in_progress</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">rtt_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Move the chunk to the retransmit queue. The chunks</span>
<span class="cm">			 * on the retransmit queue are always kept in order.</span>
<span class="cm">			 */</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="n">lchunk</span><span class="p">);</span>
			<span class="n">sctp_insert_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">,</span> <span class="n">lchunk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: transport: %p, reason: %d, &quot;</span>
			  <span class="s">&quot;cwnd: %d, ssthresh: %d, flight_size: %d, &quot;</span>
			  <span class="s">&quot;pba: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			  <span class="n">transport</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span>
			  <span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">,</span>
			  <span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span><span class="p">,</span>
			  <span class="n">transport</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* Mark all the eligible packets on a transport for retransmission and force</span>
<span class="cm"> * one packet out.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
		     <span class="n">sctp_retransmit_reason_t</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_RTXR_T3_RTX</span>:
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T3_RETRANSMITS</span><span class="p">);</span>
		<span class="n">sctp_transport_lower_cwnd</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">SCTP_LOWER_CWND_T3_RTX</span><span class="p">);</span>
		<span class="cm">/* Update the retran path if the T3-rtx timer has expired for</span>
<span class="cm">		 * the current retran path.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span> <span class="o">==</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">)</span>
			<span class="n">sctp_assoc_update_retran_path</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rtx_data_chunks</span> <span class="o">+=</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">unack_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_RTXR_FAST_RTX</span>:
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_FAST_RETRANSMITS</span><span class="p">);</span>
		<span class="n">sctp_transport_lower_cwnd</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">SCTP_LOWER_CWND_FAST_RTX</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">fast_rtx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_RTXR_PMTUD</span>:
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_PMTUD_RETRANSMITS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_RTXR_T1_RTX</span>:
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T1_RETRANSMITS</span><span class="p">);</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_retries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">sctp_retransmit_mark</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>

	<span class="cm">/* PR-SCTP A5) Any time the T3-rtx timer expires, on any destination,</span>
<span class="cm">	 * the sender SHOULD try to advance the &quot;Advanced.Peer.Ack.Point&quot; by</span>
<span class="cm">	 * following the procedures outlined in C1 - C5.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">SCTP_RTXR_T3_RTX</span><span class="p">)</span>
		<span class="n">sctp_generate_fwdtsn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">);</span>

	<span class="cm">/* Flush the queues only on timeout, since fast_rtx is only</span>
<span class="cm">	 * triggered during sack processing and the queue</span>
<span class="cm">	 * will be flushed at the end.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCTP_RTXR_FAST_RTX</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_flush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="cm">/* rtx_timeout */</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transmit DATA chunks on the retransmit queue.  Upon return from</span>
<span class="cm"> * sctp_outq_flush_rtx() the packet &#39;pkt&#39; may contain chunks which</span>
<span class="cm"> * need to be transmitted by the caller.</span>
<span class="cm"> * We assume that pkt-&gt;transport has already been set.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is a normal kernel error return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_outq_flush_rtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">rtx_timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">start_timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
	<span class="n">sctp_xmit_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fast_rtx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lqueue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">;</span>
	<span class="n">fast_rtx</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fast_rtx</span><span class="p">;</span>

	<span class="cm">/* This loop handles time-out retransmissions, fast retransmissions,</span>
<span class="cm">	 * and retransmissions due to opening of whindow.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RFC 2960 6.3.3 Handle T3-rtx Expiration</span>
<span class="cm">	 *</span>
<span class="cm">	 * E3) Determine how many of the earliest (i.e., lowest TSN)</span>
<span class="cm">	 * outstanding DATA chunks for the address for which the</span>
<span class="cm">	 * T3-rtx has expired will fit into a single packet, subject</span>
<span class="cm">	 * to the MTU constraint for the path corresponding to the</span>
<span class="cm">	 * destination transport address to which the retransmission</span>
<span class="cm">	 * is being sent (this may be different from the address for</span>
<span class="cm">	 * which the timer expires [see Section 6.4]). Call this value</span>
<span class="cm">	 * K. Bundle and retransmit those K DATA chunks in a single</span>
<span class="cm">	 * packet to the destination endpoint.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [Just to be painfully clear, if we are retransmitting</span>
<span class="cm">	 * because a timeout just happened, we should send only ONE</span>
<span class="cm">	 * packet of retransmitted data.]</span>
<span class="cm">	 *</span>
<span class="cm">	 * For fast retransmissions we also send only ONE packet.  However,</span>
<span class="cm">	 * if we are just flushing the queue due to open window, we&#39;ll</span>
<span class="cm">	 * try to send as much as possible.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">chunk1</span><span class="p">,</span> <span class="n">lqueue</span><span class="p">,</span> <span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the chunk is abandoned, move it to abandoned list. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_chunk_abandoned</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
			<span class="n">sctp_insert_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Make sure that Gap Acked TSNs are not retransmitted.  A</span>
<span class="cm">		 * simple approach is just to move such TSNs out of the</span>
<span class="cm">		 * way and into a &#39;transmitted&#39; queue and skip to the</span>
<span class="cm">		 * next chunk.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we are doing fast retransmit, ignore non-fast_rtransmit</span>
<span class="cm">		 * chunks</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fast_rtx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="nl">redo:</span>
		<span class="cm">/* Attempt to append this chunk to the packet. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_XMIT_PMTU_FULL</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">has_data</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">has_cookie_echo</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If this packet did not contain DATA then</span>
<span class="cm">				 * retransmission did not happen, so do it</span>
<span class="cm">				 * again.  We&#39;ll ignore the error here since</span>
<span class="cm">				 * control chunks are already freed so there</span>
<span class="cm">				 * is nothing we can do.</span>
<span class="cm">				 */</span>
				<span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Send this packet.  */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

			<span class="cm">/* If we are retransmitting, we should only</span>
<span class="cm">			 * send a single packet.</span>
<span class="cm">			 * Otherwise, try appending this chunk again.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rtx_timeout</span> <span class="o">||</span> <span class="n">fast_rtx</span><span class="p">)</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>

			<span class="cm">/* Bundle next chunk in the next round.  */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_XMIT_RWND_FULL</span>:
			<span class="cm">/* Send this packet. */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

			<span class="cm">/* Stop sending DATA as there is no more room</span>
<span class="cm">			 * at the receiver.</span>
<span class="cm">			 */</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_XMIT_NAGLE_DELAY</span>:
			<span class="cm">/* Send this packet. */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

			<span class="cm">/* Stop sending DATA because of nagle delay. */</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* The append was successful, so add this chunk to</span>
<span class="cm">			 * the transmitted list.</span>
<span class="cm">			 */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">);</span>

			<span class="cm">/* Mark the chunk as ineligible for fast retransmit</span>
<span class="cm">			 * after it is retransmitted.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">==</span> <span class="n">SCTP_NEED_FRTX</span><span class="p">)</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">=</span> <span class="n">SCTP_DONT_FRTX</span><span class="p">;</span>

			<span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set the timer if there were no errors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timer</span><span class="p">)</span>
			<span class="n">timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we are here due to a retransmit timeout or a fast</span>
<span class="cm">	 * retransmit and if there are any chunks left in the retransmit</span>
<span class="cm">	 * queue that could not fit in the PMTU sized packet, they need</span>
<span class="cm">	 * to be marked as ineligible for a subsequent fast retransmit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtx_timeout</span> <span class="o">||</span> <span class="n">fast_rtx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk1</span><span class="p">,</span> <span class="n">lqueue</span><span class="p">,</span> <span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk1</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">==</span> <span class="n">SCTP_NEED_FRTX</span><span class="p">)</span>
				<span class="n">chunk1</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">=</span> <span class="n">SCTP_DONT_FRTX</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">start_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="p">;</span>

	<span class="cm">/* Clear fast retransmit hint */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fast_rtx</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">fast_rtx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cork the outqueue so queued chunks are really queued. */</span>
<span class="kt">int</span> <span class="nf">sctp_outq_uncork</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">cork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_flush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Try to flush an outqueue.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Send everything in q which we legally can, subject to</span>
<span class="cm"> * congestion limitations.</span>
<span class="cm"> * * Note: This function can be called from multiple contexts so appropriate</span>
<span class="cm"> * locking concerns must be made.  Today we use the sock lock to protect</span>
<span class="cm"> * this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_outq_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rtx_timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="n">singleton</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">dport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vtag</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">new_transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">sctp_xmit_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">one_packet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* These transports have chunks to send. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">transport_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ltransport</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport_list</span><span class="p">);</span>
	<span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6.10 Bundling</span>
<span class="cm">	 *   ...</span>
<span class="cm">	 *   When bundling control chunks with DATA chunks, an</span>
<span class="cm">	 *   endpoint MUST place control chunks first in the outbound</span>
<span class="cm">	 *   SCTP packet.  The transmitter MUST transmit DATA chunks</span>
<span class="cm">	 *   within a SCTP packet in increasing order of TSN.</span>
<span class="cm">	 *   ...</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">control_chunk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RFC 5061, 5.3</span>
<span class="cm">		 * F1) This means that until such time as the ASCONF</span>
<span class="cm">		 * containing the add is acknowledged, the sender MUST</span>
<span class="cm">		 * NOT use the new IP address as a source for ANY SCTP</span>
<span class="cm">		 * packet except on carrying an ASCONF Chunk.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span> <span class="o">&amp;&amp;</span>
		    <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_CID_ASCONF</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="cm">/* Pick the right transport to use. */</span>
		<span class="n">new_transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_transport</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we have a prior transport pointer, see if</span>
<span class="cm">			 * the destination address of the chunk</span>
<span class="cm">			 * matches the destination address of the</span>
<span class="cm">			 * current transport.  If not a match, then</span>
<span class="cm">			 * try to look up the transport with a given</span>
<span class="cm">			 * destination address.  We do this because</span>
<span class="cm">			 * after processing ASCONFs, we may have new</span>
<span class="cm">			 * transports created.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">transport</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span>
					<span class="n">new_transport</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">new_transport</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>

			<span class="cm">/* if we still don&#39;t have a new transport, then</span>
<span class="cm">			 * use the current active path.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_transport</span><span class="p">)</span>
				<span class="n">new_transport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">new_transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">new_transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If the chunk is Heartbeat or Heartbeat Ack,</span>
<span class="cm">			 * send it to chunk-&gt;transport, even if it&#39;s</span>
<span class="cm">			 * inactive.</span>
<span class="cm">			 *</span>
<span class="cm">			 * 3.3.6 Heartbeat Acknowledgement:</span>
<span class="cm">			 * ...</span>
<span class="cm">			 * A HEARTBEAT ACK is always sent to the source IP</span>
<span class="cm">			 * address of the IP datagram containing the</span>
<span class="cm">			 * HEARTBEAT chunk to which this ack is responding.</span>
<span class="cm">			 * ...</span>
<span class="cm">			 *</span>
<span class="cm">			 * ASCONF_ACKs also must be sent to the source.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_CID_HEARTBEAT</span> <span class="o">&amp;&amp;</span>
			    <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_CID_HEARTBEAT_ACK</span> <span class="o">&amp;&amp;</span>
			    <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_CID_ASCONF_ACK</span><span class="p">)</span>
				<span class="n">new_transport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Are we switching transports?</span>
<span class="cm">		 * Take care of transport locks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_transport</span> <span class="o">!=</span> <span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">transport</span> <span class="o">=</span> <span class="n">new_transport</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">transport_list</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">;</span>
			<span class="n">sctp_packet_config</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">vtag</span><span class="p">,</span>
					   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 6.10 Bundling</span>
<span class="cm">		 *   ...</span>
<span class="cm">		 *   An endpoint MUST NOT bundle INIT, INIT ACK or SHUTDOWN</span>
<span class="cm">		 *   COMPLETE with any other chunks.  [Send them immediately.]</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">SCTP_CID_INIT</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_INIT_ACK</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_SHUTDOWN_COMPLETE</span>:
			<span class="n">sctp_packet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">singleton</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">sport</span><span class="p">,</span> <span class="n">dport</span><span class="p">);</span>
			<span class="n">sctp_packet_config</span><span class="p">(</span><span class="o">&amp;</span><span class="n">singleton</span><span class="p">,</span> <span class="n">vtag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">singleton</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">singleton</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_CID_ABORT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_test_T_bit</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">packet</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="cm">/* The following chunks are &quot;response&quot; chunks, i.e.</span>
<span class="cm">		 * they are generated in response to something we</span>
<span class="cm">		 * received.  If we are sending these, then we can</span>
<span class="cm">		 * send only 1 packet containing these chunks.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">SCTP_CID_HEARTBEAT_ACK</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_SHUTDOWN_ACK</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_COOKIE_ACK</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_COOKIE_ECHO</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_ERROR</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_ECN_CWR</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_ASCONF_ACK</span>:
			<span class="n">one_packet</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Fall through */</span>

		<span class="k">case</span> <span class="n">SCTP_CID_SACK</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_HEARTBEAT</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_SHUTDOWN</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_ECN_ECNE</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_ASCONF</span>:
		<span class="k">case</span> <span class="n">SCTP_CID_FWD_TSN</span>:
			<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_packet_transmit_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
							    <span class="n">one_packet</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span>  <span class="o">!=</span> <span class="n">SCTP_XMIT_OK</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* put the chunk back */</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">control_chunk_list</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_CID_FWD_TSN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* PR-SCTP C5) If a FORWARD TSN is sent, the</span>
<span class="cm">				 * sender MUST assure that at least one T3-rtx</span>
<span class="cm">				 * timer is running.</span>
<span class="cm">				 */</span>
				<span class="n">sctp_transport_reset_timers</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* We built a chunk with an illegal type! */</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sctp_flush_out</span><span class="p">;</span>

	<span class="cm">/* Is it OK to send data chunks?  */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_STATE_COOKIE_ECHOED</span>:
		<span class="cm">/* Only allow bundling when this packet has a COOKIE-ECHO</span>
<span class="cm">		 * chunk.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span> <span class="o">||</span> <span class="o">!</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">has_cookie_echo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* fallthru */</span>
	<span class="k">case</span> <span class="n">SCTP_STATE_ESTABLISHED</span>:
	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span>:
	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_RECEIVED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * RFC 2960 6.1  Transmission of DATA Chunks</span>
<span class="cm">		 *</span>
<span class="cm">		 * C) When the time comes for the sender to transmit,</span>
<span class="cm">		 * before sending new DATA chunks, the sender MUST</span>
<span class="cm">		 * first transmit any outstanding DATA chunks which</span>
<span class="cm">		 * are marked for retransmission (limited by the</span>
<span class="cm">		 * current cwnd).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">sctp_flush_out</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">transport</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retran</span><span class="p">;</span>

			<span class="cm">/* Switch transports &amp; prepare the packet.  */</span>

			<span class="n">transport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">transport_list</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">;</span>
			<span class="n">sctp_packet_config</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">vtag</span><span class="p">,</span>
					   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span><span class="p">);</span>
		<span class="nl">retran:</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_outq_flush_rtx</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span>
						    <span class="n">rtx_timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_timer</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">start_timer</span><span class="p">)</span>
				<span class="n">sctp_transport_reset_timers</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

			<span class="cm">/* This can happen on COOKIE-ECHO resend.  Only</span>
<span class="cm">			 * one chunk can get bundled with a COOKIE-ECHO.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">has_cookie_echo</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">sctp_flush_out</span><span class="p">;</span>

			<span class="cm">/* Don&#39;t send new data if there is still data</span>
<span class="cm">			 * waiting to retransmit.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">sctp_flush_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Apply Max.Burst limitation to the current transport in</span>
<span class="cm">		 * case it will be used for new data.  We are going to</span>
<span class="cm">		 * rest it before we return, but we want to apply the limit</span>
<span class="cm">		 * to the currently queued data.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span>
			<span class="n">sctp_transport_burst_limited</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

		<span class="cm">/* Finally, transmit new packets.  */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_outq_dequeue_data</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* RFC 2960 6.5 Every DATA chunk MUST carry a valid</span>
<span class="cm">			 * stream identifier.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_stream</span> <span class="o">&gt;=</span>
			    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* Mark as failed send. */</span>
				<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">SCTP_ERROR_INV_STRM</span><span class="p">);</span>
				<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Has this chunk expired? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_chunk_abandoned</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* If there is a specified transport, use it.</span>
<span class="cm">			 * Otherwise, we want to use the active path.</span>
<span class="cm">			 */</span>
			<span class="n">new_transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_transport</span> <span class="o">||</span>
			    <span class="p">((</span><span class="n">new_transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span> <span class="o">||</span>
			     <span class="p">(</span><span class="n">new_transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)))</span>
				<span class="n">new_transport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Change packets if necessary.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_transport</span> <span class="o">!=</span> <span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">transport</span> <span class="o">=</span> <span class="n">new_transport</span><span class="p">;</span>

				<span class="cm">/* Schedule to have this transport&#39;s</span>
<span class="cm">				 * packet flushed.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">transport_list</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">;</span>
				<span class="n">sctp_packet_config</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">vtag</span><span class="p">,</span>
						   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span><span class="p">);</span>
				<span class="cm">/* We&#39;ve switched transports, so apply the</span>
<span class="cm">				 * Burst limit to the new transport.</span>
<span class="cm">				 */</span>
				<span class="n">sctp_transport_burst_limited</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_outq_flush(%p, %p[%s]), &quot;</span><span class="p">,</span>
					  <span class="n">q</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
					  <span class="n">chunk</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span> <span class="o">?</span>
					  <span class="n">sctp_cname</span><span class="p">(</span><span class="n">SCTP_ST_CHUNK</span><span class="p">(</span>
						  <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
					  <span class="o">:</span> <span class="s">&quot;Illegal Chunk&quot;</span><span class="p">);</span>

			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;TX TSN 0x%x skb-&gt;head &quot;</span>
					<span class="s">&quot;%p skb-&gt;users %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">),</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">?</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">?</span>
					<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* Add the chunk to the packet.  */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_packet_transmit_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCTP_XMIT_PMTU_FULL</span>:
			<span class="k">case</span> <span class="n">SCTP_XMIT_RWND_FULL</span>:
			<span class="k">case</span> <span class="n">SCTP_XMIT_NAGLE_DELAY</span>:
				<span class="cm">/* We could not append this chunk, so put</span>
<span class="cm">				 * the chunk back on the output queue.</span>
<span class="cm">				 */</span>
				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_outq_flush: could &quot;</span>
					<span class="s">&quot;not transmit TSN: 0x%x, status: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">),</span>
					<span class="n">status</span><span class="p">);</span>
				<span class="n">sctp_outq_head_data</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">sctp_flush_out</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SCTP_XMIT_OK</span>:
				<span class="cm">/* The sender is in the SHUTDOWN-PENDING state,</span>
<span class="cm">				 * The sender MAY set the I-bit in the DATA</span>
<span class="cm">				 * chunk header.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span><span class="p">)</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCTP_DATA_SACK_IMM</span><span class="p">;</span>

				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="cm">/* BUG: We assume that the sctp_packet_transmit()</span>
<span class="cm">			 * call below will succeed all the time and add the</span>
<span class="cm">			 * chunk to the transmitted list and restart the</span>
<span class="cm">			 * timers.</span>
<span class="cm">			 * It is possible that the call can fail under OOM</span>
<span class="cm">			 * conditions.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Is this really a problem?  Won&#39;t this behave</span>
<span class="cm">			 * like a lost TSN?</span>
<span class="cm">			 */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">);</span>

			<span class="n">sctp_transport_reset_timers</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

			<span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Only let one DATA chunk get bundled with a</span>
<span class="cm">			 * COOKIE-ECHO chunk.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">has_cookie_echo</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">sctp_flush_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Do nothing.  */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">sctp_flush_out:</span>

	<span class="cm">/* Before returning, examine all the transports touched in</span>
<span class="cm">	 * this call.  Right now, we bluntly force clear all the</span>
<span class="cm">	 * transports.  Things might change after we implement Nagle.</span>
<span class="cm">	 * But such an examination is still required.</span>
<span class="cm">	 *</span>
<span class="cm">	 * --xguo</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ltransport</span> <span class="o">=</span> <span class="n">sctp_list_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ltransport</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span>
						      <span class="n">send_ready</span><span class="p">);</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_packet_empty</span><span class="p">(</span><span class="n">packet</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>

		<span class="cm">/* Clear the burst limited state, if any */</span>
		<span class="n">sctp_transport_burst_reset</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update unack_data based on the incoming SACK chunk */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_sack_update_unack_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">assoc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_sack_variable_t</span> <span class="o">*</span><span class="n">frags</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">unack_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">unack_data</span> <span class="o">=</span> <span class="n">assoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">-</span> <span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">frags</span> <span class="o">=</span> <span class="n">sack</span><span class="o">-&gt;</span><span class="n">variable</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">num_gap_ack_blocks</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unack_data</span> <span class="o">-=</span> <span class="p">((</span><span class="n">ntohs</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gab</span><span class="p">.</span><span class="n">end</span><span class="p">)</span> <span class="o">-</span>
				<span class="n">ntohs</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gab</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">assoc</span><span class="o">-&gt;</span><span class="n">unack_data</span> <span class="o">=</span> <span class="n">unack_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is where we REALLY process a SACK.</span>
<span class="cm"> *</span>
<span class="cm"> * Process the SACK against the outqueue.  Mostly, this just frees</span>
<span class="cm"> * things off the transmitted queue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_outq_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">tchunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">*</span><span class="n">transport_list</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="n">sctp_sack_variable_t</span> <span class="o">*</span><span class="n">frags</span> <span class="o">=</span> <span class="n">sack</span><span class="o">-&gt;</span><span class="n">variable</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sack_ctsn</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">tsn</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">highest_tsn</span><span class="p">,</span> <span class="n">highest_new_tsn</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sack_a_rwnd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outstanding</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count_of_newacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gap_ack_blocks</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">accum_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Grab the association&#39;s destination address list. */</span>
	<span class="n">transport_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">;</span>

	<span class="n">sack_ctsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">);</span>
	<span class="n">gap_ack_blocks</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">num_gap_ack_blocks</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * SFR-CACC algorithm:</span>
<span class="cm">	 * On receipt of a SACK the sender SHOULD execute the</span>
<span class="cm">	 * following statements.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) If the cumulative ack in the SACK passes next tsn_at_change</span>
<span class="cm">	 * on the current primary, the CHANGEOVER_ACTIVE flag SHOULD be</span>
<span class="cm">	 * cleared. The CYCLING_CHANGEOVER flag SHOULD also be cleared for</span>
<span class="cm">	 * all destinations.</span>
<span class="cm">	 * 2) If the SACK contains gap acks and the flag CHANGEOVER_ACTIVE</span>
<span class="cm">	 * is set the receiver of the SACK MUST take the following actions:</span>
<span class="cm">	 *</span>
<span class="cm">	 * A) Initialize the cacc_saw_newack to 0 for all destination</span>
<span class="cm">	 * addresses.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only bother if changeover_active is set. Otherwise, this is</span>
<span class="cm">	 * totally suboptimal to do on every SACK.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">changeover_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">clear_cycling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">next_tsn_at_change</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">primary</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">changeover_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">clear_cycling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clear_cycling</span> <span class="o">||</span> <span class="n">gap_ack_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">transport_list</span><span class="p">,</span>
					<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">clear_cycling</span><span class="p">)</span>
					<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cycling_changeover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">gap_ack_blocks</span><span class="p">)</span>
					<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cacc_saw_newack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Get the highest TSN in the sack. */</span>
	<span class="n">highest_tsn</span> <span class="o">=</span> <span class="n">sack_ctsn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gap_ack_blocks</span><span class="p">)</span>
		<span class="n">highest_tsn</span> <span class="o">+=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="n">gap_ack_blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">gab</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">highest_sacked</span><span class="p">,</span> <span class="n">highest_tsn</span><span class="p">))</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">highest_sacked</span> <span class="o">=</span> <span class="n">highest_tsn</span><span class="p">;</span>

	<span class="n">highest_new_tsn</span> <span class="o">=</span> <span class="n">sack_ctsn</span><span class="p">;</span>

	<span class="cm">/* Run through the retransmit queue.  Credit bytes received</span>
<span class="cm">	 * and free those chunks that we can.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_check_transmitted</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">highest_new_tsn</span><span class="p">);</span>

	<span class="cm">/* Run through the transmitted queue.</span>
<span class="cm">	 * Credit bytes received and free those chunks which we can.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a MASSIVE candidate for optimization.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">transport_list</span><span class="p">,</span> <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_check_transmitted</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">,</span>
				       <span class="n">transport</span><span class="p">,</span> <span class="n">sack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">highest_new_tsn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * SFR-CACC algorithm:</span>
<span class="cm">		 * C) Let count_of_newacks be the number of</span>
<span class="cm">		 * destinations for which cacc_saw_newack is set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cacc_saw_newack</span><span class="p">)</span>
			<span class="n">count_of_newacks</span> <span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Move the Cumulative TSN Ack Point if appropriate.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span> <span class="o">=</span> <span class="n">sack_ctsn</span><span class="p">;</span>
		<span class="n">accum_moved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gap_ack_blocks</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span> <span class="o">&amp;&amp;</span> <span class="n">accum_moved</span><span class="p">)</span>
			<span class="n">highest_new_tsn</span> <span class="o">=</span> <span class="n">highest_tsn</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">transport_list</span><span class="p">,</span> <span class="n">transports</span><span class="p">)</span>
			<span class="n">sctp_mark_missing</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span>
					  <span class="n">highest_new_tsn</span><span class="p">,</span> <span class="n">count_of_newacks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Update unack_data field in the assoc. */</span>
	<span class="n">sctp_sack_update_unack_data</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">sack</span><span class="p">);</span>

	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>

	<span class="cm">/* Throw away stuff rotting on the sack queue.  */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tchunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
				    <span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">tchunk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* ii) Set rwnd equal to the newly received a_rwnd minus the</span>
<span class="cm">	 *     number of bytes still outstanding after processing the</span>
<span class="cm">	 *     Cumulative TSN Ack and the Gap Ack Blocks.</span>
<span class="cm">	 */</span>

	<span class="n">sack_a_rwnd</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">);</span>
	<span class="n">outstanding</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">outstanding_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outstanding</span> <span class="o">&lt;</span> <span class="n">sack_a_rwnd</span><span class="p">)</span>
		<span class="n">sack_a_rwnd</span> <span class="o">-=</span> <span class="n">outstanding</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sack_a_rwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">=</span> <span class="n">sack_a_rwnd</span><span class="p">;</span>

	<span class="n">sctp_generate_fwdtsn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: sack Cumulative TSN Ack is 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: Cumulative TSN Ack of association, &quot;</span>
			  <span class="s">&quot;%p is 0x%x. Adv peer ack point: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span><span class="p">);</span>

	<span class="cm">/* See if all chunks are acked.</span>
<span class="cm">	 * Make sure the empty queue handler will get run later.</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">out_chunk_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">retransmit</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">transport_list</span><span class="p">,</span> <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sack queue is empty.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">finish:</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is the outqueue empty?  */</span>
<span class="kt">int</span> <span class="nf">sctp_outq_is_empty</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * 2nd Level Abstractions</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/* Go through a transport&#39;s transmitted list or the association&#39;s retransmit</span>
<span class="cm"> * list and move chunks that are acked by the Cumulative TSN Ack to q-&gt;sacked.</span>
<span class="cm"> * The retransmit list will not have an associated transport.</span>
<span class="cm"> *</span>
<span class="cm"> * I added coherent debug information output.	--xguo</span>
<span class="cm"> *</span>
<span class="cm"> * Instead of printing &#39;sacked&#39; or &#39;kept&#39; for each TSN on the</span>
<span class="cm"> * transmitted_queue, we print a range: SACKED: TSN1-TSN2, TSN3, TSN4-TSN5.</span>
<span class="cm"> * KEPT TSN6-TSN7, etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_check_transmitted</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">transmitted_queue</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">,</span>
				   <span class="n">__u32</span> <span class="o">*</span><span class="n">highest_new_tsn_in_sack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">tchunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tlist</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sack_ctsn</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rtt</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">restart_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">migrate_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* These state variables are for coherent debug output. --xguo */</span>

<span class="cp">#if SCTP_DEBUG</span>
	<span class="n">__u32</span> <span class="n">dbg_ack_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* An ACKed TSN range starts here... */</span>
	<span class="n">__u32</span> <span class="n">dbg_last_ack_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* ...and finishes here.	     */</span>
	<span class="n">__u32</span> <span class="n">dbg_kept_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* An un-ACKed range starts here...  */</span>
	<span class="n">__u32</span> <span class="n">dbg_last_kept_tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* ...and finishes here.	     */</span>

	<span class="cm">/* 0 : The last TSN was ACKed.</span>
<span class="cm">	 * 1 : The last TSN was NOT ACKed (i.e. KEPT).</span>
<span class="cm">	 * -1: We need to initialize.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">dbg_prt_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* SCTP_DEBUG */</span><span class="cp"></span>

	<span class="n">sack_ctsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlist</span><span class="p">);</span>

	<span class="cm">/* The while loop will skip empty transmitted queues. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="p">(</span><span class="n">lchunk</span> <span class="o">=</span> <span class="n">sctp_list_dequeue</span><span class="p">(</span><span class="n">transmitted_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tchunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
				    <span class="n">transmitted_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_chunk_abandoned</span><span class="p">(</span><span class="n">tchunk</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Move the chunk to abandoned list. */</span>
			<span class="n">sctp_insert_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">,</span> <span class="n">lchunk</span><span class="p">);</span>

			<span class="cm">/* If this chunk has not been acked, stop</span>
<span class="cm">			 * considering it as &#39;outstanding&#39;.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
					<span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">-=</span>
							<span class="n">sctp_data_size</span><span class="p">(</span><span class="n">tchunk</span><span class="p">);</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">outstanding_bytes</span> <span class="o">-=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">tchunk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_acked</span><span class="p">(</span><span class="n">sack</span><span class="p">,</span> <span class="n">tsn</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If this queue is the retransmit queue, the</span>
<span class="cm">			 * retransmit timer has already reclaimed</span>
<span class="cm">			 * the outstanding bytes for this chunk, so only</span>
<span class="cm">			 * count bytes associated with a transport.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If this chunk is being used for RTT</span>
<span class="cm">				 * measurement, calculate the RTT and update</span>
<span class="cm">				 * the RTO using this value.</span>
<span class="cm">				 *</span>
<span class="cm">				 * 6.3.1 C5) Karn&#39;s algorithm: RTT measurements</span>
<span class="cm">				 * MUST NOT be made using packets that were</span>
<span class="cm">				 * retransmitted (and thus for which it is</span>
<span class="cm">				 * ambiguous whether the reply was for the</span>
<span class="cm">				 * first instance of the packet or a later</span>
<span class="cm">				 * instance).</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span> <span class="o">&amp;&amp;</span>
				    <span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">rtt_in_progress</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">rtt_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">rtt</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">sent_at</span><span class="p">;</span>
					<span class="n">sctp_transport_update_rto</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span>
								  <span class="n">rtt</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* If the chunk hasn&#39;t been marked as ACKED,</span>
<span class="cm">			 * mark it and account bytes_acked if the</span>
<span class="cm">			 * chunk had a valid transport (it will not</span>
<span class="cm">			 * have a transport if ASCONF had deleted it</span>
<span class="cm">			 * while DATA was outstanding).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="o">*</span><span class="n">highest_new_tsn_in_sack</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
				<span class="n">bytes_acked</span> <span class="o">+=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">tchunk</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
					<span class="n">migrate_bytes</span> <span class="o">+=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">tchunk</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* RFC 2960  6.3.2 Retransmission Timer Rules</span>
<span class="cm">				 *</span>
<span class="cm">				 * R3) Whenever a SACK is received</span>
<span class="cm">				 * that acknowledges the DATA chunk</span>
<span class="cm">				 * with the earliest outstanding TSN</span>
<span class="cm">				 * for that address, restart T3-rtx</span>
<span class="cm">				 * timer for that address with its</span>
<span class="cm">				 * current RTO.</span>
<span class="cm">				 */</span>
				<span class="n">restart_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * SFR-CACC algorithm:</span>
<span class="cm">					 * 2) If the SACK contains gap acks</span>
<span class="cm">					 * and the flag CHANGEOVER_ACTIVE is</span>
<span class="cm">					 * set the receiver of the SACK MUST</span>
<span class="cm">					 * take the following action:</span>
<span class="cm">					 *</span>
<span class="cm">					 * B) For each TSN t being acked that</span>
<span class="cm">					 * has not been acked in any SACK so</span>
<span class="cm">					 * far, set cacc_saw_newack to 1 for</span>
<span class="cm">					 * the destination that the TSN was</span>
<span class="cm">					 * sent to.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">transport</span> <span class="o">&amp;&amp;</span>
					    <span class="n">sack</span><span class="o">-&gt;</span><span class="n">num_gap_ack_blocks</span> <span class="o">&amp;&amp;</span>
					    <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span>
					    <span class="n">changeover_active</span><span class="p">)</span>
						<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cacc_saw_newack</span>
							<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* RFC2960 7.2.4, sctpimpguide-05 2.8.2</span>
<span class="cm">				 * M2) Each time a SACK arrives reporting</span>
<span class="cm">				 * &#39;Stray DATA chunk(s)&#39; record the highest TSN</span>
<span class="cm">				 * reported as newly acknowledged, call this</span>
<span class="cm">				 * value &#39;HighestTSNinSack&#39;. A newly</span>
<span class="cm">				 * acknowledged DATA chunk is one not</span>
<span class="cm">				 * previously acknowledged in a SACK.</span>
<span class="cm">				 *</span>
<span class="cm">				 * When the SCTP sender of data receives a SACK</span>
<span class="cm">				 * chunk that acknowledges, for the first time,</span>
<span class="cm">				 * the receipt of a DATA chunk, all the still</span>
<span class="cm">				 * unacknowledged DATA chunks whose TSN is</span>
<span class="cm">				 * older than that newly acknowledged DATA</span>
<span class="cm">				 * chunk, are qualified as &#39;Stray DATA chunks&#39;.</span>
<span class="cm">				 */</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlist</span><span class="p">);</span>
			<span class="p">}</span>

<span class="cp">#if SCTP_DEBUG</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dbg_prt_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* last TSN was ACKed */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_ack_tsn</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">tsn</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* This TSN belongs to the</span>
<span class="cm">					 * current ACK range.</span>
<span class="cm">					 */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_ack_tsn</span> <span class="o">!=</span> <span class="n">dbg_ack_tsn</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Display the end of the</span>
<span class="cm">					 * current range.</span>
<span class="cm">					 */</span>
					<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;-%08x&quot;</span><span class="p">,</span>
							       <span class="n">dbg_last_ack_tsn</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/* Start a new range.  */</span>
				<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;,%08x&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
				<span class="n">dbg_ack_tsn</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* The last TSN was NOT ACKed. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_kept_tsn</span> <span class="o">!=</span> <span class="n">dbg_kept_tsn</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Display the end of current range. */</span>
					<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;-%08x&quot;</span><span class="p">,</span>
							       <span class="n">dbg_last_kept_tsn</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="cm">/* FALL THROUGH... */</span>
			<span class="nl">default:</span>
				<span class="cm">/* This is the first-ever TSN we examined.  */</span>
				<span class="cm">/* Start a new range of ACK-ed TSNs.  */</span>
				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ACKed: %08x&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
				<span class="n">dbg_prt_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">dbg_ack_tsn</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dbg_last_ack_tsn</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* SCTP_DEBUG */</span><span class="cp"></span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: Receiver reneged on &quot;</span>
						  <span class="s">&quot;data TSN: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">__func__</span><span class="p">,</span>
						  <span class="n">tsn</span><span class="p">);</span>
				<span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tchunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
					<span class="n">bytes_acked</span> <span class="o">-=</span> <span class="n">sctp_data_size</span><span class="p">(</span><span class="n">tchunk</span><span class="p">);</span>

				<span class="cm">/* RFC 2960 6.3.2 Retransmission Timer Rules</span>
<span class="cm">				 *</span>
<span class="cm">				 * R4) Whenever a SACK is received missing a</span>
<span class="cm">				 * TSN that was previously acknowledged via a</span>
<span class="cm">				 * Gap Ack Block, start T3-rtx for the</span>
<span class="cm">				 * destination address to which the DATA</span>
<span class="cm">				 * chunk was originally</span>
<span class="cm">				 * transmitted if it is not already running.</span>
<span class="cm">				 */</span>
				<span class="n">restart_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">list_add_tail</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlist</span><span class="p">);</span>

<span class="cp">#if SCTP_DEBUG</span>
			<span class="cm">/* See the above comments on ACK-ed TSNs. */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dbg_prt_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_kept_tsn</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">tsn</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_kept_tsn</span> <span class="o">!=</span> <span class="n">dbg_kept_tsn</span><span class="p">)</span>
					<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;-%08x&quot;</span><span class="p">,</span>
							       <span class="n">dbg_last_kept_tsn</span><span class="p">);</span>

				<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;,%08x&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
				<span class="n">dbg_kept_tsn</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="mi">0</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_ack_tsn</span> <span class="o">!=</span> <span class="n">dbg_ack_tsn</span><span class="p">)</span>
					<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;-%08x&quot;</span><span class="p">,</span>
							       <span class="n">dbg_last_ack_tsn</span><span class="p">);</span>
				<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="cm">/* FALL THROUGH... */</span>
			<span class="nl">default:</span>
				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;KEPT: %08x&quot;</span><span class="p">,</span><span class="n">tsn</span><span class="p">);</span>
				<span class="n">dbg_prt_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dbg_kept_tsn</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dbg_last_kept_tsn</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* SCTP_DEBUG */</span><span class="cp"></span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if SCTP_DEBUG</span>
	<span class="cm">/* Finish off the last range, displaying its ending TSN.  */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dbg_prt_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_ack_tsn</span> <span class="o">!=</span> <span class="n">dbg_ack_tsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;-%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dbg_last_ack_tsn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dbg_last_kept_tsn</span> <span class="o">!=</span> <span class="n">dbg_kept_tsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;-%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dbg_last_kept_tsn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK_CONT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SCTP_DEBUG */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_acked</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

			<span class="cm">/* We may have counted DATA that was migrated</span>
<span class="cm">			 * to this transport due to DEL-IP operation.</span>
<span class="cm">			 * Subtract those bytes, since the were never</span>
<span class="cm">			 * send on this transport and shouldn&#39;t be</span>
<span class="cm">			 * credited to this transport.</span>
<span class="cm">			 */</span>
			<span class="n">bytes_acked</span> <span class="o">-=</span> <span class="n">migrate_bytes</span><span class="p">;</span>

			<span class="cm">/* 8.2. When an outstanding TSN is acknowledged,</span>
<span class="cm">			 * the endpoint shall clear the error counter of</span>
<span class="cm">			 * the destination transport address to which the</span>
<span class="cm">			 * DATA chunk was last sent.</span>
<span class="cm">			 * The association&#39;s overall error counter is</span>
<span class="cm">			 * also cleared.</span>
<span class="cm">			 */</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * While in SHUTDOWN PENDING, we may have started</span>
<span class="cm">			 * the T5 shutdown guard timer after reaching the</span>
<span class="cm">			 * retransmission limit. Stop that timer as soon</span>
<span class="cm">			 * as the receiver acknowledged any data.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span> <span class="o">&amp;&amp;</span>
			    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span>
				<span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">]))</span>
					<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

			<span class="cm">/* Mark the destination transport address as</span>
<span class="cm">			 * active if it is not so marked.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sctp_assoc_control_transport</span><span class="p">(</span>
					<span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span>
					<span class="n">transport</span><span class="p">,</span>
					<span class="n">SCTP_TRANSPORT_UP</span><span class="p">,</span>
					<span class="n">SCTP_RECEIVED_SACK</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">sctp_transport_raise_cwnd</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">,</span>
						  <span class="n">bytes_acked</span><span class="p">);</span>

			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">-=</span> <span class="n">bytes_acked</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">transport</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">outstanding_bytes</span> <span class="o">-=</span> <span class="n">bytes_acked</span> <span class="o">+</span> <span class="n">migrate_bytes</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* RFC 2960 6.1, sctpimpguide-06 2.15.2</span>
<span class="cm">			 * When a sender is doing zero window probing, it</span>
<span class="cm">			 * should not timeout the association if it continues</span>
<span class="cm">			 * to receive new packets from the receiver. The</span>
<span class="cm">			 * reason is that the receiver MAY keep its window</span>
<span class="cm">			 * closed for an indefinite time.</span>
<span class="cm">			 * A sender is doing zero window probing when the</span>
<span class="cm">			 * receiver&#39;s advertised window is zero, and there is</span>
<span class="cm">			 * only one data chunk in flight to the receiver.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Allow the association to timeout while in SHUTDOWN</span>
<span class="cm">			 * PENDING or SHUTDOWN RECEIVED in case the receiver</span>
<span class="cm">			 * stays in zero window mode forever.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlist</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">sack_ctsn</span><span class="o">+</span><span class="mi">2</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: SACK received for zero &quot;</span>
						  <span class="s">&quot;window probe: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">__func__</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">);</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">transport</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* RFC 2960 6.3.2 Retransmission Timer Rules</span>
<span class="cm">		 *</span>
<span class="cm">		 * R2) Whenever all outstanding data sent to an address have</span>
<span class="cm">		 * been acknowledged, turn off the T3-rtx timer of that</span>
<span class="cm">		 * address.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">restart_timer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">,</span>
				       <span class="n">jiffies</span> <span class="o">+</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">))</span>
				<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlist</span><span class="p">,</span> <span class="n">transmitted_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Mark chunks as missing and consequently may get retransmitted. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_mark_missing</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">transmitted_queue</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			      <span class="n">__u32</span> <span class="n">highest_new_tsn_in_sack</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">count_of_newacks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">do_fast_retransmit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">transmitted_queue</span><span class="p">,</span> <span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>

		<span class="cm">/* RFC 2960 7.2.4, sctpimpguide-05 2.8.2 M3) Examine all</span>
<span class="cm">		 * &#39;Unacknowledged TSN&#39;s&#39;, if the TSN number of an</span>
<span class="cm">		 * &#39;Unacknowledged TSN&#39; is smaller than the &#39;HighestTSNinSack&#39;</span>
<span class="cm">		 * value, increment the &#39;TSN.Missing.Report&#39; count on that</span>
<span class="cm">		 * chunk if it has NOT been fast retransmitted or marked for</span>
<span class="cm">		 * fast retransmit already.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">==</span> <span class="n">SCTP_CAN_FRTX</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span> <span class="o">&amp;&amp;</span>
		    <span class="n">TSN_lt</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">highest_new_tsn_in_sack</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* SFR-CACC may require us to skip marking</span>
<span class="cm">			 * this chunk as missing.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span> <span class="o">||</span> <span class="o">!</span><span class="n">sctp_cacc_skip</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span>
						<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">,</span>
						<span class="n">count_of_newacks</span><span class="p">,</span> <span class="n">tsn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_missing_report</span><span class="o">++</span><span class="p">;</span>

				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span>
					<span class="s">&quot;%s: TSN 0x%x missing counter: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">tsn</span><span class="p">,</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_missing_report</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * M4) If any DATA chunk is found to have a</span>
<span class="cm">		 * &#39;TSN.Missing.Report&#39;</span>
<span class="cm">		 * value larger than or equal to 3, mark that chunk for</span>
<span class="cm">		 * retransmission and start the fast retransmit procedure.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">tsn_missing_report</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">=</span> <span class="n">SCTP_NEED_FRTX</span><span class="p">;</span>
			<span class="n">do_fast_retransmit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_fast_retransmit</span><span class="p">)</span>
			<span class="n">sctp_retransmit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">SCTP_RTXR_FAST_RTX</span><span class="p">);</span>

		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: transport: %p, cwnd: %d, &quot;</span>
				  <span class="s">&quot;ssthresh: %d, flight_size: %d, pba: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">,</span>
				  <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span><span class="p">,</span>
				  <span class="n">transport</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Is the given TSN acked by this packet?  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_acked</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">sctp_sack_variable_t</span> <span class="o">*</span><span class="n">frags</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">gap</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">pass</span><span class="p">;</span>

	<span class="cm">/* 3.3.4 Selective Acknowledgement (SACK) (3):</span>
<span class="cm">	 *</span>
<span class="cm">	 * Gap Ack Blocks:</span>
<span class="cm">	 *  These fields contain the Gap Ack Blocks. They are repeated</span>
<span class="cm">	 *  for each Gap Ack Block up to the number of Gap Ack Blocks</span>
<span class="cm">	 *  defined in the Number of Gap Ack Blocks field. All DATA</span>
<span class="cm">	 *  chunks with TSNs greater than or equal to (Cumulative TSN</span>
<span class="cm">	 *  Ack + Gap Ack Block Start) and less than or equal to</span>
<span class="cm">	 *  (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack</span>
<span class="cm">	 *  Block are assumed to have been received correctly.</span>
<span class="cm">	 */</span>

	<span class="n">frags</span> <span class="o">=</span> <span class="n">sack</span><span class="o">-&gt;</span><span class="n">variable</span><span class="p">;</span>
	<span class="n">gap</span> <span class="o">=</span> <span class="n">tsn</span> <span class="o">-</span> <span class="n">ctsn</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">num_gap_ack_blocks</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gab</span><span class="p">.</span><span class="n">start</span><span class="p">),</span> <span class="n">gap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">TSN_lte</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gab</span><span class="p">.</span><span class="n">end</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">pass</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">pass:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_get_skip_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="o">*</span><span class="n">skiplist</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">nskips</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nskips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skiplist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stream</span> <span class="o">==</span> <span class="n">stream</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create and add a fwdtsn chunk to the outq&#39;s control queue if needed. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_generate_fwdtsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">ctsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ftsn_chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="n">ftsn_skip_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nskips</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* PR-SCTP C1) Let SackCumAck be the Cumulative TSN ACK carried in the</span>
<span class="cm">	 * received SACK.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If (Advanced.Peer.Ack.Point &lt; SackCumAck), then update</span>
<span class="cm">	 * Advanced.Peer.Ack.Point to be equal to SackCumAck.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">))</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">=</span> <span class="n">ctsn</span><span class="p">;</span>

	<span class="cm">/* PR-SCTP C2) Try to further advance the &quot;Advanced.Peer.Ack.Point&quot;</span>
<span class="cm">	 * locally, that is, to move &quot;Advanced.Peer.Ack.Point&quot; up as long as</span>
<span class="cm">	 * the chunk next in the out-queue space is marked as &quot;abandoned&quot; as</span>
<span class="cm">	 * shown in the following example:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assuming that a SACK arrived with the Cumulative TSN ACK 102</span>
<span class="cm">	 * and the Advanced.Peer.Ack.Point is updated to this value:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   out-queue at the end of  ==&gt;   out-queue after Adv.Ack.Point</span>
<span class="cm">	 *   normal SACK processing           local advancement</span>
<span class="cm">	 *                ...                           ...</span>
<span class="cm">	 *   Adv.Ack.Pt-&gt; 102 acked                     102 acked</span>
<span class="cm">	 *                103 abandoned                 103 abandoned</span>
<span class="cm">	 *                104 abandoned     Adv.Ack.P-&gt; 104 abandoned</span>
<span class="cm">	 *                105                           105</span>
<span class="cm">	 *                106 acked                     106 acked</span>
<span class="cm">	 *                ...                           ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this example, the data sender successfully advanced the</span>
<span class="cm">	 * &quot;Advanced.Peer.Ack.Point&quot; from 102 to 104 locally.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">,</span>
					<span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>

		<span class="cm">/* Remove any chunks in the abandoned queue that are acked by</span>
<span class="cm">		 * the ctsn.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="n">lchunk</span><span class="p">);</span>
			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">tsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">=</span> <span class="n">tsn</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
					 <span class="n">SCTP_DATA_UNORDERED</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">skip_pos</span> <span class="o">=</span> <span class="n">sctp_get_skip_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftsn_skip_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">nskips</span><span class="p">,</span>
						<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">);</span>
				<span class="n">ftsn_skip_arr</span><span class="p">[</span><span class="n">skip_pos</span><span class="p">].</span><span class="n">stream</span> <span class="o">=</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
				<span class="n">ftsn_skip_arr</span><span class="p">[</span><span class="n">skip_pos</span><span class="p">].</span><span class="n">ssn</span> <span class="o">=</span>
					 <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skip_pos</span> <span class="o">==</span> <span class="n">nskips</span><span class="p">)</span>
					<span class="n">nskips</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nskips</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* PR-SCTP C3) If, after step C1 and C2, the &quot;Advanced.Peer.Ack.Point&quot;</span>
<span class="cm">	 * is greater than the Cumulative TSN ACK carried in the received</span>
<span class="cm">	 * SACK, the data sender MUST send the data receiver a FORWARD TSN</span>
<span class="cm">	 * chunk containing the latest value of the</span>
<span class="cm">	 * &quot;Advanced.Peer.Ack.Point&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * C4) For each &quot;abandoned&quot; TSN the sender of the FORWARD TSN SHOULD</span>
<span class="cm">	 * list each stream and sequence number in the forwarded TSN. This</span>
<span class="cm">	 * information will enable the receiver to easily find any</span>
<span class="cm">	 * stranded TSN&#39;s waiting on stream reorder queues. Each stream</span>
<span class="cm">	 * SHOULD only be reported once; this means that if multiple</span>
<span class="cm">	 * abandoned messages occur in the same stream then only the</span>
<span class="cm">	 * highest abandoned stream sequence number is reported. If the</span>
<span class="cm">	 * total size of the FORWARD TSN does NOT fit in a single MTU then</span>
<span class="cm">	 * the sender of the FORWARD TSN SHOULD lower the</span>
<span class="cm">	 * Advanced.Peer.Ack.Point to the last TSN that will fit in a</span>
<span class="cm">	 * single MTU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">&gt;</span> <span class="n">ctsn</span><span class="p">)</span>
		<span class="n">ftsn_chunk</span> <span class="o">=</span> <span class="n">sctp_make_fwdtsn</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span><span class="p">,</span>
					      <span class="n">nskips</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ftsn_skip_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftsn_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftsn_chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">control_chunk_list</span><span class="p">);</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
