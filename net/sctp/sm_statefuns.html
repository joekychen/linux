<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › sm_statefuns.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sm_statefuns.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2002 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2002      Nokia Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This is part of the SCTP Linux Kernel Implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * These are the state functions for the state machine.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Mathew Kotowsky       &lt;kotowsky@sctp.org&gt;</span>
<span class="cm"> *    Sridhar Samudrala     &lt;samudrala@us.ibm.com&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Hui Huang 	    &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Dajiang Zhang 	    &lt;dajiang.zhang@nokia.com&gt;</span>
<span class="cm"> *    Daisy Chang	    &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *    Ryan Layer	    &lt;rmlayer@us.ibm.com&gt;</span>
<span class="cm"> *    Kevin Gao		    &lt;kevin.gao@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/inet_ecn.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>
<span class="cp">#include &lt;net/sctp/structs.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">sctp_abort_pkt_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_eat_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
			 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">sctp_ootb_pkt_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_send_stale_cookie_err</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">);</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_do_5_2_6_stale</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
						 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
						 <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
						 <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
						 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_shut_8_4_5</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sctp_sm_pull_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_stop_t1_and_abort</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
					   <span class="n">__be16</span> <span class="n">error</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sk_err</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_abort_violation</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_violation_paramlen</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ext</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_violation_ctsn</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">sctp_sf_violation_chunk</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_ierror_t</span> <span class="n">sctp_sf_authenticate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="n">__sctp_sf_do_9_1_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">);</span>

<span class="cm">/* Small helper function that checks if the chunk length</span>
<span class="cm"> * is of the appropriate length.  The &#39;required_length&#39; argument</span>
<span class="cm"> * is set to be the size of a specific chunk we are testing.</span>
<span class="cm"> * Return Values:  1 = Valid length</span>
<span class="cm"> * 		   0 = Invalid length</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">sctp_chunk_length_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
			   <span class="n">__u16</span> <span class="n">required_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">chunk_length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">chunk_length</span> <span class="o">&lt;</span> <span class="n">required_length</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**********************************************************</span>
<span class="cm"> * These are the state functions for handling chunk events.</span>
<span class="cm"> **********************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Process the final SHUTDOWN COMPLETE.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 (C) (diagram), 9.2</span>
<span class="cm"> * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify</span>
<span class="cm"> * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be</span>
<span class="cm"> * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint</span>
<span class="cm"> * should stop the T2-shutdown timer and remove all knowledge of the</span>
<span class="cm"> * association (and thus the association enters the CLOSED state).</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: 8.5.1(C), sctpimpguide 2.41.</span>
<span class="cm"> * C) Rules for packet carrying SHUTDOWN COMPLETE:</span>
<span class="cm"> * ...</span>
<span class="cm"> * - The receiver of a SHUTDOWN COMPLETE shall accept the packet</span>
<span class="cm"> *   if the Verification Tag field of the packet matches its own tag and</span>
<span class="cm"> *   the T bit is not set</span>
<span class="cm"> *   OR</span>
<span class="cm"> *   it is set to its peer&#39;s tag and the T bit is set in the Chunk</span>
<span class="cm"> *   Flags.</span>
<span class="cm"> *   Otherwise, the receiver MUST silently discard the packet</span>
<span class="cm"> *   and take no further action.  An endpoint MUST ignore the</span>
<span class="cm"> *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_4_C</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				  <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify_either</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.10 Bundling</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint MUST NOT bundle INIT, INIT ACK or</span>
<span class="cm">	 * SHUTDOWN COMPLETE with any other chunks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">singleton</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 10.2 SCTP-to-ULP</span>
<span class="cm">	 *</span>
<span class="cm">	 * H) SHUTDOWN COMPLETE notification</span>
<span class="cm">	 *</span>
<span class="cm">	 * When SCTP completes the shutdown procedures (section 9.2) this</span>
<span class="cm">	 * notification is passed to the upper layer.</span>
<span class="cm">	 */</span>
	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_SHUTDOWN_COMP</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>

	<span class="cm">/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint</span>
<span class="cm">	 * will verify that it is in SHUTDOWN-ACK-SENT state, if it is</span>
<span class="cm">	 * not the chunk should be discarded. If the endpoint is in</span>
<span class="cm">	 * the SHUTDOWN-ACK-SENT state the endpoint should stop the</span>
<span class="cm">	 * T2-shutdown timer and remove all knowledge of the</span>
<span class="cm">	 * association (and thus the association enters the CLOSED</span>
<span class="cm">	 * state).</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_SHUTDOWNS</span><span class="p">);</span>
	<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Respond to a normal INIT chunk.</span>
<span class="cm"> * We are the side that is being asked for an association.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.1 Normal Establishment of an Association, B</span>
<span class="cm"> * B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  The</span>
<span class="cm"> *    destination IP address of the INIT ACK MUST be set to the source</span>
<span class="cm"> *    IP address of the INIT to which this INIT ACK is responding.  In</span>
<span class="cm"> *    the response, besides filling in other parameters, &quot;Z&quot; must set the</span>
<span class="cm"> *    Verification Tag field to Tag_A, and also provide its own</span>
<span class="cm"> *    Verification Tag (Tag_Z) in the Initiate Tag field.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: Must be 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_1B_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="n">sctp_unrecognized_param_t</span> <span class="o">*</span><span class="n">unk_param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* 6.10 Bundling</span>
<span class="cm">	 * An endpoint MUST NOT bundle INIT, INIT ACK or</span>
<span class="cm">	 * SHUTDOWN COMPLETE with any other chunks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * IG Section 2.11.2</span>
<span class="cm">	 * Furthermore, we require that the receiver of an INIT chunk MUST</span>
<span class="cm">	 * enforce these rules by silently discarding an arriving packet</span>
<span class="cm">	 * with an INIT chunk that is bundled with other chunks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">singleton</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* If the packet is an OOTB packet which is temporarily on the</span>
<span class="cm">	 * control endpoint, respond with an ABORT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">sctp_sk</span><span class="p">((</span><span class="n">sctp_get_ctl_sock</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTOFBLUES</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 3.1 A packet containing an INIT chunk MUST have a zero Verification</span>
<span class="cm">	 * Tag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the INIT chunk has a valid length.</span>
<span class="cm">	 * Normally, this would cause an ABORT with a Protocol Violation</span>
<span class="cm">	 * error, but since we don&#39;t have an association, we&#39;ll</span>
<span class="cm">	 * just discard the packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_init_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* If the INIT is coming toward a closing socket, we&#39;ll send back</span>
<span class="cm">	 * and ABORT.  Essentially, this catches the race of INIT being</span>
<span class="cm">	 * backloged to the socket at the same time as the user isses close().</span>
<span class="cm">	 * Since the socket and all its associations are going away, we</span>
<span class="cm">	 * can treat this OOTB</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">,</span> <span class="n">CLOSING</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Verify the INIT chunk before processing it. */</span>
	<span class="n">err_chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_verify_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">err_chunk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This chunk contains fatal error. It is to be discarded.</span>
<span class="cm">		 * Send an ABORT, with causes if there is any.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_abort_pkt_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
					<span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">),</span>
					<span class="n">ntohs</span><span class="p">(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>

			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
						<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
				<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						    <span class="n">commands</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Grab the INIT header.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">init_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_inithdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Tag the variable length parameters.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_inithdr_t</span><span class="p">));</span>

	<span class="n">new_asoc</span> <span class="o">=</span> <span class="n">sctp_make_temp_asoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_asoc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_assoc_set_bind_addr_from_ep</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span>
					     <span class="n">sctp_scope</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">)),</span>
					     <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_init</span><span class="p">;</span>

	<span class="cm">/* The call, sctp_process_init(), can fail on memory allocation.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_init</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span>
			       <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span>
			       <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem_init</span><span class="p">;</span>

	<span class="cm">/* B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  */</span>

	<span class="cm">/* If there are errors need to be reported for unknown parameters,</span>
<span class="cm">	 * make sure to reserve enough room in the INIT ACK for them.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">);</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_init_ack</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_init</span><span class="p">;</span>

	<span class="cm">/* If there are errors need to be reported for unknown parameters,</span>
<span class="cm">	 * include them in the outgoing INIT ACK as &quot;Unrecognized parameter&quot;</span>
<span class="cm">	 * parameter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the &quot;Unrecognized parameter&quot; parameter(s) out of the</span>
<span class="cm">		 * ERROR chunk generated by sctp_verify_init(). Since the</span>
<span class="cm">		 * error cause code for &quot;unknown parameter&quot; and the</span>
<span class="cm">		 * &quot;Unrecognized parameter&quot; type is the same, we can</span>
<span class="cm">		 * construct the parameters in INIT ACK by copying the</span>
<span class="cm">		 * ERROR causes over.</span>
<span class="cm">		 */</span>
		<span class="n">unk_param</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_unrecognized_param_t</span> <span class="o">*</span><span class="p">)</span>
			    <span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="o">+</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>
		<span class="cm">/* Replace the cause code with the &quot;Unrecognized parameter&quot;</span>
<span class="cm">		 * parameter type.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">unk_param</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_ASOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note:  After sending out INIT ACK with the State Cookie parameter,</span>
<span class="cm">	 * &quot;Z&quot; MUST NOT allocate any resources, nor keep any states for the</span>
<span class="cm">	 * new association.  Otherwise, &quot;Z&quot; will be vulnerable to resource</span>
<span class="cm">	 * attacks.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>

<span class="nl">nomem_init:</span>
	<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Respond to a normal INIT ACK chunk.</span>
<span class="cm"> * We are the side that is initiating the association.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.1 Normal Establishment of an Association, C</span>
<span class="cm"> * C) Upon reception of the INIT ACK from &quot;Z&quot;, &quot;A&quot; shall stop the T1-init</span>
<span class="cm"> *    timer and leave COOKIE-WAIT state. &quot;A&quot; shall then send the State</span>
<span class="cm"> *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start</span>
<span class="cm"> *    the T1-cookie timer, and enter the COOKIE-ECHOED state.</span>
<span class="cm"> *</span>
<span class="cm"> *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound</span>
<span class="cm"> *    DATA chunks, but it MUST be the first chunk in the packet and</span>
<span class="cm"> *    until the COOKIE ACK is returned the sender MUST NOT send any</span>
<span class="cm"> *    other packets to the peer.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: 3.3.3</span>
<span class="cm"> *   If the value of the Initiate Tag in a received INIT ACK chunk is</span>
<span class="cm"> *   found to be 0, the receiver MUST treat it as an error and close the</span>
<span class="cm"> *   association by transmitting an ABORT.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_1C_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">initchunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* 6.10 Bundling</span>
<span class="cm">	 * An endpoint MUST NOT bundle INIT, INIT ACK or</span>
<span class="cm">	 * SHUTDOWN COMPLETE with any other chunks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">singleton</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the INIT-ACK chunk has a valid length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_initack_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>
	<span class="cm">/* Grab the INIT header.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">init_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_inithdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Verify the INIT chunk before processing it. */</span>
	<span class="n">err_chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_verify_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">err_chunk</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">sctp_error_t</span> <span class="n">error</span> <span class="o">=</span> <span class="n">SCTP_ERROR_NO_RESOURCE</span><span class="p">;</span>

		<span class="cm">/* This chunk contains fatal error. It is to be discarded.</span>
<span class="cm">		 * Send an ABORT, with causes.  If there are no causes,</span>
<span class="cm">		 * then there wasn&#39;t enough memory.  Just terminate</span>
<span class="cm">		 * the association.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_abort_pkt_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
					<span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">),</span>
					<span class="n">ntohs</span><span class="p">(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>

			<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
						<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
				<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">SCTP_ERROR_INV_PARAM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* SCTP-AUTH, Section 6.3:</span>
<span class="cm">		 *    It should be noted that if the receiver wants to tear</span>
<span class="cm">		 *    down an association in an authenticated way only, the</span>
<span class="cm">		 *    handling of malformed packets should not result in</span>
<span class="cm">		 *    tearing down the association.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This means that if we only want to abort associations</span>
<span class="cm">		 * in an authenticated way (i.e AUTH+ABORT), then we</span>
<span class="cm">		 * can&#39;t destroy this association just because the packet</span>
<span class="cm">		 * was malformed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_recv_cid</span><span class="p">(</span><span class="n">SCTP_CID_ABORT</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sctp_stop_t1_and_abort</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">ECONNREFUSED</span><span class="p">,</span>
						<span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Tag the variable length parameters.  Note that we never</span>
<span class="cm">	 * convert the parameters in an INIT chunk.</span>
<span class="cm">	 */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_inithdr_t</span><span class="p">));</span>

	<span class="n">initchunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PEER_INIT</span><span class="p">,</span>
			<span class="n">SCTP_PEER_INIT</span><span class="p">(</span><span class="n">initchunk</span><span class="p">));</span>

	<span class="cm">/* Reset init error count upon receipt of INIT-ACK.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_COUNTER_RESET</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* 5.1 C) &quot;A&quot; shall stop the T1-init timer and leave</span>
<span class="cm">	 * COOKIE-WAIT state.  &quot;A&quot; shall then ... start the T1-cookie</span>
<span class="cm">	 * timer, and enter the COOKIE-ECHOED state.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_COOKIE_ECHOED</span><span class="p">));</span>

	<span class="cm">/* SCTP-AUTH: genereate the assocition shared keys so that</span>
<span class="cm">	 * we can potentially signe the COOKIE-ECHO.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_SHKEY</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* 5.1 C) &quot;A&quot; shall then send the State Cookie received in the</span>
<span class="cm">	 * INIT ACK chunk in a COOKIE ECHO chunk, ...</span>
<span class="cm">	 */</span>
	<span class="cm">/* If there is any errors to report, send the ERROR chunk generated</span>
<span class="cm">	 * for unknown parameters as well.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_COOKIE_ECHO</span><span class="p">,</span>
			<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Respond to a normal COOKIE ECHO chunk.</span>
<span class="cm"> * We are the side that is being asked for an association.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.1 Normal Establishment of an Association, D</span>
<span class="cm"> * D) Upon reception of the COOKIE ECHO chunk, Endpoint &quot;Z&quot; will reply</span>
<span class="cm"> *    with a COOKIE ACK chunk after building a TCB and moving to</span>
<span class="cm"> *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with</span>
<span class="cm"> *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK</span>
<span class="cm"> *    chunk MUST be the first chunk in the packet.</span>
<span class="cm"> *</span>
<span class="cm"> *   IMPLEMENTATION NOTE: An implementation may choose to send the</span>
<span class="cm"> *   Communication Up notification to the SCTP user upon reception</span>
<span class="cm"> *   of a valid COOKIE ECHO chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules</span>
<span class="cm"> * D) Rules for packet carrying a COOKIE ECHO</span>
<span class="cm"> *</span>
<span class="cm"> * - When sending a COOKIE ECHO, the endpoint MUST use the value of the</span>
<span class="cm"> *   Initial Tag received in the INIT ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * - The receiver of a COOKIE ECHO follows the procedures in Section 5.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_1D_ce</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				      <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">;</span>
	<span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="o">*</span><span class="n">ai_ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chk_p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* If the packet is an OOTB packet which is temporarily on the</span>
<span class="cm">	 * control endpoint, respond with an ABORT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">sctp_sk</span><span class="p">((</span><span class="n">sctp_get_ctl_sock</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTOFBLUES</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure that the COOKIE_ECHO chunk has a valid length.</span>
<span class="cm">	 * In this case, we check that we have enough for at least a</span>
<span class="cm">	 * chunk header.  More detailed verification is done</span>
<span class="cm">	 * in sctp_unpack_cookie().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* If the endpoint is not listening or if the number of associations</span>
<span class="cm">	 * on the TCP-style socket exceed the max backlog, respond with an</span>
<span class="cm">	 * ABORT.</span>
<span class="cm">	 */</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sk_acceptq_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* &quot;Decode&quot; the chunk.  We have no optional parameters so we</span>
<span class="cm">	 * are in good shape.</span>
<span class="cm">	 */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint</span>
<span class="cm">	 * &quot;Z&quot; will reply with a COOKIE ACK chunk after building a TCB</span>
<span class="cm">	 * and moving to the ESTABLISHED state.</span>
<span class="cm">	 */</span>
	<span class="n">new_asoc</span> <span class="o">=</span> <span class="n">sctp_unpack_cookie</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">err_chk_p</span><span class="p">);</span>

	<span class="cm">/* FIXME:</span>
<span class="cm">	 * If the re-build failed, what is the proper error path</span>
<span class="cm">	 * from here?</span>
<span class="cm">	 *</span>
<span class="cm">	 * [We should abort the association. --piggy]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Several errors are possible.  A bad cookie should</span>
<span class="cm">		 * be silently discarded, but think about logging it too.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span>:
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">SCTP_IERROR_STALE_COOKIE</span>:
			<span class="n">sctp_send_stale_cookie_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
						   <span class="n">err_chk_p</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">SCTP_IERROR_BAD_SIG</span>:
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/* Delay state machine commands until later.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Re-build the bind address for the association is done in</span>
<span class="cm">	 * the sctp_unpack_cookie() already.</span>
<span class="cm">	 */</span>
	<span class="cm">/* This is a brand-new association, so these are not yet side</span>
<span class="cm">	 * effects--it is safe to run them here.</span>
<span class="cm">	 */</span>
	<span class="n">peer_init</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_init</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_addr</span><span class="p">,</span>
			       <span class="n">peer_init</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem_init</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH:  Now that we&#39;ve populate required fields in</span>
<span class="cm">	 * sctp_process_init, set up the assocaition shared keys as</span>
<span class="cm">	 * necessary so that we can potentially authenticate the ACK</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_auth_asoc_init_active_key</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_init</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo</span>
<span class="cm">	 * is supposed to be authenticated and we have to do delayed</span>
<span class="cm">	 * authentication.  We&#39;ve just recreated the association using</span>
<span class="cm">	 * the information in the cookie and now it&#39;s much easier to</span>
<span class="cm">	 * do the authentication.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="n">auth</span><span class="p">;</span>
		<span class="n">sctp_ierror_t</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* set-up our fake chunk so that we can process it */</span>
		<span class="n">auth</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth_chunk</span><span class="p">;</span>
		<span class="n">auth</span><span class="p">.</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
		<span class="n">auth</span><span class="p">.</span><span class="n">sctp_hdr</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="p">;</span>
		<span class="n">auth</span><span class="p">.</span><span class="n">chunk_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_push</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth_chunk</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth_chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>
		<span class="n">auth</span><span class="p">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">sctp_sf_authenticate</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">new_asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">auth</span><span class="p">);</span>

		<span class="cm">/* We can now safely free the auth_chunk clone */</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth_chunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SCTP_IERROR_NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_cookie_ack</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_init</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm">	 *</span>
<span class="cm">	 * D) IMPLEMENTATION NOTE: An implementation may choose to</span>
<span class="cm">	 * send the Communication Up notification to the SCTP user</span>
<span class="cm">	 * upon reception of a valid COOKIE ECHO chunk.</span>
<span class="cm">	 */</span>
	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_COMM_UP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">,</span>
					     <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_ev</span><span class="p">;</span>

	<span class="cm">/* Sockets API Draft Section 5.3.1.6</span>
<span class="cm">	 * When a peer sends a Adaptation Layer Indication parameter , SCTP</span>
<span class="cm">	 * delivers this notification to inform the application that of the</span>
<span class="cm">	 * peers requested adaptation layer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ai_ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_adaptation_indication</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span>
							    <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ai_ev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem_aiev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add all the state machine commands now since we&#39;ve created</span>
<span class="cm">	 * everything.  This way we don&#39;t introduce memory corruptions</span>
<span class="cm">	 * during side-effect processing and correclty count established</span>
<span class="cm">	 * associations.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_ASOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_PASSIVEESTABS</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_START</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">));</span>

	<span class="cm">/* This will send the COOKIE ACK */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

	<span class="cm">/* Queue the ASSOC_CHANGE event */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span> <span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>

	<span class="cm">/* Send up the Adaptation Layer Indication event */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ai_ev</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ai_ev</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem_aiev:</span>
	<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
<span class="nl">nomem_ev:</span>
	<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">repl</span><span class="p">);</span>
<span class="nl">nomem_init:</span>
	<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Respond to a normal COOKIE ACK chunk.</span>
<span class="cm"> * We are the side that is being asked for an association.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm"> *</span>
<span class="cm"> * E) Upon reception of the COOKIE ACK, endpoint &quot;A&quot; will move from the</span>
<span class="cm"> *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie</span>
<span class="cm"> *    timer. It may also notify its ULP about the successful</span>
<span class="cm"> *    establishment of the association with a Communication Up</span>
<span class="cm"> *    notification (see Section 10).</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_1E_ca</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				      <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Verify that the chunk length for the COOKIE-ACK is OK.</span>
<span class="cm">	 * If we don&#39;t do this, any bundled chunks may be junked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Reset init error count upon receipt of COOKIE-ACK,</span>
<span class="cm">	 * to avoid problems with the managemement of this</span>
<span class="cm">	 * counter in stale cookie situations when a transition back</span>
<span class="cm">	 * from the COOKIE-ECHOED state to the COOKIE-WAIT</span>
<span class="cm">	 * state is performed.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_COUNTER_RESET</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm">	 *</span>
<span class="cm">	 * E) Upon reception of the COOKIE ACK, endpoint &quot;A&quot; will move</span>
<span class="cm">	 * from the COOKIE-ECHOED state to the ESTABLISHED state,</span>
<span class="cm">	 * stopping the T1-cookie timer.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ACTIVEESTABS</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_START</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">));</span>

	<span class="cm">/* It may also notify its ULP about the successful</span>
<span class="cm">	 * establishment of the association with a Communication Up</span>
<span class="cm">	 * notification (see Section 10).</span>
<span class="cm">	 */</span>
	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_COMM_UP</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">,</span>
					     <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span> <span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>

	<span class="cm">/* Sockets API Draft Section 5.3.1.6</span>
<span class="cm">	 * When a peer sends a Adaptation Layer Indication parameter , SCTP</span>
<span class="cm">	 * delivers this notification to inform the application that of the</span>
<span class="cm">	 * peers requested adaptation layer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_adaptation_indication</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Generate and sendout a heartbeat packet.  */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_heartbeat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>

	<span class="cm">/* Send a heartbeat to our peer.  */</span>
	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_heartbeat</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

	<span class="cm">/* Set rto_pending indicating that an RTT measurement</span>
<span class="cm">	 * is started with this heartbeat chunk.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_RTO_PENDING</span><span class="p">,</span>
			<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Generate a HEARTBEAT packet on the given transport.  */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_sendbeat_8_3</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
		<span class="cm">/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Section 3.3.5.</span>
<span class="cm">	 * The Sender-specific Heartbeat Info field should normally include</span>
<span class="cm">	 * information about the sender&#39;s current time when this HEARTBEAT</span>
<span class="cm">	 * chunk is sent and the destination transport address to which this</span>
<span class="cm">	 * HEARTBEAT is sent (see Section 8.3).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_HB_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_DISPOSITION_NOMEM</span> <span class="o">==</span>
				<span class="n">sctp_sf_heartbeat</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

		<span class="cm">/* Set transport error counter and association error counter</span>
<span class="cm">		 * when sending heartbeat.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TRANSPORT_HB_SENT</span><span class="p">,</span>
				<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TRANSPORT_IDLE</span><span class="p">,</span>
			<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMER_UPDATE</span><span class="p">,</span>
			<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an heartbeat request.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 8.3 Path Heartbeat</span>
<span class="cm"> * The receiver of the HEARTBEAT should immediately respond with a</span>
<span class="cm"> * HEARTBEAT ACK that contains the Heartbeat Information field copied</span>
<span class="cm"> * from the received HEARTBEAT chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> * When receiving an SCTP packet, the endpoint MUST ensure that the</span>
<span class="cm"> * value in the Verification Tag field of the received SCTP packet</span>
<span class="cm"> * matches its own Tag. If the received Verification Tag value does not</span>
<span class="cm"> * match the receiver&#39;s own tag value, the receiver shall silently</span>
<span class="cm"> * discard the packet and shall not process it any further except for</span>
<span class="cm"> * those cases listed in Section 8.5.1 below.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_beat_8_3</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">paylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the HEARTBEAT chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_heartbeat_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* 8.3 The receiver of the HEARTBEAT should immediately</span>
<span class="cm">	 * respond with a HEARTBEAT ACK that contains the Heartbeat</span>
<span class="cm">	 * Information field copied from the received HEARTBEAT chunk.</span>
<span class="cm">	 */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">hb_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_heartbeathdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">paylen</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">paylen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_heartbeat_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
					<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">hb_hdr</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process the returning HEARTBEAT ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 8.3 Path Heartbeat</span>
<span class="cm"> * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT</span>
<span class="cm"> * should clear the error counter of the destination transport</span>
<span class="cm"> * address to which the HEARTBEAT was sent, and mark the destination</span>
<span class="cm"> * transport address as active if it is not so marked. The endpoint may</span>
<span class="cm"> * optionally report to the upper layer when an inactive destination</span>
<span class="cm"> * address is marked as active due to the reception of the latest</span>
<span class="cm"> * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also</span>
<span class="cm"> * clear the association overall error count as well (as defined</span>
<span class="cm"> * in section 8.1).</span>
<span class="cm"> *</span>
<span class="cm"> * The receiver of the HEARTBEAT ACK should also perform an RTT</span>
<span class="cm"> * measurement for that destination transport address using the time</span>
<span class="cm"> * value carried in the HEARTBEAT ACK chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_backbeat_8_3</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">from_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="n">sctp_sender_hb_info_t</span> <span class="o">*</span><span class="n">hbinfo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_interval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)</span> <span class="o">+</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_sender_hb_info_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">hbinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_sender_hb_info_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/* Make sure that the length of the parameter is what we expect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">hbinfo</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="o">!=</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_sender_hb_info_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">from_addr</span> <span class="o">=</span> <span class="n">hbinfo</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="n">link</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_addr</span><span class="p">);</span>

	<span class="cm">/* This should never happen, but lets log it if so.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">from_addr</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;%s association %p could not find address %pI6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">__func__</span><span class="p">,</span>
					     <span class="n">asoc</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">from_addr</span><span class="p">.</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;%s association %p could not find address %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">__func__</span><span class="p">,</span>
					     <span class="n">asoc</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">from_addr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate the 64-bit random nonce. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hbinfo</span><span class="o">-&gt;</span><span class="n">hb_nonce</span> <span class="o">!=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">hb_nonce</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>

	<span class="n">max_interval</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">hbinterval</span> <span class="o">+</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">;</span>

	<span class="cm">/* Check if the timestamp looks valid.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">hbinfo</span><span class="o">-&gt;</span><span class="n">sent_at</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">hbinfo</span><span class="o">-&gt;</span><span class="n">sent_at</span> <span class="o">+</span> <span class="n">max_interval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: HEARTBEAT ACK with invalid timestamp &quot;</span>
				  <span class="s">&quot;received for transport: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of</span>
<span class="cm">	 * the HEARTBEAT should clear the error counter of the</span>
<span class="cm">	 * destination transport address to which the HEARTBEAT was</span>
<span class="cm">	 * sent and mark the destination transport address as active if</span>
<span class="cm">	 * it is not so marked.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TRANSPORT_ON</span><span class="p">,</span> <span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">link</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to send out an abort for the restart</span>
<span class="cm"> * condition.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_sf_send_restart_abort</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">ssa</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span>
				      <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">addrparm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_errhdr</span> <span class="o">*</span><span class="n">errhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_errhdr</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr_param</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">ssa</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>

	<span class="cm">/* Build the error on the stack.   We are way to malloc crazy</span>
<span class="cm">	 * throughout the code today.</span>
<span class="cm">	 */</span>
	<span class="n">errhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_errhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">addrparm</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">)</span><span class="n">errhdr</span><span class="o">-&gt;</span><span class="n">variable</span><span class="p">;</span>

	<span class="cm">/* Copy into a parm format. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">to_addr_param</span><span class="p">(</span><span class="n">ssa</span><span class="p">,</span> <span class="n">addrparm</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">);</span>

	<span class="n">errhdr</span><span class="o">-&gt;</span><span class="n">cause</span> <span class="o">=</span> <span class="n">SCTP_ERROR_RESTART</span><span class="p">;</span>
	<span class="n">errhdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Assign to the control socket. */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">((</span><span class="n">sctp_get_ctl_sock</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* Association is NULL since this may be a restart attack and we</span>
<span class="cm">	 * want to send back the attacker&#39;s vtag.</span>
<span class="cm">	 */</span>
	<span class="n">pkt</span> <span class="o">=</span> <span class="n">sctp_abort_pkt_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">errhdr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span> <span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">pkt</span><span class="p">));</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>

	<span class="cm">/* Discard the rest of the inbound packet. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DISCARD_PACKET</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

<span class="nl">out:</span>
	<span class="cm">/* Even if there is no memory, treat as a failure so</span>
<span class="cm">	 * the packet will get dropped.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">list_has_sctp_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			       <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* A restart is occurring, check to make sure no new addresses</span>
<span class="cm"> * are being added as we may be under a takeover attack.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_sf_check_restart_addrs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">new_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Implementor&#39;s Guide - Section 5.2.2</span>
<span class="cm">	 * ...</span>
<span class="cm">	 * Before responding the endpoint MUST check to see if the</span>
<span class="cm">	 * unexpected INIT adds new addresses to the association. If new</span>
<span class="cm">	 * addresses are added to the association, the endpoint MUST respond</span>
<span class="cm">	 * with an ABORT..</span>
<span class="cm">	 */</span>

	<span class="cm">/* Search through all current addresses and make sure</span>
<span class="cm">	 * we aren&#39;t adding any new ones.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">new_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			    <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_has_sctp_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">new_addr</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_sf_send_restart_abort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_addr</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span>
						   <span class="n">commands</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Return success if all addresses were found. */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Populate the verification/tie tags based on overlapping INIT</span>
<span class="cm"> * scenario.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_tietags_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */</span>

	<span class="k">case</span> <span class="n">SCTP_STATE_COOKIE_WAIT</span>:
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span>     <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">;</span>
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_ttag</span>     <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">;</span>
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_ttag</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_STATE_COOKIE_ECHOED</span>:
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span>     <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">;</span>
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_ttag</span>     <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">;</span>
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_ttag</span>   <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,</span>
<span class="cm">	 * COOKIE-WAIT and SHUTDOWN-ACK-SENT</span>
<span class="cm">	 */</span>
	<span class="nl">default:</span>
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_ttag</span>   <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">;</span>
		<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_ttag</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Other parameters for the endpoint SHOULD be copied from the</span>
<span class="cm">	 * existing parameters of the association (e.g. number of</span>
<span class="cm">	 * outbound streams) into the INIT ACK and cookie.</span>
<span class="cm">	 */</span>
	<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span>                  <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">;</span>
	<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span>  <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">;</span>
	<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">;</span>
	<span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span>         <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare vtag/tietag values to determine unexpected COOKIE-ECHO</span>
<span class="cm"> * handling action.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns value representing action to be taken.   These action values</span>
<span class="cm"> * correspond to Action/Description values in RFC 2960, Table 2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="nf">sctp_tietags_compare</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* In this case, the peer may have restarted.  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span> <span class="o">!=</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">!=</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_ttag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_ttag</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>

	<span class="cm">/* Collision case B. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">!=</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Collision case D. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>

	<span class="cm">/* Collision case C. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span> <span class="o">!=</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_ttag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_ttag</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;C&#39;</span><span class="p">;</span>

	<span class="cm">/* No match to any of the special cases; discard this packet. */</span>
	<span class="k">return</span> <span class="sc">&#39;E&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Common helper routine for both duplicate and simulataneous INIT</span>
<span class="cm"> * chunk handling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_unexpected_init</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_disposition_t</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="n">sctp_unrecognized_param_t</span> <span class="o">*</span><span class="n">unk_param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* 6.10 Bundling</span>
<span class="cm">	 * An endpoint MUST NOT bundle INIT, INIT ACK or</span>
<span class="cm">	 * SHUTDOWN COMPLETE with any other chunks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * IG Section 2.11.2</span>
<span class="cm">	 * Furthermore, we require that the receiver of an INIT chunk MUST</span>
<span class="cm">	 * enforce these rules by silently discarding an arriving packet</span>
<span class="cm">	 * with an INIT chunk that is bundled with other chunks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">singleton</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* 3.1 A packet containing an INIT chunk MUST have a zero Verification</span>
<span class="cm">	 * Tag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the INIT chunk has a valid length.</span>
<span class="cm">	 * In this case, we generate a protocol violation since we have</span>
<span class="cm">	 * an association established.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_init_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>
	<span class="cm">/* Grab the INIT header.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">init_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_inithdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Tag the variable length parameters.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_inithdr_t</span><span class="p">));</span>

	<span class="cm">/* Verify the INIT chunk before processing it. */</span>
	<span class="n">err_chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_verify_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">err_chunk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This chunk contains fatal error. It is to be discarded.</span>
<span class="cm">		 * Send an ABORT, with causes if there is any.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_abort_pkt_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
					<span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">),</span>
					<span class="n">ntohs</span><span class="p">(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
						<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
				<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						    <span class="n">commands</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Other parameters for the endpoint SHOULD be copied from the</span>
<span class="cm">	 * existing parameters of the association (e.g. number of</span>
<span class="cm">	 * outbound streams) into the INIT ACK and cookie.</span>
<span class="cm">	 * FIXME:  We are copying parameters from the endpoint not the</span>
<span class="cm">	 * association.</span>
<span class="cm">	 */</span>
	<span class="n">new_asoc</span> <span class="o">=</span> <span class="n">sctp_make_temp_asoc</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_asoc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_assoc_set_bind_addr_from_ep</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span>
				<span class="n">sctp_scope</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">)),</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* In the outbound INIT ACK the endpoint MUST copy its current</span>
<span class="cm">	 * Verification Tag and Peers Verification tag into a reserved</span>
<span class="cm">	 * place (local tie-tag and per tie-tag) within the state cookie.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_init</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span>
			       <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span>
			       <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Make sure no new addresses are being added during the</span>
<span class="cm">	 * restart.   Do not do this check for COOKIE-WAIT state,</span>
<span class="cm">	 * since there are no peer addresses to check against.</span>
<span class="cm">	 * Upon return an ABORT will have been sent if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">COOKIE_WAIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sf_check_restart_addrs</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
						 <span class="n">commands</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">nomem_retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sctp_tietags_populate</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* B) &quot;Z&quot; shall respond immediately with an INIT ACK chunk.  */</span>

	<span class="cm">/* If there are errors need to be reported for unknown parameters,</span>
<span class="cm">	 * make sure to reserve enough room in the INIT ACK for them.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_init_ack</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* If there are errors need to be reported for unknown parameters,</span>
<span class="cm">	 * include them in the outgoing INIT ACK as &quot;Unrecognized parameter&quot;</span>
<span class="cm">	 * parameter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the &quot;Unrecognized parameter&quot; parameter(s) out of the</span>
<span class="cm">		 * ERROR chunk generated by sctp_verify_init(). Since the</span>
<span class="cm">		 * error cause code for &quot;unknown parameter&quot; and the</span>
<span class="cm">		 * &quot;Unrecognized parameter&quot; type is the same, we can</span>
<span class="cm">		 * construct the parameters in INIT ACK by copying the</span>
<span class="cm">		 * ERROR causes over.</span>
<span class="cm">		 */</span>
		<span class="n">unk_param</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_unrecognized_param_t</span> <span class="o">*</span><span class="p">)</span>
			    <span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="o">+</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>
		<span class="cm">/* Replace the cause code with the &quot;Unrecognized parameter&quot;</span>
<span class="cm">		 * parameter type.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">unk_param</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_ASOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: After sending out INIT ACK with the State Cookie parameter,</span>
<span class="cm">	 * &quot;Z&quot; MUST NOT allocate any resources for this new association.</span>
<span class="cm">	 * Otherwise, &quot;Z&quot; will be vulnerable to resource attacks.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="nl">nomem_retval:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_asoc</span><span class="p">)</span>
		<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">);</span>
<span class="nl">cleanup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle simultaneous INIT.</span>
<span class="cm"> * This means we started an INIT and then we got an INIT request from</span>
<span class="cm"> * our peer.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)</span>
<span class="cm"> * This usually indicates an initialization collision, i.e., each</span>
<span class="cm"> * endpoint is attempting, at about the same time, to establish an</span>
<span class="cm"> * association with the other endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an</span>
<span class="cm"> * endpoint MUST respond with an INIT ACK using the same parameters it</span>
<span class="cm"> * sent in its original INIT chunk (including its Verification Tag,</span>
<span class="cm"> * unchanged). These original parameters are combined with those from the</span>
<span class="cm"> * newly received INIT chunk. The endpoint shall also generate a State</span>
<span class="cm"> * Cookie with the INIT ACK. The endpoint uses the parameters sent in its</span>
<span class="cm"> * INIT to calculate the State Cookie.</span>
<span class="cm"> *</span>
<span class="cm"> * After that, the endpoint MUST NOT change its state, the T1-init</span>
<span class="cm"> * timer shall be left running and the corresponding TCB MUST NOT be</span>
<span class="cm"> * destroyed. The normal procedures for handling State Cookies when</span>
<span class="cm"> * a TCB exists will resolve the duplicate INITs to a single association.</span>
<span class="cm"> *</span>
<span class="cm"> * For an endpoint that is in the COOKIE-ECHOED state it MUST populate</span>
<span class="cm"> * its Tie-Tags with the Tag information of itself and its peer (see</span>
<span class="cm"> * section 5.2.2 for a description of the Tie-Tags).</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: Not explicit, but an INIT can not have a valid</span>
<span class="cm"> * verification tag, so we skip the check.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_2_1_siminit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Call helper to do the real work for both simulataneous and</span>
<span class="cm">	 * duplicate INIT chunk handling.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_do_unexpected_init</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle duplicated INIT messages.  These are usually delayed</span>
<span class="cm"> * restransmissions.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,</span>
<span class="cm"> * COOKIE-ECHOED and COOKIE-WAIT</span>
<span class="cm"> *</span>
<span class="cm"> * Unless otherwise stated, upon reception of an unexpected INIT for</span>
<span class="cm"> * this association, the endpoint shall generate an INIT ACK with a</span>
<span class="cm"> * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its</span>
<span class="cm"> * current Verification Tag and peer&#39;s Verification Tag into a reserved</span>
<span class="cm"> * place within the state cookie.  We shall refer to these locations as</span>
<span class="cm"> * the Peer&#39;s-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet</span>
<span class="cm"> * containing this INIT ACK MUST carry a Verification Tag value equal to</span>
<span class="cm"> * the Initiation Tag found in the unexpected INIT.  And the INIT ACK</span>
<span class="cm"> * MUST contain a new Initiation Tag (randomly generated see Section</span>
<span class="cm"> * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the</span>
<span class="cm"> * existing parameters of the association (e.g. number of outbound</span>
<span class="cm"> * streams) into the INIT ACK and cookie.</span>
<span class="cm"> *</span>
<span class="cm"> * After sending out the INIT ACK, the endpoint shall take no further</span>
<span class="cm"> * actions, i.e., the existing association, including its current state,</span>
<span class="cm"> * and the corresponding TCB MUST NOT be changed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Only when a TCB exists and the association is not in a COOKIE-</span>
<span class="cm"> * WAIT state are the Tie-Tags populated.  For a normal association INIT</span>
<span class="cm"> * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be</span>
<span class="cm"> * set to 0 (indicating that no previous TCB existed).  The INIT ACK and</span>
<span class="cm"> * State Cookie are populated as specified in section 5.2.1.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: Not specified, but an INIT has no way of knowing</span>
<span class="cm"> * what the verification tag could be, so we ignore it.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_2_2_dupinit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Call helper to do the real work for both simulataneous and</span>
<span class="cm">	 * duplicate INIT chunk handling.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_do_unexpected_init</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Unexpected INIT-ACK handler.</span>
<span class="cm"> *</span>
<span class="cm"> * Section 5.2.3</span>
<span class="cm"> * If an INIT ACK received by an endpoint in any state other than the</span>
<span class="cm"> * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.</span>
<span class="cm"> * An unexpected INIT ACK usually indicates the processing of an old or</span>
<span class="cm"> * duplicated INIT chunk.</span>
<span class="cm">*/</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_2_3_initack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Per the above section, we&#39;ll discard the chunk if we have an</span>
<span class="cm">	 * endpoint.  If this is an OOTB INIT-ACK, treat it as such.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">sctp_sk</span><span class="p">((</span><span class="n">sctp_get_ctl_sock</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_ootb</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sctp_sf_discard_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action &#39;A&#39;)</span>
<span class="cm"> *</span>
<span class="cm"> * Section 5.2.4</span>
<span class="cm"> *  A)  In this case, the peer may have restarted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_dupcook_a</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
	<span class="n">sctp_disposition_t</span> <span class="n">disposition</span><span class="p">;</span>

	<span class="cm">/* new_asoc is a brand-new association, so these are not yet</span>
<span class="cm">	 * side effects--it is safe to run them here.</span>
<span class="cm">	 */</span>
	<span class="n">peer_init</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_init</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">peer_init</span><span class="p">,</span>
			       <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Make sure no new addresses are being added during the</span>
<span class="cm">	 * restart.  Though this is a pretty complicated attack</span>
<span class="cm">	 * since you&#39;d have to get inside the cookie.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sf_check_restart_addrs</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes</span>
<span class="cm">	 * the peer has restarted (Action A), it MUST NOT setup a new</span>
<span class="cm">	 * association but instead resend the SHUTDOWN ACK and send an ERROR</span>
<span class="cm">	 * chunk with a &quot;Cookie Received while Shutting Down&quot; error cause to</span>
<span class="cm">	 * its peer.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_state</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SHUTDOWN_ACK_SENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">disposition</span> <span class="o">=</span> <span class="n">sctp_sf_do_9_2_reshutack</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
				<span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
				<span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_DISPOSITION_NOMEM</span> <span class="o">==</span> <span class="n">disposition</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_make_op_error</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
					 <span class="n">SCTP_ERROR_COOKIE_IN_SHUTDOWN</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>

		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked</span>
<span class="cm">	 * data. Consider the optional choice of resending of this data.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_T3_RTX_TIMERS_STOP</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PURGE_OUTQUEUE</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue</span>
<span class="cm">	 * and ASCONF-ACK cache.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PURGE_ASCONF_QUEUE</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_cookie_ack</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Report association restart to upper layer. */</span>
	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_RESTART</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">,</span>
					     <span class="n">new_asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_ev</span><span class="p">;</span>

	<span class="cm">/* Update the content of current association. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_UPDATE_ASSOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span> <span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem_ev:</span>
	<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">repl</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action &#39;B&#39;)</span>
<span class="cm"> *</span>
<span class="cm"> * Section 5.2.4</span>
<span class="cm"> *   B) In this case, both sides may be attempting to start an association</span>
<span class="cm"> *      at about the same time but the peer endpoint started its INIT</span>
<span class="cm"> *      after responding to the local endpoint&#39;s INIT</span>
<span class="cm"> */</span>
<span class="cm">/* This case represents an initialization collision.  */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_dupcook_b</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>

	<span class="cm">/* new_asoc is a brand-new association, so these are not yet</span>
<span class="cm">	 * side effects--it is safe to run them here.</span>
<span class="cm">	 */</span>
	<span class="n">peer_init</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_init</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">peer_init</span><span class="p">,</span>
			       <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Update the content of current association.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_UPDATE_ASSOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_START</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_cookie_ack</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

	<span class="cm">/* RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm">	 *</span>
<span class="cm">	 * D) IMPLEMENTATION NOTE: An implementation may choose to</span>
<span class="cm">	 * send the Communication Up notification to the SCTP user</span>
<span class="cm">	 * upon reception of a valid COOKIE ECHO chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Sadly, this needs to be implemented as a side-effect, because</span>
<span class="cm">	 * we are not guaranteed to have set the association id of the real</span>
<span class="cm">	 * association and so these notifications need to be delayed until</span>
<span class="cm">	 * the association id is allocated.</span>
<span class="cm">	 */</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_CHANGE</span><span class="p">,</span> <span class="n">SCTP_U8</span><span class="p">(</span><span class="n">SCTP_COMM_UP</span><span class="p">));</span>

	<span class="cm">/* Sockets API Draft Section 5.3.1.6</span>
<span class="cm">	 * When a peer sends a Adaptation Layer Indication parameter , SCTP</span>
<span class="cm">	 * delivers this notification to inform the application that of the</span>
<span class="cm">	 * peers requested adaptation layer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This also needs to be done as a side effect for the same reason as</span>
<span class="cm">	 * above.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ADAPTATION_IND</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action &#39;C&#39;)</span>
<span class="cm"> *</span>
<span class="cm"> * Section 5.2.4</span>
<span class="cm"> *  C) In this case, the local endpoint&#39;s cookie has arrived late.</span>
<span class="cm"> *     Before it arrived, the local endpoint sent an INIT and received an</span>
<span class="cm"> *     INIT-ACK and finally sent a COOKIE ECHO with the peer&#39;s same tag</span>
<span class="cm"> *     but a new tag of its own.</span>
<span class="cm"> */</span>
<span class="cm">/* This case represents an initialization collision.  */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_dupcook_c</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The cookie should be silently discarded.</span>
<span class="cm">	 * The endpoint SHOULD NOT change states and should leave</span>
<span class="cm">	 * any timers running.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action &#39;D&#39;)</span>
<span class="cm"> *</span>
<span class="cm"> * Section 5.2.4</span>
<span class="cm"> *</span>
<span class="cm"> * D) When both local and remote tags match the endpoint should always</span>
<span class="cm"> *    enter the ESTABLISHED state, if it has not already done so.</span>
<span class="cm"> */</span>
<span class="cm">/* This case represents an initialization collision.  */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_dupcook_d</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">ai_ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>

	<span class="cm">/* Clarification from Implementor&#39;s Guide:</span>
<span class="cm">	 * D) When both local and remote tags match the endpoint should</span>
<span class="cm">	 * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.</span>
<span class="cm">	 * It should stop any cookie timer that may be running and send</span>
<span class="cm">	 * a COOKIE ACK.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Don&#39;t accidentally move back into established state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
				<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_START</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>

		<span class="cm">/* RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm">		 *</span>
<span class="cm">		 * D) IMPLEMENTATION NOTE: An implementation may choose</span>
<span class="cm">		 * to send the Communication Up notification to the</span>
<span class="cm">		 * SCTP user upon reception of a valid COOKIE</span>
<span class="cm">		 * ECHO chunk.</span>
<span class="cm">		 */</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">SCTP_COMM_UP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">,</span>
					     <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="cm">/* Sockets API Draft Section 5.3.1.6</span>
<span class="cm">		 * When a peer sends a Adaptation Layer Indication parameter,</span>
<span class="cm">		 * SCTP delivers this notification to inform the application</span>
<span class="cm">		 * that of the peers requested adaptation layer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ai_ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_adaptation_indication</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
								 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ai_ev</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_cookie_ack</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ai_ev</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
					<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ai_ev</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ai_ev</span><span class="p">)</span>
		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">ai_ev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span>
		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying</span>
<span class="cm"> * chunk was retransmitted and then delayed in the network.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: None.  Do cookie validation.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_2_4_dupcook</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_disposition_t</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new_asoc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">action</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chk_p</span><span class="p">;</span>

	<span class="cm">/* Make sure that the chunk has a valid length from the protocol</span>
<span class="cm">	 * perspective.  In this case check to make sure we have at least</span>
<span class="cm">	 * enough for the chunk header.  Cookie length verification is</span>
<span class="cm">	 * done later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* &quot;Decode&quot; the chunk.  We have no optional parameters so we</span>
<span class="cm">	 * are in good shape.</span>
<span class="cm">	 */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie</span>
<span class="cm">	 * of a duplicate COOKIE ECHO match the Verification Tags of the</span>
<span class="cm">	 * current association, consider the State Cookie valid even if</span>
<span class="cm">	 * the lifespan is exceeded.</span>
<span class="cm">	 */</span>
	<span class="n">new_asoc</span> <span class="o">=</span> <span class="n">sctp_unpack_cookie</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">err_chk_p</span><span class="p">);</span>

	<span class="cm">/* FIXME:</span>
<span class="cm">	 * If the re-build failed, what is the proper error path</span>
<span class="cm">	 * from here?</span>
<span class="cm">	 *</span>
<span class="cm">	 * [We should abort the association. --piggy]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Several errors are possible.  A bad cookie should</span>
<span class="cm">		 * be silently discarded, but think about logging it too.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span>:
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="k">case</span> <span class="o">-</span><span class="n">SCTP_IERROR_STALE_COOKIE</span>:
			<span class="n">sctp_send_stale_cookie_err</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
						   <span class="n">err_chk_p</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">SCTP_IERROR_BAD_SIG</span>:
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Compare the tie_tag in cookie with the verification tag of</span>
<span class="cm">	 * current association.</span>
<span class="cm">	 */</span>
	<span class="n">action</span> <span class="o">=</span> <span class="n">sctp_tietags_compare</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;A&#39;</span>: <span class="cm">/* Association restart. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_sf_do_dupcook_a</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
					      <span class="n">new_asoc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="sc">&#39;B&#39;</span>: <span class="cm">/* Collision case B. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_sf_do_dupcook_b</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
					      <span class="n">new_asoc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="sc">&#39;C&#39;</span>: <span class="cm">/* Collision case C. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_sf_do_dupcook_c</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
					      <span class="n">new_asoc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="sc">&#39;D&#39;</span>: <span class="cm">/* Collision case D. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_sf_do_dupcook_d</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
					      <span class="n">new_asoc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span> <span class="cm">/* Discard packet for all others. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Delete the tempory new association. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_ASOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">new_asoc</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* Restore association pointer to provide SCTP command interpeter</span>
<span class="cm">	 * with a valid context in case it needs to manipulate</span>
<span class="cm">	 * the queues */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_ASOC</span><span class="p">,</span>
			 <span class="n">SCTP_ASOC</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ABORT.  (SHUTDOWN-PENDING state)</span>
<span class="cm"> *</span>
<span class="cm"> * See sctp_sf_do_9_1_abort().</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shutdown_pending_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify_either</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ABORT chunk has a valid length.</span>
<span class="cm">	 * Since this is an ABORT chunk, we have to discard it</span>
<span class="cm">	 * because of the following text:</span>
<span class="cm">	 * RFC 2960, Section 3.3.7</span>
<span class="cm">	 *    If an endpoint receives an ABORT with a format error or for an</span>
<span class="cm">	 *    association that doesn&#39;t exist, it MUST silently discard it.</span>
<span class="cm">	 * Because the length is &quot;invalid&quot;, we can&#39;t really discard just</span>
<span class="cm">	 * as we do not know its true length.  So, to be safe, discard the</span>
<span class="cm">	 * packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_abort_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* ADD-IP: Special case for ABORT chunks</span>
<span class="cm">	 * F4)  One special consideration is that ABORT Chunks arriving</span>
<span class="cm">	 * destined to the IP address being deleted MUST be</span>
<span class="cm">	 * ignored (see Section 5.3.1 for further details).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ADDR_DEL</span> <span class="o">==</span>
		    <span class="n">sctp_bind_addr_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_discard_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__sctp_sf_do_9_1_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ABORT.  (SHUTDOWN-SENT state)</span>
<span class="cm"> *</span>
<span class="cm"> * See sctp_sf_do_9_1_abort().</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shutdown_sent_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify_either</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ABORT chunk has a valid length.</span>
<span class="cm">	 * Since this is an ABORT chunk, we have to discard it</span>
<span class="cm">	 * because of the following text:</span>
<span class="cm">	 * RFC 2960, Section 3.3.7</span>
<span class="cm">	 *    If an endpoint receives an ABORT with a format error or for an</span>
<span class="cm">	 *    association that doesn&#39;t exist, it MUST silently discard it.</span>
<span class="cm">	 * Because the length is &quot;invalid&quot;, we can&#39;t really discard just</span>
<span class="cm">	 * as we do not know its true length.  So, to be safe, discard the</span>
<span class="cm">	 * packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_abort_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* ADD-IP: Special case for ABORT chunks</span>
<span class="cm">	 * F4)  One special consideration is that ABORT Chunks arriving</span>
<span class="cm">	 * destined to the IP address being deleted MUST be</span>
<span class="cm">	 * ignored (see Section 5.3.1 for further details).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ADDR_DEL</span> <span class="o">==</span>
		    <span class="n">sctp_bind_addr_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_discard_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Stop the T2-shutdown timer. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="cm">/* Stop the T5-shutdown guard timer.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">__sctp_sf_do_9_1_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ABORT.  (SHUTDOWN-ACK-SENT state)</span>
<span class="cm"> *</span>
<span class="cm"> * See sctp_sf_do_9_1_abort().</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shutdown_ack_sent_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The same T2 timer, so we should be able to use</span>
<span class="cm">	 * common function with the SHUTDOWN-SENT state.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_shutdown_sent_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle an Error received in COOKIE_ECHOED state.</span>
<span class="cm"> *</span>
<span class="cm"> * Only handle the error type of stale COOKIE Error, the other errors will</span>
<span class="cm"> * be ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_echoed_err</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ERROR chunk has a valid length.</span>
<span class="cm">	 * The parameter walking depends on this as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_operr_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Process the error here */</span>
	<span class="cm">/* FUTURE FIXME:  When PR-SCTP related and other optional</span>
<span class="cm">	 * parms are emitted, this will have to change to handle multiple</span>
<span class="cm">	 * errors.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_walk_errors</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ERROR_STALE_COOKIE</span> <span class="o">==</span> <span class="n">err</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sctp_sf_do_5_2_6_stale</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
							<span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* It is possible to have malformed error causes, and that</span>
<span class="cm">	 * will cause us to end the walk early.  However, since</span>
<span class="cm">	 * we are discarding the packet, there should be no adverse</span>
<span class="cm">	 * affects.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a Stale COOKIE Error</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 5.2.6 Handle Stale COOKIE Error</span>
<span class="cm"> * If the association is in the COOKIE-ECHOED state, the endpoint may elect</span>
<span class="cm"> * one of the following three alternatives.</span>
<span class="cm"> * ...</span>
<span class="cm"> * 3) Send a new INIT chunk to the endpoint, adding a Cookie</span>
<span class="cm"> *    Preservative parameter requesting an extension to the lifetime of</span>
<span class="cm"> *    the State Cookie. When calculating the time extension, an</span>
<span class="cm"> *    implementation SHOULD use the RTT information measured based on the</span>
<span class="cm"> *    previous COOKIE ECHO / ERROR exchange, and should add no more</span>
<span class="cm"> *    than 1 second beyond the measured RTT, due to long State Cookie</span>
<span class="cm"> *    lifetimes making the endpoint more subject to a replay attack.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  Not explicit, but safe to ignore.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_5_2_6_stale</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
						 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
						 <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
						 <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
						 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">stale</span><span class="p">;</span>
	<span class="n">sctp_cookie_preserve_param_t</span> <span class="n">bht</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">attempts</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attempts</span> <span class="o">&gt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_STALE_COOKIE</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/* When calculating the time extension, an implementation</span>
<span class="cm">	 * SHOULD use the RTT information measured based on the</span>
<span class="cm">	 * previous COOKIE ECHO / ERROR exchange, and should add no</span>
<span class="cm">	 * more than 1 second beyond the measured RTT, due to long</span>
<span class="cm">	 * State Cookie lifetimes making the endpoint more subject to</span>
<span class="cm">	 * a replay attack.</span>
<span class="cm">	 * Measure of Staleness&#39;s unit is usec. (1/1000000 sec)</span>
<span class="cm">	 * Suggested Cookie Life-span Increment&#39;s unit is msec.</span>
<span class="cm">	 * (1/1000 sec)</span>
<span class="cm">	 * In general, if you use the suggested cookie life, the value</span>
<span class="cm">	 * found in the field of measure of staleness should be doubled</span>
<span class="cm">	 * to give ample time to retransmit the new cookie and thus</span>
<span class="cm">	 * yield a higher probability of success on the reattempt.</span>
<span class="cm">	 */</span>
	<span class="n">stale</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">err</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)));</span>
	<span class="n">stale</span> <span class="o">=</span> <span class="p">(</span><span class="n">stale</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">bht</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_COOKIE_PRESERVATIVE</span><span class="p">;</span>
	<span class="n">bht</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">bht</span><span class="p">));</span>
	<span class="n">bht</span><span class="p">.</span><span class="n">lifespan_increment</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">stale</span><span class="p">);</span>

	<span class="cm">/* Build that new INIT chunk.  */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bht</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bht</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bht</span><span class="p">);</span>

	<span class="cm">/* Clear peer&#39;s init_tag cached in assoc as we are sending a new INIT */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_CLEAR_INIT_TAG</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* Stop pending T3-rtx and heartbeat timers */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_T3_RTX_TIMERS_STOP</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_STOP</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* Delete non-primary peer ip addresses since we are transitioning</span>
<span class="cm">	 * back to the COOKIE-WAIT state</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DEL_NON_PRIMARY</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="cm">/* If we&#39;ve sent any data bundled with COOKIE-ECHO we will need to</span>
<span class="cm">	 * resend</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_T1_RETRAN</span><span class="p">,</span>
			<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">));</span>

	<span class="cm">/* Cast away the const modifier, as we want to just</span>
<span class="cm">	 * rerun it through as a sideffect.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_COUNTER_INC</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_COOKIE_WAIT</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ABORT.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 9.1</span>
<span class="cm"> * After checking the Verification Tag, the receiving endpoint shall</span>
<span class="cm"> * remove the association from its record, and shall report the</span>
<span class="cm"> * termination to its upper layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules</span>
<span class="cm"> * B) Rules for packet carrying ABORT:</span>
<span class="cm"> *</span>
<span class="cm"> *  - The endpoint shall always fill in the Verification Tag field of the</span>
<span class="cm"> *    outbound packet with the destination endpoint&#39;s tag value if it</span>
<span class="cm"> *    is known.</span>
<span class="cm"> *</span>
<span class="cm"> *  - If the ABORT is sent in response to an OOTB packet, the endpoint</span>
<span class="cm"> *    MUST follow the procedure described in Section 8.4.</span>
<span class="cm"> *</span>
<span class="cm"> *  - The receiver MUST accept the packet if the Verification Tag</span>
<span class="cm"> *    matches either its own tag, OR the tag of its peer. Otherwise, the</span>
<span class="cm"> *    receiver MUST silently discard the packet and take no further</span>
<span class="cm"> *    action.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_1_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify_either</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ABORT chunk has a valid length.</span>
<span class="cm">	 * Since this is an ABORT chunk, we have to discard it</span>
<span class="cm">	 * because of the following text:</span>
<span class="cm">	 * RFC 2960, Section 3.3.7</span>
<span class="cm">	 *    If an endpoint receives an ABORT with a format error or for an</span>
<span class="cm">	 *    association that doesn&#39;t exist, it MUST silently discard it.</span>
<span class="cm">	 * Because the length is &quot;invalid&quot;, we can&#39;t really discard just</span>
<span class="cm">	 * as we do not know its true length.  So, to be safe, discard the</span>
<span class="cm">	 * packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_abort_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* ADD-IP: Special case for ABORT chunks</span>
<span class="cm">	 * F4)  One special consideration is that ABORT Chunks arriving</span>
<span class="cm">	 * destined to the IP address being deleted MUST be</span>
<span class="cm">	 * ignored (see Section 5.3.1 for further details).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ADDR_DEL</span> <span class="o">==</span>
		    <span class="n">sctp_bind_addr_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_discard_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__sctp_sf_do_9_1_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">__sctp_sf_do_9_1_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">error</span> <span class="o">=</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>

	<span class="cm">/* See if we have an error cause code in the chunk.  */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_errhdr</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
		<span class="n">sctp_walk_errors</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">err</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="p">((</span><span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span> <span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNRESET</span><span class="p">));</span>
	<span class="cm">/* ASSOC_FAILED will DELETE_TCB. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span> <span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">error</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
	<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ABORT.  (COOKIE-WAIT state)</span>
<span class="cm"> *</span>
<span class="cm"> * See sctp_sf_do_9_1_abort() above.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_wait_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">error</span> <span class="o">=</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify_either</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ABORT chunk has a valid length.</span>
<span class="cm">	 * Since this is an ABORT chunk, we have to discard it</span>
<span class="cm">	 * because of the following text:</span>
<span class="cm">	 * RFC 2960, Section 3.3.7</span>
<span class="cm">	 *    If an endpoint receives an ABORT with a format error or for an</span>
<span class="cm">	 *    association that doesn&#39;t exist, it MUST silently discard it.</span>
<span class="cm">	 * Because the length is &quot;invalid&quot;, we can&#39;t really discard just</span>
<span class="cm">	 * as we do not know its true length.  So, to be safe, discard the</span>
<span class="cm">	 * packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_abort_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* See if we have an error cause code in the chunk.  */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_errhdr</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="p">((</span><span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_stop_t1_and_abort</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">ECONNREFUSED</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
				      <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_wait_icmp_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sctp_stop_t1_and_abort</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">,</span>
				      <span class="n">ENOPROTOOPT</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span>
				      <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ABORT.  (COOKIE-ECHOED state)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_echoed_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* There is a single T1 timer, so we should be able to use</span>
<span class="cm">	 * common function with the COOKIE-WAIT state.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_cookie_wait_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop T1 timer and abort association with &quot;INIT failed&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * This is common code called by several sctp_sf_*_abort() functions above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_stop_t1_and_abort</span><span class="p">(</span><span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
					   <span class="n">__be16</span> <span class="n">error</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sk_err</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ABORT received (INIT).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span> <span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">sk_err</span><span class="p">));</span>
	<span class="cm">/* CMD_INIT_FAILED will DELETE_TCB. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_FAILED</span><span class="p">,</span>
			<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">error</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_do_9_2_shut</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 9.2</span>
<span class="cm"> * Upon the reception of the SHUTDOWN, the peer endpoint shall</span>
<span class="cm"> *  - enter the SHUTDOWN-RECEIVED state,</span>
<span class="cm"> *</span>
<span class="cm"> *  - stop accepting new data from its SCTP user</span>
<span class="cm"> *</span>
<span class="cm"> *  - verify, by checking the Cumulative TSN Ack field of the chunk,</span>
<span class="cm"> *    that all its outstanding DATA chunks have been received by the</span>
<span class="cm"> *    SHUTDOWN sender.</span>
<span class="cm"> *</span>
<span class="cm"> * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT</span>
<span class="cm"> * send a SHUTDOWN in response to a ULP request. And should discard</span>
<span class="cm"> * subsequent SHUTDOWN chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are still outstanding DATA chunks left, the SHUTDOWN</span>
<span class="cm"> * receiver shall continue to follow normal data transmission</span>
<span class="cm"> * procedures defined in Section 6 until all outstanding DATA chunks</span>
<span class="cm"> * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept</span>
<span class="cm"> * new data from its SCTP user.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_shutdown</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_shutdownhdr_t</span> <span class="o">*</span><span class="n">sdh</span><span class="p">;</span>
	<span class="n">sctp_disposition_t</span> <span class="n">disposition</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the SHUTDOWN chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Convert the elaborate header.  */</span>
	<span class="n">sdh</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_shutdownhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_shutdownhdr_t</span><span class="p">));</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">shutdown_hdr</span> <span class="o">=</span> <span class="n">sdh</span><span class="p">;</span>
	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sdh</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ctsn %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">);</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ctsn_ack_point %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If Cumulative TSN Ack beyond the max tsn currently</span>
<span class="cm">	 * send, terminating the association and respond to the</span>
<span class="cm">	 * sender with an ABORT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_ctsn</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm">	 * When a peer sends a SHUTDOWN, SCTP delivers this notification to</span>
<span class="cm">	 * inform the application that it should cease sending data.</span>
<span class="cm">	 */</span>
	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_shutdown_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disposition</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span> <span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>

	<span class="cm">/* Upon the reception of the SHUTDOWN, the peer endpoint shall</span>
<span class="cm">	 *  - enter the SHUTDOWN-RECEIVED state,</span>
<span class="cm">	 *  - stop accepting new data from its SCTP user</span>
<span class="cm">	 *</span>
<span class="cm">	 * [This is implicit in the new state.]</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_SHUTDOWN_RECEIVED</span><span class="p">));</span>
	<span class="n">disposition</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_outq_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">disposition</span> <span class="o">=</span> <span class="n">sctp_sf_do_9_2_shutdown_ack</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
							  <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_DISPOSITION_NOMEM</span> <span class="o">==</span> <span class="n">disposition</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*  - verify, by checking the Cumulative TSN Ack field of the</span>
<span class="cm">	 *    chunk, that all its outstanding DATA chunks have been</span>
<span class="cm">	 *    received by the SHUTDOWN sender.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_CTSN</span><span class="p">,</span>
			<span class="n">SCTP_BE32</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">shutdown_hdr</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">disposition</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_do_9_2_shut_ctsn</span>
<span class="cm"> *</span>
<span class="cm"> * Once an endpoint has reached the SHUTDOWN-RECEIVED state,</span>
<span class="cm"> * it MUST NOT send a SHUTDOWN in response to a ULP request.</span>
<span class="cm"> * The Cumulative TSN Ack of the received SHUTDOWN chunk</span>
<span class="cm"> * MUST be processed.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_shut_ctsn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_shutdownhdr_t</span> <span class="o">*</span><span class="n">sdh</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the SHUTDOWN chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">sdh</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_shutdownhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sdh</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ctsn %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">);</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ctsn_ack_point %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If Cumulative TSN Ack beyond the max tsn currently</span>
<span class="cm">	 * send, terminating the association and respond to the</span>
<span class="cm">	 * sender with an ABORT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_ctsn</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* verify, by checking the Cumulative TSN Ack field of the</span>
<span class="cm">	 * chunk, that all its outstanding DATA chunks have been</span>
<span class="cm">	 * received by the SHUTDOWN sender.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_CTSN</span><span class="p">,</span>
			<span class="n">SCTP_BE32</span><span class="p">(</span><span class="n">sdh</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RFC 2960 9.2</span>
<span class="cm"> * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk</span>
<span class="cm"> * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination</span>
<span class="cm"> * transport addresses (either in the IP addresses or in the INIT chunk)</span>
<span class="cm"> * that belong to this association, it should discard the INIT chunk and</span>
<span class="cm"> * retransmit the SHUTDOWN ACK chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_reshutack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>

	<span class="cm">/* Make sure that the chunk has a valid length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Since we are not going to really process this INIT, there</span>
<span class="cm">	 * is no point in verifying chunk boundries.  Just generate</span>
<span class="cm">	 * the SHUTDOWN ACK.</span>
<span class="cm">	 */</span>
	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_shutdown_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Set the transport for the SHUTDOWN ACK chunk and the timeout for</span>
<span class="cm">	 * the T2-SHUTDOWN timer.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SETUP_T2</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="cm">/* and restart the T2-shutdown timer. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_do_ecn_cwr</span>
<span class="cm"> *</span>
<span class="cm"> * Section:  Appendix A: Explicit Congestion Notification</span>
<span class="cm"> *</span>
<span class="cm"> * CWR:</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 2481 details a specific bit for a sender to send in the header of</span>
<span class="cm"> * its next outbound TCP segment to indicate to its peer that it has</span>
<span class="cm"> * reduced its congestion window.  This is termed the CWR bit.  For</span>
<span class="cm"> * SCTP the same indication is made by including the CWR chunk.</span>
<span class="cm"> * This chunk contains one data element, i.e. the TSN number that</span>
<span class="cm"> * was sent in the ECNE chunk.  This element represents the lowest</span>
<span class="cm"> * TSN number in the datagram that was originally marked with the</span>
<span class="cm"> * CE bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: 8.5 Verification Tag [Normal verification]</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_ecn_cwr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				      <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_cwrhdr_t</span> <span class="o">*</span><span class="n">cwr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lowest_tsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_ecne_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">cwr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_cwrhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_cwrhdr_t</span><span class="p">));</span>

	<span class="n">lowest_tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">cwr</span><span class="o">-&gt;</span><span class="n">lowest_tsn</span><span class="p">);</span>

	<span class="cm">/* Does this CWR ack the last sent congestion notification? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_ecne_tsn</span><span class="p">,</span> <span class="n">lowest_tsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Stop sending ECNE. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span>
				<span class="n">SCTP_CMD_ECN_CWR</span><span class="p">,</span>
				<span class="n">SCTP_U32</span><span class="p">(</span><span class="n">lowest_tsn</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_do_ecne</span>
<span class="cm"> *</span>
<span class="cm"> * Section:  Appendix A: Explicit Congestion Notification</span>
<span class="cm"> *</span>
<span class="cm"> * ECN-Echo</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 2481 details a specific bit for a receiver to send back in its</span>
<span class="cm"> * TCP acknowledgements to notify the sender of the Congestion</span>
<span class="cm"> * Experienced (CE) bit having arrived from the network.  For SCTP this</span>
<span class="cm"> * same indication is made by including the ECNE chunk.  This chunk</span>
<span class="cm"> * contains one data element, i.e. the lowest TSN associated with the IP</span>
<span class="cm"> * datagram marked with the CE bit.....</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: 8.5 Verification Tag [Normal verification]</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_ecne</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_ecnehdr_t</span> <span class="o">*</span><span class="n">ecne</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_ecne_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">ecne</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_ecnehdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_ecnehdr_t</span><span class="p">));</span>

	<span class="cm">/* If this is a newer ECNE than the last CWR packet we sent out */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ECN_ECNE</span><span class="p">,</span>
			<span class="n">SCTP_U32</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">ecne</span><span class="o">-&gt;</span><span class="n">lowest_tsn</span><span class="p">)));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Section: 6.2  Acknowledgement on Reception of DATA Chunks</span>
<span class="cm"> *</span>
<span class="cm"> * The SCTP endpoint MUST always acknowledge the reception of each valid</span>
<span class="cm"> * DATA chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * The guidelines on delayed acknowledgement algorithm specified in</span>
<span class="cm"> * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an</span>
<span class="cm"> * acknowledgement SHOULD be generated for at least every second packet</span>
<span class="cm"> * (not every second DATA chunk) received, and SHOULD be generated within</span>
<span class="cm"> * 200 ms of the arrival of any unacknowledged DATA chunk. In some</span>
<span class="cm"> * situations it may be beneficial for an SCTP transmitter to be more</span>
<span class="cm"> * conservative than the algorithms detailed in this document allow.</span>
<span class="cm"> * However, an SCTP transmitter MUST NOT be more aggressive than the</span>
<span class="cm"> * following algorithms allow.</span>
<span class="cm"> *</span>
<span class="cm"> * A SCTP receiver MUST NOT generate more than one SACK for every</span>
<span class="cm"> * incoming packet, other than to update the offered window as the</span>
<span class="cm"> * receiving application consumes new data.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_eat_data_6_2</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_arg_t</span> <span class="n">force</span> <span class="o">=</span> <span class="n">SCTP_NOFORCE</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_data_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_eat_data</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span> <span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_NO_ERROR</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_HIGH_TSN</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_BAD_STREAM</span>:
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_IN_DATA_CHUNK_DISCARDS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard_noforce</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_DUP_TSN</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_IGNORE_TSN</span>:
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_IN_DATA_CHUNK_DISCARDS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard_force</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_NO_DATA</span>:
		<span class="k">goto</span> <span class="n">consume</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_PROTO_VIOLATION</span>:
		<span class="k">return</span> <span class="n">sctp_sf_abort_violation</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_datahdr_t</span><span class="p">));</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_SACK_IMM</span><span class="p">)</span>
		<span class="n">force</span> <span class="o">=</span> <span class="n">SCTP_FORCE</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* If this is the last chunk in a packet, we need to count it</span>
<span class="cm">	 * toward sack generation.  Note that we need to SACK every</span>
<span class="cm">	 * OTHER packet containing data chunks, EVEN IF WE DISCARD</span>
<span class="cm">	 * THEM.  We elect to NOT generate SACK&#39;s if the chunk fails</span>
<span class="cm">	 * the verification tag test.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks</span>
<span class="cm">	 *</span>
<span class="cm">	 * The SCTP endpoint MUST always acknowledge the reception of</span>
<span class="cm">	 * each valid DATA chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The guidelines on delayed acknowledgement algorithm</span>
<span class="cm">	 * specified in  Section 4.2 of [RFC2581] SHOULD be followed.</span>
<span class="cm">	 * Specifically, an acknowledgement SHOULD be generated for at</span>
<span class="cm">	 * least every second packet (not every second DATA chunk)</span>
<span class="cm">	 * received, and SHOULD be generated within 200 ms of the</span>
<span class="cm">	 * arrival of any unacknowledged DATA chunk.  In some</span>
<span class="cm">	 * situations it may be beneficial for an SCTP transmitter to</span>
<span class="cm">	 * be more conservative than the algorithms detailed in this</span>
<span class="cm">	 * document allow. However, an SCTP transmitter MUST NOT be</span>
<span class="cm">	 * more aggressive than the following algorithms allow.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">end_of_packet</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">force</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">discard_force:</span>
	<span class="cm">/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks</span>
<span class="cm">	 *</span>
<span class="cm">	 * When a packet arrives with duplicate DATA chunk(s) and with</span>
<span class="cm">	 * no new DATA chunk(s), the endpoint MUST immediately send a</span>
<span class="cm">	 * SACK with no delay.  If a packet arrives with duplicate</span>
<span class="cm">	 * DATA chunk(s) bundled with new DATA chunks, the endpoint</span>
<span class="cm">	 * MAY immediately send a SACK.  Normally receipt of duplicate</span>
<span class="cm">	 * DATA chunks will occur when the original SACK chunk was lost</span>
<span class="cm">	 * and the peer&#39;s RTO has expired.  The duplicate TSN number(s)</span>
<span class="cm">	 * SHOULD be reported in the SACK as duplicate.</span>
<span class="cm">	 */</span>
	<span class="cm">/* In our case, we split the MAY SACK advice up whether or not</span>
<span class="cm">	 * the last chunk is a duplicate.&#39;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">end_of_packet</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">SCTP_FORCE</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>

<span class="nl">discard_noforce:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">end_of_packet</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">force</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="nl">consume:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_eat_data_fast_4_4</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 (4)</span>
<span class="cm"> * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received</span>
<span class="cm"> *    DATA chunks without delay.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_eat_data_fast_4_4</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_data_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_eat_data</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span> <span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_NO_ERROR</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_HIGH_TSN</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_DUP_TSN</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_IGNORE_TSN</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_BAD_STREAM</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_NO_DATA</span>:
		<span class="k">goto</span> <span class="n">consume</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_PROTO_VIOLATION</span>:
		<span class="k">return</span> <span class="n">sctp_sf_abort_violation</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_datahdr_t</span><span class="p">));</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Go a head and force a SACK, since we are shutting down. */</span>

	<span class="cm">/* Implementor&#39;s Guide.</span>
<span class="cm">	 *</span>
<span class="cm">	 * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately</span>
<span class="cm">	 * respond to each received packet containing one or more DATA chunk(s)</span>
<span class="cm">	 * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">end_of_packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must delay the chunk creation since the cumulative</span>
<span class="cm">		 * TSN has not been updated yet.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SHUTDOWN</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">SCTP_FORCE</span><span class="p">());</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">consume:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Section: 6.2  Processing a Received SACK</span>
<span class="cm"> * D) Any time a SACK arrives, the endpoint performs the following:</span>
<span class="cm"> *</span>
<span class="cm"> *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,</span>
<span class="cm"> *     then drop the SACK.   Since Cumulative TSN Ack is monotonically</span>
<span class="cm"> *     increasing, a SACK whose Cumulative TSN Ack is less than the</span>
<span class="cm"> *     Cumulative TSN Ack Point indicates an out-of-order SACK.</span>
<span class="cm"> *</span>
<span class="cm"> *     ii) Set rwnd equal to the newly received a_rwnd minus the number</span>
<span class="cm"> *     of bytes still outstanding after processing the Cumulative TSN Ack</span>
<span class="cm"> *     and the Gap Ack Blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *     iii) If the SACK is missing a TSN that was previously</span>
<span class="cm"> *     acknowledged via a Gap Ack Block (e.g., the data receiver</span>
<span class="cm"> *     reneged on the data), then mark the corresponding DATA chunk</span>
<span class="cm"> *     as available for retransmit:  Mark it as missing for fast</span>
<span class="cm"> *     retransmit as described in Section 7.2.4 and if no retransmit</span>
<span class="cm"> *     timer is running for the destination address to which the DATA</span>
<span class="cm"> *     chunk was originally transmitted, then T3-rtx is started for</span>
<span class="cm"> *     that destination address.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_eat_sack_6_2</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_sackhdr_t</span> <span class="o">*</span><span class="n">sackh</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the SACK chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_sack_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Pull the SACK chunk from the data buffer */</span>
	<span class="n">sackh</span> <span class="o">=</span> <span class="n">sctp_sm_pull_sack</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="cm">/* Was this a bogus SACK? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sackh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">sack_hdr</span> <span class="o">=</span> <span class="n">sackh</span><span class="p">;</span>
	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sackh</span><span class="o">-&gt;</span><span class="n">cum_tsn_ack</span><span class="p">);</span>

	<span class="cm">/* i) If Cumulative TSN Ack is less than the Cumulative TSN</span>
<span class="cm">	 *     Ack Point, then drop the SACK.  Since Cumulative TSN</span>
<span class="cm">	 *     Ack is monotonically increasing, a SACK whose</span>
<span class="cm">	 *     Cumulative TSN Ack is less than the Cumulative TSN Ack</span>
<span class="cm">	 *     Point indicates an out-of-order SACK.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ctsn %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">);</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;ctsn_ack_point %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If Cumulative TSN Ack beyond the max tsn currently</span>
<span class="cm">	 * send, terminating the association and respond to the</span>
<span class="cm">	 * sender with an ABORT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TSN_lt</span><span class="p">(</span><span class="n">ctsn</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_ctsn</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Return this SACK for further processing.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_SACK</span><span class="p">,</span> <span class="n">SCTP_SACKH</span><span class="p">(</span><span class="n">sackh</span><span class="p">));</span>

	<span class="cm">/* Note: We do the rest of the work on the PROCESS_SACK</span>
<span class="cm">	 * sideeffect.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generate an ABORT in response to a packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 8.4 Handle &quot;Out of the blue&quot; Packets, sctpimpguide 2.41</span>
<span class="cm"> *</span>
<span class="cm"> * 8) The receiver should respond to the sender of the OOTB packet with</span>
<span class="cm"> *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet</span>
<span class="cm"> *    MUST fill in the Verification Tag field of the outbound packet</span>
<span class="cm"> *    with the value found in the Verification Tag field of the OOTB</span>
<span class="cm"> *    packet and set the T-bit in the Chunk Flags to indicate that the</span>
<span class="cm"> *    Verification Tag is reflected.  After sending this ABORT, the</span>
<span class="cm"> *    receiver of the OOTB packet shall discard the OOTB packet and take</span>
<span class="cm"> *    no further action.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">abort</span><span class="p">;</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_ootb_pkt_new</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make an ABORT. The T bit will be set if the asoc</span>
<span class="cm">		 * is NULL.</span>
<span class="cm">		 */</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abort</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_ootb_pkt_free</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Reflect vtag if T-Bit is set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_test_T_bit</span><span class="p">(</span><span class="n">abort</span><span class="p">))</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">);</span>

		<span class="cm">/* Set the skb to the belonging sock for accounting.  */</span>
		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">abort</span><span class="p">);</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
				<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>

		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>

		<span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR</span>
<span class="cm"> * event as ULP notification for each cause included in the chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * API 5.3.1.3 - SCTP_REMOTE_ERROR</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm">*/</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_operr_notify</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ERROR chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_operr_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>
	<span class="n">sctp_walk_errors</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">err</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_paramlen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">err</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_OPERR</span><span class="p">,</span>
			<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an inbound SHUTDOWN ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * From Section 9.2:</span>
<span class="cm"> * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall</span>
<span class="cm"> * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its</span>
<span class="cm"> * peer, and remove all record of the association.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_final</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>
	<span class="cm">/* 10.2 H) SHUTDOWN COMPLETE notification</span>
<span class="cm">	 *</span>
<span class="cm">	 * When SCTP completes the shutdown procedures (section 9.2) this</span>
<span class="cm">	 * notification is passed to the upper layer.</span>
<span class="cm">	 */</span>
	<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_assoc_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCTP_SHUTDOWN_COMP</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* ...send a SHUTDOWN COMPLETE chunk to its peer, */</span>
	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_shutdown_complete</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_chunk</span><span class="p">;</span>

	<span class="cm">/* Do all the commands now (after allocation), so that we</span>
<span class="cm">	 * have consistent state if memory allocation failes</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span> <span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>

	<span class="cm">/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall</span>
<span class="cm">	 * stop the T2-shutdown timer,</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_SHUTDOWNS</span><span class="p">);</span>
	<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="cm">/* ...and remove all record of the association. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>

<span class="nl">nomem_chunk:</span>
	<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RFC 2960, 8.4 - Handle &quot;Out of the blue&quot; Packets, sctpimpguide 2.41.</span>
<span class="cm"> *</span>
<span class="cm"> * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should</span>
<span class="cm"> *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.</span>
<span class="cm"> *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB</span>
<span class="cm"> *    packet must fill in the Verification Tag field of the outbound</span>
<span class="cm"> *    packet with the Verification Tag received in the SHUTDOWN ACK and</span>
<span class="cm"> *    set the T-bit in the Chunk Flags to indicate that the Verification</span>
<span class="cm"> *    Tag is reflected.</span>
<span class="cm"> *</span>
<span class="cm"> * 8) The receiver should respond to the sender of the OOTB packet with</span>
<span class="cm"> *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet</span>
<span class="cm"> *    MUST fill in the Verification Tag field of the outbound packet</span>
<span class="cm"> *    with the value found in the Verification Tag field of the OOTB</span>
<span class="cm"> *    packet and set the T-bit in the Chunk Flags to indicate that the</span>
<span class="cm"> *    Verification Tag is reflected.  After sending this ABORT, the</span>
<span class="cm"> *    receiver of the OOTB packet shall discard the OOTB packet and take</span>
<span class="cm"> *    no further action.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_ootb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">ch_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ootb_shut_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ootb_cookie_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTOFBLUES</span><span class="p">);</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Report violation if the chunk is less then minimal */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

		<span class="cm">/* Now that we know we at least have a chunk header,</span>
<span class="cm">		 * do things that are type appropriate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_SHUTDOWN_ACK</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="n">ootb_shut_ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* RFC 2960, Section 3.3.7</span>
<span class="cm">		 *   Moreover, under any circumstances, an endpoint that</span>
<span class="cm">		 *   receives an ABORT  MUST NOT respond to that ABORT by</span>
<span class="cm">		 *   sending an ABORT of its own.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_ABORT</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

		<span class="cm">/* RFC 8.4, 7) If the packet contains a &quot;Stale cookie&quot; ERROR</span>
<span class="cm">		 * or a COOKIE ACK the SCTP Packet should be silently</span>
<span class="cm">		 * discarded.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_COOKIE_ACK</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="n">ootb_cookie_ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_CID_ERROR</span> <span class="o">==</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_walk_errors</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ERROR_STALE_COOKIE</span> <span class="o">==</span> <span class="n">err</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ootb_cookie_ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Report violation if chunk len overflows */</span>
		<span class="n">ch_end</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ch</span><span class="p">)</span> <span class="o">+</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch_end</span> <span class="o">&gt;</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

		<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ch_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ch_end</span> <span class="o">&lt;</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ootb_shut_ack</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_shut_8_4_5</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ootb_cookie_ack</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sctp_sf_tabort_8_4_8</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle an &quot;Out of the blue&quot; SHUTDOWN ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 8.4 5, sctpimpguide 2.41.</span>
<span class="cm"> *</span>
<span class="cm"> * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should</span>
<span class="cm"> *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.</span>
<span class="cm"> *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB</span>
<span class="cm"> *    packet must fill in the Verification Tag field of the outbound</span>
<span class="cm"> *    packet with the Verification Tag received in the SHUTDOWN ACK and</span>
<span class="cm"> *    set the T-bit in the Chunk Flags to indicate that the Verification</span>
<span class="cm"> *    Tag is reflected.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, type, arg, commands)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (sctp_disposition_t)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shut_8_4_5</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">shut</span><span class="p">;</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_ootb_pkt_new</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make an SHUTDOWN_COMPLETE.</span>
<span class="cm">		 * The T bit will be set if the asoc is NULL.</span>
<span class="cm">		 */</span>
		<span class="n">shut</span> <span class="o">=</span> <span class="n">sctp_make_shutdown_complete</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shut</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_ootb_pkt_free</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Reflect vtag if T-Bit is set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_test_T_bit</span><span class="p">(</span><span class="n">shut</span><span class="p">))</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">);</span>

		<span class="cm">/* Set the skb to the belonging sock for accounting.  */</span>
		<span class="n">shut</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">shut</span><span class="p">);</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
				<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>

		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>

		<span class="cm">/* If the chunk length is invalid, we don&#39;t want to process</span>
<span class="cm">		 * the reset of the packet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

		<span class="cm">/* We need to discard the rest of the packet to prevent</span>
<span class="cm">		 * potential bomming attacks from additional bundled chunks.</span>
<span class="cm">		 * This is documented in SCTP Threats ID.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK</span>
<span class="cm"> *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the</span>
<span class="cm"> *   procedures in section 8.4 SHOULD be followed, in other words it</span>
<span class="cm"> *   should be treated as an Out Of The Blue packet.</span>
<span class="cm"> *   [This means that we do NOT check the Verification Tag on these</span>
<span class="cm"> *   chunks. --piggy ]</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_8_5_1_E_sa</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				      <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="cm">/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Although we do have an association in this case, it corresponds</span>
<span class="cm">	 * to a restarted association. So the packet is treated as an OOTB</span>
<span class="cm">	 * packet and the state function that handles OOTB SHUTDOWN_ACK is</span>
<span class="cm">	 * called with a NULL association.</span>
<span class="cm">	 */</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTOFBLUES</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sctp_sf_shut_8_4_5</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_asconf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">asconf_ack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span>	<span class="o">*</span><span class="n">err_param</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sctp_addiphdr_t</span>		<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span>	<span class="o">*</span><span class="n">addr_param</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">serial</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ADD-IP: Section 4.1.1</span>
<span class="cm">	 * This chunk MUST be sent in an authenticated way by using</span>
<span class="cm">	 * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk</span>
<span class="cm">	 * is received unauthenticated it MUST be silently discarded as</span>
<span class="cm">	 * described in [I-D.ietf-tsvwg-sctp-auth].</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_noauth</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_discard_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ASCONF ADDIP chunk has a valid length.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_addiphdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">serial</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>

	<span class="n">addr_param</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr_param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_paramlen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr_param</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Verify the ASCONF chunk before processing it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_verify_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">),</span>
			    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">err_param</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_paramlen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">err_param</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* ADDIP 5.2 E1) Compare the value of the serial number to the value</span>
<span class="cm">	 * the endpoint stored in a new association variable</span>
<span class="cm">	 * &#39;Peer-Serial-Number&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_serial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If this is the first instance of ASCONF in the packet,</span>
<span class="cm">		 * we can clean our old ASCONF-ACKs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">has_asconf</span><span class="p">)</span>
			<span class="n">sctp_assoc_clean_asconf_ack_cache</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

		<span class="cm">/* ADDIP 5.2 E4) When the Sequence Number matches the next one</span>
<span class="cm">		 * expected, process the ASCONF as described below and after</span>
<span class="cm">		 * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to</span>
<span class="cm">		 * the response packet and cache a copy of it (in the event it</span>
<span class="cm">		 * later needs to be retransmitted).</span>
<span class="cm">		 *</span>
<span class="cm">		 * Essentially, do V1-V5.</span>
<span class="cm">		 */</span>
		<span class="n">asconf_ack</span> <span class="o">=</span> <span class="n">sctp_process_asconf</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span>
						 <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asconf_ack</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">serial</span> <span class="o">&lt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_serial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ADDIP 5.2 E2)</span>
<span class="cm">		 * If the value found in the Sequence Number is less than the</span>
<span class="cm">		 * (&#39;Peer- Sequence-Number&#39; + 1), simply skip to the next</span>
<span class="cm">		 * ASCONF, and include in the outbound response packet</span>
<span class="cm">		 * any previously cached ASCONF-ACK response that was</span>
<span class="cm">		 * sent and saved that matches the Sequence Number of the</span>
<span class="cm">		 * ASCONF.  Note: It is possible that no cached ASCONF-ACK</span>
<span class="cm">		 * Chunk exists.  This will occur when an older ASCONF</span>
<span class="cm">		 * arrives out of order.  In such a case, the receiver</span>
<span class="cm">		 * should skip the ASCONF Chunk and not include ASCONF-ACK</span>
<span class="cm">		 * Chunk for that chunk.</span>
<span class="cm">		 */</span>
		<span class="n">asconf_ack</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_asconf_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asconf_ack</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>

		<span class="cm">/* Reset the transport so that we select the correct one</span>
<span class="cm">		 * this time around.  This is to make sure that we don&#39;t</span>
<span class="cm">		 * accidentally use a stale transport that&#39;s been removed.</span>
<span class="cm">		 */</span>
		<span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since</span>
<span class="cm">		 * it must be either a stale packet or from an attacker.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ADDIP 5.2 E6)  The destination address of the SCTP packet</span>
<span class="cm">	 * containing the ASCONF-ACK Chunks MUST be the source address of</span>
<span class="cm">	 * the SCTP packet that held the ASCONF Chunks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To do this properly, we&#39;ll set the destination address of the chunk</span>
<span class="cm">	 * and at the transmit time, will try look up the transport to use.</span>
<span class="cm">	 * Since ASCONFs may be bundled, the correct transport may not be</span>
<span class="cm">	 * created until we process the entire packet, thus this workaround.</span>
<span class="cm">	 */</span>
	<span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">asconf_ack</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">new_transport</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">sctp_sf_heartbeat</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">new_transport</span><span class="p">,</span>
                    <span class="n">commands</span><span class="p">);</span>
		<span class="p">((</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">new_transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ADDIP Section 4.3 General rules for address manipulation</span>
<span class="cm"> * When building TLV parameters for the ASCONF Chunk that will add or</span>
<span class="cm"> * delete IP addresses the D0 to D13 rules should be applied:</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_asconf_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">asconf_ack</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">last_asconf</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">abort</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span>	<span class="o">*</span><span class="n">err_param</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sctp_addiphdr_t</span>		<span class="o">*</span><span class="n">addip_hdr</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">sent_serial</span><span class="p">,</span> <span class="n">rcvd_serial</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">asconf_ack</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ADD-IP, Section 4.1.2:</span>
<span class="cm">	 * This chunk MUST be sent in an authenticated way by using</span>
<span class="cm">	 * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk</span>
<span class="cm">	 * is received unauthenticated it MUST be silently discarded as</span>
<span class="cm">	 * described in [I-D.ietf-tsvwg-sctp-auth].</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_noauth</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_discard_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the ADDIP chunk has a valid length.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">asconf_ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_chunk_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">addip_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_addiphdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">rcvd_serial</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">addip_hdr</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* Verify the ASCONF-ACK chunk before processing it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_verify_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">addip_hdr</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span>
	    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">chunk_end</span><span class="p">,</span>
	    <span class="o">&amp;</span><span class="n">err_param</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_paramlen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">err_param</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addip_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_addiphdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">last_asconf</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">addip_hdr</span><span class="p">;</span>
		<span class="n">sent_serial</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">addip_hdr</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sent_serial</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_serial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* D0) If an endpoint receives an ASCONF-ACK that is greater than or</span>
<span class="cm">	 * equal to the next serial number to be used but no ASCONF chunk is</span>
<span class="cm">	 * outstanding the endpoint MUST ABORT the association. Note that a</span>
<span class="cm">	 * sequence number is greater than if it is no more than 2^^31-1</span>
<span class="cm">	 * larger than the current sequence number (using serial arithmetic).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ADDIP_SERIAL_gte</span><span class="p">(</span><span class="n">rcvd_serial</span><span class="p">,</span> <span class="n">sent_serial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asconf_ack</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abort</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">abort</span><span class="p">,</span> <span class="n">SCTP_ERROR_ASCONF_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">abort</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* We are going to ABORT, so we might as well stop</span>
<span class="cm">		 * processing the rest of the chunks in the packet.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DISCARD_PACKET</span><span class="p">,</span><span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNABORTED</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_ASCONF_ACK</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rcvd_serial</span> <span class="o">==</span> <span class="n">sent_serial</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_asconf_ack</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="n">asconf_ack</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Successfully processed ASCONF_ACK.  We can</span>
<span class="cm">			 * release the next asconf if we have one.</span>
<span class="cm">			 */</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_NEXT_ASCONF</span><span class="p">,</span>
					<span class="n">SCTP_NULL</span><span class="p">());</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">abort</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asconf_ack</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abort</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">abort</span><span class="p">,</span> <span class="n">SCTP_ERROR_RSRC_LOW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">abort</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* We are going to ABORT, so we might as well stop</span>
<span class="cm">		 * processing the rest of the chunks in the packet.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DISCARD_PACKET</span><span class="p">,</span><span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNABORTED</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_ASCONF_ACK</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP</span>
<span class="cm"> *</span>
<span class="cm"> * When a FORWARD TSN chunk arrives, the data receiver MUST first update</span>
<span class="cm"> * its cumulative TSN point to the value carried in the FORWARD TSN</span>
<span class="cm"> * chunk, and then MUST further advance its cumulative TSN point locally</span>
<span class="cm"> * if possible.</span>
<span class="cm"> * After the above processing, the data receiver MUST stop reporting any</span>
<span class="cm"> * missing TSNs earlier than or equal to the new cumulative TSN point.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_eat_fwd_tsn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span> <span class="o">*</span><span class="n">fwdtsn_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="o">*</span><span class="n">skip</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure that the FORWARD_TSN chunk has valid length.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_chunk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">fwdtsn_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">fwdtsn_hdr</span> <span class="o">=</span> <span class="n">fwdtsn_hdr</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">fwdtsn_hdr</span><span class="o">-&gt;</span><span class="n">new_cum_tsn</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: TSN 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>

	<span class="cm">/* The TSN is too high--silently discard the chunk and count on it</span>
<span class="cm">	 * getting retransmitted later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_tsnmap_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">tsn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">discard_noforce</span><span class="p">;</span>

	<span class="cm">/* Silently discard the chunk if stream-id is not valid */</span>
	<span class="n">sctp_walk_fwdtsn</span><span class="p">(</span><span class="n">skip</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">skip</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard_noforce</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_FWDTSN</span><span class="p">,</span> <span class="n">SCTP_U32</span><span class="p">(</span><span class="n">tsn</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span><span class="p">))</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_FWDTSN</span><span class="p">,</span>
				<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>

	<span class="cm">/* Count this as receiving DATA. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: For now send a SACK, but DATA processing may</span>
<span class="cm">	 * send another.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">SCTP_NOFORCE</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">discard_noforce:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_eat_fwd_tsn_fast</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span> <span class="o">*</span><span class="n">fwdtsn_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="o">*</span><span class="n">skip</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure that the FORWARD_TSN chunk has a valid length.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_chunk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">fwdtsn_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">fwdtsn_hdr</span> <span class="o">=</span> <span class="n">fwdtsn_hdr</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">fwdtsn_hdr</span><span class="o">-&gt;</span><span class="n">new_cum_tsn</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: TSN 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>

	<span class="cm">/* The TSN is too high--silently discard the chunk and count on it</span>
<span class="cm">	 * getting retransmitted later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_tsnmap_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">tsn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">gen_shutdown</span><span class="p">;</span>

	<span class="cm">/* Silently discard the chunk if stream-id is not valid */</span>
	<span class="n">sctp_walk_fwdtsn</span><span class="p">(</span><span class="n">skip</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">skip</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">gen_shutdown</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_FWDTSN</span><span class="p">,</span> <span class="n">SCTP_U32</span><span class="p">(</span><span class="n">tsn</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span><span class="p">))</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PROCESS_FWDTSN</span><span class="p">,</span>
				<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>

	<span class="cm">/* Go a head and force a SACK, since we are shutting down. */</span>
<span class="nl">gen_shutdown:</span>
	<span class="cm">/* Implementor&#39;s Guide.</span>
<span class="cm">	 *</span>
<span class="cm">	 * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately</span>
<span class="cm">	 * respond to each received packet containing one or more DATA chunk(s)</span>
<span class="cm">	 * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SHUTDOWN</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">SCTP_FORCE</span><span class="p">());</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SCTP-AUTH Section 6.3 Receiving authenticated chukns</span>
<span class="cm"> *</span>
<span class="cm"> *    The receiver MUST use the HMAC algorithm indicated in the HMAC</span>
<span class="cm"> *    Identifier field.  If this algorithm was not specified by the</span>
<span class="cm"> *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk</span>
<span class="cm"> *    during association setup, the AUTH chunk and all chunks after it MUST</span>
<span class="cm"> *    be discarded and an ERROR chunk SHOULD be sent with the error cause</span>
<span class="cm"> *    defined in Section 4.1.</span>
<span class="cm"> *</span>
<span class="cm"> *    If an endpoint with no shared key receives a Shared Key Identifier</span>
<span class="cm"> *    other than 0, it MUST silently discard all authenticated chunks.  If</span>
<span class="cm"> *    the endpoint has at least one endpoint pair shared key for the peer,</span>
<span class="cm"> *    it MUST use the key specified by the Shared Key Identifier if a</span>
<span class="cm"> *    key has been configured for that Shared Key Identifier.  If no</span>
<span class="cm"> *    endpoint pair shared key has been configured for that Shared Key</span>
<span class="cm"> *    Identifier, all authenticated chunks MUST be silently discarded.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag:  8.5 Verification Tag [Normal verification]</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_ierror_t</span> <span class="nf">sctp_sf_authenticate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authhdr</span> <span class="o">*</span><span class="n">auth_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hmac</span> <span class="o">*</span><span class="n">hmac</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sig_len</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">key_id</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">save_digest</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">digest</span><span class="p">;</span>

	<span class="cm">/* Pull in the auth header, so we can do some more verification */</span>
	<span class="n">auth_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">auth_hdr</span> <span class="o">=</span> <span class="n">auth_hdr</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authhdr</span><span class="p">));</span>

	<span class="cm">/* Make sure that we suport the HMAC algorithm from the auth</span>
<span class="cm">	 * chunk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_asoc_verify_hmac_id</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">hmac_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_AUTH_BAD_HMAC</span><span class="p">;</span>

	<span class="cm">/* Make sure that the provided shared key identifier has been</span>
<span class="cm">	 * configured</span>
<span class="cm">	 */</span>
	<span class="n">key_id</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">shkey_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key_id</span> <span class="o">!=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">active_key_id</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sctp_auth_get_shkey</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">key_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_AUTH_BAD_KEYID</span><span class="p">;</span>


	<span class="cm">/* Make sure that the length of the signature matches what</span>
<span class="cm">	 * we expect.</span>
<span class="cm">	 */</span>
	<span class="n">sig_len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_auth_chunk_t</span><span class="p">);</span>
	<span class="n">hmac</span> <span class="o">=</span> <span class="n">sctp_auth_get_hmac</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">hmac_id</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig_len</span> <span class="o">!=</span> <span class="n">hmac</span><span class="o">-&gt;</span><span class="n">hmac_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_PROTO_VIOLATION</span><span class="p">;</span>

	<span class="cm">/* Now that we&#39;ve done validation checks, we can compute and</span>
<span class="cm">	 * verify the hmac.  The steps involved are:</span>
<span class="cm">	 *  1. Save the digest from the chunk.</span>
<span class="cm">	 *  2. Zero out the digest in the chunk.</span>
<span class="cm">	 *  3. Compute the new digest</span>
<span class="cm">	 *  4. Compare saved and new digests.</span>
<span class="cm">	 */</span>
	<span class="n">digest</span> <span class="o">=</span> <span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">hmac</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">sig_len</span><span class="p">);</span>

	<span class="n">save_digest</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">sig_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_digest</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sig_len</span><span class="p">);</span>

	<span class="n">sctp_auth_calculate_hmac</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sctp_auth_chunk</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/* Discard the packet if the digests do not match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">save_digest</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="n">sig_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">save_digest</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_BAD_SIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">save_digest</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">SCTP_IERROR_NO_ERROR</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_eat_auth</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_authhdr</span> <span class="o">*</span><span class="n">auth_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">;</span>
	<span class="n">sctp_ierror_t</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Make sure that the peer has AUTH capable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_unk_chunk</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_BAD_TAG</span><span class="p">,</span>
				<span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure that the AUTH chunk has valid length.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_auth_chunk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">auth_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_sf_authenticate</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_AUTH_BAD_HMAC</span>:
		<span class="cm">/* Generate the ERROR chunk and discard the rest</span>
<span class="cm">		 * of the packet</span>
<span class="cm">		 */</span>
		<span class="n">err_chunk</span> <span class="o">=</span> <span class="n">sctp_make_op_error</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
					       <span class="n">SCTP_ERROR_UNSUP_HMAC</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">hmac_id</span><span class="p">,</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* Fall Through */</span>
	<span class="k">case</span> <span class="n">SCTP_IERROR_AUTH_BAD_KEYID</span>:
	<span class="k">case</span> <span class="n">SCTP_IERROR_BAD_SIG</span>:
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SCTP_IERROR_PROTO_VIOLATION</span>:
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SCTP_IERROR_NOMEM</span>:
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

	<span class="nl">default:</span>			<span class="cm">/* Prevent gcc warnings */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">active_key_id</span> <span class="o">!=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">shkey_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

		<span class="n">ev</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_authkey</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hdr</span><span class="o">-&gt;</span><span class="n">shkey_id</span><span class="p">),</span>
				    <span class="n">SCTP_AUTH_NEWKEY</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span>
				<span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an unknown chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 3.2. Also, 2.1 in the implementor&#39;s guide.</span>
<span class="cm"> *</span>
<span class="cm"> * Chunk Types are encoded such that the highest-order two bits specify</span>
<span class="cm"> * the action that must be taken if the processing endpoint does not</span>
<span class="cm"> * recognize the Chunk Type.</span>
<span class="cm"> *</span>
<span class="cm"> * 00 - Stop processing this SCTP packet and discard it, do not process</span>
<span class="cm"> *      any further chunks within it.</span>
<span class="cm"> *</span>
<span class="cm"> * 01 - Stop processing this SCTP packet and discard it, do not process</span>
<span class="cm"> *      any further chunks within it, and report the unrecognized</span>
<span class="cm"> *      chunk in an &#39;Unrecognized Chunk Type&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * 10 - Skip this chunk and continue processing.</span>
<span class="cm"> *</span>
<span class="cm"> * 11 - Skip this chunk and continue processing, but report in an ERROR</span>
<span class="cm"> *      Chunk using the &#39;Unrecognized Chunk Type&#39; cause of error.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_unk_chunk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">unk_chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">;</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Processing the unknown chunk id %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">unk_chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="cm">/* Make sure that the chunk has a valid length.</span>
<span class="cm">	 * Since we don&#39;t know the chunk type, we use a general</span>
<span class="cm">	 * chunkhdr structure to make a comparison.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">unk_chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">chunk</span> <span class="o">&amp;</span> <span class="n">SCTP_CID_ACTION_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_CID_ACTION_DISCARD</span>:
		<span class="cm">/* Discard the packet.  */</span>
		<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_CID_ACTION_DISCARD_ERR</span>:
		<span class="cm">/* Generate an ERROR chunk as response. */</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">unk_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>
		<span class="n">err_chunk</span> <span class="o">=</span> <span class="n">sctp_make_op_error</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">unk_chunk</span><span class="p">,</span>
					       <span class="n">SCTP_ERROR_UNKNOWN_CHUNK</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span>
					       <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)),</span>
					       <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* Discard the packet.  */</span>
		<span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_CID_ACTION_SKIP</span>:
		<span class="cm">/* Skip the chunk.  */</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_CID_ACTION_SKIP_ERR</span>:
		<span class="cm">/* Generate an ERROR chunk as response. */</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">unk_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>
		<span class="n">err_chunk</span> <span class="o">=</span> <span class="n">sctp_make_op_error</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">unk_chunk</span><span class="p">,</span>
					       <span class="n">SCTP_ERROR_UNKNOWN_CHUNK</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span>
					       <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)),</span>
					       <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err_chunk</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* Skip the chunk.  */</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Discard the chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2</span>
<span class="cm"> * [Too numerous to mention...]</span>
<span class="cm"> * Verification Tag: No verification needed.</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_discard_chunk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="cm">/* Make sure that the chunk has a valid length.</span>
<span class="cm">	 * Since we don&#39;t know the chunk type, we use a general</span>
<span class="cm">	 * chunkhdr structure to make a comparison.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Chunk %d is discarded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Discard the whole packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 8.4 2)</span>
<span class="cm"> *</span>
<span class="cm"> * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST</span>
<span class="cm"> *    silently discard the OOTB packet and take no further action.</span>
<span class="cm"> *</span>
<span class="cm"> * Verification Tag: No verification necessary</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_pdiscard</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_IN_PKT_DISCARDS</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DISCARD_PACKET</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * The other end is violating protocol.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: Not specified</span>
<span class="cm"> * Verification Tag: Not specified</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (asoc, reply_msg, msg_up, timers, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * We simply tag the chunk as a violation.  The state machine will log</span>
<span class="cm"> * the violation and continue.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_violation</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="cm">/* Make sure that the chunk has a valid length. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
						  <span class="n">commands</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_VIOLATION</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common function to handle a protocol violation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_abort_violation</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span>  <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">abort</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH, Section 6.3:</span>
<span class="cm">	 *    It should be noted that if the receiver wants to tear</span>
<span class="cm">	 *    down an association in an authenticated way only, the</span>
<span class="cm">	 *    handling of malformed packets should not result in</span>
<span class="cm">	 *    tearing down the association.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This means that if we only want to abort associations</span>
<span class="cm">	 * in an authenticated way (i.e AUTH+ABORT), then we</span>
<span class="cm">	 * can&#39;t destroy this association just because the packet</span>
<span class="cm">	 * was malformed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_recv_cid</span><span class="p">(</span><span class="n">SCTP_CID_ABORT</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="cm">/* Make the abort chunk. */</span>
	<span class="n">abort</span> <span class="o">=</span> <span class="n">sctp_make_abort_violation</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abort</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Treat INIT-ACK as a special case during COOKIE-WAIT. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_CID_INIT_ACK</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_initack_chunk_t</span> <span class="o">*</span><span class="n">initack</span><span class="p">;</span>

			<span class="n">initack</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_initack_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span>
						     <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_initack_chunk_t</span><span class="p">)))</span>
				<span class="n">abort</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCTP_CHUNK_FLAG_T</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inittag</span><span class="p">;</span>

				<span class="n">inittag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">initack</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">init_tag</span><span class="p">);</span>
				<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_UPDATE_INITTAG</span><span class="p">,</span>
						<span class="n">SCTP_U32</span><span class="p">(</span><span class="n">inittag</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">abort</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">SCTP_STATE_COOKIE_ECHOED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
					<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
					<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNREFUSED</span><span class="p">));</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_FAILED</span><span class="p">,</span>
					<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_PROTO_VIOLATION</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
					<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNABORTED</span><span class="p">));</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
					<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_PROTO_VIOLATION</span><span class="p">));</span>
			<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_ootb_pkt_new</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem_pkt</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_test_T_bit</span><span class="p">(</span><span class="n">abort</span><span class="p">))</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">);</span>

		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">abort</span><span class="p">);</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
			<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>

		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>

<span class="nl">discard:</span>
	<span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>

<span class="nl">nomem_pkt:</span>
	<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">abort</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a protocol violation when the chunk length is invalid.</span>
<span class="cm"> * &quot;Invalid&quot; length is identified as smaller than the minimal length a</span>
<span class="cm"> * given chunk can be.  For example, a SACK chunk has invalid length</span>
<span class="cm"> * if its length is set to be smaller than the size of sctp_sack_chunk_t.</span>
<span class="cm"> *</span>
<span class="cm"> * We inform the other end by sending an ABORT with a Protocol Violation</span>
<span class="cm"> * error code.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: Not specified</span>
<span class="cm"> * Verification Tag:  Nothing to do</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (reply_msg, msg_up, counters)</span>
<span class="cm"> *</span>
<span class="cm"> * Generate an  ABORT chunk and terminate the association.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_violation_chunklen</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">err_str</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;The following chunk had invalid length:&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_sf_abort_violation</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span> <span class="n">err_str</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">err_str</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a protocol violation when the parameter length is invalid.</span>
<span class="cm"> * If the length is smaller than the minimum length of a given parameter,</span>
<span class="cm"> * or accumulated length in multi parameters exceeds the end of the chunk,</span>
<span class="cm"> * the length is considered as invalid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_violation_paramlen</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ext</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span>  <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">ext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">abort</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_recv_cid</span><span class="p">(</span><span class="n">SCTP_CID_ABORT</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="cm">/* Make the abort chunk. */</span>
	<span class="n">abort</span> <span class="o">=</span> <span class="n">sctp_make_violation_paramlen</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abort</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">abort</span><span class="p">));</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
			<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNABORTED</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
			<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_PROTO_VIOLATION</span><span class="p">));</span>
	<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>

<span class="nl">discard:</span>
	<span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle a protocol violation when the peer trying to advance the</span>
<span class="cm"> * cumulative tsn ack to a point beyond the max tsn currently sent.</span>
<span class="cm"> *</span>
<span class="cm"> * We inform the other end by sending an ABORT with a Protocol Violation</span>
<span class="cm"> * error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_violation_ctsn</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">err_str</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;The cumulative tsn ack beyond the max tsn currently sent:&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_sf_abort_violation</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span> <span class="n">err_str</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">err_str</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Handle protocol violation of an invalid chunk bundling.  For example,</span>
<span class="cm"> * when we have an association and we receive bundled INIT-ACK, or</span>
<span class="cm"> * SHUDOWN-COMPLETE, our peer is clearly violationg the &quot;MUST NOT bundle&quot;</span>
<span class="cm"> * statement from the specs.  Additionally, there might be an attacker</span>
<span class="cm"> * on the path and we may not want to continue this communication.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_violation_chunk</span><span class="p">(</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				     <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">err_str</span><span class="p">[]</span><span class="o">=</span><span class="s">&quot;The following chunk violates protocol:&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_sf_violation</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sctp_sf_abort_violation</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span> <span class="n">err_str</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">err_str</span><span class="p">));</span>
<span class="p">}</span>
<span class="cm">/***************************************************************************</span>
<span class="cm"> * These are the state functions for handling primitive (Section 10) events.</span>
<span class="cm"> ***************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * sctp_sf_do_prm_asoc</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 10.1 ULP-to-SCTP</span>
<span class="cm"> * B) Associate</span>
<span class="cm"> *</span>
<span class="cm"> * Format: ASSOCIATE(local SCTP instance name, destination transport addr,</span>
<span class="cm"> * outbound stream count)</span>
<span class="cm"> * -&gt; association id [,destination transport addr list] [,outbound stream</span>
<span class="cm"> * count]</span>
<span class="cm"> *</span>
<span class="cm"> * This primitive allows the upper layer to initiate an association to a</span>
<span class="cm"> * specific peer endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * The peer endpoint shall be specified by one of the transport addresses</span>
<span class="cm"> * which defines the endpoint (see Section 1.4).  If the local SCTP</span>
<span class="cm"> * instance has not been initialized, the ASSOCIATE is considered an</span>
<span class="cm"> * error.</span>
<span class="cm"> * [This is not relevant for the kernel implementation since we do all</span>
<span class="cm"> * initialization at boot time.  It we hadn&#39;t initialized we wouldn&#39;t</span>
<span class="cm"> * get anywhere near this code.]</span>
<span class="cm"> *</span>
<span class="cm"> * An association id, which is a local handle to the SCTP association,</span>
<span class="cm"> * will be returned on successful establishment of the association. If</span>
<span class="cm"> * SCTP is not able to open an SCTP association with the peer endpoint,</span>
<span class="cm"> * an error is returned.</span>
<span class="cm"> * [In the kernel implementation, the struct sctp_association needs to</span>
<span class="cm"> * be created BEFORE causing this primitive to run.]</span>
<span class="cm"> *</span>
<span class="cm"> * Other association parameters may be returned, including the</span>
<span class="cm"> * complete destination transport addresses of the peer as well as the</span>
<span class="cm"> * outbound stream count of the local endpoint. One of the transport</span>
<span class="cm"> * address from the returned destination addresses will be selected by</span>
<span class="cm"> * the local endpoint as default primary path for sending SCTP packets</span>
<span class="cm"> * to this peer.  The returned &quot;destination transport addr list&quot; can</span>
<span class="cm"> * be used by the ULP to change the default primary path or to force</span>
<span class="cm"> * sending a packet to a specific transport address.  [All of this</span>
<span class="cm"> * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING</span>
<span class="cm"> * function.]</span>
<span class="cm"> *</span>
<span class="cm"> * Mandatory attributes:</span>
<span class="cm"> *</span>
<span class="cm"> * o local SCTP instance name - obtained from the INITIALIZE operation.</span>
<span class="cm"> *   [This is the argument asoc.]</span>
<span class="cm"> * o destination transport addr - specified as one of the transport</span>
<span class="cm"> * addresses of the peer endpoint with which the association is to be</span>
<span class="cm"> * established.</span>
<span class="cm"> *  [This is asoc-&gt;peer.active_path.]</span>
<span class="cm"> * o outbound stream count - the number of outbound streams the ULP</span>
<span class="cm"> * would like to open towards this peer endpoint.</span>
<span class="cm"> * [BUG: This is not currently implemented.]</span>
<span class="cm"> * Optional attributes:</span>
<span class="cm"> *</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is a disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_prm_asoc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span><span class="o">*</span> <span class="n">my_asoc</span><span class="p">;</span>

	<span class="cm">/* The comment below says that we enter COOKIE-WAIT AFTER</span>
<span class="cm">	 * sending the INIT, but that doesn&#39;t actually work in our</span>
<span class="cm">	 * implementation...</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_COOKIE_WAIT</span><span class="p">));</span>

	<span class="cm">/* RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm">	 *</span>
<span class="cm">	 * A) &quot;A&quot; first sends an INIT chunk to &quot;Z&quot;.  In the INIT, &quot;A&quot;</span>
<span class="cm">	 * must provide its Verification Tag (Tag_A) in the Initiate</span>
<span class="cm">	 * Tag field.  Tag_A SHOULD be a random number in the range of</span>
<span class="cm">	 * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...</span>
<span class="cm">	 */</span>

	<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Cast away the const modifier, as we want to just</span>
<span class="cm">	 * rerun it through as a sideffect.</span>
<span class="cm">	 */</span>
	<span class="n">my_asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_ASOC</span><span class="p">,</span> <span class="n">SCTP_ASOC</span><span class="p">(</span><span class="n">my_asoc</span><span class="p">));</span>

	<span class="cm">/* Choose transport for INIT. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_CHOOSE_TRANSPORT</span><span class="p">,</span>
			<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

	<span class="cm">/* After sending the INIT, &quot;A&quot; starts the T1-init timer and</span>
<span class="cm">	 * enters the COOKIE-WAIT state.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process the SEND primitive.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 10.1 ULP-to-SCTP</span>
<span class="cm"> * E) Send</span>
<span class="cm"> *</span>
<span class="cm"> * Format: SEND(association id, buffer address, byte count [,context]</span>
<span class="cm"> *         [,stream id] [,life time] [,destination transport address]</span>
<span class="cm"> *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )</span>
<span class="cm"> * -&gt; result</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main method to send user data via SCTP.</span>
<span class="cm"> *</span>
<span class="cm"> * Mandatory attributes:</span>
<span class="cm"> *</span>
<span class="cm"> *  o association id - local handle to the SCTP association</span>
<span class="cm"> *</span>
<span class="cm"> *  o buffer address - the location where the user message to be</span>
<span class="cm"> *    transmitted is stored;</span>
<span class="cm"> *</span>
<span class="cm"> *  o byte count - The size of the user data in number of bytes;</span>
<span class="cm"> *</span>
<span class="cm"> * Optional attributes:</span>
<span class="cm"> *</span>
<span class="cm"> *  o context - an optional 32 bit integer that will be carried in the</span>
<span class="cm"> *    sending failure notification to the ULP if the transportation of</span>
<span class="cm"> *    this User Message fails.</span>
<span class="cm"> *</span>
<span class="cm"> *  o stream id - to indicate which stream to send the data on. If not</span>
<span class="cm"> *    specified, stream 0 will be used.</span>
<span class="cm"> *</span>
<span class="cm"> *  o life time - specifies the life time of the user data. The user data</span>
<span class="cm"> *    will not be sent by SCTP after the life time expires. This</span>
<span class="cm"> *    parameter can be used to avoid efforts to transmit stale</span>
<span class="cm"> *    user messages. SCTP notifies the ULP if the data cannot be</span>
<span class="cm"> *    initiated to transport (i.e. sent to the destination via SCTP&#39;s</span>
<span class="cm"> *    send primitive) within the life time variable. However, the</span>
<span class="cm"> *    user data will be transmitted if SCTP has attempted to transmit a</span>
<span class="cm"> *    chunk before the life time expired.</span>
<span class="cm"> *</span>
<span class="cm"> *  o destination transport address - specified as one of the destination</span>
<span class="cm"> *    transport addresses of the peer endpoint to which this packet</span>
<span class="cm"> *    should be sent. Whenever possible, SCTP should use this destination</span>
<span class="cm"> *    transport address for sending the packets, instead of the current</span>
<span class="cm"> *    primary path.</span>
<span class="cm"> *</span>
<span class="cm"> *  o unorder flag - this flag, if present, indicates that the user</span>
<span class="cm"> *    would like the data delivered in an unordered fashion to the peer</span>
<span class="cm"> *    (i.e., the U flag is set to 1 on all DATA chunks carrying this</span>
<span class="cm"> *    message).</span>
<span class="cm"> *</span>
<span class="cm"> *  o no-bundle flag - instructs SCTP not to bundle this user data with</span>
<span class="cm"> *    other outbound DATA chunks. SCTP MAY still bundle even when</span>
<span class="cm"> *    this flag is present, when faced with network congestion.</span>
<span class="cm"> *</span>
<span class="cm"> *  o payload protocol-id - A 32 bit unsigned integer that is to be</span>
<span class="cm"> *    passed to the peer indicating the type of payload protocol data</span>
<span class="cm"> *    being transmitted. This value is passed as opaque data by SCTP.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_prm_send</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_MSG</span><span class="p">,</span> <span class="n">SCTP_DATAMSG</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process the SHUTDOWN primitive.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 10.1:</span>
<span class="cm"> * C) Shutdown</span>
<span class="cm"> *</span>
<span class="cm"> * Format: SHUTDOWN(association id)</span>
<span class="cm"> * -&gt; result</span>
<span class="cm"> *</span>
<span class="cm"> * Gracefully closes an association. Any locally queued user data</span>
<span class="cm"> * will be delivered to the peer. The association will be terminated only</span>
<span class="cm"> * after the peer acknowledges all the SCTP packets sent.  A success code</span>
<span class="cm"> * will be returned on successful termination of the association. If</span>
<span class="cm"> * attempting to terminate the association results in a failure, an error</span>
<span class="cm"> * code shall be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Mandatory attributes:</span>
<span class="cm"> *</span>
<span class="cm"> *  o association id - local handle to the SCTP association</span>
<span class="cm"> *</span>
<span class="cm"> * Optional attributes:</span>
<span class="cm"> *</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_prm_shutdown</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">disposition</span><span class="p">;</span>

	<span class="cm">/* From 9.2 Shutdown of an Association</span>
<span class="cm">	 * Upon receipt of the SHUTDOWN primitive from its upper</span>
<span class="cm">	 * layer, the endpoint enters SHUTDOWN-PENDING state and</span>
<span class="cm">	 * remains there until all outstanding data has been</span>
<span class="cm">	 * acknowledged by its peer. The endpoint accepts no new data</span>
<span class="cm">	 * from its upper layer, but retransmits data to the far end</span>
<span class="cm">	 * if necessary to fill gaps.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_SHUTDOWN_PENDING</span><span class="p">));</span>

	<span class="n">disposition</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_outq_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">disposition</span> <span class="o">=</span> <span class="n">sctp_sf_do_9_2_start_shutdown</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
							    <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">disposition</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process the ABORT primitive.</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 10.1:</span>
<span class="cm"> * C) Abort</span>
<span class="cm"> *</span>
<span class="cm"> * Format: Abort(association id [, cause code])</span>
<span class="cm"> * -&gt; result</span>
<span class="cm"> *</span>
<span class="cm"> * Ungracefully closes an association. Any locally queued user data</span>
<span class="cm"> * will be discarded and an ABORT chunk is sent to the peer.  A success code</span>
<span class="cm"> * will be returned on successful abortion of the association. If</span>
<span class="cm"> * attempting to abort the association results in a failure, an error</span>
<span class="cm"> * code shall be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Mandatory attributes:</span>
<span class="cm"> *</span>
<span class="cm"> *  o association id - local handle to the SCTP association</span>
<span class="cm"> *</span>
<span class="cm"> * Optional attributes:</span>
<span class="cm"> *</span>
<span class="cm"> *  o cause code - reason of the abort to be passed to the peer</span>
<span class="cm"> *</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_1_prm_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* From 9.1 Abort of an Association</span>
<span class="cm">	 * Upon receipt of the ABORT primitive from its upper</span>
<span class="cm">	 * layer, the endpoint enters CLOSED state and</span>
<span class="cm">	 * discard all outstanding data has been</span>
<span class="cm">	 * acknowledged by its peer. The endpoint accepts no new data</span>
<span class="cm">	 * from its upper layer, but retransmits data to the far end</span>
<span class="cm">	 * if necessary to fill gaps.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">abort</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_disposition_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">abort</span><span class="p">));</span>

	<span class="cm">/* Even if we can&#39;t send the ABORT due to low memory delete the</span>
<span class="cm">	 * TCB.  This is a departure from our typical NOMEM handling.</span>
<span class="cm">	 */</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
			<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNABORTED</span><span class="p">));</span>
	<span class="cm">/* Delete the established association. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
			<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_USER_ABORT</span><span class="p">));</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
	<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We tried an illegal operation on an association which is closed.  */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_error_closed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_ERROR</span><span class="p">,</span> <span class="n">SCTP_ERROR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We tried an illegal operation on an association which is shutting</span>
<span class="cm"> * down.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_error_shutdown</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					  <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					  <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_ERROR</span><span class="p">,</span>
			<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_cookie_wait_prm_shutdown</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 Note: 2</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explicitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues a shutdown while in COOKIE_WAIT state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_wait_prm_shutdown</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_SHUTDOWNS</span><span class="p">);</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DELETE_TCB</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_cookie_echoed_prm_shutdown</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 Note: 2</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explcitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues a shutdown while in COOKIE_ECHOED state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_echoed_prm_shutdown</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* There is a single T1 timer, so we should be able to use</span>
<span class="cm">	 * common function with the COOKIE-WAIT state.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_cookie_wait_prm_shutdown</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_cookie_wait_prm_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 Note: 2</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explicitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues an abort while in COOKIE_WAIT state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_wait_prm_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">abort</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">sctp_disposition_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Stop T1-init timer */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">abort</span><span class="p">));</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_CLOSED</span><span class="p">));</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>

	<span class="cm">/* Even if we can&#39;t send the ABORT due to low memory delete the</span>
<span class="cm">	 * TCB.  This is a departure from our typical NOMEM handling.</span>
<span class="cm">	 */</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
			<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNREFUSED</span><span class="p">));</span>
	<span class="cm">/* Delete the established association. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_FAILED</span><span class="p">,</span>
			<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_USER_ABORT</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_cookie_echoed_prm_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 Note: 3</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explcitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues an abort while in COOKIE_ECHOED state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_cookie_echoed_prm_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* There is a single T1 timer, so we should be able to use</span>
<span class="cm">	 * common function with the COOKIE-WAIT state.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_cookie_wait_prm_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_shutdown_pending_prm_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explicitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues an abort while in SHUTDOWN-PENDING state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shutdown_pending_prm_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop the T5-shutdown guard timer.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">sctp_sf_do_9_1_prm_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_shutdown_sent_prm_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explicitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues an abort while in SHUTDOWN-SENT state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shutdown_sent_prm_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop the T2-shutdown timer.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="cm">/* Stop the T5-shutdown guard timer.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">sctp_sf_do_9_1_prm_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_cookie_echoed_prm_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> * The RFC does not explcitly address this issue, but is the route through the</span>
<span class="cm"> * state table when someone issues an abort while in COOKIE_ECHOED state.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers)</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_shutdown_ack_sent_prm_abort</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The same T2 timer, so we should be able to use</span>
<span class="cm">	 * common function with the SHUTDOWN-SENT state.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sctp_sf_shutdown_sent_prm_abort</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process the REQUESTHEARTBEAT primitive</span>
<span class="cm"> *</span>
<span class="cm"> * 10.1 ULP-to-SCTP</span>
<span class="cm"> * J) Request Heartbeat</span>
<span class="cm"> *</span>
<span class="cm"> * Format: REQUESTHEARTBEAT(association id, destination transport address)</span>
<span class="cm"> *</span>
<span class="cm"> * -&gt; result</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs the local endpoint to perform a HeartBeat on the specified</span>
<span class="cm"> * destination transport address of the given association. The returned</span>
<span class="cm"> * result should indicate whether the transmission of the HEARTBEAT</span>
<span class="cm"> * chunk to the destination address is successful.</span>
<span class="cm"> *</span>
<span class="cm"> * Mandatory attributes:</span>
<span class="cm"> *</span>
<span class="cm"> * o association id - local handle to the SCTP association</span>
<span class="cm"> *</span>
<span class="cm"> * o destination transport address - the transport address of the</span>
<span class="cm"> *   association on which a heartbeat should be issued.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_prm_requestheartbeat</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_DISPOSITION_NOMEM</span> <span class="o">==</span> <span class="n">sctp_sf_heartbeat</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
				      <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * RFC 2960 (bis), section 8.3</span>
<span class="cm">	 *</span>
<span class="cm">	 *    D) Request an on-demand HEARTBEAT on a specific destination</span>
<span class="cm">	 *    transport address of a given association.</span>
<span class="cm">	 *</span>
<span class="cm">	 *    The endpoint should increment the respective error  counter of</span>
<span class="cm">	 *    the destination transport address each time a HEARTBEAT is sent</span>
<span class="cm">	 *    to that address and not acknowledged within one RTO.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TRANSPORT_HB_SENT</span><span class="p">,</span>
			<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ADDIP Section 4.1 ASCONF Chunk Procedures</span>
<span class="cm"> * When an endpoint has an ASCONF signaled change to be sent to the</span>
<span class="cm"> * remote endpoint it should do A1 to A9</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_prm_asconf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SETUP_T4</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ignore the primitive event</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the primitive.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_ignore_primitive</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Primitive type %d is ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">primitive</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***************************************************************************</span>
<span class="cm"> * These are the state functions for the OTHER events.</span>
<span class="cm"> ***************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * When the SCTP stack has no more user data to send or retransmit, this</span>
<span class="cm"> * notification is given to the user. Also, at the time when a user app</span>
<span class="cm"> * subscribes to this event, if there is no data to be sent or</span>
<span class="cm"> * retransmit, the stack will immediately send up this notification.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_no_pending_tsn</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_sender_dry_event</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_EVENT_ULP</span><span class="p">,</span> <span class="n">SCTP_ULPEVENT</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the shutdown negotiation.</span>
<span class="cm"> *</span>
<span class="cm"> * From Section 9.2:</span>
<span class="cm"> * Once all its outstanding data has been acknowledged, the endpoint</span>
<span class="cm"> * shall send a SHUTDOWN chunk to its peer including in the Cumulative</span>
<span class="cm"> * TSN Ack field the last sequential TSN it has received from the peer.</span>
<span class="cm"> * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT</span>
<span class="cm"> * state. If the timer expires, the endpoint must re-send the SHUTDOWN</span>
<span class="cm"> * with the updated last sequential TSN received from its peer.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_start_shutdown</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>

	<span class="cm">/* Once all its outstanding data has been acknowledged, the</span>
<span class="cm">	 * endpoint shall send a SHUTDOWN chunk to its peer including</span>
<span class="cm">	 * in the Cumulative TSN Ack field the last sequential TSN it</span>
<span class="cm">	 * has received from the peer.</span>
<span class="cm">	 */</span>
	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_shutdown</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Set the transport for the SHUTDOWN chunk and the timeout for the</span>
<span class="cm">	 * T2-shutdown timer.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SETUP_T2</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="cm">/* It shall then start the T2-shutdown timer */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="cm">/* RFC 4960 Section 9.2</span>
<span class="cm">	 * The sender of the SHUTDOWN MAY also start an overall guard timer</span>
<span class="cm">	 * &#39;T5-shutdown-guard&#39; to bound the overall time for shutdown sequence.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">));</span>

	<span class="cm">/* and enter the SHUTDOWN-SENT state.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_SHUTDOWN_SENT</span><span class="p">));</span>

	<span class="cm">/* sctp-implguide 2.10 Issues with Heartbeating and failover</span>
<span class="cm">	 *</span>
<span class="cm">	 * HEARTBEAT ... is discontinued after sending either SHUTDOWN</span>
<span class="cm">	 * or SHUTDOWN-ACK.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_STOP</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generate a SHUTDOWN ACK now that everything is SACK&#39;d.</span>
<span class="cm"> *</span>
<span class="cm"> * From Section 9.2:</span>
<span class="cm"> *</span>
<span class="cm"> * If it has no more outstanding DATA chunks, the SHUTDOWN receiver</span>
<span class="cm"> * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,</span>
<span class="cm"> * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the</span>
<span class="cm"> * endpoint must re-send the SHUTDOWN ACK.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_9_2_shutdown_ack</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>

	<span class="cm">/* There are 2 ways of getting here:</span>
<span class="cm">	 *    1) called in response to a SHUTDOWN chunk</span>
<span class="cm">	 *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For the case (2), the arg parameter is set to NULL.  We need</span>
<span class="cm">	 * to check that we have a chunk before accessing it&#39;s fields.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_vtag_verify</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sctp_sf_pdiscard</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>

		<span class="cm">/* Make sure that the SHUTDOWN chunk has a valid length. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_length_valid</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_chunk_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">sctp_sf_violation_chunklen</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
							  <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver</span>
<span class="cm">	 * shall send a SHUTDOWN ACK ...</span>
<span class="cm">	 */</span>
	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_shutdown_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Set the transport for the SHUTDOWN ACK chunk and the timeout for</span>
<span class="cm">	 * the T2-shutdown timer.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SETUP_T2</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="cm">/* and start/restart a T2-shutdown timer of its own, */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">));</span>

	<span class="cm">/* Enter the SHUTDOWN-ACK-SENT state.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_SHUTDOWN_ACK_SENT</span><span class="p">));</span>

	<span class="cm">/* sctp-implguide 2.10 Issues with Heartbeating and failover</span>
<span class="cm">	 *</span>
<span class="cm">	 * HEARTBEAT ... is discontinued after sending either SHUTDOWN</span>
<span class="cm">	 * or SHUTDOWN-ACK.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_HB_TIMERS_STOP</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ignore the event defined as other</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the event.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_ignore_other</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;The event other type %d is ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">other</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DISCARD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************************</span>
<span class="cm"> * These are the state functions for handling timeout events.</span>
<span class="cm"> ************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * RTX Timeout</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 6.3.3 Handle T3-rtx Expiration</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever the retransmission timer T3-rtx expires for a destination</span>
<span class="cm"> * address, do the following:</span>
<span class="cm"> * [See below]</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_6_3_3_rtx</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T3_RTX_EXPIREDS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We are here likely because the receiver had its rwnd</span>
<span class="cm">			 * closed for a while and we have not been able to</span>
<span class="cm">			 * transmit the locally queued data within the maximum</span>
<span class="cm">			 * retransmission attempts limit.  Start the T5</span>
<span class="cm">			 * shutdown guard timer to give the receiver one last</span>
<span class="cm">			 * chance and some additional time to recover before</span>
<span class="cm">			 * aborting.</span>
<span class="cm">			 */</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_START_ONCE</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
					<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
			<span class="cm">/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
					<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>
			<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
			<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* E1) For the destination address for which the timer</span>
<span class="cm">	 * expires, adjust its ssthresh with rules defined in Section</span>
<span class="cm">	 * 7.2.3 and set the cwnd &lt;- MTU.</span>
<span class="cm">	 */</span>

	<span class="cm">/* E2) For the destination address for which the timer</span>
<span class="cm">	 * expires, set RTO &lt;- RTO * 2 (&quot;back off the timer&quot;).  The</span>
<span class="cm">	 * maximum value discussed in rule C7 above (RTO.max) may be</span>
<span class="cm">	 * used to provide an upper bound to this doubling operation.</span>
<span class="cm">	 */</span>

	<span class="cm">/* E3) Determine how many of the earliest (i.e., lowest TSN)</span>
<span class="cm">	 * outstanding DATA chunks for the address for which the</span>
<span class="cm">	 * T3-rtx has expired will fit into a single packet, subject</span>
<span class="cm">	 * to the MTU constraint for the path corresponding to the</span>
<span class="cm">	 * destination transport address to which the retransmission</span>
<span class="cm">	 * is being sent (this may be different from the address for</span>
<span class="cm">	 * which the timer expires [see Section 6.4]).  Call this</span>
<span class="cm">	 * value K. Bundle and retransmit those K DATA chunks in a</span>
<span class="cm">	 * single packet to the destination endpoint.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Any DATA chunks that were sent to the address for</span>
<span class="cm">	 * which the T3-rtx timer expired but did not fit in one MTU</span>
<span class="cm">	 * (rule E3 above), should be marked for retransmission and</span>
<span class="cm">	 * sent as soon as cwnd allows (normally when a SACK arrives).</span>
<span class="cm">	 */</span>

	<span class="cm">/* Do some failure management (Section 8.2). */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_STRIKE</span><span class="p">,</span> <span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>

	<span class="cm">/* NB: Rules E4 and F1 are implicit in R1.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_RETRAN</span><span class="p">,</span> <span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generate delayed SACK on timeout</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 6.2  Acknowledgement on Reception of DATA Chunks</span>
<span class="cm"> *</span>
<span class="cm"> * The guidelines on delayed acknowledgement algorithm specified in</span>
<span class="cm"> * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an</span>
<span class="cm"> * acknowledgement SHOULD be generated for at least every second packet</span>
<span class="cm"> * (not every second DATA chunk) received, and SHOULD be generated</span>
<span class="cm"> * within 200 ms of the arrival of any unacknowledged DATA chunk.  In</span>
<span class="cm"> * some situations it may be beneficial for an SCTP transmitter to be</span>
<span class="cm"> * more conservative than the algorithms detailed in this document</span>
<span class="cm"> * allow. However, an SCTP transmitter MUST NOT be more aggressive than</span>
<span class="cm"> * the following algorithms allow.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_do_6_2_sack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_DELAY_SACK_EXPIREDS</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_GEN_SACK</span><span class="p">,</span> <span class="n">SCTP_FORCE</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_t1_init_timer_expire</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 Note: 2</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> *  RFC 2960 Section 4 Notes</span>
<span class="cm"> *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT</span>
<span class="cm"> *     and re-start the T1-init timer without changing state.  This MUST</span>
<span class="cm"> *     be repeated up to &#39;Max.Init.Retransmits&#39; times.  After that, the</span>
<span class="cm"> *     endpoint MUST abort the initialization process and report the</span>
<span class="cm"> *     error to SCTP user.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers, events)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_t1_init_timer_expire</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">attempts</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Timer T1 expired (INIT).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T1_INIT_EXPIREDS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attempts</span> <span class="o">&lt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
		<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

		<span class="cm">/* Choose transport for INIT. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_CHOOSE_TRANSPORT</span><span class="p">,</span>
				<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>

		<span class="cm">/* Issue a sideeffect to do the needed accounting. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_RESTART</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">));</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Giving up on INIT, attempts: %d&quot;</span>
				  <span class="s">&quot; max_init_attempts: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">attempts</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span><span class="p">);</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sctp_sf_t1_cookie_timer_expire</span>
<span class="cm"> *</span>
<span class="cm"> * Section: 4 Note: 2</span>
<span class="cm"> * Verification Tag:</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc)</span>
<span class="cm"> *</span>
<span class="cm"> *  RFC 2960 Section 4 Notes</span>
<span class="cm"> *  3) If the T1-cookie timer expires, the endpoint MUST retransmit</span>
<span class="cm"> *     COOKIE ECHO and re-start the T1-cookie timer without changing</span>
<span class="cm"> *     state.  This MUST be repeated up to &#39;Max.Init.Retransmits&#39; times.</span>
<span class="cm"> *     After that, the endpoint MUST abort the initialization process and</span>
<span class="cm"> *     report the error to SCTP user.</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * (timers, events)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_t1_cookie_timer_expire</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">repl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">attempts</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_err_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Timer T1 expired (COOKIE-ECHO).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T1_COOKIE_EXPIREDS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attempts</span> <span class="o">&lt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">repl</span> <span class="o">=</span> <span class="n">sctp_make_cookie_echo</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">repl</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_CHOOSE_TRANSPORT</span><span class="p">,</span>
				<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>
		<span class="cm">/* Issue a sideeffect to do the needed accounting. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_COOKIEECHO_RESTART</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">));</span>

		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_INIT_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN</span>
<span class="cm"> * with the updated last sequential TSN received from its peer.</span>
<span class="cm"> *</span>
<span class="cm"> * An endpoint should limit the number of retransmissions of the</span>
<span class="cm"> * SHUTDOWN chunk to the protocol parameter &#39;Association.Max.Retrans&#39;.</span>
<span class="cm"> * If this threshold is exceeded the endpoint should destroy the TCB and</span>
<span class="cm"> * MUST report the peer endpoint unreachable to the upper layer (and</span>
<span class="cm"> * thus the association enters the CLOSED state).  The reception of any</span>
<span class="cm"> * packet from its peer (i.e. as the peer sends all of its queued DATA</span>
<span class="cm"> * chunks) should clear the endpoint&#39;s retransmission count and restart</span>
<span class="cm"> * the T2-Shutdown timer,  giving its peer ample opportunity to transmit</span>
<span class="cm"> * all of its queued DATA chunks that have not yet been sent.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_t2_timer_expire</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Timer T2 expired.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T2_SHUTDOWN_EXPIREDS</span><span class="p">);</span>

	<span class="p">((</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shutdown_retries</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
		<span class="cm">/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_SENT</span>:
		<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_shutdown</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_ACK_SENT</span>:
		<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_shutdown_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Do some failure management (Section 8.2).</span>
<span class="cm">	 * If we remove the transport an SHUTDOWN was last sent to, don&#39;t</span>
<span class="cm">	 * do failure management.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">shutdown_last_sent_to</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_STRIKE</span><span class="p">,</span>
				<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">shutdown_last_sent_to</span><span class="p">));</span>

	<span class="cm">/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for</span>
<span class="cm">	 * the T2-shutdown timer.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SETUP_T2</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>

	<span class="cm">/* Restart the T2-shutdown timer.  */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ADDIP Section 4.1 ASCONF CHunk Procedures</span>
<span class="cm"> * If the T4 RTO timer expires the endpoint should do B1 to B5</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_t4_timer_expire</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T4_RTO_EXPIREDS</span><span class="p">);</span>

	<span class="cm">/* ADDIP 4.1 B1) Increment the error counters and perform path failure</span>
<span class="cm">	 * detection on the appropriate destination address as defined in</span>
<span class="cm">	 * RFC2960 [5] section 8.1 and 8.2.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="p">)</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_STRIKE</span><span class="p">,</span>
				<span class="n">SCTP_TRANSPORT</span><span class="p">(</span><span class="n">transport</span><span class="p">));</span>

	<span class="cm">/* Reconfig T4 timer and transport. */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SETUP_T4</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>

	<span class="cm">/* ADDIP 4.1 B2) Increment the association error counters and perform</span>
<span class="cm">	 * endpoint failure detection on the association as defined in</span>
<span class="cm">	 * RFC2960 [5] section 8.1 and 8.2.</span>
<span class="cm">	 * association error counter is incremented in SCTP_CMD_STRIKE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_STOP</span><span class="p">,</span>
				<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_DISPOSITION_ABORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ADDIP 4.1 B3) Back-off the destination address RTO value to which</span>
<span class="cm">	 * the ASCONF chunk was sent by doubling the RTO timer value.</span>
<span class="cm">	 * This is done in SCTP_CMD_STRIKE.</span>
<span class="cm">	 */</span>

	<span class="cm">/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible</span>
<span class="cm">	 * choose an alternate destination address (please refer to RFC2960</span>
<span class="cm">	 * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this</span>
<span class="cm">	 * chunk, it MUST be the same (including its serial number) as the last</span>
<span class="cm">	 * ASCONF sent.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">);</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
			<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">));</span>

	<span class="cm">/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different</span>
<span class="cm">	 * destination is selected, then the RTO used will be that of the new</span>
<span class="cm">	 * destination address.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_TIMER_RESTART</span><span class="p">,</span>
			<span class="n">SCTP_TO</span><span class="p">(</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sctpimpguide-05 Section 2.12.2</span>
<span class="cm"> * The sender of the SHUTDOWN MAY also start an overall guard timer</span>
<span class="cm"> * &#39;T5-shutdown-guard&#39; to bound the overall time for shutdown sequence.</span>
<span class="cm"> * At the expiration of this timer the sender SHOULD abort the association</span>
<span class="cm"> * by sending an ABORT chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_t5_timer_expire</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					   <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Timer T5 expired.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS</span><span class="p">);</span>

	<span class="n">reply</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
			<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">));</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
			<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">));</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
	<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_DELETE_TCB</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,</span>
<span class="cm"> * the association is automatically closed by starting the shutdown process.</span>
<span class="cm"> * The work that needs to be done is same as when SHUTDOWN is initiated by</span>
<span class="cm"> * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_autoclose_timer_expire</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">disposition</span><span class="p">;</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_AUTOCLOSE_EXPIREDS</span><span class="p">);</span>

	<span class="cm">/* From 9.2 Shutdown of an Association</span>
<span class="cm">	 * Upon receipt of the SHUTDOWN primitive from its upper</span>
<span class="cm">	 * layer, the endpoint enters SHUTDOWN-PENDING state and</span>
<span class="cm">	 * remains there until all outstanding data has been</span>
<span class="cm">	 * acknowledged by its peer. The endpoint accepts no new data</span>
<span class="cm">	 * from its upper layer, but retransmits data to the far end</span>
<span class="cm">	 * if necessary to fill gaps.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_NEW_STATE</span><span class="p">,</span>
			<span class="n">SCTP_STATE</span><span class="p">(</span><span class="n">SCTP_STATE_SHUTDOWN_PENDING</span><span class="p">));</span>

	<span class="n">disposition</span> <span class="o">=</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_outq_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">disposition</span> <span class="o">=</span> <span class="n">sctp_sf_do_9_2_start_shutdown</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
							    <span class="n">arg</span><span class="p">,</span> <span class="n">commands</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">disposition</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> * These are sa state functions which could apply to all types of events.</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * This table entry is not implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_not_impl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
				    <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_NOT_IMPL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This table entry represents a bug.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_bug</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
			       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_BUG</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This table entry represents the firing of a timer in the wrong state.</span>
<span class="cm"> * Since timer deletion cannot be guaranteed a timer &#39;may&#39; end up firing</span>
<span class="cm"> * when the association is in the wrong state.   This event should</span>
<span class="cm"> * be ignored, so as to prevent any rearming of the timer.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> * (endpoint, asoc, chunk)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the disposition of the chunk.</span>
<span class="cm"> */</span>
<span class="n">sctp_disposition_t</span> <span class="nf">sctp_sf_timer_ignore</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">sctp_subtype_t</span> <span class="n">type</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
					<span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Timer %d ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">chunk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCTP_DISPOSITION_CONSUME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * 2nd Level Abstractions</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/* Pull the SACK chunk based on the SACK header. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="nf">sctp_sm_pull_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">num_blocks</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">num_dup_tsns</span><span class="p">;</span>

	<span class="cm">/* Protect ourselves from reading too far into</span>
<span class="cm">	 * the skb from a bogus sender.</span>
<span class="cm">	 */</span>
	<span class="n">sack</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">num_blocks</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">num_gap_ack_blocks</span><span class="p">);</span>
	<span class="n">num_dup_tsns</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sack</span><span class="o">-&gt;</span><span class="n">num_dup_tsns</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sackhdr</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_blocks</span> <span class="o">+</span> <span class="n">num_dup_tsns</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sack</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create an ABORT packet to be sent as a response, with the specified</span>
<span class="cm"> * error causes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="nf">sctp_abort_pkt_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">abort</span><span class="p">;</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_ootb_pkt_new</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make an ABORT.</span>
<span class="cm">		 * The T bit will be set if the asoc is NULL.</span>
<span class="cm">		 */</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abort</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_ootb_pkt_free</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Reflect vtag if T-Bit is set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_test_T_bit</span><span class="p">(</span><span class="n">abort</span><span class="p">))</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">);</span>

		<span class="cm">/* Add specified error causes, i.e., payload, to the</span>
<span class="cm">		 * end of the chunk.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">abort</span><span class="p">,</span> <span class="n">paylen</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

		<span class="cm">/* Set the skb to the belonging sock for accounting.  */</span>
		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">abort</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">packet</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate a packet for responding in the OOTB conditions.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="nf">sctp_ootb_pkt_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sport</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">dport</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vtag</span><span class="p">;</span>

	<span class="cm">/* Get the source and destination port from the inbound packet.  */</span>
	<span class="n">sport</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">dport</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">);</span>

	<span class="cm">/* The V-tag is going to be the same as the inbound packet if no</span>
<span class="cm">	 * association exists, otherwise, use the peer&#39;s vtag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special case the INIT-ACK as there is no peer&#39;s vtag</span>
<span class="cm">		 * yet.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_CID_INIT_ACK</span>:
		<span class="p">{</span>
			<span class="n">sctp_initack_chunk_t</span> <span class="o">*</span><span class="n">initack</span><span class="p">;</span>

			<span class="n">initack</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_initack_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>
			<span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">initack</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">init_tag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">vtag</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Special case the INIT and stale COOKIE_ECHO as there is no</span>
<span class="cm">		 * vtag yet.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_CID_INIT</span>:
		<span class="p">{</span>
			<span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>

			<span class="n">init</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">;</span>
			<span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">init_tag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">vtag</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Make a transport for the bucket, Eliza... */</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_transport_new</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="cm">/* Cache a route for the transport with the chunk&#39;s destination as</span>
<span class="cm">	 * the source address.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_transport_route</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span>
			     <span class="n">sctp_sk</span><span class="p">(</span><span class="n">sctp_get_ctl_sock</span><span class="p">()));</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_packet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">sport</span><span class="p">,</span> <span class="n">dport</span><span class="p">);</span>
	<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_packet_config</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">vtag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">packet</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free the packet allocated earlier for responding in the OOTB condition.  */</span>
<span class="kt">void</span> <span class="nf">sctp_ootb_pkt_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_transport_free</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_send_stale_cookie_err</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				       <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err_chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="n">sctp_ootb_pkt_new</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>

			<span class="cm">/* Override the OOTB vtag from the cookie. */</span>
			<span class="n">cookie</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span><span class="p">;</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">vtag</span> <span class="o">=</span> <span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span><span class="p">;</span>

			<span class="cm">/* Set the skb to the belonging sock for accounting. */</span>
			<span class="n">err_chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
			<span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">err_chunk</span><span class="p">);</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SEND_PKT</span><span class="p">,</span>
					<span class="n">SCTP_PACKET</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
			<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTCTRLCHUNKS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sctp_chunk_free</span> <span class="p">(</span><span class="n">err_chunk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Process a data chunk */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_eat_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
			 <span class="n">sctp_cmd_seq_t</span> <span class="o">*</span><span class="n">commands</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_datahdr_t</span> <span class="o">*</span><span class="n">data_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="n">sctp_verb_t</span> <span class="n">deliver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tsn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_tsnmap</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_tsnmap</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ssn</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ordered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data_hdr</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_datahdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_datahdr_t</span><span class="p">));</span>

	<span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;eat_data: TSN 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>

	<span class="cm">/* ASSERT:  Now skb-&gt;data is really the user data.  */</span>

	<span class="cm">/* Process ECN based congestion.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since the chunk structure is reused for all chunks within</span>
<span class="cm">	 * a packet, we use ecn_ce_done to track if we&#39;ve already</span>
<span class="cm">	 * done CE processing for this packet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to do ECN processing even if we plan to discard the</span>
<span class="cm">	 * chunk later.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">ecn_ce_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">ecn_ce_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span>
			<span class="n">ipver2af</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">&amp;&amp;</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">is_ce</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Do real work as sideffect. */</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ECN_CE</span><span class="p">,</span>
					<span class="n">SCTP_U32</span><span class="p">(</span><span class="n">tsn</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">sctp_tsnmap_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The TSN is too high--silently discard the chunk and</span>
<span class="cm">		 * count on it getting retransmitted later.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_HIGH_TSN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is a duplicate.  Record it.  */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_DUP</span><span class="p">,</span> <span class="n">SCTP_U32</span><span class="p">(</span><span class="n">tsn</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_DUP_TSN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is a new TSN.  */</span>

	<span class="cm">/* Discard if there is no room in the receive window.</span>
<span class="cm">	 * Actually, allow a little bit of overflow (up to a MTU).</span>
<span class="cm">	 */</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">datalen</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_data_chunk_t</span><span class="p">);</span>

	<span class="n">deliver</span> <span class="o">=</span> <span class="n">SCTP_CMD_CHUNK_ULP</span><span class="p">;</span>

	<span class="cm">/* Think about partial delivery. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">datalen</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">.</span><span class="n">pd_mode</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Even if we don&#39;t accept this chunk there is</span>
<span class="cm">		 * memory pressure.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_PART_DELIVER</span><span class="p">,</span> <span class="n">SCTP_NULL</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="cm">/* Spill over rwnd a little bit.  Note: While allowed, this spill over</span>
<span class="cm">	 * seems a bit troublesome in that frag_point varies based on</span>
<span class="cm">	 * PMTU.  In cases, such as loopback, this might be a rather</span>
<span class="cm">	 * large spill over.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data_accepted</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">||</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">+</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/* If this is the next TSN, consider reneging to make</span>
<span class="cm">		 * room.   Note: Playing nice with a confused sender.  A</span>
<span class="cm">		 * malicious sender can still eat up all our buffer</span>
<span class="cm">		 * space and in the future we may want to detect and</span>
<span class="cm">		 * do more drastic reneging.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_tsnmap_has_gap</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Reneging for tsn:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
			<span class="n">deliver</span> <span class="o">=</span> <span class="n">SCTP_CMD_RENEGE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Discard tsn: %u len: %Zd, &quot;</span>
					  <span class="s">&quot;rwnd: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
					  <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SCTP_IERROR_IGNORE_TSN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Also try to renege to limit our memory usage in the event that</span>
<span class="cm">	 * we are under memory pressure</span>
<span class="cm">	 * If we can&#39;t renege, don&#39;t worry about it, the sk_rmem_schedule</span>
<span class="cm">	 * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our</span>
<span class="cm">	 * memory usage too much</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot_creator</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_tsnmap_has_gap</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	           <span class="p">(</span><span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Under Pressure! Reneging for tsn:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
			<span class="n">deliver</span> <span class="o">=</span> <span class="n">SCTP_CMD_RENEGE</span><span class="p">;</span>
		 <span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Section 3.3.10.9 No User Data (9)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Cause of error</span>
<span class="cm">	 * ---------------</span>
<span class="cm">	 * No User Data:  This error cause is returned to the originator of a</span>
<span class="cm">	 * DATA chunk if a received DATA chunk has no user data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">datalen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_make_abort_no_data</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">tsn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* We are going to ABORT, so we might as well stop</span>
<span class="cm">		 * processing the rest of the chunks in the packet.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_DISCARD_PACKET</span><span class="p">,</span><span class="n">SCTP_NULL</span><span class="p">());</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_SET_SK_ERR</span><span class="p">,</span>
				<span class="n">SCTP_ERROR</span><span class="p">(</span><span class="n">ECONNABORTED</span><span class="p">));</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_ASSOC_FAILED</span><span class="p">,</span>
				<span class="n">SCTP_PERR</span><span class="p">(</span><span class="n">SCTP_ERROR_NO_DATA</span><span class="p">));</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_ABORTEDS</span><span class="p">);</span>
		<span class="n">SCTP_DEC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_NO_DATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data_accepted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Note: Some chunks may get overcounted (if we drop) or overcounted</span>
<span class="cm">	 * if we renege and the chunk arrives again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_UNORDERED</span><span class="p">)</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_INUNORDERCHUNKS</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_INORDERCHUNKS</span><span class="p">);</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number</span>
<span class="cm">	 *</span>
<span class="cm">	 * If an endpoint receive a DATA chunk with an invalid stream</span>
<span class="cm">	 * identifier, it shall acknowledge the reception of the DATA chunk</span>
<span class="cm">	 * following the normal procedure, immediately send an ERROR chunk</span>
<span class="cm">	 * with cause set to &quot;Invalid Stream Identifier&quot; (See Section 3.3.10)</span>
<span class="cm">	 * and discard the DATA chunk.</span>
<span class="cm">	 */</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mark tsn as received even though we drop it */</span>
		<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPORT_TSN</span><span class="p">,</span> <span class="n">SCTP_U32</span><span class="p">(</span><span class="n">tsn</span><span class="p">));</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_make_op_error</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">SCTP_ERROR_INV_STRM</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">),</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">SCTP_CMD_REPLY</span><span class="p">,</span>
					<span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_BAD_STREAM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if the SSN is possible for this TSN.</span>
<span class="cm">	 * The biggest gap we can record is 4K wide.  Since SSNs wrap</span>
<span class="cm">	 * at an unsigned short, there is no way that an SSN can</span>
<span class="cm">	 * wrap and for a valid TSN.  We can simply check if the current</span>
<span class="cm">	 * SSN is smaller then the next expected one.  If it is, it wrapped</span>
<span class="cm">	 * and is invalid.</span>
<span class="cm">	 */</span>
	<span class="n">ssn</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span> <span class="o">&amp;&amp;</span> <span class="n">SSN_lt</span><span class="p">(</span><span class="n">ssn</span><span class="p">,</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">sid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">SCTP_IERROR_PROTO_VIOLATION</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send the data up to the user.  Note:  Schedule  the</span>
<span class="cm">	 * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK</span>
<span class="cm">	 * chunk needs the updated rwnd.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_add_cmd_sf</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">deliver</span><span class="p">,</span> <span class="n">SCTP_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">SCTP_IERROR_NO_ERROR</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
