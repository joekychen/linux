<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › transport.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>transport.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2003 International Business Machines Corp.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * This module provides the abstraction for an SCTP tranport representing</span>
<span class="cm"> * a remote transport address.  For local transport addresses, we just use</span>
<span class="cm"> * union sctp_addr.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Xingang Guo           &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Hui Huang             &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala	    &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="cm">/* 1st Level Abstractions.  */</span>

<span class="cm">/* Initialize a new transport from provided memory.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_transport_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
						  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Copy in the address.  */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">ipaddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">af_specific</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span><span class="p">));</span>

	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">sack_generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* From 6.3.1 RTO Calculation:</span>
<span class="cm">	 *</span>
<span class="cm">	 * C1) Until an RTT measurement has been made for a packet sent to the</span>
<span class="cm">	 * given destination transport address, set RTO to the protocol</span>
<span class="cm">	 * parameter &#39;RTO.Initial&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sctp_rto_initial</span><span class="p">);</span>

	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">last_time_heard</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">last_time_ecne_reduced</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span> <span class="n">SPP_HB_DISABLE</span> <span class="o">|</span>
			    <span class="n">SPP_PMTUD_ENABLE</span> <span class="o">|</span>
			    <span class="n">SPP_SACKDELAY_ENABLE</span><span class="p">;</span>

	<span class="cm">/* Initialize the default path max_retrans.  */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span>  <span class="o">=</span> <span class="n">sctp_max_retrans_path</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">send_ready</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transports</span><span class="p">);</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">,</span> <span class="n">sctp_generate_t3_rtx_event</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">peer</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span> <span class="n">sctp_generate_heartbeat_event</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">peer</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">,</span>
		    <span class="n">sctp_generate_proto_unreach_event</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">peer</span><span class="p">);</span>

	<span class="cm">/* Initialize the 64-bit random nonce sent with heartbeat. */</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">hb_nonce</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">hb_nonce</span><span class="p">));</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">peer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate and initialize a new transport.  */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_transport_new</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="n">transport</span> <span class="o">=</span> <span class="n">t_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_transport_init</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">SCTP_DBG_OBJCNT_INC</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">transport</span><span class="p">;</span>

<span class="nl">fail_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This transport is no longer needed.  Free up if possible, or</span>
<span class="cm"> * delay until it last reference count.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Try to delete the heartbeat timer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">))</span>
		<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

	<span class="cm">/* Delete the T3_rtx timer if it&#39;s active.</span>
<span class="cm">	 * There is no point in not doing this now and letting</span>
<span class="cm">	 * structure hang around in memory since we know</span>
<span class="cm">	 * the tranport is going away.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span>
		<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

	<span class="cm">/* Delete the ICMP proto unreachable timer if it&#39;s active. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">proto_unreach_timer</span><span class="p">))</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>

	<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Destroy the transport data structure.</span>
<span class="cm"> * Assumes there are no more users of this structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_transport_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">,</span> <span class="s">&quot;Transport is not dead&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">)</span>
		<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>

	<span class="n">sctp_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">);</span>

	<span class="n">dst_release</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
	<span class="n">SCTP_DBG_OBJCNT_DEC</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Start T3_rtx timer if it is not already running and update the heartbeat</span>
<span class="cm"> * timer.  This routine is called every time a DATA chunk is sent.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_reset_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* RFC 2960 6.3.2 Retransmission Timer Rules</span>
<span class="cm">	 *</span>
<span class="cm">	 * R1) Every time a DATA chunk is sent to any address(including a</span>
<span class="cm">	 * retransmission), if the T3-rtx timer of that address is not running</span>
<span class="cm">	 * start it running so that it will expire after the RTO of that</span>
<span class="cm">	 * address.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">,</span>
			       <span class="n">jiffies</span> <span class="o">+</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">))</span>
			<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

	<span class="cm">/* When a data chunk is sent, reset the heartbeat interval.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span>
		       <span class="n">sctp_transport_timeout</span><span class="p">(</span><span class="n">transport</span><span class="p">)))</span>
	    <span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This transport has been assigned to an association.</span>
<span class="cm"> * Initialize fields from the association or from the sock itself.</span>
<span class="cm"> * Register the reference count in the association.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_set_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">asoc</span><span class="p">;</span>
	<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize the pmtu of a transport. */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we don&#39;t have a fresh route, look one up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">||</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">obsolete</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dst_release</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">get_dst</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">dst_mtu</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXSEGMENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_transport_update_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pmtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmtu</span> <span class="o">&lt;</span> <span class="n">SCTP_DEFAULT_MINSEGMENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: Reported pmtu %d too low, using default minimum of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">pmtu</span><span class="p">,</span>
			<span class="n">SCTP_DEFAULT_MINSEGMENT</span><span class="p">);</span>
		<span class="cm">/* Use default minimum segment size and disable</span>
<span class="cm">		 * pmtu discovery on this transport.</span>
<span class="cm">		 */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MINSEGMENT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">pmtu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dst</span> <span class="o">=</span> <span class="n">sctp_transport_dst_check</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span>
		<span class="n">dst</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">update_pmtu</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">pmtu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caches the dst entry and source address for a transport&#39;s destination</span>
<span class="cm"> * address.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_route</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			  <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="p">;</span>

	<span class="n">af</span><span class="o">-&gt;</span><span class="n">get_dst</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">,</span> <span class="n">sctp_opt2sk</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">saddr</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">af</span><span class="o">-&gt;</span><span class="n">get_saddr</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_DISABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">dst_mtu</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>

		<span class="cm">/* Initialize sk-&gt;sk_rcv_saddr, if the transport is the</span>
<span class="cm">		 * association&#39;s active path for getsockname().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">transport</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">)))</span>
			<span class="n">opt</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">to_sk_saddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXSEGMENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Hold a reference to a transport.  */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Release a reference to a transport and clean up</span>
<span class="cm"> * if there are no more references.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">sctp_transport_destroy</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Update transport&#39;s RTO based on the newly calculated RTT. */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_update_rto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">rtt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check for valid transport.  */</span>
	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="s">&quot;NULL transport&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>

	<span class="cm">/* We should not be doing any RTO updates unless rto_pending is set.  */</span>
	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto_pending</span><span class="p">,</span> <span class="s">&quot;rto_pending not set&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 6.3.1 C3) When a new RTT measurement R&#39; is made, set</span>
<span class="cm">		 * RTTVAR &lt;- (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT - R&#39;|</span>
<span class="cm">		 * SRTT &lt;- (1 - RTO.Alpha) * SRTT + RTO.Alpha * R&#39;</span>
<span class="cm">		 */</span>

		<span class="cm">/* Note:  The above algorithm has been rewritten to</span>
<span class="cm">		 * express rto_beta and rto_alpha as inverse powers</span>
<span class="cm">		 * of two.</span>
<span class="cm">		 * For example, assuming the default value of RTO.Alpha of</span>
<span class="cm">		 * 1/8, rto_alpha would be expressed as 3.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">-</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">&gt;&gt;</span> <span class="n">sctp_rto_beta</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">-</span> <span class="n">rtt</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">sctp_rto_beta</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">-</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">&gt;&gt;</span> <span class="n">sctp_rto_alpha</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">(</span><span class="n">rtt</span> <span class="o">&gt;&gt;</span> <span class="n">sctp_rto_alpha</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 6.3.1 C2) When the first RTT measurement R is made, set</span>
<span class="cm">		 * SRTT &lt;- R, RTTVAR &lt;- R/2.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="n">rtt</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">rtt</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 6.3.1 G1) Whenever RTTVAR is computed, if RTTVAR = 0, then</span>
<span class="cm">	 * adjust RTTVAR &lt;- G, where G is the CLOCK GRANULARITY.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">SCTP_CLOCK_GRANULARITY</span><span class="p">;</span>

	<span class="cm">/* 6.3.1 C3) After the computation, update RTO &lt;- SRTT + 4 * RTTVAR. */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">+</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* 6.3.1 C6) Whenever RTO is computed, if it is less than RTO.Min</span>
<span class="cm">	 * seconds then it is rounded up to RTO.Min seconds.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_min</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_min</span><span class="p">;</span>

	<span class="cm">/* 6.3.1 C7) A maximum value may be placed on RTO provided it is</span>
<span class="cm">	 * at least RTO.max seconds.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">rtt</span><span class="p">;</span>

	<span class="cm">/* Reset rto_pending so that a new RTT measurement is started when a</span>
<span class="cm">	 * new data chunk is sent.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: transport: %p, rtt: %d, srtt: %d &quot;</span>
			  <span class="s">&quot;rttvar: %d, rto: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			  <span class="n">tp</span><span class="p">,</span> <span class="n">rtt</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine updates the transport&#39;s cwnd and partial_bytes_acked</span>
<span class="cm"> * parameters based on the bytes acked in the received SACK.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_raise_cwnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			       <span class="n">__u32</span> <span class="n">sack_ctsn</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">bytes_acked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cwnd</span><span class="p">,</span> <span class="n">ssthresh</span><span class="p">,</span> <span class="n">flight_size</span><span class="p">,</span> <span class="n">pba</span><span class="p">,</span> <span class="n">pmtu</span><span class="p">;</span>

	<span class="n">cwnd</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">;</span>
	<span class="n">flight_size</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">flight_size</span><span class="p">;</span>

	<span class="cm">/* See if we need to exit Fast Recovery first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TSN_lte</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery_exit</span><span class="p">,</span> <span class="n">sack_ctsn</span><span class="p">))</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The appropriate cwnd increase algorithm is performed if, and only</span>
<span class="cm">	 * if the cumulative TSN whould advanced and the congestion window is</span>
<span class="cm">	 * being fully utilized.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TSN_lte</span><span class="p">(</span><span class="n">sack_ctsn</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">flight_size</span> <span class="o">&lt;</span> <span class="n">cwnd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ssthresh</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">;</span>
	<span class="n">pba</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span><span class="p">;</span>
	<span class="n">pmtu</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cwnd</span> <span class="o">&lt;=</span> <span class="n">ssthresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RFC 4960 7.2.1</span>
<span class="cm">		 * o  When cwnd is less than or equal to ssthresh, an SCTP</span>
<span class="cm">		 *    endpoint MUST use the slow-start algorithm to increase</span>
<span class="cm">		 *    cwnd only if the current congestion window is being fully</span>
<span class="cm">		 *    utilized, an incoming SACK advances the Cumulative TSN</span>
<span class="cm">		 *    Ack Point, and the data sender is not in Fast Recovery.</span>
<span class="cm">		 *    Only when these three conditions are met can the cwnd be</span>
<span class="cm">		 *    increased; otherwise, the cwnd MUST not be increased.</span>
<span class="cm">		 *    If these conditions are met, then cwnd MUST be increased</span>
<span class="cm">		 *    by, at most, the lesser of 1) the total size of the</span>
<span class="cm">		 *    previously outstanding DATA chunk(s) acknowledged, and</span>
<span class="cm">		 *    2) the destination&#39;s path MTU.  This upper bound protects</span>
<span class="cm">		 *    against the ACK-Splitting attack outlined in [SAVAGE99].</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_acked</span> <span class="o">&gt;</span> <span class="n">pmtu</span><span class="p">)</span>
			<span class="n">cwnd</span> <span class="o">+=</span> <span class="n">pmtu</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cwnd</span> <span class="o">+=</span> <span class="n">bytes_acked</span><span class="p">;</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: SLOW START: transport: %p, &quot;</span>
				  <span class="s">&quot;bytes_acked: %d, cwnd: %d, ssthresh: %d, &quot;</span>
				  <span class="s">&quot;flight_size: %d, pba: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span>
				  <span class="n">transport</span><span class="p">,</span> <span class="n">bytes_acked</span><span class="p">,</span> <span class="n">cwnd</span><span class="p">,</span>
				  <span class="n">ssthresh</span><span class="p">,</span> <span class="n">flight_size</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* RFC 2960 7.2.2 Whenever cwnd is greater than ssthresh,</span>
<span class="cm">		 * upon each SACK arrival that advances the Cumulative TSN Ack</span>
<span class="cm">		 * Point, increase partial_bytes_acked by the total number of</span>
<span class="cm">		 * bytes of all new chunks acknowledged in that SACK including</span>
<span class="cm">		 * chunks acknowledged by the new Cumulative TSN Ack and by</span>
<span class="cm">		 * Gap Ack Blocks.</span>
<span class="cm">		 *</span>
<span class="cm">		 * When partial_bytes_acked is equal to or greater than cwnd</span>
<span class="cm">		 * and before the arrival of the SACK the sender had cwnd or</span>
<span class="cm">		 * more bytes of data outstanding (i.e., before arrival of the</span>
<span class="cm">		 * SACK, flightsize was greater than or equal to cwnd),</span>
<span class="cm">		 * increase cwnd by MTU, and reset partial_bytes_acked to</span>
<span class="cm">		 * (partial_bytes_acked - cwnd).</span>
<span class="cm">		 */</span>
		<span class="n">pba</span> <span class="o">+=</span> <span class="n">bytes_acked</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">&gt;=</span> <span class="n">cwnd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cwnd</span> <span class="o">+=</span> <span class="n">pmtu</span><span class="p">;</span>
			<span class="n">pba</span> <span class="o">=</span> <span class="p">((</span><span class="n">cwnd</span> <span class="o">&lt;</span> <span class="n">pba</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">pba</span> <span class="o">-</span> <span class="n">cwnd</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: CONGESTION AVOIDANCE: &quot;</span>
				  <span class="s">&quot;transport: %p, bytes_acked: %d, cwnd: %d, &quot;</span>
				  <span class="s">&quot;ssthresh: %d, flight_size: %d, pba: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">__func__</span><span class="p">,</span>
				  <span class="n">transport</span><span class="p">,</span> <span class="n">bytes_acked</span><span class="p">,</span> <span class="n">cwnd</span><span class="p">,</span>
				  <span class="n">ssthresh</span><span class="p">,</span> <span class="n">flight_size</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">cwnd</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span> <span class="o">=</span> <span class="n">pba</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine is used to lower the transport&#39;s cwnd when congestion is</span>
<span class="cm"> * detected.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_lower_cwnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
			       <span class="n">sctp_lower_cwnd_t</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_LOWER_CWND_T3_RTX</span>:
		<span class="cm">/* RFC 2960 Section 7.2.3, sctpimpguide</span>
<span class="cm">		 * When the T3-rtx timer expires on an address, SCTP should</span>
<span class="cm">		 * perform slow start by:</span>
<span class="cm">		 *      ssthresh = max(cwnd/2, 4*MTU)</span>
<span class="cm">		 *      cwnd = 1*MTU</span>
<span class="cm">		 *      partial_bytes_acked = 0</span>
<span class="cm">		 */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
					  <span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>

		<span class="cm">/* T3-rtx also clears fast recovery */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_LOWER_CWND_FAST_RTX</span>:
		<span class="cm">/* RFC 2960 7.2.4 Adjust the ssthresh and cwnd of the</span>
<span class="cm">		 * destination address(es) to which the missing DATA chunks</span>
<span class="cm">		 * were last sent, according to the formula described in</span>
<span class="cm">		 * Section 7.2.3.</span>
<span class="cm">		 *</span>
<span class="cm">		 * RFC 2960 7.2.3, sctpimpguide Upon detection of packet</span>
<span class="cm">		 * losses from SACK (see Section 7.2.4), An endpoint</span>
<span class="cm">		 * should do the following:</span>
<span class="cm">		 *      ssthresh = max(cwnd/2, 4*MTU)</span>
<span class="cm">		 *      cwnd = ssthresh</span>
<span class="cm">		 *      partial_bytes_acked = 0</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* Mark Fast recovery */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">fast_recovery_exit</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
					  <span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_LOWER_CWND_ECNE</span>:
		<span class="cm">/* RFC 2481 Section 6.1.2.</span>
<span class="cm">		 * If the sender receives an ECN-Echo ACK packet</span>
<span class="cm">		 * then the sender knows that congestion was encountered in the</span>
<span class="cm">		 * network on the path from the sender to the receiver. The</span>
<span class="cm">		 * indication of congestion should be treated just as a</span>
<span class="cm">		 * congestion loss in non-ECN Capable TCP. That is, the TCP</span>
<span class="cm">		 * source halves the congestion window &quot;cwnd&quot; and reduces the</span>
<span class="cm">		 * slow start threshold &quot;ssthresh&quot;.</span>
<span class="cm">		 * A critical condition is that TCP does not react to</span>
<span class="cm">		 * congestion indications more than once every window of</span>
<span class="cm">		 * data (or more loosely more than once every round-trip time).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">last_time_ecne_reduced</span> <span class="o">+</span>
					<span class="n">transport</span><span class="o">-&gt;</span><span class="n">rtt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
						  <span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">last_time_ecne_reduced</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_LOWER_CWND_INACTIVE</span>:
		<span class="cm">/* RFC 2960 Section 7.2.1, sctpimpguide</span>
<span class="cm">		 * When the endpoint does not transmit data on a given</span>
<span class="cm">		 * transport address, the cwnd of the transport address</span>
<span class="cm">		 * should be adjusted to max(cwnd/2, 4*MTU) per RTO.</span>
<span class="cm">		 * NOTE: Although the draft recommends that this check needs</span>
<span class="cm">		 * to be done every RTO interval, we do it every hearbeat</span>
<span class="cm">		 * interval.</span>
<span class="cm">		 */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
					 <span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: transport: %p reason: %d cwnd: &quot;</span>
			  <span class="s">&quot;%d ssthresh: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			  <span class="n">transport</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span>
			  <span class="n">transport</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Apply Max.Burst limit to the congestion window:</span>
<span class="cm"> * sctpimpguide-05 2.14.2</span>
<span class="cm"> * D) When the time comes for the sender to</span>
<span class="cm"> * transmit new DATA chunks, the protocol parameter Max.Burst MUST</span>
<span class="cm"> * first be applied to limit how many new DATA chunks may be sent.</span>
<span class="cm"> * The limit is applied by adjusting cwnd as follows:</span>
<span class="cm"> * 	if ((flightsize+ Max.Burst * MTU) &lt; cwnd)</span>
<span class="cm"> * 		cwnd = flightsize + Max.Burst * MTU</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">sctp_transport_burst_limited</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">old_cwnd</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cwnd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_burst_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">burst_limited</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">max_burst_bytes</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">*</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_burst_bytes</span> <span class="o">&lt;</span> <span class="n">old_cwnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">max_burst_bytes</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">burst_limited</span> <span class="o">=</span> <span class="n">old_cwnd</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Restore the old cwnd congestion window, after the burst had it&#39;s</span>
<span class="cm"> * desired effect.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_burst_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">burst_limited</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">burst_limited</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">burst_limited</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* What is the next timeout value for this transport? */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sctp_transport_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">+</span> <span class="n">sctp_jitter</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">hbinterval</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">+=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reset transport variables to their initial values */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 (bis), Section 5.2.4</span>
<span class="cm">	 * All the congestion control parameters (e.g., cwnd, ssthresh)</span>
<span class="cm">	 * related to this peer MUST be reset to their initial values</span>
<span class="cm">	 * (see Section 6.2.1)</span>
<span class="cm">	 */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="n">max_t</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="mi">4380</span><span class="p">));</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">burst_limited</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">a_rwnd</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset these additional varibles so that we have a clean</span>
<span class="cm">	 * slate.</span>
<span class="cm">	 */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rto_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">hb_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Initialize the state information for SFR-CACC */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">changeover_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cycling_changeover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">next_tsn_at_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cacc_saw_newack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Schedule retransmission on the given transport */</span>
<span class="kt">void</span> <span class="nf">sctp_transport_immediate_rtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stop pending T3_rtx_timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">);</span>
		<span class="n">sctp_transport_put</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sctp_retransmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">SCTP_RTXR_T3_RTX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">))</span>
			<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
