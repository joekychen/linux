<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › sm_make_chunk.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sm_make_chunk.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001-2002 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * These functions work with the state functions in sctp_sm_statefuns.c</span>
<span class="cm"> * to implement the state operations.  These functions implement the</span>
<span class="cm"> * steps which require modifying existing data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    C. Robin              &lt;chris@hundredacre.ac.uk&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Xingang Guo           &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Dajiang Zhang	    &lt;dajiang.zhang@nokia.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala	    &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Daisy Chang	    &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *    Kevin Gao             &lt;kevin.gao@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;	</span><span class="cm">/* for get_random_bytes */</span><span class="cp"></span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="n">SCTP_STATIC</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sctp_make_chunk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				   <span class="n">__u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paylen</span><span class="p">);</span>
<span class="k">static</span> <span class="n">sctp_cookie_param_t</span> <span class="o">*</span><span class="n">sctp_pack_cookie</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">init_chunk</span><span class="p">,</span>
					<span class="kt">int</span> <span class="o">*</span><span class="n">cookie_len</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">raw_addrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrs_len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sctp_process_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			      <span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">peer_addr</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sctp_addto_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* What was the inbound interface for this chunk? */</span>
<span class="kt">int</span> <span class="nf">sctp_chunk_iif</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">ipver2af</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="p">)</span>
		<span class="n">iif</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iif</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RFC 2960 3.3.2 Initiation (INIT) (1)</span>
<span class="cm"> *</span>
<span class="cm"> * Note 2: The ECN capable field is reserved for future use of</span>
<span class="cm"> * Explicit Congestion Notification.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="n">ecap_param</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SCTP_PARAM_ECN_CAPABLE</span><span class="p">,</span>
	<span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paramhdr</span><span class="p">)),</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="n">prsctp_param</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SCTP_PARAM_FWD_TSN_SUPPORT</span><span class="p">,</span>
	<span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paramhdr</span><span class="p">)),</span>
<span class="p">};</span>

<span class="cm">/* A helper to initialize an op error inside a</span>
<span class="cm"> * provided chunk, as most cause codes will be embedded inside an</span>
<span class="cm"> * abort chunk.</span>
<span class="cm"> */</span>
<span class="kt">void</span>  <span class="nf">sctp_init_cause</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">cause_code</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_errhdr_t</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Cause code constants are now defined in network order.  */</span>
	<span class="n">err</span><span class="p">.</span><span class="n">cause</span> <span class="o">=</span> <span class="n">cause_code</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">paylen</span><span class="p">;</span>
	<span class="n">err</span><span class="p">.</span><span class="n">length</span>  <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">err_hdr</span> <span class="o">=</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* A helper to initialize an op error inside a</span>
<span class="cm"> * provided chunk, as most cause codes will be embedded inside an</span>
<span class="cm"> * abort chunk.  Differs from sctp_init_cause in that it won&#39;t oops</span>
<span class="cm"> * if there isn&#39;t enough space in the op error chunk</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_init_cause_fixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">cause_code</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_errhdr_t</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Cause code constants are now defined in network order.  */</span>
	<span class="n">err</span><span class="p">.</span><span class="n">cause</span> <span class="o">=</span> <span class="n">cause_code</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">paylen</span><span class="p">;</span>
	<span class="n">err</span><span class="p">.</span><span class="n">length</span>  <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">err_hdr</span> <span class="o">=</span> <span class="n">sctp_addto_chunk_fixed</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span>
						     <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">),</span>
						     <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 3.3.2 Initiation (INIT) (1)</span>
<span class="cm"> *</span>
<span class="cm"> * This chunk is used to initiate a SCTP association between two</span>
<span class="cm"> * endpoints. The format of the INIT chunk is shown below:</span>
<span class="cm"> *</span>
<span class="cm"> *     0                   1                   2                   3</span>
<span class="cm"> *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    |   Type = 1    |  Chunk Flags  |      Chunk Length             |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    |                         Initiate Tag                          |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    |           Advertised Receiver Window Credit (a_rwnd)          |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    |  Number of Outbound Streams   |  Number of Inbound Streams    |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    |                          Initial TSN                          |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    \                                                               \</span>
<span class="cm"> *    /              Optional/Variable-Length Parameters              /</span>
<span class="cm"> *    \                                                               \</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The INIT chunk contains the following parameters. Unless otherwise</span>
<span class="cm"> * noted, each parameter MUST only be included once in the INIT chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Fixed Parameters                     Status</span>
<span class="cm"> * ----------------------------------------------</span>
<span class="cm"> * Initiate Tag                        Mandatory</span>
<span class="cm"> * Advertised Receiver Window Credit   Mandatory</span>
<span class="cm"> * Number of Outbound Streams          Mandatory</span>
<span class="cm"> * Number of Inbound Streams           Mandatory</span>
<span class="cm"> * Initial TSN                         Mandatory</span>
<span class="cm"> *</span>
<span class="cm"> * Variable Parameters                  Status     Type Value</span>
<span class="cm"> * -------------------------------------------------------------</span>
<span class="cm"> * IPv4 Address (Note 1)               Optional    5</span>
<span class="cm"> * IPv6 Address (Note 1)               Optional    6</span>
<span class="cm"> * Cookie Preservative                 Optional    9</span>
<span class="cm"> * Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)</span>
<span class="cm"> * Host Name Address (Note 3)          Optional    11</span>
<span class="cm"> * Supported Address Types (Note 4)    Optional    12</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vparam_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_inithdr_t</span> <span class="n">init</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">chunksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_types</span><span class="p">,</span> <span class="n">addrs_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">sctp_supported_addrs_param_t</span> <span class="n">sat</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">types</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">sctp_adaptation_ind_param_t</span> <span class="n">aiparam</span><span class="p">;</span>
	<span class="n">sctp_supported_ext_param_t</span> <span class="n">ext_param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">extensions</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="n">auth_chunks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="o">*</span><span class="n">auth_hmacs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 3.3.2 Initiation (INIT) (1)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note 1: The INIT chunks can contain multiple addresses that</span>
<span class="cm">	 * can be IPv4 and/or IPv6 in any combination.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Convert the provided bind address list to raw format. */</span>
	<span class="n">addrs</span> <span class="o">=</span> <span class="n">sctp_bind_addrs_to_raw</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrs_len</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

	<span class="n">init</span><span class="p">.</span><span class="n">init_tag</span>		   <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">);</span>
	<span class="n">init</span><span class="p">.</span><span class="n">a_rwnd</span>		   <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">);</span>
	<span class="n">init</span><span class="p">.</span><span class="n">num_outbound_streams</span>  <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">);</span>
	<span class="n">init</span><span class="p">.</span><span class="n">num_inbound_streams</span>   <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">);</span>
	<span class="n">init</span><span class="p">.</span><span class="n">initial_tsn</span>	   <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">);</span>

	<span class="cm">/* How many address types are needed? */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">num_types</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">supported_addrs</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">types</span><span class="p">);</span>

	<span class="n">chunksize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="o">+</span> <span class="n">addrs_len</span><span class="p">;</span>
	<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">SCTP_SAT_LEN</span><span class="p">(</span><span class="n">num_types</span><span class="p">));</span>
	<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecap_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_prsctp_enable</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prsctp_param</span><span class="p">);</span>

	<span class="cm">/* ADDIP: Section 4.2.7:</span>
<span class="cm">	 *  An implementation supporting this extension [ADDIP] MUST list</span>
<span class="cm">	 *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and</span>
<span class="cm">	 *  INIT-ACK parameters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extensions</span><span class="p">[</span><span class="n">num_ext</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_ASCONF</span><span class="p">;</span>
		<span class="n">extensions</span><span class="p">[</span><span class="n">num_ext</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_ASCONF_ACK</span><span class="p">;</span>
		<span class="n">num_ext</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aiparam</span><span class="p">);</span>

	<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">vparam_len</span><span class="p">;</span>

	<span class="cm">/* Account for AUTH related parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add random parameter length*/</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_random</span><span class="p">);</span>

		<span class="cm">/* Add HMACS parameter length if any were defined */</span>
		<span class="n">auth_hmacs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_hmacs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">auth_hmacs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Add CHUNKS parameter length */</span>
		<span class="n">auth_chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_chunks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">auth_chunks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">extensions</span><span class="p">[</span><span class="n">num_ext</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_AUTH</span><span class="p">;</span>
		<span class="n">num_ext</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we have any extensions to report, account for that */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_ext</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_supported_ext_param_t</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">num_ext</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 3.3.2 Initiation (INIT) (1)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note 3: An INIT chunk MUST NOT contain more than one Host</span>
<span class="cm">	 * Name address parameter. Moreover, the sender of the INIT</span>
<span class="cm">	 * MUST NOT combine any other address types with the Host Name</span>
<span class="cm">	 * address in the INIT. The receiver of INIT MUST ignore any</span>
<span class="cm">	 * other address types if the Host Name address parameter is</span>
<span class="cm">	 * present in the received INIT chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * PLEASE DO NOT FIXME [This version does not support Host Name.]</span>
<span class="cm">	 */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_INIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">init_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">init</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init</span><span class="p">);</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addrs_len</span><span class="p">,</span> <span class="n">addrs</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 3.3.2 Initiation (INIT) (1)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note 4: This parameter, when present, specifies all the</span>
<span class="cm">	 * address types the sending endpoint can support. The absence</span>
<span class="cm">	 * of this parameter indicates that the sending endpoint can</span>
<span class="cm">	 * support any address type.</span>
<span class="cm">	 */</span>
	<span class="n">sat</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_SUPPORTED_ADDRESS_TYPES</span><span class="p">;</span>
	<span class="n">sat</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SCTP_SAT_LEN</span><span class="p">(</span><span class="n">num_types</span><span class="p">));</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sat</span><span class="p">);</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">num_types</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">types</span><span class="p">);</span>

	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecap_param</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ecap_param</span><span class="p">);</span>

	<span class="cm">/* Add the supported extensions parameter.  Be nice and add this</span>
<span class="cm">	 * fist before addiding the parameters for the extensions themselves</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext_param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_SUPPORTED_EXT</span><span class="p">;</span>
		<span class="n">ext_param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
			    <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_supported_ext_param_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_ext</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_supported_ext_param_t</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">ext_param</span><span class="p">);</span>
		<span class="n">sctp_addto_param</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">num_ext</span><span class="p">,</span> <span class="n">extensions</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_prsctp_enable</span><span class="p">)</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prsctp_param</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">prsctp_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">aiparam</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_ADAPTATION_LAYER_IND</span><span class="p">;</span>
		<span class="n">aiparam</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aiparam</span><span class="p">));</span>
		<span class="n">aiparam</span><span class="p">.</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aiparam</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">aiparam</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Add SCTP-AUTH chunks to the parameter list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_random</span><span class="p">),</span>
				 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_random</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_hmacs</span><span class="p">)</span>
			<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span>
					<span class="n">auth_hmacs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_chunks</span><span class="p">)</span>
			<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span>
					<span class="n">auth_chunks</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">nodata:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_init_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unkparam_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_inithdr_t</span> <span class="n">initack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addrs_len</span><span class="p">;</span>
	<span class="n">sctp_cookie_param_t</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cookie_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">chunksize</span><span class="p">;</span>
	<span class="n">sctp_adaptation_ind_param_t</span> <span class="n">aiparam</span><span class="p">;</span>
	<span class="n">sctp_supported_ext_param_t</span> <span class="n">ext_param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">extensions</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="n">auth_chunks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="o">*</span><span class="n">auth_hmacs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="o">*</span><span class="n">auth_random</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Note: there may be no addresses to embed. */</span>
	<span class="n">addrs</span> <span class="o">=</span> <span class="n">sctp_bind_addrs_to_raw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrs_len</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

	<span class="n">initack</span><span class="p">.</span><span class="n">init_tag</span>	        <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span><span class="p">);</span>
	<span class="n">initack</span><span class="p">.</span><span class="n">a_rwnd</span>			<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">);</span>
	<span class="n">initack</span><span class="p">.</span><span class="n">num_outbound_streams</span>	<span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">);</span>
	<span class="n">initack</span><span class="p">.</span><span class="n">num_inbound_streams</span>	<span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">);</span>
	<span class="n">initack</span><span class="p">.</span><span class="n">initial_tsn</span>		<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">);</span>

	<span class="cm">/* FIXME:  We really ought to build the cookie right</span>
<span class="cm">	 * into the packet instead of allocating more fresh memory.</span>
<span class="cm">	 */</span>
	<span class="n">cookie</span> <span class="o">=</span> <span class="n">sctp_pack_cookie</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie_len</span><span class="p">,</span>
				  <span class="n">addrs</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">addrs_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cookie</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_cookie</span><span class="p">;</span>

	<span class="cm">/* Calculate the total size of allocation, include the reserved</span>
<span class="cm">	 * space for reporting unknown parameters if it is specified.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">chunksize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">initack</span><span class="p">)</span> <span class="o">+</span> <span class="n">addrs_len</span> <span class="o">+</span> <span class="n">cookie_len</span> <span class="o">+</span> <span class="n">unkparam_len</span><span class="p">;</span>

	<span class="cm">/* Tell peer that we&#39;ll do ECN only if peer advertised such cap.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecap_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prsctp_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extensions</span><span class="p">[</span><span class="n">num_ext</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_ASCONF</span><span class="p">;</span>
		<span class="n">extensions</span><span class="p">[</span><span class="n">num_ext</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_ASCONF_ACK</span><span class="p">;</span>
		<span class="n">num_ext</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aiparam</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">auth_random</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_random</span><span class="p">;</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_random</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

		<span class="n">auth_hmacs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_hmacs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">auth_hmacs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">auth_chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_chunks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">auth_chunks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">extensions</span><span class="p">[</span><span class="n">num_ext</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_CID_AUTH</span><span class="p">;</span>
		<span class="n">num_ext</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_ext</span><span class="p">)</span>
		<span class="n">chunksize</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_supported_ext_param_t</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">num_ext</span><span class="p">);</span>

	<span class="cm">/* Now allocate and fill out the chunk.  */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_INIT_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem_chunk</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [INIT ACK back to where the INIT came from.]</span>
<span class="cm">	 */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">init_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">initack</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">initack</span><span class="p">);</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addrs_len</span><span class="p">,</span> <span class="n">addrs</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">cookie_len</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span><span class="p">)</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecap_param</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ecap_param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext_param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_SUPPORTED_EXT</span><span class="p">;</span>
		<span class="n">ext_param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
			    <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_supported_ext_param_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_ext</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_supported_ext_param_t</span><span class="p">),</span>
				 <span class="o">&amp;</span><span class="n">ext_param</span><span class="p">);</span>
		<span class="n">sctp_addto_param</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">num_ext</span><span class="p">,</span> <span class="n">extensions</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span><span class="p">)</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prsctp_param</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">prsctp_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">aiparam</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_ADAPTATION_LAYER_IND</span><span class="p">;</span>
		<span class="n">aiparam</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aiparam</span><span class="p">));</span>
		<span class="n">aiparam</span><span class="p">.</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aiparam</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">aiparam</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_random</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span>
				 <span class="n">auth_random</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_hmacs</span><span class="p">)</span>
			<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_hmacs</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span>
					<span class="n">auth_hmacs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auth_chunks</span><span class="p">)</span>
			<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">auth_chunks</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span>
					<span class="n">auth_chunks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We need to remove the const qualifier at this point.  */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span> <span class="n">asoc</span><span class="p">;</span>

<span class="nl">nomem_chunk:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>
<span class="nl">nomem_cookie:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 3.3.11 Cookie Echo (COOKIE ECHO) (10):</span>
<span class="cm"> *</span>
<span class="cm"> * This chunk is used only during the initialization of an association.</span>
<span class="cm"> * It is sent by the initiator of an association to its peer to complete</span>
<span class="cm"> * the initialization process. This chunk MUST precede any DATA chunk</span>
<span class="cm"> * sent within the association, but MAY be bundled with one or more DATA</span>
<span class="cm"> * chunks in the same packet.</span>
<span class="cm"> *</span>
<span class="cm"> *      0                   1                   2                   3</span>
<span class="cm"> *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |   Type = 10   |Chunk  Flags   |         Length                |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     /                     Cookie                                    /</span>
<span class="cm"> *     \                                                               \</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> * Chunk Flags: 8 bit</span>
<span class="cm"> *</span>
<span class="cm"> *   Set to zero on transmit and ignored on receipt.</span>
<span class="cm"> *</span>
<span class="cm"> * Length: 16 bits (unsigned integer)</span>
<span class="cm"> *</span>
<span class="cm"> *   Set to the size of the chunk in bytes, including the 4 bytes of</span>
<span class="cm"> *   the chunk header and the size of the Cookie.</span>
<span class="cm"> *</span>
<span class="cm"> * Cookie: variable size</span>
<span class="cm"> *</span>
<span class="cm"> *   This field must contain the exact cookie received in the</span>
<span class="cm"> *   State Cookie parameter from the previous INIT ACK.</span>
<span class="cm"> *</span>
<span class="cm"> *   An implementation SHOULD make the cookie as small as possible</span>
<span class="cm"> *   to insure interoperability.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_cookie_echo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cookie_len</span><span class="p">;</span>

	<span class="n">cookie</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie</span><span class="p">;</span>
	<span class="n">cookie_len</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie_len</span><span class="p">;</span>

	<span class="cm">/* Build a cookie echo chunk.  */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_COOKIE_ECHO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cookie_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">cookie_len</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [COOKIE ECHO back to where the INIT ACK came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):</span>
<span class="cm"> *</span>
<span class="cm"> * This chunk is used only during the initialization of an</span>
<span class="cm"> * association.  It is used to acknowledge the receipt of a COOKIE</span>
<span class="cm"> * ECHO chunk.  This chunk MUST precede any DATA or SACK chunk sent</span>
<span class="cm"> * within the association, but MAY be bundled with one or more DATA</span>
<span class="cm"> * chunks or SACK chunk in the same SCTP packet.</span>
<span class="cm"> *</span>
<span class="cm"> *      0                   1                   2                   3</span>
<span class="cm"> *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |   Type = 11   |Chunk  Flags   |     Length = 4                |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> * Chunk Flags: 8 bits</span>
<span class="cm"> *</span>
<span class="cm"> *   Set to zero on transmit and ignored on receipt.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_cookie_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_COOKIE_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [COOKIE ACK back to where the COOKIE ECHO came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Appendix A: Explicit Congestion Notification:</span>
<span class="cm"> *  CWR:</span>
<span class="cm"> *</span>
<span class="cm"> *  RFC 2481 details a specific bit for a sender to send in the header of</span>
<span class="cm"> *  its next outbound TCP segment to indicate to its peer that it has</span>
<span class="cm"> *  reduced its congestion window.  This is termed the CWR bit.  For</span>
<span class="cm"> *  SCTP the same indication is made by including the CWR chunk.</span>
<span class="cm"> *  This chunk contains one data element, i.e. the TSN number that</span>
<span class="cm"> *  was sent in the ECNE chunk.  This element represents the lowest</span>
<span class="cm"> *  TSN number in the datagram that was originally marked with the</span>
<span class="cm"> *  CE bit.</span>
<span class="cm"> *</span>
<span class="cm"> *     0                   1                   2                   3</span>
<span class="cm"> *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    | Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *    |                      Lowest TSN Number                        |</span>
<span class="cm"> *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> *     Note: The CWR is considered a Control chunk.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_cwr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">const</span> <span class="n">__u32</span> <span class="n">lowest_tsn</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">sctp_cwrhdr_t</span> <span class="n">cwr</span><span class="p">;</span>

	<span class="n">cwr</span><span class="p">.</span><span class="n">lowest_tsn</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">lowest_tsn</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_ECN_CWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_cwrhdr_t</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">ecn_cwr_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cwr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cwr</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [Report a reduced congestion window back to where the ECNE</span>
<span class="cm">	 * came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make an ECNE chunk.  This is a congestion experienced report.  */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_ecne</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">__u32</span> <span class="n">lowest_tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">sctp_ecnehdr_t</span> <span class="n">ecne</span><span class="p">;</span>

	<span class="n">ecne</span><span class="p">.</span><span class="n">lowest_tsn</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">lowest_tsn</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_ECN_ECNE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_ecnehdr_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">ecne_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ecne</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ecne</span><span class="p">);</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make a DATA chunk for the given association from the provided</span>
<span class="cm"> * parameters.  However, do not populate the data payload.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_datafrag_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">ssn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_datahdr</span> <span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chunk_len</span><span class="p">;</span>

	<span class="cm">/* We assign the TSN as LATE as possible, not here when</span>
<span class="cm">	 * creating the chunk.</span>
<span class="cm">	 */</span>
	<span class="n">dp</span><span class="p">.</span><span class="n">tsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dp</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_stream</span><span class="p">);</span>
	<span class="n">dp</span><span class="p">.</span><span class="n">ppid</span>   <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_ppid</span><span class="p">;</span>

	<span class="cm">/* Set the flags for an unordered send.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">sinfo_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_UNORDERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SCTP_DATA_UNORDERED</span><span class="p">;</span>
		<span class="n">dp</span><span class="p">.</span><span class="n">ssn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dp</span><span class="p">.</span><span class="n">ssn</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ssn</span><span class="p">);</span>

	<span class="n">chunk_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_DATA</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">chunk_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span> <span class="o">=</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dp</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">sinfo</span><span class="p">,</span> <span class="n">sinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">));</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create a selective ackowledgement (SACK) for the given</span>
<span class="cm"> * association.  This reports on which TSN&#39;s we&#39;ve seen to date,</span>
<span class="cm"> * including duplicates and gaps.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_sack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="n">sack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">num_gabs</span><span class="p">,</span> <span class="n">num_dup_tsns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">aptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_tsnmap</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_tsnmap</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_gap_ack_block</span> <span class="n">gabs</span><span class="p">[</span><span class="n">SCTP_MAX_GABS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">gabs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gabs</span><span class="p">));</span>
	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sackCTSNAck sent:  0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctsn</span><span class="p">);</span>

	<span class="cm">/* How much room is needed in the chunk? */</span>
	<span class="n">num_gabs</span> <span class="o">=</span> <span class="n">sctp_tsnmap_num_gabs</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">gabs</span><span class="p">);</span>
	<span class="n">num_dup_tsns</span> <span class="o">=</span> <span class="n">sctp_tsnmap_num_dups</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

	<span class="cm">/* Initialize the SACK header.  */</span>
	<span class="n">sack</span><span class="p">.</span><span class="n">cum_tsn_ack</span>	    <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ctsn</span><span class="p">);</span>
	<span class="n">sack</span><span class="p">.</span><span class="n">a_rwnd</span> 		    <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">);</span>
	<span class="n">sack</span><span class="p">.</span><span class="n">num_gap_ack_blocks</span>     <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">num_gabs</span><span class="p">);</span>
	<span class="n">sack</span><span class="p">.</span><span class="n">num_dup_tsns</span>           <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">num_dup_tsns</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
		<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_gap_ack_block</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_gabs</span>
		<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_dup_tsns</span><span class="p">;</span>

	<span class="cm">/* Create the chunk.  */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_SACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, etc.) to the same destination transport</span>
<span class="cm">	 * address from which it received the DATA or control chunk to</span>
<span class="cm">	 * which it is replying.  This rule should also be followed if</span>
<span class="cm">	 * the endpoint is bundling DATA chunks together with the</span>
<span class="cm">	 * reply chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, when acknowledging multiple DATA chunks received</span>
<span class="cm">	 * in packets from different source addresses in a single</span>
<span class="cm">	 * SACK, the SACK chunk may be transmitted to one of the</span>
<span class="cm">	 * destination transport addresses from which the DATA or</span>
<span class="cm">	 * control chunks being acknowledged were received.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [BUG:  We do not implement the following paragraph.</span>
<span class="cm">	 * Perhaps we should remember the last transport we used for a</span>
<span class="cm">	 * SACK and avoid that (if possible) if we have seen any</span>
<span class="cm">	 * duplicates. --piggy]</span>
<span class="cm">	 *</span>
<span class="cm">	 * When a receiver of a duplicate DATA chunk sends a SACK to a</span>
<span class="cm">	 * multi- homed endpoint it MAY be beneficial to vary the</span>
<span class="cm">	 * destination address and not use the source address of the</span>
<span class="cm">	 * DATA chunk.  The reason being that receiving a duplicate</span>
<span class="cm">	 * from a multi-homed endpoint might indicate that the return</span>
<span class="cm">	 * path (as specified in the source address of the DATA chunk)</span>
<span class="cm">	 * for the SACK is broken.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [Send to the address from which we last received a DATA chunk.]</span>
<span class="cm">	 */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">last_data_from</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">sack_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sack</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sack</span><span class="p">);</span>

	<span class="cm">/* Add the gap ack block information.   */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_gabs</span><span class="p">)</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_gabs</span><span class="p">,</span>
				 <span class="n">gabs</span><span class="p">);</span>

	<span class="cm">/* Add the duplicate TSN information.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_dup_tsns</span><span class="p">)</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_dup_tsns</span><span class="p">,</span>
				 <span class="n">sctp_tsnmap_get_dups</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>

	<span class="cm">/* Once we have a sack generated, check to see what our sack</span>
<span class="cm">	 * generation is, if its 0, reset the transports to 0, and reset</span>
<span class="cm">	 * the association generation to 1</span>
<span class="cm">	 *</span>
<span class="cm">	 * The idea is that zero is never used as a valid generation for the</span>
<span class="cm">	 * association so no transport will match after a wrap event like this,</span>
<span class="cm">	 * Until the next sack</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">aptr</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_generation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				    <span class="n">transports</span><span class="p">)</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">sack_generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aptr</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_generation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make a SHUTDOWN chunk. */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_shutdown</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">sctp_shutdownhdr_t</span> <span class="n">shut</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ctsn</span><span class="p">;</span>

	<span class="n">ctsn</span> <span class="o">=</span> <span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>
	<span class="n">shut</span><span class="p">.</span><span class="n">cum_tsn_ack</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ctsn</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_SHUTDOWN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_shutdownhdr_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">shutdown_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shut</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">shut</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_shutdown_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_SHUTDOWN_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [ACK back to where the SHUTDOWN came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_shutdown_complete</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the T-bit if we have no association (vtag will be</span>
<span class="cm">	 * reflected)</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">asoc</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">SCTP_CHUNK_FLAG_T</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_SHUTDOWN_COMPLETE</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [Report SHUTDOWN COMPLETE back to where the SHUTDOWN ACK</span>
<span class="cm">	 * came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create an ABORT.  Note that we set the T bit if we have no</span>
<span class="cm"> * association, except when responding to an INIT (sctpimpguide 2.41).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">size_t</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the T-bit if we have no association and &#39;chunk&#39; is not</span>
<span class="cm">	 * an INIT (vtag will be reflected).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_CID_INIT</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">SCTP_CHUNK_FLAG_T</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_ABORT</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">hint</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [ABORT back to where the offender came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper to create ABORT with a NO_USER_DATA error.  */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_abort_no_data</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">payload</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span>
				 <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tsn</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_mem</span><span class="p">;</span>

	<span class="cm">/* Put the tsn back into network byte order.  */</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tsn</span><span class="p">);</span>
	<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">SCTP_ERROR_NO_DATA</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [ABORT back to where the offender came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

<span class="nl">no_mem:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper to create ABORT with a SCTP_ERROR_USER_ABORT error.  */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_abort_user</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">payload</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">paylen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_chunk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paylen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Put the msg_iov together into payload.  */</span>
		<span class="n">payload</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">paylen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_payload</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">SCTP_ERROR_USER_ABORT</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">paylen</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paylen</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">err_copy:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="nl">err_payload:</span>
	<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err_chunk:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Append bytes to the end of a parameter.  Will panic if chunk is not big</span>
<span class="cm"> * enough.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sctp_addto_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chunklen</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Adjust the chunk length field.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">chunklen</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make an ABORT chunk with a PROTOCOL VIOLATION cause code. */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_abort_violation</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">__u8</span>   <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>  <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="n">phdr</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">paylen</span>
					<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">SCTP_ERROR_PROTO_VIOLATION</span><span class="p">,</span> <span class="n">paylen</span>
					<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">));</span>

	<span class="n">phdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">phdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">paylen</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
	<span class="n">sctp_addto_param</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">phdr</span><span class="p">);</span>

<span class="nl">end:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_violation_paramlen</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">error</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;The following parameter had invalid length:&quot;</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_abort</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">SCTP_ERROR_PROTO_VIOLATION</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">));</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">error</span><span class="p">),</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">sctp_addto_param</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">),</span> <span class="n">param</span><span class="p">);</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make a HEARTBEAT chunk.  */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_heartbeat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">sctp_sender_hb_info_t</span> <span class="n">hbinfo</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_HEARTBEAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hbinfo</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">hbinfo</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_HEARTBEAT_INFO</span><span class="p">;</span>
	<span class="n">hbinfo</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_sender_hb_info_t</span><span class="p">));</span>
	<span class="n">hbinfo</span><span class="p">.</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">;</span>
	<span class="n">hbinfo</span><span class="p">.</span><span class="n">sent_at</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">hbinfo</span><span class="p">.</span><span class="n">hb_nonce</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">hb_nonce</span><span class="p">;</span>

	<span class="cm">/* Cast away the &#39;const&#39;, as this is just telling the chunk</span>
<span class="cm">	 * what transport it belongs to.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">)</span> <span class="n">transport</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">hbs_hdr</span> <span class="o">=</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hbinfo</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">hbinfo</span><span class="p">);</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_heartbeat_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span>  <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_HEARTBEAT_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">paylen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">hbs_hdr</span> <span class="o">=</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">paylen</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, * etc.) to the same destination transport</span>
<span class="cm">	 * address from which it * received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [HBACK back to where the HEARTBEAT came from.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create an Operation Error chunk with the specified space reserved.</span>
<span class="cm"> * This routine can be used for containing multiple causes in the chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_op_error_space</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,</span>
<span class="cm">	 * HEARTBEAT ACK, etc.) to the same destination transport</span>
<span class="cm">	 * address from which it received the DATA or control chunk</span>
<span class="cm">	 * to which it is replying.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create an Operation Error chunk of a fixed size,</span>
<span class="cm"> * specifically, max(asoc-&gt;pathmtu, SCTP_DEFAULT_MAXSEGMENT)</span>
<span class="cm"> * This is a helper function to allocate an error chunk for</span>
<span class="cm"> * for those invalid parameter codes in which we may not want</span>
<span class="cm"> * to report all the errors, if the incomming chunk is large</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_op_error_fixed</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">asoc</span> <span class="o">?</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXSEGMENT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_make_op_error_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create an Operation Error chunk.  */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_op_error</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				 <span class="n">__be16</span> <span class="n">cause_code</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">paylen</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">reserve_tail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_op_error_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">paylen</span> <span class="o">+</span> <span class="n">reserve_tail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">sctp_init_cause</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">cause_code</span><span class="p">,</span> <span class="n">paylen</span> <span class="o">+</span> <span class="n">reserve_tail</span><span class="p">);</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">paylen</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserve_tail</span><span class="p">)</span>
		<span class="n">sctp_addto_param</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">reserve_tail</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_auth</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hmac</span> <span class="o">*</span><span class="n">hmac_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_authhdr</span> <span class="n">auth_hdr</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">hmac</span><span class="p">;</span>

	<span class="cm">/* Get the first hmac that the peer told us to use */</span>
	<span class="n">hmac_desc</span> <span class="o">=</span> <span class="n">sctp_auth_asoc_get_hmac</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hmac_desc</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_AUTH</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">hmac_desc</span><span class="o">-&gt;</span><span class="n">hmac_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_authhdr_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">auth_hdr</span><span class="p">.</span><span class="n">hmac_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">hmac_desc</span><span class="o">-&gt;</span><span class="n">hmac_id</span><span class="p">);</span>
	<span class="n">auth_hdr</span><span class="p">.</span><span class="n">shkey_id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">active_key_id</span><span class="p">);</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">auth_hdr</span> <span class="o">=</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_authhdr_t</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">auth_hdr</span><span class="p">);</span>

	<span class="n">hmac</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">hmac_desc</span><span class="o">-&gt;</span><span class="n">hmac_len</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">hmac</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hmac_desc</span><span class="o">-&gt;</span><span class="n">hmac_len</span><span class="p">);</span>

	<span class="cm">/* Adjust the chunk header to include the empty MAC */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
		<span class="n">htons</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="n">hmac_desc</span><span class="o">-&gt;</span><span class="n">hmac_len</span><span class="p">);</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/********************************************************************</span>
<span class="cm"> * 2nd Level Abstractions</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/* Turn an skb into a chunk.</span>
<span class="cm"> * FIXME: Eventually move the structure directly inside the skb-&gt;cb[].</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_chunkify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">sctp_chunk_cachep</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;chunkifying skb %p w/o an sk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">skb</span>		<span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">asoc</span>		<span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">has_tsn</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">has_ssn</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">rtt_in_progress</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">sent_at</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">singleton</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">end_of_packet</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">ecn_ce_done</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">pdiscard</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* sctpimpguide-05.txt Section 2.8.2</span>
<span class="cm">	 * M1) Each time a new DATA chunk is transmitted</span>
<span class="cm">	 * set the &#39;TSN.Missing.Report&#39; count for that TSN to 0. The</span>
<span class="cm">	 * &#39;TSN.Missing.Report&#39; count will be used to determine missing chunks</span>
<span class="cm">	 * and when to fast retransmit.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">tsn_missing_report</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">tsn_gap_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">fast_retransmit</span> <span class="o">=</span> <span class="n">SCTP_CAN_FRTX</span><span class="p">;</span>

	<span class="cm">/* If this is a fragmented message, track all fragments</span>
<span class="cm">	 * of the message (for SEND_FAILED).</span>
<span class="cm">	 */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Polish the bead hole.  */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">);</span>
	<span class="n">SCTP_DBG_OBJCNT_INC</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set chunk-&gt;source and dest based on the IP header in chunk-&gt;skb.  */</span>
<span class="kt">void</span> <span class="nf">sctp_init_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		     <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Extract the source address from a chunk.  */</span>
<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="nf">sctp_source</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we have a known transport, use that.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise, extract it from the IP header.  */</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Create a new chunk, setting the type and flags headers from the</span>
<span class="cm"> * arguments, reserving enough space for a &#39;paylen&#39; byte payload.</span>
<span class="cm"> */</span>
<span class="n">SCTP_STATIC</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_chunk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				   <span class="n">__u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paylen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">chunk_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* No need to allocate LL here, as this is only a chunk. */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">WORD_ROUND</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">paylen</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="cm">/* Make room for the chunk header.  */</span>
	<span class="n">chunk_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>
	<span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span>	  <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span>  <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span> <span class="o">?</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_chunkify</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span> <span class="o">=</span> <span class="n">chunk_hdr</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">);</span>

	<span class="cm">/* Determine if the chunk needs to be authenticated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_send_cid</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="n">retval</span><span class="o">-&gt;</span><span class="n">auth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Set the skb to the belonging sock for accounting.  */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Release the memory occupied by a chunk.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_chunk_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>

	<span class="cm">/* Free the chunk skb data and the SCTP_chunk stub itself. */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">SCTP_DBG_OBJCNT_DEC</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sctp_chunk_cachep</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Possibly, free the chunk.  */</span>
<span class="kt">void</span> <span class="nf">sctp_chunk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Release our reference on the message tracker. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">)</span>
		<span class="n">sctp_datamsg_put</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">sctp_chunk_put</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Grab a reference to the chunk. */</span>
<span class="kt">void</span> <span class="nf">sctp_chunk_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Release a reference to the chunk. */</span>
<span class="kt">void</span> <span class="nf">sctp_chunk_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">sctp_chunk_destroy</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Append bytes to the end of a chunk.  Will panic if chunk is not big</span>
<span class="cm"> * enough.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">sctp_addto_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">padding</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chunklen</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">padlen</span> <span class="o">=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">chunklen</span><span class="p">)</span> <span class="o">-</span> <span class="n">chunklen</span><span class="p">;</span>

	<span class="n">padding</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">padlen</span><span class="p">);</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padlen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Adjust the chunk length field.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">chunklen</span> <span class="o">+</span> <span class="n">padlen</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Append bytes to the end of a chunk. Returns NULL if there isn&#39;t sufficient</span>
<span class="cm"> * space in the chunk</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">sctp_addto_chunk_fixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Append bytes from user space to the end of a chunk.  Will panic if</span>
<span class="cm"> * chunk is not big enough.</span>
<span class="cm"> * Returns a kernel err value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_user_addto_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make room in chunk for data.  */</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Copy data (whole iovec) into chunk */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovecend</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Adjust the chunk length field.  */</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
		<span class="n">htons</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper function to assign a TSN if needed.  This assumes that both</span>
<span class="cm"> * the data_hdr and association have already been assigned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_chunk_assign_ssn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">lchunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ssn</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">has_ssn</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* All fragments will be on the same stream */</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">);</span>
	<span class="n">stream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Now assign the sequence number to the entire message.</span>
<span class="cm">	 * All fragments must have the same stream sequence number.</span>
<span class="cm">	 */</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lchunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">,</span> <span class="n">frag_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lchunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_UNORDERED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ssn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lchunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_LAST_FRAG</span><span class="p">)</span>
				<span class="n">ssn</span> <span class="o">=</span> <span class="n">sctp_ssn_next</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ssn</span> <span class="o">=</span> <span class="n">sctp_ssn_peek</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">lchunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">ssn</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ssn</span><span class="p">);</span>
		<span class="n">lchunk</span><span class="o">-&gt;</span><span class="n">has_ssn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Helper function to assign a TSN if needed.  This assumes that both</span>
<span class="cm"> * the data_hdr and association have already been assigned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_chunk_assign_tsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">has_tsn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is the last possible instant to</span>
<span class="cm">		 * assign a TSN.</span>
<span class="cm">		 */</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span> <span class="o">=</span>
			<span class="n">htonl</span><span class="p">(</span><span class="n">sctp_association_get_next_tsn</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">));</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">has_tsn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Create a CLOSED association to use with an incoming packet.  */</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_make_temp_asoc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="cm">/* Create the bare association.  */</span>
	<span class="n">scope</span> <span class="o">=</span> <span class="n">sctp_scope</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
	<span class="n">asoc</span> <span class="o">=</span> <span class="n">sctp_association_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="cm">/* Create an entry for the source address of the packet.  */</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">ipver2af</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_addr</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Build a cookie representing asoc.</span>
<span class="cm"> * This INCLUDES the param header needed to put the cookie in the INIT ACK.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_cookie_param_t</span> <span class="o">*</span><span class="nf">sctp_pack_cookie</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">init_chunk</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="o">*</span><span class="n">cookie_len</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">raw_addrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrs_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_cookie_param_t</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">headersize</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="cm">/* Header size is static data prior to the actual cookie, including</span>
<span class="cm">	 * any padding.</span>
<span class="cm">	 */</span>
	<span class="n">headersize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">)</span> <span class="o">+</span>
		     <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_signed_cookie</span><span class="p">)</span> <span class="o">-</span>
		      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_cookie</span><span class="p">));</span>
	<span class="n">bodysize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_cookie</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">init_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="n">addrs_len</span><span class="p">;</span>

	<span class="cm">/* Pad out the cookie to a multiple to make the signature</span>
<span class="cm">	 * functions simpler to write.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bodysize</span> <span class="o">%</span> <span class="n">SCTP_COOKIE_MULTIPLE</span><span class="p">)</span>
		<span class="n">bodysize</span> <span class="o">+=</span> <span class="n">SCTP_COOKIE_MULTIPLE</span>
			<span class="o">-</span> <span class="p">(</span><span class="n">bodysize</span> <span class="o">%</span> <span class="n">SCTP_COOKIE_MULTIPLE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cookie_len</span> <span class="o">=</span> <span class="n">headersize</span> <span class="o">+</span> <span class="n">bodysize</span><span class="p">;</span>

	<span class="cm">/* Clear this memory since we are sending this data structure</span>
<span class="cm">	 * out on the network.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="o">*</span><span class="n">cookie_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>

	<span class="n">cookie</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="p">)</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">;</span>

	<span class="cm">/* Set up the parameter header.  */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_STATE_COOKIE</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="o">*</span><span class="n">cookie_len</span><span class="p">);</span>

	<span class="cm">/* Copy the cookie part of the association itself.  */</span>
	<span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="cm">/* Save the raw address list length in the cookie. */</span>
	<span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">raw_addr_list_len</span> <span class="o">=</span> <span class="n">addrs_len</span><span class="p">;</span>

	<span class="cm">/* Remember PR-SCTP capability. */</span>
	<span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">prsctp_capable</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span><span class="p">;</span>

	<span class="cm">/* Save adaptation indication in the cookie. */</span>
	<span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">;</span>

	<span class="cm">/* Set an expiration time for the cookie.  */</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">expiration</span><span class="p">);</span>
	<span class="n">TIMEVAL_ADD</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">,</span> <span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">expiration</span><span class="p">);</span>

	<span class="cm">/* Copy the peer&#39;s init packet.  */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">init_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">,</span>
	       <span class="n">ntohs</span><span class="p">(</span><span class="n">init_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>

	<span class="cm">/* Copy the raw local address list of the association. */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
	       <span class="n">ntohs</span><span class="p">(</span><span class="n">init_chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span> <span class="n">raw_addrs</span><span class="p">,</span> <span class="n">addrs_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hash_desc</span> <span class="n">desc</span><span class="p">;</span>

		<span class="cm">/* Sign the message.  */</span>
		<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">);</span>
		<span class="n">keylen</span> <span class="o">=</span> <span class="n">SCTP_SECRET_SIZE</span><span class="p">;</span>
		<span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">secret_key</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">current_key</span><span class="p">];</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">crypto_hash_setkey</span><span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">tfm</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keylen</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">crypto_hash_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">,</span> <span class="n">cookie</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_cookie</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">free_cookie:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="nl">nodata:</span>
	<span class="o">*</span><span class="n">cookie_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unpack the cookie from COOKIE ECHO chunk, recreating the association.  */</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_unpack_cookie</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_cookie</span> <span class="o">*</span><span class="n">bear_cookie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">headersize</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">,</span> <span class="n">fixed_size</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">digest</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hash_desc</span> <span class="n">desc</span><span class="p">;</span>

	<span class="cm">/* Header size is static data prior to the actual cookie, including</span>
<span class="cm">	 * any padding.</span>
<span class="cm">	 */</span>
	<span class="n">headersize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">)</span> <span class="o">+</span>
		     <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_signed_cookie</span><span class="p">)</span> <span class="o">-</span>
		      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_cookie</span><span class="p">));</span>
	<span class="n">bodysize</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="n">headersize</span><span class="p">;</span>
	<span class="n">fixed_size</span> <span class="o">=</span> <span class="n">headersize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_cookie</span><span class="p">);</span>

	<span class="cm">/* Verify that the chunk looks like it even has a cookie.</span>
<span class="cm">	 * There must be enough room for our cookie and our peer&#39;s</span>
<span class="cm">	 * INIT chunk.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">fixed_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunkhdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">malformed</span><span class="p">;</span>

	<span class="cm">/* Verify that the cookie has been padded out. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bodysize</span> <span class="o">%</span> <span class="n">SCTP_COOKIE_MULTIPLE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">malformed</span><span class="p">;</span>

	<span class="cm">/* Process the cookie.  */</span>
	<span class="n">cookie</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">cookie_hdr</span><span class="p">;</span>
	<span class="n">bear_cookie</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_hmac</span><span class="p">;</span>

	<span class="cm">/* Check the signature.  */</span>
	<span class="n">keylen</span> <span class="o">=</span> <span class="n">SCTP_SECRET_SIZE</span><span class="p">;</span>
	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">bear_cookie</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">secret_key</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">current_key</span><span class="p">];</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hmac</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">SCTP_SIGNATURE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crypto_hash_setkey</span><span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">tfm</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keylen</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">crypto_hash_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">,</span> <span class="n">digest</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">cookie</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">SCTP_SIGNATURE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Try the previous key. */</span>
		<span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">secret_key</span><span class="p">[</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">last_key</span><span class="p">];</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">SCTP_SIGNATURE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crypto_hash_setkey</span><span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">tfm</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keylen</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">crypto_hash_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">bodysize</span><span class="p">,</span> <span class="n">digest</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">cookie</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">SCTP_SIGNATURE_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Yikes!  Still bad signature! */</span>
			<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_BAD_SIG</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">no_hmac:</span>
	<span class="cm">/* IG Section 2.35.2:</span>
<span class="cm">	 *  3) Compare the port numbers and the verification tag contained</span>
<span class="cm">	 *     within the COOKIE ECHO chunk to the actual port numbers and the</span>
<span class="cm">	 *     verification tag within the SCTP common header of the received</span>
<span class="cm">	 *     packet. If these values do not match the packet MUST be silently</span>
<span class="cm">	 *     discarded,</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">vtag</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bear_cookie</span><span class="o">-&gt;</span><span class="n">my_vtag</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_BAD_TAG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">!=</span> <span class="n">bear_cookie</span><span class="o">-&gt;</span><span class="n">peer_addr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">||</span>
	    <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bear_cookie</span><span class="o">-&gt;</span><span class="n">my_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_BAD_PORTS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if the cookie is stale.  If there is already</span>
<span class="cm">	 * an association, there is no need to check cookie&#39;s expiration</span>
<span class="cm">	 * for init collision case of lost COOKIE ACK.</span>
<span class="cm">	 * If skb has been timestamped, then use the stamp, otherwise</span>
<span class="cm">	 * use current time.  This introduces a small possibility that</span>
<span class="cm">	 * that a cookie may be considered expired, but his would only slow</span>
<span class="cm">	 * down the new association establishment instead of every packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMP</span><span class="p">))</span>
		<span class="n">skb_get_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">&amp;&amp;</span> <span class="n">tv_lt</span><span class="p">(</span><span class="n">bear_cookie</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">,</span> <span class="n">tv</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Section 3.3.10.3 Stale Cookie Error (3)</span>
<span class="cm">		 *</span>
<span class="cm">		 * Cause of error</span>
<span class="cm">		 * ---------------</span>
<span class="cm">		 * Stale Cookie Error:  Indicates the receipt of a valid State</span>
<span class="cm">		 * Cookie that has expired.</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">sctp_make_op_error_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">suseconds_t</span> <span class="n">usecs</span> <span class="o">=</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span>
				<span class="n">bear_cookie</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000L</span> <span class="o">+</span>
				<span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">bear_cookie</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
			<span class="n">__be32</span> <span class="n">n</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">usecs</span><span class="p">);</span>

			<span class="n">sctp_init_cause</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="n">SCTP_ERROR_STALE_COOKIE</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
			<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
			<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_STALE_COOKIE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make a new base association.  */</span>
	<span class="n">scope</span> <span class="o">=</span> <span class="n">sctp_scope</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">));</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_association_new</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up our peer&#39;s port number.  */</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">);</span>

	<span class="cm">/* Populate the association from the cookie.  */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="n">bear_cookie</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bear_cookie</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_assoc_set_bind_addr_from_cookie</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">bear_cookie</span><span class="p">,</span>
						 <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Also, add the destination address. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">address_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sctp_add_bind_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span>
				<span class="n">SCTP_ADDR_SRC</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">=</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span> <span class="o">=</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">addip_serial</span> <span class="o">=</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">=</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span> <span class="o">=</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">prsctp_capable</span><span class="p">;</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="n">retval</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">;</span>

	<span class="cm">/* The INIT stuff will be done by the side effects.  */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">sctp_association_free</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">malformed:</span>
	<span class="cm">/* Yikes!  The packet is either corrupt or deliberately</span>
<span class="cm">	 * malformed.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">SCTP_IERROR_MALFORMED</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * 3rd Level Abstractions</span>
<span class="cm"> ********************************************************************/</span>

<span class="k">struct</span> <span class="n">__sctp_missing</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">num_missing</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>  <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Report a missing mandatory parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_process_missing_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="n">sctp_param_t</span> <span class="n">paramtype</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__sctp_missing</span> <span class="n">report</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">report</span><span class="p">));</span>

	<span class="cm">/* Make an ERROR chunk, preparing enough room for</span>
<span class="cm">	 * returning multiple unknown parameters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">errp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">sctp_make_op_error_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">report</span><span class="p">.</span><span class="n">num_missing</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">report</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">paramtype</span><span class="p">;</span>
		<span class="n">sctp_init_cause</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="n">SCTP_ERROR_MISS_PARAM</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">report</span><span class="p">));</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">report</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">report</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Stop processing this chunk. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Report an Invalid Mandatory Parameter.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_process_inv_mandatory</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Invalid Mandatory Parameter Error has no payload. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">errp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">sctp_make_op_error_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span>
		<span class="n">sctp_init_cause</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="n">SCTP_ERROR_INV_PARAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Stop processing this chunk. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_process_inv_paramlength</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is a fatal error.  Any accumulated non-fatal errors are</span>
<span class="cm">	 * not reported.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">);</span>

	<span class="cm">/* Create an error chunk and fill it in with our payload. */</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">sctp_make_violation_paramlen</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Do not attempt to handle the HOST_NAME parm.  However, do</span>
<span class="cm"> * send back an indicator to the peer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_process_hn_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/* Processing of the HOST_NAME parameter will generate an</span>
<span class="cm">	 * ABORT.  If we&#39;ve accumulated any non-fatal errors, they</span>
<span class="cm">	 * would be unrecognized parameters and we should not include</span>
<span class="cm">	 * them in the ABORT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">);</span>

	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">sctp_make_op_error_space</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_init_cause</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Stop processing this chunk. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_verify_ext_param</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">num_ext</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">have_auth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have_asconf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_ext</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">ext</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		    <span class="k">case</span> <span class="n">SCTP_CID_AUTH</span>:
			    <span class="n">have_auth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>
		    <span class="k">case</span> <span class="n">SCTP_CID_ASCONF</span>:
		    <span class="k">case</span> <span class="n">SCTP_CID_ASCONF_ACK</span>:
			    <span class="n">have_asconf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* ADD-IP Security: The draft requires us to ABORT or ignore the</span>
<span class="cm">	 * INIT/INIT-ACK if ADD-IP is listed, but AUTH is not.  Do this</span>
<span class="cm">	 * only if ADD-IP is turned on and we are not backward-compatible</span>
<span class="cm">	 * mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_noauth</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_enable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">have_auth</span> <span class="o">&amp;&amp;</span> <span class="n">have_asconf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_process_ext_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">num_ext</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_ext</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">ext</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		    <span class="k">case</span> <span class="n">SCTP_CID_FWD_TSN</span>:
			    <span class="k">if</span> <span class="p">(</span><span class="n">sctp_prsctp_enable</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span><span class="p">)</span>
				    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>
		    <span class="k">case</span> <span class="n">SCTP_CID_AUTH</span>:
			    <span class="cm">/* if the peer reports AUTH, assume that he</span>
<span class="cm">			     * supports AUTH.</span>
<span class="cm">			     */</span>
			    <span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
				    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>
		    <span class="k">case</span> <span class="n">SCTP_CID_ASCONF</span>:
		    <span class="k">case</span> <span class="n">SCTP_CID_ASCONF_ACK</span>:
			    <span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_enable</span><span class="p">)</span>
				    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			    <span class="k">break</span><span class="p">;</span>
		    <span class="nl">default:</span>
			    <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* RFC 3.2.1 &amp; the Implementers Guide 2.2.</span>
<span class="cm"> *</span>
<span class="cm"> * The Parameter Types are encoded such that the</span>
<span class="cm"> * highest-order two bits specify the action that must be</span>
<span class="cm"> * taken if the processing endpoint does not recognize the</span>
<span class="cm"> * Parameter Type.</span>
<span class="cm"> *</span>
<span class="cm"> * 00 - Stop processing this parameter; do not process any further</span>
<span class="cm"> * 	parameters within this chunk</span>
<span class="cm"> *</span>
<span class="cm"> * 01 - Stop processing this parameter, do not process any further</span>
<span class="cm"> *	parameters within this chunk, and report the unrecognized</span>
<span class="cm"> *	parameter in an &#39;Unrecognized Parameter&#39; ERROR chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * 10 - Skip this parameter and continue processing.</span>
<span class="cm"> *</span>
<span class="cm"> * 11 - Skip this parameter and continue processing but</span>
<span class="cm"> *	report the unrecognized parameter in an</span>
<span class="cm"> *	&#39;Unrecognized Parameter&#39; ERROR chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * 	SCTP_IERROR_NO_ERROR - continue with the chunk</span>
<span class="cm"> * 	SCTP_IERROR_ERROR    - stop and report an error.</span>
<span class="cm"> * 	SCTP_IERROR_NOMEME   - out of memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_ierror_t</span> <span class="nf">sctp_process_unk_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					    <span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_NO_ERROR</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SCTP_PARAM_ACTION_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_ACTION_DISCARD</span>:
		<span class="n">retval</span> <span class="o">=</span>  <span class="n">SCTP_IERROR_ERROR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_ACTION_SKIP</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_ACTION_DISCARD_ERR</span>:
		<span class="n">retval</span> <span class="o">=</span>  <span class="n">SCTP_IERROR_ERROR</span><span class="p">;</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_ACTION_SKIP_ERR</span>:
		<span class="cm">/* Make an ERROR chunk, preparing enough room for</span>
<span class="cm">		 * returning multiple unknown parameters.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
			<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">sctp_make_op_error_fixed</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_init_cause_fixed</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span> <span class="n">SCTP_ERROR_UNKNOWN_PARAM</span><span class="p">,</span>
					<span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))))</span>
				<span class="n">sctp_addto_chunk_fixed</span><span class="p">(</span><span class="o">*</span><span class="n">errp</span><span class="p">,</span>
						<span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)),</span>
						<span class="n">param</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* If there is no memory for generating the ERROR</span>
<span class="cm">			 * report as specified, an ABORT will be triggered</span>
<span class="cm">			 * to the peer and the association won&#39;t be</span>
<span class="cm">			 * established.</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_NOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Verify variable length parameters</span>
<span class="cm"> * Return values:</span>
<span class="cm"> * 	SCTP_IERROR_ABORT - trigger an ABORT</span>
<span class="cm"> * 	SCTP_IERROR_NOMEM - out of memory (abort)</span>
<span class="cm"> *	SCTP_IERROR_ERROR - stop processing, trigger an ERROR</span>
<span class="cm"> * 	SCTP_IERROR_NO_ERROR - continue with the chunk</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_ierror_t</span> <span class="nf">sctp_verify_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">,</span>
					<span class="n">sctp_cid_t</span> <span class="n">cid</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">err_chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_hmac_algo_param</span> <span class="o">*</span><span class="n">hmacs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_NO_ERROR</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">n_elt</span><span class="p">,</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* FIXME - This routine is not looking at each parameter per the</span>
<span class="cm">	 * chunk type, i.e., unrecognized parameters should be further</span>
<span class="cm">	 * identified based on the chunk id.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_IPV6_ADDRESS</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_COOKIE_PRESERVATIVE</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_SUPPORTED_ADDRESS_TYPES</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_STATE_COOKIE</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_HEARTBEAT_INFO</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_UNRECOGNIZED_PARAMETERS</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_ECN_CAPABLE</span>:
	<span class="k">case</span> <span class="n">SCTP_PARAM_ADAPTATION_LAYER_IND</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_SUPPORTED_EXT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_verify_ext_param</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">SCTP_IERROR_ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_enable</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fallthrough</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_HOST_NAME_ADDRESS</span>:
		<span class="cm">/* Tell the peer, we won&#39;t support this param.  */</span>
		<span class="n">sctp_process_hn_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">err_chunk</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_FWD_TSN_SUPPORT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_prsctp_enable</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fallthrough</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_RANDOM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fallthrough</span><span class="p">;</span>

		<span class="cm">/* SCTP-AUTH: Secion 6.1</span>
<span class="cm">		 * If the random number is not 32 byte long the association</span>
<span class="cm">		 * MUST be aborted.  The ABORT chunk SHOULD contain the error</span>
<span class="cm">		 * cause &#39;Protocol Violation&#39;.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_AUTH_RANDOM_LENGTH</span> <span class="o">!=</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_process_inv_paramlength</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span>
							<span class="n">chunk</span><span class="p">,</span> <span class="n">err_chunk</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_ABORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_CHUNKS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fallthrough</span><span class="p">;</span>

		<span class="cm">/* SCTP-AUTH: Section 3.2</span>
<span class="cm">		 * The CHUNKS parameter MUST be included once in the INIT or</span>
<span class="cm">		 *  INIT-ACK chunk if the sender wants to receive authenticated</span>
<span class="cm">		 *  chunks.  Its maximum length is 260 bytes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">260</span> <span class="o">&lt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_process_inv_paramlength</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span>
						     <span class="n">chunk</span><span class="p">,</span> <span class="n">err_chunk</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_ABORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_HMAC_ALGO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fallthrough</span><span class="p">;</span>

		<span class="n">hmacs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hmac_algo_param</span> <span class="o">*</span><span class="p">)</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
		<span class="n">n_elt</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* SCTP-AUTH: Section 6.1</span>
<span class="cm">		 * The HMAC algorithm based on SHA-1 MUST be supported and</span>
<span class="cm">		 * included in the HMAC-ALGO parameter.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_elt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hmacs</span><span class="o">-&gt;</span><span class="n">hmac_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">SCTP_AUTH_HMAC_ID_SHA1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="n">SCTP_AUTH_HMAC_ID_SHA1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_process_inv_paramlength</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
						     <span class="n">err_chunk</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_IERROR_ABORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="nl">fallthrough:</span>
	<span class="nl">default:</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Unrecognized param: %d for chunk %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">cid</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_process_unk_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">err_chunk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Verify the INIT packet before we process it.  */</span>
<span class="kt">int</span> <span class="nf">sctp_verify_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
		     <span class="n">sctp_cid_t</span> <span class="n">cid</span><span class="p">,</span>
		     <span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">has_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Verify stream values are non-zero. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="o">==</span> <span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_outbound_streams</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_inbound_streams</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">init_tag</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">SCTP_DEFAULT_MINWINDOW</span> <span class="o">&gt;</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">a_rwnd</span><span class="p">)))</span> <span class="p">{</span>

		<span class="k">return</span> <span class="n">sctp_process_inv_mandatory</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check for missing mandatory parameters.  */</span>
	<span class="n">sctp_walk_params</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">peer_init</span><span class="p">,</span> <span class="n">init_hdr</span><span class="p">.</span><span class="n">params</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_PARAM_STATE_COOKIE</span> <span class="o">==</span> <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="n">has_cookie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="cm">/* for (loop through all parameters) */</span>

	<span class="cm">/* There is a possibility that a parameter length was bad and</span>
<span class="cm">	 * in that case we would have stoped walking the parameters.</span>
<span class="cm">	 * The current param.p would point at the bad one.</span>
<span class="cm">	 * Current consensus on the mailing list is to generate a PROTOCOL</span>
<span class="cm">	 * VIOLATION error.  We build the ERROR chunk here and let the normal</span>
<span class="cm">	 * error handling code build and send the packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_process_inv_paramlength</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>

	<span class="cm">/* The only missing mandatory param possible today is</span>
<span class="cm">	 * the state cookie for an INIT-ACK chunk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">SCTP_CID_INIT_ACK</span> <span class="o">==</span> <span class="n">cid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_cookie</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sctp_process_missing_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_PARAM_STATE_COOKIE</span><span class="p">,</span>
						  <span class="n">chunk</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>

	<span class="cm">/* Verify all the variable length parameters */</span>
	<span class="n">sctp_walk_params</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">peer_init</span><span class="p">,</span> <span class="n">init_hdr</span><span class="p">.</span><span class="n">params</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sctp_verify_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		    <span class="k">case</span> <span class="n">SCTP_IERROR_ABORT</span>:
		    <span class="k">case</span> <span class="n">SCTP_IERROR_NOMEM</span>:
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		    <span class="k">case</span> <span class="n">SCTP_IERROR_ERROR</span>:
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		    <span class="k">case</span> <span class="n">SCTP_IERROR_NO_ERROR</span>:
		    <span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="cm">/* for (loop through all parameters) */</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unpack the parameters in an INIT packet into an association.</span>
<span class="cm"> * Returns 0 on failure, else success.</span>
<span class="cm"> * FIXME:  This is an association method.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_process_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">peer_addr</span><span class="p">,</span>
		      <span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">src_match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We must include the address that the INIT packet came from.</span>
<span class="cm">	 * This is the only address that matters for an INIT packet.</span>
<span class="cm">	 * When processing a COOKIE ECHO, we retrieve the from address</span>
<span class="cm">	 * of the INIT from the cookie.</span>
<span class="cm">	 */</span>

	<span class="cm">/* This implementation defaults to making the first transport</span>
<span class="cm">	 * added as the primary transport.  The source address seems to</span>
<span class="cm">	 * be a a better choice than any of the embedded addresses.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">peer_addr</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">SCTP_ACTIVE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">peer_addr</span><span class="p">))</span>
		<span class="n">src_match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Process the initialization parameters.  */</span>
	<span class="n">sctp_walk_params</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">peer_init</span><span class="p">,</span> <span class="n">init_hdr</span><span class="p">.</span><span class="n">params</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_match</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span> <span class="o">||</span>
		    <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_PARAM_IPV6_ADDRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
			<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
					    <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sctp_hdr</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="n">sctp_source</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span>
				<span class="n">src_match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_process_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">peer_addr</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* source address of chunk may not match any valid address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_match</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>

	<span class="cm">/* AUTH: After processing the parameters, make sure that we</span>
<span class="cm">	 * have all the required info to potentially do authentications.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span> <span class="o">||</span>
					<span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span><span class="p">))</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* In a non-backward compatible mode, if the peer claims</span>
<span class="cm">	 * support for ADD-IP but not AUTH,  the ADD-IP spec states</span>
<span class="cm">	 * that we MUST ABORT the association. Section 6.  The section</span>
<span class="cm">	 * also give us an option to silently ignore the packet, which</span>
<span class="cm">	 * is what we&#39;ll do here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_noauth</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">auth_capable</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_disabled_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SCTP_PARAM_ADD_IP</span> <span class="o">|</span>
						  <span class="n">SCTP_PARAM_DEL_IP</span> <span class="o">|</span>
						  <span class="n">SCTP_PARAM_SET_PRIMARY</span><span class="p">);</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Walk list of transports, removing transports in the UNKNOWN state. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_assoc_rm_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* The fixed INIT headers are always in network byte</span>
<span class="cm">	 * order.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">init_tag</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">a_rwnd</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">a_rwnd</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">num_outbound_streams</span> <span class="o">=</span>
		<span class="n">ntohs</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_outbound_streams</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">num_inbound_streams</span> <span class="o">=</span>
		<span class="n">ntohs</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_inbound_streams</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">initial_tsn</span> <span class="o">=</span>
		<span class="n">ntohl</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">);</span>

	<span class="cm">/* Apply the upper bounds for output streams based on peer&#39;s</span>
<span class="cm">	 * number of inbound streams.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span>  <span class="o">&gt;</span>
	    <span class="n">ntohs</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_inbound_streams</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span> <span class="o">=</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_inbound_streams</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span> <span class="o">&gt;</span>
	    <span class="n">ntohs</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_outbound_streams</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span> <span class="o">=</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">init_hdr</span><span class="p">.</span><span class="n">num_outbound_streams</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Copy Initiation tag from INIT to VT_peer in cookie.   */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span><span class="p">;</span>

	<span class="cm">/* Peer Rwnd   : Current calculated value of the peer&#39;s rwnd.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">a_rwnd</span><span class="p">;</span>

	<span class="cm">/* Copy cookie in case we need to resend COOKIE-ECHO. */</span>
	<span class="n">cookie</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie_len</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily</span>
<span class="cm">	 * high (for example, implementations MAY use the size of the receiver</span>
<span class="cm">	 * advertised window).</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">a_rwnd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up the TSN tracking pieces.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_tsnmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">SCTP_TSN_MAP_INITIAL</span><span class="p">,</span>
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number</span>
<span class="cm">	 *</span>
<span class="cm">	 * The stream sequence number in all the streams shall start</span>
<span class="cm">	 * from 0 when the association is established.  Also, when the</span>
<span class="cm">	 * stream sequence number reaches the value 65535 the next</span>
<span class="cm">	 * stream sequence number shall be set to 0.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Allocate storage for the negotiated streams if it is not a temporary</span>
<span class="cm">	 * association.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span> <span class="o">=</span> <span class="n">sctp_ssnmap_new</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">,</span>
					       <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_assoc_set_id</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ADDIP Section 4.1 ASCONF Chunk Procedures</span>
<span class="cm">	 *</span>
<span class="cm">	 * When an endpoint has an ASCONF signaled change to be sent to the</span>
<span class="cm">	 * remote endpoint it should do the following:</span>
<span class="cm">	 * ...</span>
<span class="cm">	 * A2) A serial number should be assigned to the Chunk. The serial</span>
<span class="cm">	 * number should be a monotonically increasing number. All serial</span>
<span class="cm">	 * numbers are defined to be initialized at the start of the</span>
<span class="cm">	 * association to the same value as the Initial TSN.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_serial</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">initial_tsn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">clean_up:</span>
	<span class="cm">/* Release the transport structures. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_ACTIVE</span><span class="p">)</span>
			<span class="n">sctp_assoc_rm_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Update asoc with the option described in param.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC2960 3.3.2.1 Optional/Variable Length Parameters in INIT</span>
<span class="cm"> *</span>
<span class="cm"> * asoc is the association to update.</span>
<span class="cm"> * param is the variable length parameter to use for update.</span>
<span class="cm"> * cid tells us if this is an INIT, INIT ACK or COOKIE ECHO.</span>
<span class="cm"> * If the current packet is an INIT we want to minimize the amount of</span>
<span class="cm"> * work we do.  In particular, we should not build transport</span>
<span class="cm"> * structures for the addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_process_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			      <span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">peer_addr</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">stale</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">addr_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* We maintain all INIT parameters in network byte order all the</span>
<span class="cm">	 * time.  This allows us to not worry about whether the parameters</span>
<span class="cm">	 * came from a fresh INIT, and INIT ACK, or were stored in a cookie.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_IPV6_ADDRESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">PF_INET6</span> <span class="o">!=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_addr_param</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span>:
		<span class="cm">/* v4 addresses are not allowed on v6-only socket */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_only_sock</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
<span class="nl">do_addr_param:</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
		<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">scope</span> <span class="o">=</span> <span class="n">sctp_scope</span><span class="p">(</span><span class="n">peer_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_in_scope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">scope</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_COOKIE_PRESERVATIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_cookie_preserve_enable</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">stale</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">life</span><span class="o">-&gt;</span><span class="n">lifespan_increment</span><span class="p">);</span>

		<span class="cm">/* Suggested Cookie Life span increment&#39;s unit is msec,</span>
<span class="cm">		 * (1/1000sec).</span>
<span class="cm">		 */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">stale</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">+=</span> <span class="p">(</span><span class="n">stale</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_HOST_NAME_ADDRESS</span>:
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;unimplemented SCTP_HOST_NAME_ADDRESS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_SUPPORTED_ADDRESS_TYPES</span>:
		<span class="cm">/* Turn off the default values first so we&#39;ll know which</span>
<span class="cm">		 * ones are really set by the peer.</span>
<span class="cm">		 */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv4_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv6_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Assume that peer supports the address family</span>
<span class="cm">		 * by which it sends a packet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">peer_addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv6_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">peer_addr</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv4_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Cycle through address types; avoid divide by 0. */</span>
		<span class="n">sat</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sat</span><span class="p">)</span>
			<span class="n">sat</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sat</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">sat</span><span class="o">-&gt;</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span>:
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv4_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SCTP_PARAM_IPV6_ADDRESS</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">PF_INET6</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span>
					<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv6_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SCTP_PARAM_HOST_NAME_ADDRESS</span>:
				<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">hostname_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span> <span class="cm">/* Just ignore anything else.  */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_STATE_COOKIE</span>:
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie_len</span> <span class="o">=</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">);</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_HEARTBEAT_INFO</span>:
		<span class="cm">/* Would be odd to receive, but it causes no problems. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_UNRECOGNIZED_PARAMETERS</span>:
		<span class="cm">/* Rejected during verify stage. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_ECN_CAPABLE</span>:
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ecn_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_ADAPTATION_LAYER_IND</span>:
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">aind</span><span class="o">-&gt;</span><span class="n">adaptation_ind</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_addip_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fall_through</span><span class="p">;</span>

		<span class="n">addr_param</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_param_t</span><span class="p">);</span>

		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
		<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr_param</span><span class="p">,</span>
				    <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* if the address is invalid, we can&#39;t process it.</span>
<span class="cm">		 * XXX: see spec for what to do.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_SUPPORTED_EXT</span>:
		<span class="n">sctp_process_ext_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_FWD_TSN_SUPPORT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_prsctp_enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">prsctp_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Fall Through */</span>
		<span class="k">goto</span> <span class="n">fall_through</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_RANDOM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fall_through</span><span class="p">;</span>

		<span class="cm">/* Save peer&#39;s random parameter */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span>
					    <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_HMAC_ALGO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fall_through</span><span class="p">;</span>

		<span class="cm">/* Save peer&#39;s HMAC list */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span>
					    <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set the default HMAC the peer requested*/</span>
		<span class="n">sctp_auth_asoc_set_default_hmac</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">hmac_algo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_PARAM_CHUNKS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_auth_enable</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fall_through</span><span class="p">;</span>

		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">,</span>
					    <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="nl">fall_through:</span>
	<span class="nl">default:</span>
		<span class="cm">/* Any unrecognized parameters should have been caught</span>
<span class="cm">		 * and handled by sctp_verify_param() which should be</span>
<span class="cm">		 * called prior to this routine.  Simply log the error</span>
<span class="cm">		 * here.</span>
<span class="cm">		 */</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Ignoring param: %d for association %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">asoc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Select a new verification tag.  */</span>
<span class="n">__u32</span> <span class="nf">sctp_generate_tag</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* I believe that this random number generator complies with RFC1750.</span>
<span class="cm">	 * A tag of 0 is reserved for special cases (e.g. INIT).</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">x</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Select an initial TSN to send during startup.  */</span>
<span class="n">__u32</span> <span class="nf">sctp_generate_tsn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ADDIP 3.1.1 Address Configuration Change Chunk (ASCONF)</span>
<span class="cm"> *      0                   1                   2                   3</span>
<span class="cm"> *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     | Type = 0xC1   |  Chunk Flags  |      Chunk Length             |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                       Serial Number                           |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                    Address Parameter                          |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                     ASCONF Parameter #1                       |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     \                                                               \</span>
<span class="cm"> *     /                             ....                              /</span>
<span class="cm"> *     \                                                               \</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                     ASCONF Parameter #N                       |</span>
<span class="cm"> *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> * Address Parameter and other parameter will not be wrapped in this function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">vparam_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addiphdr_t</span> <span class="n">asconf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">asconf</span><span class="p">)</span> <span class="o">+</span> <span class="n">vparam_len</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="n">addrparam</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>

	<span class="n">addrlen</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">to_addr_param</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrparam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addrlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>

	<span class="cm">/* Create the chunk.  */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_ASCONF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">asconf</span><span class="p">.</span><span class="n">serial</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_serial</span><span class="o">++</span><span class="p">);</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">addip_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">asconf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">asconf</span><span class="p">);</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrparam</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ADDIP</span>
<span class="cm"> * 3.2.1 Add IP Address</span>
<span class="cm"> * 	0                   1                   2                   3</span>
<span class="cm"> * 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |        Type = 0xC001          |    Length = Variable          |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |               ASCONF-Request Correlation ID                   |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                       Address Parameter                       |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> * 3.2.2 Delete IP Address</span>
<span class="cm"> * 	0                   1                   2                   3</span>
<span class="cm"> * 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |        Type = 0xC002          |    Length = Variable          |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |               ASCONF-Request Correlation ID                   |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                       Address Parameter                       |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_asconf_update_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					      <span class="k">union</span> <span class="n">sctp_addr</span>	      <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sockaddr</span>	      <span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
					      <span class="kt">int</span>		      <span class="n">addrcnt</span><span class="p">,</span>
					      <span class="n">__be16</span>		      <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addip_param_t</span>	<span class="n">param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span>	<span class="n">addr_param</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span>		<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span>		<span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">paramlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">addr_param_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">totallen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">del_pickup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get total length of all the address parameters. */</span>
	<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
		<span class="n">addr_param_len</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">to_addr_param</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_param</span><span class="p">);</span>

		<span class="n">totallen</span> <span class="o">+=</span> <span class="n">paramlen</span><span class="p">;</span>
		<span class="n">totallen</span> <span class="o">+=</span> <span class="n">addr_param_len</span><span class="p">;</span>

		<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">del_pickup</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* reuse the parameter length from the same scope one */</span>
			<span class="n">totallen</span> <span class="o">+=</span> <span class="n">paramlen</span><span class="p">;</span>
			<span class="n">totallen</span> <span class="o">+=</span> <span class="n">addr_param_len</span><span class="p">;</span>
			<span class="n">del_pickup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;mkasconf_update_ip: picked same-scope del_pending addr, totallen for all addresses is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">totallen</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Create an asconf chunk with the required length. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">totallen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Add the address parameters to the asconf chunk. */</span>
	<span class="n">addr_buf</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">addr_buf</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
		<span class="n">addr_param_len</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">to_addr_param</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_param</span><span class="p">);</span>
		<span class="n">param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">paramlen</span> <span class="o">+</span> <span class="n">addr_param_len</span><span class="p">);</span>
		<span class="n">param</span><span class="p">.</span><span class="n">crr_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">paramlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addr_param_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_param</span><span class="p">);</span>

		<span class="n">addr_buf</span> <span class="o">+=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">SCTP_PARAM_ADD_IP</span> <span class="o">&amp;&amp;</span> <span class="n">del_pickup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">;</span>
		<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>
		<span class="n">addr_param_len</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">to_addr_param</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_param</span><span class="p">);</span>
		<span class="n">param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_DEL_IP</span><span class="p">;</span>
		<span class="n">param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">paramlen</span> <span class="o">+</span> <span class="n">addr_param_len</span><span class="p">);</span>
		<span class="n">param</span><span class="p">.</span><span class="n">crr_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">paramlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addr_param_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_param</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ADDIP</span>
<span class="cm"> * 3.2.4 Set Primary IP Address</span>
<span class="cm"> *	0                   1                   2                   3</span>
<span class="cm"> *	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |        Type =0xC004           |    Length = Variable          |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |               ASCONF-Request Correlation ID                   |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                       Address Parameter                       |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> * Create an ASCONF chunk with Set Primary IP address parameter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_asconf_set_prim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addip_param_t</span>	<span class="n">param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> 	<span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span>	<span class="n">addrparam</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">addrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span>		<span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span><span class="p">);</span>

	<span class="n">addrlen</span> <span class="o">=</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">to_addr_param</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrparam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addrlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">addrlen</span><span class="p">;</span>

	<span class="cm">/* Create the chunk and make asconf header. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_asconf</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span><span class="p">;</span>
	<span class="n">param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">param</span><span class="p">.</span><span class="n">crr_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrparam</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ADDIP 3.1.2 Address Configuration Acknowledgement Chunk (ASCONF-ACK)</span>
<span class="cm"> *      0                   1                   2                   3</span>
<span class="cm"> *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     | Type = 0x80   |  Chunk Flags  |      Chunk Length             |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                       Serial Number                           |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                 ASCONF Parameter Response#1                   |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     \                                                               \</span>
<span class="cm"> *     /                             ....                              /</span>
<span class="cm"> *     \                                                               \</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *     |                 ASCONF Parameter Response#N                   |</span>
<span class="cm"> *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> * Create an ASCONF_ACK chunk with enough space for the parameter responses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_asconf_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					       <span class="n">__u32</span> <span class="n">serial</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vparam_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addiphdr_t</span>		<span class="n">asconf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">asconf</span><span class="p">)</span> <span class="o">+</span> <span class="n">vparam_len</span><span class="p">;</span>

	<span class="cm">/* Create the chunk.  */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_ASCONF_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">asconf</span><span class="p">.</span><span class="n">serial</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>

	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">addip_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">asconf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">asconf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add response parameters to an ASCONF_ACK chunk. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_add_asconf_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">crr_id</span><span class="p">,</span>
			      <span class="n">__be16</span> <span class="n">err_code</span><span class="p">,</span> <span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="n">asconf_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addip_param_t</span> 	<span class="n">ack_param</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span>		<span class="n">err_param</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">asconf_param_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">err_param_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__be16</span>			<span class="n">response_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span> <span class="o">==</span> <span class="n">err_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">response_type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_SUCCESS_REPORT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">response_type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_ERR_CAUSE</span><span class="p">;</span>
		<span class="n">err_param_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">err_param</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asconf_param</span><span class="p">)</span>
			<span class="n">asconf_param_len</span> <span class="o">=</span>
				 <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Add Success Indication or Error Cause Indication parameter. */</span>
	<span class="n">ack_param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">response_type</span><span class="p">;</span>
	<span class="n">ack_param</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ack_param</span><span class="p">)</span> <span class="o">+</span>
					   <span class="n">err_param_len</span> <span class="o">+</span>
					   <span class="n">asconf_param_len</span><span class="p">);</span>
	<span class="n">ack_param</span><span class="p">.</span><span class="n">crr_id</span> <span class="o">=</span> <span class="n">crr_id</span><span class="p">;</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack_param</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ack_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span> <span class="o">==</span> <span class="n">err_code</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Add Error Cause parameter. */</span>
	<span class="n">err_param</span><span class="p">.</span><span class="n">cause</span> <span class="o">=</span> <span class="n">err_code</span><span class="p">;</span>
	<span class="n">err_param</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">err_param_len</span> <span class="o">+</span> <span class="n">asconf_param_len</span><span class="p">);</span>
	<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">err_param_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_param</span><span class="p">);</span>

	<span class="cm">/* Add the failed TLV copied from ASCONF chunk. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asconf_param</span><span class="p">)</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asconf_param_len</span><span class="p">,</span> <span class="n">asconf_param</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Process a asconf parameter. */</span>
<span class="k">static</span> <span class="n">__be16</span> <span class="nf">sctp_process_asconf_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">asconf</span><span class="p">,</span>
				       <span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="n">asconf_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">peer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">addr_param</span><span class="p">;</span>

	<span class="n">addr_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_param</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_param_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_PARAM_ADD_IP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_PARAM_DEL_IP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCTP_ERROR_UNKNOWN_PARAM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">addr_param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_IPV6_ADDRESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv6_address</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv4_address</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">addr_param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">;</span>

	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr_param</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* ADDIP 4.2.1  This parameter MUST NOT contain a broadcast</span>
<span class="cm">	 * or multicast address.</span>
<span class="cm">	 * (note: wildcard is permitted and requires special handling so</span>
<span class="cm">	 *  make sure we check for that)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">is_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">addr_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">asconf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_ADD_IP</span>:
		<span class="cm">/* Section 4.2.1:</span>
<span class="cm">		 * If the address 0.0.0.0 or ::0 is provided, the source</span>
<span class="cm">		 * address of the packet MUST be added.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">is_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

		<span class="cm">/* ADDIP 4.3 D9) If an endpoint receives an ADD IP address</span>
<span class="cm">		 * request and does not have the local resources to add this</span>
<span class="cm">		 * new address to the association, it MUST return an Error</span>
<span class="cm">		 * Cause TLV set to the new error code &#39;Operation Refused</span>
<span class="cm">		 * Due to Resource Shortage&#39;.</span>
<span class="cm">		 */</span>

		<span class="n">peer</span> <span class="o">=</span> <span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">peer</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_ERROR_RSRC_LOW</span><span class="p">;</span>

		<span class="cm">/* Start the heartbeat timer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">hb_timer</span><span class="p">,</span> <span class="n">sctp_transport_timeout</span><span class="p">(</span><span class="n">peer</span><span class="p">)))</span>
			<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">new_transport</span> <span class="o">=</span> <span class="n">peer</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_DEL_IP</span>:
		<span class="cm">/* ADDIP 4.3 D7) If a request is received to delete the</span>
<span class="cm">		 * last remaining IP address of a peer endpoint, the receiver</span>
<span class="cm">		 * MUST send an Error Cause TLV with the error cause set to the</span>
<span class="cm">		 * new error code &#39;Request to Delete Last Remaining IP Address&#39;.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_ERROR_DEL_LAST_IP</span><span class="p">;</span>

		<span class="cm">/* ADDIP 4.3 D8) If a request is received to delete an IP</span>
<span class="cm">		 * address which is also the source address of the IP packet</span>
<span class="cm">		 * which contained the ASCONF chunk, the receiver MUST reject</span>
<span class="cm">		 * this request. To reject the request the receiver MUST send</span>
<span class="cm">		 * an Error Cause TLV set to the new error code &#39;Request to</span>
<span class="cm">		 * Delete Source IP Address&#39;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">SCTP_ERROR_DEL_SRC_IP</span><span class="p">;</span>

		<span class="cm">/* Section 4.2.2</span>
<span class="cm">		 * If the address 0.0.0.0 or ::0 is provided, all</span>
<span class="cm">		 * addresses of the peer except	the source address of the</span>
<span class="cm">		 * packet MUST be deleted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">is_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asconf</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
			<span class="n">sctp_assoc_del_nonprimary_peers</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span>
							<span class="n">asconf</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sctp_assoc_del_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span>:
		<span class="cm">/* ADDIP Section 4.2.4</span>
<span class="cm">		 * If the address 0.0.0.0 or ::0 is provided, the receiver</span>
<span class="cm">		 * MAY mark the source address of the packet as its</span>
<span class="cm">		 * primary.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">is_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">.</span><span class="n">v4</span><span class="p">,</span> <span class="n">sctp_source</span><span class="p">(</span><span class="n">asconf</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

		<span class="n">peer</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">peer</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCTP_ERROR_DNS_FAILED</span><span class="p">;</span>

		<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">peer</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Verify the ASCONF packet before we process it.  */</span>
<span class="kt">int</span> <span class="nf">sctp_verify_asconf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="o">*</span><span class="n">param_hdr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">chunk_end</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="n">asconf_param</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">plen</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">param_hdr</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="n">chunk_end</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">chunk_end</span> <span class="o">-</span> <span class="n">length</span> <span class="o">||</span>
		    <span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_PARAM_ADD_IP</span>:
		<span class="k">case</span> <span class="n">SCTP_PARAM_DEL_IP</span>:
		<span class="k">case</span> <span class="n">SCTP_PARAM_SET_PRIMARY</span>:
			<span class="n">asconf_param</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="p">)</span><span class="n">param</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
			<span class="n">plen</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_param_t</span><span class="p">)</span> <span class="o">+</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCTP_PARAM_SUCCESS_REPORT</span>:
		<span class="k">case</span> <span class="n">SCTP_PARAM_ADAPTATION_LAYER_IND</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_param_t</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">+=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">v</span> <span class="o">!=</span> <span class="n">chunk_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process an incoming ASCONF chunk with the next expected serial no. and</span>
<span class="cm"> * return an ASCONF_ACK chunk to be sent in response.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_process_asconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">asconf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addiphdr_t</span>		<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span>	<span class="o">*</span><span class="n">addr_param</span><span class="p">;</span>
	<span class="n">sctp_addip_param_t</span>	<span class="o">*</span><span class="n">asconf_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">asconf_ack</span><span class="p">;</span>

	<span class="n">__be16</span>	<span class="n">err_code</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">chunk_len</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">serial</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">all_param_pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">chunk_len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_addiphdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">serial</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* Skip the addiphdr and store a pointer to address parameter.  */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addiphdr_t</span><span class="p">);</span>
	<span class="n">addr_param</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">)(</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">chunk_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Skip the address parameter and store a pointer to the first</span>
<span class="cm">	 * asconf parameter.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr_param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
	<span class="n">asconf_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">chunk_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* create an ASCONF_ACK chunk.</span>
<span class="cm">	 * Based on the definitions of parameters, we know that the size of</span>
<span class="cm">	 * ASCONF_ACK parameters are less than or equal to the fourfold of ASCONF</span>
<span class="cm">	 * parameters.</span>
<span class="cm">	 */</span>
	<span class="n">asconf_ack</span> <span class="o">=</span> <span class="n">sctp_make_asconf_ack</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">serial</span><span class="p">,</span> <span class="n">chunk_len</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asconf_ack</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Process the TLVs contained within the ASCONF chunk. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">chunk_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_code</span> <span class="o">=</span> <span class="n">sctp_process_asconf_param</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asconf</span><span class="p">,</span>
						     <span class="n">asconf_param</span><span class="p">);</span>
		<span class="cm">/* ADDIP 4.1 A7)</span>
<span class="cm">		 * If an error response is received for a TLV parameter,</span>
<span class="cm">		 * all TLVs with no response before the failed TLV are</span>
<span class="cm">		 * considered successful if not reported.  All TLVs after</span>
<span class="cm">		 * the failed response are considered unsuccessful unless</span>
<span class="cm">		 * a specific success indication is present for the parameter.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span> <span class="o">!=</span> <span class="n">err_code</span><span class="p">)</span>
			<span class="n">all_param_pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">all_param_pass</span><span class="p">)</span>
			<span class="n">sctp_add_asconf_response</span><span class="p">(</span><span class="n">asconf_ack</span><span class="p">,</span>
						 <span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">crr_id</span><span class="p">,</span> <span class="n">err_code</span><span class="p">,</span>
						 <span class="n">asconf_param</span><span class="p">);</span>

		<span class="cm">/* ADDIP 4.3 D11) When an endpoint receiving an ASCONF to add</span>
<span class="cm">		 * an IP address sends an &#39;Out of Resource&#39; in its response, it</span>
<span class="cm">		 * MUST also fail any subsequent add or delete requests bundled</span>
<span class="cm">		 * in the ASCONF.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_ERROR_RSRC_LOW</span> <span class="o">==</span> <span class="n">err_code</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="cm">/* Move to the next ASCONF param. */</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="n">asconf_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">chunk_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_serial</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If we are sending a new ASCONF_ACK hold a reference to it in assoc</span>
<span class="cm">	 * after freeing the reference to old asconf ack if any.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asconf_ack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="n">asconf_ack</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_ack_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">asconf_ack</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process a asconf parameter that is successfully acked. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_asconf_param_success</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="n">asconf_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">addr_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">saddr</span><span class="p">;</span>

	<span class="n">addr_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_param</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_param_t</span><span class="p">);</span>

	<span class="cm">/* We have checked the packet before, so we do not check again.	*/</span>
	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">param_type2af</span><span class="p">(</span><span class="n">addr_param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">type</span><span class="p">));</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">from_addr_param</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr_param</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_ADD_IP</span>:
		<span class="cm">/* This is always done in BH context with a socket lock</span>
<span class="cm">		 * held, so the list can not change.</span>
<span class="cm">		 */</span>
		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span>
				<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCTP_ADDR_SRC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dst_release</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCTP_PARAM_DEL_IP</span>:
		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">sctp_del_bind_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">);</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dst_release</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get the corresponding ASCONF response error code from the ASCONF_ACK chunk</span>
<span class="cm"> * for the given asconf parameter.  If there is no response for this parameter,</span>
<span class="cm"> * return the error code based on the third argument &#39;no_err&#39;.</span>
<span class="cm"> * ADDIP 4.1</span>
<span class="cm"> * A7) If an error response is received for a TLV parameter, all TLVs with no</span>
<span class="cm"> * response before the failed TLV are considered successful if not reported.</span>
<span class="cm"> * All TLVs after the failed response are considered unsuccessful unless a</span>
<span class="cm"> * specific success indication is present for the parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be16</span> <span class="nf">sctp_get_asconf_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">asconf_ack</span><span class="p">,</span>
				      <span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="n">asconf_param</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">no_err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_addip_param_t</span>	<span class="o">*</span><span class="n">asconf_ack_param</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span>		<span class="o">*</span><span class="n">err_param</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">asconf_ack_len</span><span class="p">;</span>
	<span class="n">__be16</span>			<span class="n">err_code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_err</span><span class="p">)</span>
		<span class="n">err_code</span> <span class="o">=</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err_code</span> <span class="o">=</span> <span class="n">SCTP_ERROR_REQ_REFUSED</span><span class="p">;</span>

	<span class="n">asconf_ack_len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">);</span>

	<span class="cm">/* Skip the addiphdr from the asconf_ack chunk and store a pointer to</span>
<span class="cm">	 * the first asconf_ack parameter.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addiphdr_t</span><span class="p">);</span>
	<span class="n">asconf_ack_param</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_addip_param_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
						  <span class="n">length</span><span class="p">);</span>
	<span class="n">asconf_ack_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">asconf_ack_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asconf_ack_param</span><span class="o">-&gt;</span><span class="n">crr_id</span> <span class="o">==</span> <span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">crr_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">asconf_ack_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCTP_PARAM_SUCCESS_REPORT</span>:
				<span class="k">return</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SCTP_PARAM_ERR_CAUSE</span>:
				<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_param_t</span><span class="p">);</span>
				<span class="n">err_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_ack_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
				<span class="n">asconf_ack_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">asconf_ack_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err_param</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">return</span> <span class="n">SCTP_ERROR_INV_PARAM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">return</span> <span class="n">SCTP_ERROR_INV_PARAM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf_ack_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="n">asconf_ack_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_ack_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">asconf_ack_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process an incoming ASCONF_ACK chunk against the cached last ASCONF chunk. */</span>
<span class="kt">int</span> <span class="nf">sctp_process_asconf_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">asconf_ack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span>	<span class="o">*</span><span class="n">asconf</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span>	<span class="o">*</span><span class="n">addr_param</span><span class="p">;</span>
	<span class="n">sctp_addip_param_t</span>	<span class="o">*</span><span class="n">asconf_param</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">asconf_len</span> <span class="o">=</span> <span class="n">asconf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">all_param_pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">no_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">err_code</span> <span class="o">=</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>

	<span class="cm">/* Skip the chunkhdr and addiphdr from the last asconf sent and store</span>
<span class="cm">	 * a pointer to address parameter.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addip_chunk_t</span><span class="p">);</span>
	<span class="n">addr_param</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">)(</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">asconf_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Skip the address parameter in the last asconf sent and store a</span>
<span class="cm">	 * pointer to the first asconf parameter.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr_param</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
	<span class="n">asconf_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">asconf_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* ADDIP 4.1</span>
<span class="cm">	 * A8) If there is no response(s) to specific TLV parameter(s), and no</span>
<span class="cm">	 * failures are indicated, then all request(s) are considered</span>
<span class="cm">	 * successful.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asconf_ack</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_addiphdr_t</span><span class="p">))</span>
		<span class="n">all_param_pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Process the TLVs contained in the last sent ASCONF chunk. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">asconf_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all_param_pass</span><span class="p">)</span>
			<span class="n">err_code</span> <span class="o">=</span> <span class="n">SCTP_ERROR_NO_ERROR</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">err_code</span> <span class="o">=</span> <span class="n">sctp_get_asconf_response</span><span class="p">(</span><span class="n">asconf_ack</span><span class="p">,</span>
							    <span class="n">asconf_param</span><span class="p">,</span>
							    <span class="n">no_err</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">no_err</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">SCTP_ERROR_NO_ERROR</span> <span class="o">!=</span> <span class="n">err_code</span><span class="p">))</span>
				<span class="n">no_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">err_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCTP_ERROR_NO_ERROR</span>:
			<span class="n">sctp_asconf_param_success</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asconf_param</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_ERROR_RSRC_LOW</span>:
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_ERROR_UNKNOWN_PARAM</span>:
			<span class="cm">/* Disable sending this type of asconf parameter in</span>
<span class="cm">			 * future.</span>
<span class="cm">			 */</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_disabled_mask</span> <span class="o">|=</span>
				<span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCTP_ERROR_REQ_REFUSED</span>:
		<span class="k">case</span> <span class="n">SCTP_ERROR_DEL_LAST_IP</span>:
		<span class="k">case</span> <span class="n">SCTP_ERROR_DEL_SRC_IP</span>:
		<span class="nl">default:</span>
			 <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Skip the processed asconf parameter and move to the next</span>
<span class="cm">		 * one.</span>
<span class="cm">		 */</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">asconf_param</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="n">asconf_param</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asconf_param</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">asconf_len</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_err</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sctp_transport_immediate_rtx</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free the cached last sent asconf chunk. */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
	<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">asconf</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make a FWD TSN chunk. */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_make_fwdtsn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="n">__u32</span> <span class="n">new_cum_tsn</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nstreams</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="o">*</span><span class="n">skiplist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span> <span class="n">ftsn_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_fwdtsn_skip</span> <span class="n">skip</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hint</span> <span class="o">=</span> <span class="p">(</span><span class="n">nstreams</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sctp_make_chunk</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">SCTP_CID_FWD_TSN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hint</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ftsn_hdr</span><span class="p">.</span><span class="n">new_cum_tsn</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">new_cum_tsn</span><span class="p">);</span>
	<span class="n">retval</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">fwdtsn_hdr</span> <span class="o">=</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ftsn_hdr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ftsn_hdr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nstreams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skip</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">skiplist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stream</span><span class="p">;</span>
		<span class="n">skip</span><span class="p">.</span><span class="n">ssn</span> <span class="o">=</span> <span class="n">skiplist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ssn</span><span class="p">;</span>
		<span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skip</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">skip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
