<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › associola.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>associola.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * This module provides the abstraction for an SCTP association.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson          &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Xingang Guo           &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Hui Huang             &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala	    &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Daisy Chang	    &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Ryan Layer	    &lt;rmlayer@us.ibm.com&gt;</span>
<span class="cm"> *    Kevin Gao             &lt;kevin.gao@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="cm">/* Forward declarations for internal functions. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_assoc_bh_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_assoc_free_asconf_acks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_assoc_free_asconf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>

<span class="cm">/* Keep track of the new idr low so that we don&#39;t re-use association id</span>
<span class="cm"> * numbers too fast.  It is protected by they idr spin lock is in the</span>
<span class="cm"> * range of 1 - INT_MAX.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">idr_low</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


<span class="cm">/* 1st Level Abstractions. */</span>

<span class="cm">/* Initialize a new association from provided memory. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_association_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					  <span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">,</span>
					  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Retrieve the SCTP per socket area.  */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">((</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Discarding const is appropriate here.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">)</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">sctp_endpoint_hold</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Hold the sock.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Initialize the common base substructure.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_EP_TYPE_ASSOCIATION</span><span class="p">;</span>

	<span class="cm">/* Initialize the object handling fields.  */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Initialize the bind addr area.  */</span>
	<span class="n">sctp_bind_addr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCTP_STATE_CLOSED</span><span class="p">;</span>

	<span class="cm">/* Set these values from the socket values, a conversion between</span>
<span class="cm">	 * millsecons to seconds/microseconds must also be done.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">cookie_life</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_cookie_life</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span>
					<span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">user_frag</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">user_frag</span><span class="p">;</span>

	<span class="cm">/* Set the association max_retrans and RTO values from the</span>
<span class="cm">	 * socket values.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_retrans</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">assocparams</span><span class="p">.</span><span class="n">sasoc_asocmaxrxt</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_initial</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_max</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_min</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rtoinfo</span><span class="p">.</span><span class="n">srto_min</span><span class="p">);</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Initialize the association&#39;s heartbeat interval based on the</span>
<span class="cm">	 * sock configured value.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">hbinterval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">hbinterval</span><span class="p">);</span>

	<span class="cm">/* Initialize path max retrans value. */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">;</span>

	<span class="cm">/* Initialize default path MTU. */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>

	<span class="cm">/* Set association default SACK delay */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">sackfreq</span><span class="p">;</span>

	<span class="cm">/* Set the association default flags controlling</span>
<span class="cm">	 * Heartbeat, SACK delay, and Path MTU Discovery.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">param_flags</span><span class="p">;</span>

	<span class="cm">/* Initialize the maximum mumber of new data packets that can be sent</span>
<span class="cm">	 * in a burst.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_burst</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">max_burst</span><span class="p">;</span>

	<span class="cm">/* initialize association timers */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_NONE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T1_COOKIE</span><span class="p">]</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T1_INIT</span><span class="p">]</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T2_SHUTDOWN</span><span class="p">]</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T3_RTX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T4_RTO</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* sctpimpguide Section 2.12.2</span>
<span class="cm">	 * If the &#39;T5-shutdown-guard&#39; timer is used, it SHOULD be set to the</span>
<span class="cm">	 * recommended value of 5 times &#39;RTO.Max&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD</span><span class="p">]</span>
		<span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_max</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_HEARTBEAT</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">]</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_AUTOCLOSE</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">,</span> <span class="n">sctp_max_autoclose</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* Initializes the timers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">SCTP_EVENT_TIMEOUT_NONE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCTP_NUM_TIMEOUT_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sctp_timer_events</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Pull default initialization values from the sock options.</span>
<span class="cm">	 * Note: This assumes that the values have already been</span>
<span class="cm">	 * validated in the sock.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_max_instreams</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_instreams</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">sinit_num_ostreams</span>  <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_num_ostreams</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_attempts</span>	<span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_attempts</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">max_init_timeo</span> <span class="o">=</span>
		 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">initmsg</span><span class="p">.</span><span class="n">sinit_max_init_timeo</span><span class="p">);</span>

	<span class="cm">/* Allocate storage for the ssnmap after the inbound and outbound</span>
<span class="cm">	 * streams have been negotiated during Init.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set the local window size for receive.</span>
<span class="cm">	 * This is also the rcvbuf space per association.</span>
<span class="cm">	 * RFC 6 - A SCTP receiver MUST be able to receive a minimum of</span>
<span class="cm">	 * 1500 bytes in one SCTP packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SCTP_DEFAULT_MINWINDOW</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MINWINDOW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Use my own max window until I learn something better.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXWINDOW</span><span class="p">;</span>

	<span class="cm">/* Set the sndbuf size for transmit.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sndbuf_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Initialize the receive memory counter */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rmem_alloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_vtag</span> <span class="o">=</span> <span class="n">sctp_generate_tag</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">init_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* INIT needs a vtag of 0. */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_vtag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_ttag</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">peer_ttag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">my_port</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span> <span class="o">=</span> <span class="n">sctp_generate_tsn</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">highest_sacked</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_cwr_tsn</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">unack_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ADDIP Section 4.1 Asconf Chunk Procedures</span>
<span class="cm">	 *</span>
<span class="cm">	 * When an endpoint has an ASCONF signaled change to be sent to the</span>
<span class="cm">	 * remote endpoint it should do the following:</span>
<span class="cm">	 * ...</span>
<span class="cm">	 * A2) a serial number should be assigned to the chunk. The serial</span>
<span class="cm">	 * number SHOULD be a monotonically increasing number. The serial</span>
<span class="cm">	 * numbers SHOULD be initialized at the start of the</span>
<span class="cm">	 * association to the same value as the initial TSN.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_serial</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_chunk_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_ack_list</span><span class="p">);</span>

	<span class="cm">/* Make an empty list of remote transport addresses.  */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 5.1 Normal Establishment of an Association</span>
<span class="cm">	 *</span>
<span class="cm">	 * After the reception of the first data chunk in an</span>
<span class="cm">	 * association the endpoint must immediately respond with a</span>
<span class="cm">	 * sack to acknowledge the data chunk.  Subsequent</span>
<span class="cm">	 * acknowledgements should be done as described in Section</span>
<span class="cm">	 * 6.2.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [We implement this by telling a new association that it</span>
<span class="cm">	 * already received one packet.]</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_generation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Assume that the peer will tell us if he recognizes ASCONF</span>
<span class="cm">	 * as part of INIT exchange.</span>
<span class="cm">	 * The sctp_addip_noauth option is there for backward compatibilty</span>
<span class="cm">	 * and will revert old behavior.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_addip_noauth</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">asconf_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">new_transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Create an input queue.  */</span>
	<span class="n">sctp_inq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">);</span>
	<span class="n">sctp_inq_set_th_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">,</span> <span class="n">sctp_assoc_bh_rcv</span><span class="p">);</span>

	<span class="cm">/* Create an output queue.  */</span>
	<span class="n">sctp_outq_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_ulpq_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">asoc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_tsnmap</span><span class="p">));</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">need_ecne</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Assume that peer would support both address types unless we are</span>
<span class="cm">	 * told otherwise.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv4_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_INET6</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv6_address</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">);</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">autoclose</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">autoclose</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_stream</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_stream</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_ppid</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_ppid</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_flags</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_flags</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_context</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_context</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_timetolive</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_timetolive</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span><span class="p">;</span>

	<span class="cm">/* AUTH related initializations */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">endpoint_shared_keys</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sctp_auth_asoc_copy_shkeys</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">active_key_id</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">active_key_id</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asoc_shared_key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_hmac_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Save the hmacs and chunks list into this association */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs_list</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_hmacs</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs_list</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_hmacs_list</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_chunk_list</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_chunks</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_chunk_list</span><span class="p">,</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">auth_chunk_list</span><span class="o">-&gt;</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">));</span>

	<span class="cm">/* Get the AUTH random number for this association */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_paramhdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">auth_random</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_RANDOM</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">SCTP_AUTH_RANDOM_LENGTH</span><span class="p">);</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">SCTP_AUTH_RANDOM_LENGTH</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>

<span class="nl">fail_init:</span>
	<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate and initialize a new association */</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_association_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">,</span>
					 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">t_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_association_init</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">malloced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">SCTP_DBG_OBJCNT_INC</span><span class="p">(</span><span class="n">assoc</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;Created asoc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>

<span class="nl">fail_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free this association if possible.  There may still be users, so</span>
<span class="cm"> * the actual deallocation may be delayed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_association_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Only real associations count against the endpoint, so</span>
<span class="cm">	 * don&#39;t bother for if this is a temporary association.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">);</span>

		<span class="cm">/* Decrement the backlog value for a TCP-style listening</span>
<span class="cm">		 * socket.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sctp_sstate</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">LISTENING</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark as dead, so other users can know this structure is</span>
<span class="cm">	 * going away.</span>
<span class="cm">	 */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Dispose of any data lying around in the outqueue. */</span>
	<span class="n">sctp_outq_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">);</span>

	<span class="cm">/* Dispose of any pending messages for the upper layer. */</span>
	<span class="n">sctp_ulpq_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">);</span>

	<span class="cm">/* Dispose of any pending chunks on the inqueue. */</span>
	<span class="n">sctp_inq_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">);</span>

	<span class="n">sctp_tsnmap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>

	<span class="cm">/* Free ssnmap storage. */</span>
	<span class="n">sctp_ssnmap_free</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="p">);</span>

	<span class="cm">/* Clean up the bound address list. */</span>
	<span class="n">sctp_bind_addr_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">);</span>

	<span class="cm">/* Do we need to go through all of our timers and</span>
<span class="cm">	 * delete them?   To be safe we will try to delete all, but we</span>
<span class="cm">	 * should be able to go through and make a guess based</span>
<span class="cm">	 * on our state.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">SCTP_EVENT_TIMEOUT_NONE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCTP_NUM_TIMEOUT_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Free peer&#39;s cached cookie. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">cookie</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span><span class="p">);</span>

	<span class="cm">/* Release the transport structures. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">sctp_transport_free</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sctp_asconf_queue_teardown</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Free pending address space being deleted */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_addr_del_pending</span><span class="p">);</span>

	<span class="cm">/* AUTH - Free the endpoint shared keys */</span>
	<span class="n">sctp_auth_destroy_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">endpoint_shared_keys</span><span class="p">);</span>

	<span class="cm">/* AUTH - Free the association shared key */</span>
	<span class="n">sctp_auth_key_put</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asoc_shared_key</span><span class="p">);</span>

	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cleanup and free up an association. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_association_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">,</span> <span class="s">&quot;Assoc is not dead&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>

	<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rmem_alloc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">malloced</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="n">SCTP_DBG_OBJCNT_DEC</span><span class="p">(</span><span class="n">assoc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Change the primary destination address for the peer. */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_set_primary</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">changeover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* it&#39;s a changeover only if we already have a primary path</span>
<span class="cm">	 * that we are changing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span> <span class="o">!=</span> <span class="n">transport</span><span class="p">)</span>
		<span class="n">changeover</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>

	<span class="cm">/* Set a default msg_name for events. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span><span class="p">));</span>

	<span class="cm">/* If the primary path is changing, assume that the</span>
<span class="cm">	 * user wants to use this new path.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ACTIVE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">))</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SFR-CACC algorithm:</span>
<span class="cm">	 * Upon the receipt of a request to change the primary</span>
<span class="cm">	 * destination address, on the data structure for the new</span>
<span class="cm">	 * primary destination, the sender MUST do the following:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) If CHANGEOVER_ACTIVE is set, then there was a switch</span>
<span class="cm">	 * to this destination address earlier. The sender MUST set</span>
<span class="cm">	 * CYCLING_CHANGEOVER to indicate that this switch is a</span>
<span class="cm">	 * double switch to the same destination address.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Really, only bother is we have data queued or outstanding on</span>
<span class="cm">	 * the association.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">outstanding_bytes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">.</span><span class="n">out_qlen</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">changeover_active</span><span class="p">)</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">cycling_changeover</span> <span class="o">=</span> <span class="n">changeover</span><span class="p">;</span>

	<span class="cm">/* 2) The sender MUST set CHANGEOVER_ACTIVE to indicate that</span>
<span class="cm">	 * a changeover has occurred.</span>
<span class="cm">	 */</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">changeover_active</span> <span class="o">=</span> <span class="n">changeover</span><span class="p">;</span>

	<span class="cm">/* 3) The sender MUST store the next TSN to be sent in</span>
<span class="cm">	 * next_tsn_at_change.</span>
<span class="cm">	 */</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">cacc</span><span class="p">.</span><span class="n">next_tsn_at_change</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove a transport from an association.  */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_rm_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>	<span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_assoc_rm_peer:association %p addr: &quot;</span><span class="p">,</span>
				 <span class="s">&quot; port: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">asoc</span><span class="p">,</span>
				 <span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">),</span>
				 <span class="n">ntohs</span><span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>

	<span class="cm">/* If we are to remove the current retran_path, update it</span>
<span class="cm">	 * to the next peer before removing this peer from the list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">sctp_assoc_update_retran_path</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Remove this peer from the list. */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transports</span><span class="p">);</span>

	<span class="cm">/* Get the first transport of asoc. */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>

	<span class="cm">/* Update any entries that match the peer to be deleted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">last_data_from</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">last_data_from</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>

	<span class="cm">/* If we remove the transport an INIT was last sent to, set it to</span>
<span class="cm">	 * NULL. Combined with the update of the retran path above, this</span>
<span class="cm">	 * will cause the next INIT to be sent to the next available</span>
<span class="cm">	 * transport, maintaining the cycle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_last_sent_to</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">init_last_sent_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If we remove the transport an SHUTDOWN was last sent to, set it</span>
<span class="cm">	 * to NULL. Combined with the update of the retran path above, this</span>
<span class="cm">	 * will cause the next SHUTDOWN to be sent to the next available</span>
<span class="cm">	 * transport, maintaining the cycle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">shutdown_last_sent_to</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">shutdown_last_sent_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If we remove the transport an ASCONF was last sent to, set it to</span>
<span class="cm">	 * NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span> <span class="o">&amp;&amp;</span>
	    <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">peer</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If we have something on the transmitted list, we have to</span>
<span class="cm">	 * save it off.  The best place is the active path.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">active</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>

		<span class="cm">/* Reset the transport of each chunk on this list */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">,</span>
					<span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">rtt_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">);</span>

		<span class="cm">/* Start a T3 timer here in case it wasn&#39;t running so</span>
<span class="cm">		 * that these migrated packets have a chance to get</span>
<span class="cm">		 * retrnasmitted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">T3_rtx_timer</span><span class="p">,</span>
					<span class="n">jiffies</span> <span class="o">+</span> <span class="n">active</span><span class="o">-&gt;</span><span class="n">rto</span><span class="p">))</span>
				<span class="n">sctp_transport_hold</span><span class="p">(</span><span class="n">active</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span><span class="o">--</span><span class="p">;</span>

	<span class="n">sctp_transport_free</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add a transport address to an association.  */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_assoc_add_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">int</span> <span class="n">peer_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">peer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* AF_INET and AF_INET6 share common port field. */</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_assoc_add_peer:association %p addr: &quot;</span><span class="p">,</span>
				 <span class="s">&quot; port: %d state:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">asoc</span><span class="p">,</span>
				 <span class="n">addr</span><span class="p">,</span>
				 <span class="n">port</span><span class="p">,</span>
				 <span class="n">peer_state</span><span class="p">);</span>

	<span class="cm">/* Set the port if it has not been set yet.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

	<span class="cm">/* Check to see if this is a duplicate. */</span>
	<span class="n">peer</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* An UNKNOWN state is only set on transports added by</span>
<span class="cm">		 * user in sctp_connectx() call.  Such transports should be</span>
<span class="cm">		 * considered CONFIRMED per RFC 4960, Section 5.4.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCTP_ACTIVE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">peer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">peer</span> <span class="o">=</span> <span class="n">sctp_transport_new</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">peer</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sctp_transport_set_owner</span><span class="p">(</span><span class="n">peer</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Initialize the peer&#39;s heartbeat interval based on the</span>
<span class="cm">	 * association configured value.</span>
<span class="cm">	 */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">hbinterval</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">hbinterval</span><span class="p">;</span>

	<span class="cm">/* Set the path max_retrans.  */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmaxrxt</span><span class="p">;</span>

	<span class="cm">/* Initialize the peer&#39;s SACK delay timeout based on the</span>
<span class="cm">	 * association configured value.</span>
<span class="cm">	 */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">sackdelay</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackdelay</span><span class="p">;</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">sackfreq</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">sackfreq</span><span class="p">;</span>

	<span class="cm">/* Enable/disable heartbeat, SACK delay, and path MTU discovery</span>
<span class="cm">	 * based on association setting.</span>
<span class="cm">	 */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">param_flags</span><span class="p">;</span>

	<span class="n">sctp_transport_route</span><span class="p">(</span><span class="n">peer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>

	<span class="cm">/* Initialize the pmtu of the transport. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">)</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXSEGMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this is the first transport addr on this association,</span>
<span class="cm">	 * initialize the association PMTU to the peer&#39;s PMTU.</span>
<span class="cm">	 * If not and the current association PMTU is higher than the new</span>
<span class="cm">	 * peer&#39;s PMTU, reset the association PMTU to the new peer&#39;s PMTU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">peer</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">peer</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_assoc_add_peer:association %p PMTU set to &quot;</span>
			  <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">pmtu_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span> <span class="o">=</span> <span class="n">sctp_frag_point</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">);</span>

	<span class="cm">/* The asoc-&gt;peer.port might not be meaningful yet, but</span>
<span class="cm">	 * initialize the packet structure anyway.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_packet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">,</span>
			 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* 7.2.1 Slow-Start</span>
<span class="cm">	 *</span>
<span class="cm">	 * o The initial cwnd before DATA transmission or after a sufficiently</span>
<span class="cm">	 *   long idle period MUST be set to</span>
<span class="cm">	 *      min(4*MTU, max(2*MTU, 4380 bytes))</span>
<span class="cm">	 *</span>
<span class="cm">	 * o The initial value of ssthresh MAY be arbitrarily high</span>
<span class="cm">	 *   (for example, implementations MAY use the size of the</span>
<span class="cm">	 *   receiver advertised window).</span>
<span class="cm">	 */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="n">max_t</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="mi">4380</span><span class="p">));</span>

	<span class="cm">/* At this point, we may not have the receiver&#39;s advertised window,</span>
<span class="cm">	 * so initialize ssthresh to the default value and it will be set</span>
<span class="cm">	 * later when we process the INIT.</span>
<span class="cm">	 */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">ssthresh</span> <span class="o">=</span> <span class="n">SCTP_DEFAULT_MAXWINDOW</span><span class="p">;</span>

	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">partial_bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">flight_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">burst_limited</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the transport&#39;s RTO.initial value */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">rto</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rto_initial</span><span class="p">;</span>

	<span class="cm">/* Set the peer&#39;s active state. */</span>
	<span class="n">peer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">peer_state</span><span class="p">;</span>

	<span class="cm">/* Attach the remote transport to our asoc.  */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">transports</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If we do not yet have a primary path, set one.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">peer</span><span class="p">);</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">peer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">&amp;&amp;</span>
	    <span class="n">peer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">peer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">peer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delete a transport address from an association.  */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_del_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>	<span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Do book keeping for removing the peer and free it. */</span>
			<span class="n">sctp_assoc_rm_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Lookup a transport by address. */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_assoc_lookup_paddr</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* Cycle through all transports searching for a peer address. */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove all transports except a give one */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_del_nonprimary_peers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>	<span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span>	<span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				 <span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the current transport is not the primary one, delete it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">primary</span><span class="p">)</span>
			<span class="n">sctp_assoc_rm_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Engage in transport control operations.</span>
<span class="cm"> * Mark the transport up or down and send a notification to the user.</span>
<span class="cm"> * Select and update the new active and retran paths.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_control_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				  <span class="n">sctp_transport_cmd_t</span> <span class="n">command</span><span class="p">,</span>
				  <span class="n">sctp_sn_error_t</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">second</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spc_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Record the transition on the transport.  */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_TRANSPORT_UP</span>:
		<span class="cm">/* If we are moving from UNCONFIRMED state due</span>
<span class="cm">		 * to heartbeat success, report the SCTP_ADDR_CONFIRMED</span>
<span class="cm">		 * state to the user, otherwise report SCTP_ADDR_AVAILABLE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCTP_UNCONFIRMED</span> <span class="o">==</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;&amp;</span>
		    <span class="n">SCTP_HEARTBEAT_SUCCESS</span> <span class="o">==</span> <span class="n">error</span><span class="p">)</span>
			<span class="n">spc_state</span> <span class="o">=</span> <span class="n">SCTP_ADDR_CONFIRMED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">spc_state</span> <span class="o">=</span> <span class="n">SCTP_ADDR_AVAILABLE</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCTP_ACTIVE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCTP_TRANSPORT_DOWN</span>:
		<span class="cm">/* If the transport was never confirmed, do not transition it</span>
<span class="cm">		 * to inactive state.  Also, release the cached route since</span>
<span class="cm">		 * there may be a better route next time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">)</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCTP_INACTIVE</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dst_release</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spc_state</span> <span class="o">=</span> <span class="n">SCTP_ADDR_UNREACHABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Generate and send a SCTP_PEER_ADDR_CHANGE notification to the</span>
<span class="cm">	 * user.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_storage</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">sockaddr_len</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_make_peer_addr_change</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">spc_state</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span>
		<span class="n">sctp_ulpq_tail_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="cm">/* Select new active and retran paths. */</span>

	<span class="cm">/* Look for the two most recently used active transports.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code produces the wrong ordering whenever jiffies</span>
<span class="cm">	 * rolls over, but we still get usable transports, so we don&#39;t</span>
<span class="cm">	 * worry about it.</span>
<span class="cm">	 */</span>
	<span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">second</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_INACTIVE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNCONFIRMED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span> <span class="o">||</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">last_time_heard</span> <span class="o">&gt;</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">last_time_heard</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">second</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">second</span> <span class="o">||</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">last_time_heard</span> <span class="o">&gt;</span> <span class="n">second</span><span class="o">-&gt;</span><span class="n">last_time_heard</span><span class="p">)</span>
			<span class="n">second</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* RFC 2960 6.4 Multi-Homed SCTP Endpoints</span>
<span class="cm">	 *</span>
<span class="cm">	 * By default, an endpoint should always transmit to the</span>
<span class="cm">	 * primary path, unless the SCTP user explicitly specifies the</span>
<span class="cm">	 * destination transport address (and possibly source</span>
<span class="cm">	 * transport address) to use.</span>
<span class="cm">	 *</span>
<span class="cm">	 * [If the primary is active but not most recent, bump the most</span>
<span class="cm">	 * recently used transport.]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ACTIVE</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">first</span> <span class="o">!=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">second</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we failed to find a usable transport, just camp on the</span>
<span class="cm">	 * primary, even if it is inactive.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>
		<span class="n">second</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the active and retran transports.  */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Hold a reference to an association. */</span>
<span class="kt">void</span> <span class="nf">sctp_association_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Release a reference to an association and cleanup</span>
<span class="cm"> * if there are no more references.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_association_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">sctp_association_destroy</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate the next TSN, Transmission Sequence Number, for the given</span>
<span class="cm"> * association.</span>
<span class="cm"> */</span>
<span class="n">__u32</span> <span class="nf">sctp_association_get_next_tsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* From Section 1.6 Serial Number Arithmetic:</span>
<span class="cm">	 * Transmission Sequence Numbers wrap around when they reach</span>
<span class="cm">	 * 2**32 - 1.  That is, the next TSN a DATA chunk MUST use</span>
<span class="cm">	 * after transmitting TSN = 2*32 - 1 is TSN = 0.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="o">++</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">unack_data</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compare two addresses to see if they match.  Wildcard addresses</span>
<span class="cm"> * only match themselves.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_cmp_addr_exact</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">ss1</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">ss2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="n">af</span> <span class="o">=</span> <span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">ss1</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">cmp_addr</span><span class="p">(</span><span class="n">ss1</span><span class="p">,</span> <span class="n">ss2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return an ecne chunk to get prepended to a packet.</span>
<span class="cm"> * Note:  We are sly and return a shared, prealloced chunk.  FIXME:</span>
<span class="cm"> * No we don&#39;t, but we could/should.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_get_ecne_prepend</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>

	<span class="cm">/* Send ECNE if needed.</span>
<span class="cm">	 * Not being able to allocate a chunk here is not deadly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">need_ecne</span><span class="p">)</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_make_ecne</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">last_ecne_tsn</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">chunk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find which transport this TSN was sent on.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_assoc_lookup_tsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					     <span class="n">__u32</span> <span class="n">tsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">key</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tsn</span><span class="p">);</span>

	<span class="n">match</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: In general, find a more efficient data structure for</span>
<span class="cm">	 * searching.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The general strategy is to search each transport&#39;s transmitted</span>
<span class="cm">	 * list.   Return which transport this TSN lives on.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Let&#39;s be hopeful and check the active_path first.</span>
<span class="cm">	 * Another optimization would be to know if there is only one</span>
<span class="cm">	 * outbound path and not have to look for the TSN at all.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">,</span>
			<span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">match</span> <span class="o">=</span> <span class="n">active</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If not found, go search all the other transports. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
			<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span> <span class="o">==</span> <span class="n">active</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">transmitted</span><span class="p">,</span>
				<span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">match</span> <span class="o">=</span> <span class="n">transport</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is this the association we are looking for? */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_assoc_is_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">paddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">transport</span> <span class="o">=</span> <span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_bind_addr_match</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span>
					 <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">transport</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do delayed input processing.  This is scheduled by sctp_rcv(). */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_assoc_bh_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span>
			     <span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">.</span><span class="n">immediate</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="n">inqueue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">sctp_subtype_t</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The association should be held so we should be safe. */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">inqueue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">inqueue</span><span class="p">;</span>
	<span class="n">sctp_association_hold</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">sctp_inq_pop</span><span class="p">(</span><span class="n">inqueue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="n">subtype</span> <span class="o">=</span> <span class="n">SCTP_ST_CHUNK</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

		<span class="cm">/* SCTP-AUTH, Section 6.3:</span>
<span class="cm">		 *    The receiver has a list of chunk types which it expects</span>
<span class="cm">		 *    to be received only after an AUTH-chunk.  This list has</span>
<span class="cm">		 *    been sent to the peer during the association setup.  It</span>
<span class="cm">		 *    MUST silently discard these chunks if they are not placed</span>
<span class="cm">		 *    after an AUTH chunk in the packet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_auth_recv_cid</span><span class="p">(</span><span class="n">subtype</span><span class="p">.</span><span class="n">chunk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Remember where the last DATA chunk came from so we</span>
<span class="cm">		 * know where to send the SACK.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_chunk_is_data</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">last_data_from</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_INCTRLCHUNKS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">last_time_heard</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="cm">/* Run through the state machine. */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_do_sm</span><span class="p">(</span><span class="n">SCTP_EVENT_T_CHUNK</span><span class="p">,</span> <span class="n">subtype</span><span class="p">,</span>
				   <span class="n">state</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="cm">/* Check to see if the association is freed in response to</span>
<span class="cm">		 * the incoming chunk.  If so, get out of the while loop.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dead</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* If there is an error on chunk, discard this packet. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="p">)</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">pdiscard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine moves an association from its old sk to a new sk.  */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">assoc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">newsp</span> <span class="o">=</span> <span class="n">sctp_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">oldsk</span> <span class="o">=</span> <span class="n">assoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* Delete the association from the old endpoint&#39;s list of</span>
<span class="cm">	 * associations.</span>
<span class="cm">	 */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">asocs</span><span class="p">);</span>

	<span class="cm">/* Decrement the backlog value for a TCP-style socket. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_style</span><span class="p">(</span><span class="n">oldsk</span><span class="p">,</span> <span class="n">TCP</span><span class="p">))</span>
		<span class="n">oldsk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Release references to the old endpoint and the sock.  */</span>
	<span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Get a reference to the new endpoint.  */</span>
	<span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">newsp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">sctp_endpoint_hold</span><span class="p">(</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* Get a reference to the new sock.  */</span>
	<span class="n">assoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span> <span class="o">=</span> <span class="n">newsk</span><span class="p">;</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">assoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Add the association to the new endpoint&#39;s list of associations.  */</span>
	<span class="n">sctp_endpoint_add_asoc</span><span class="p">(</span><span class="n">newsp</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">,</span> <span class="n">assoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Update an association (possibly from unexpected COOKIE-ECHO processing).  */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* Copy in new parameters of peer. */</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">rwnd</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span><span class="p">;</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
	<span class="n">sctp_tsnmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span> <span class="n">SCTP_TSN_MAP_INITIAL</span><span class="p">,</span>
			 <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">initial_tsn</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/* Remove any peer addresses not present in the new association. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sctp_assoc_rm_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">)</span>
			<span class="n">sctp_transport_reset</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If the case is A (association restart), use</span>
<span class="cm">	 * initial_tsn as next_tsn. If the case is B, use</span>
<span class="cm">	 * current next_tsn in case data sent to peer</span>
<span class="cm">	 * has been discarded and needs retransmission.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">SCTP_STATE_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">next_tsn</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span><span class="p">;</span>

		<span class="cm">/* Reinitialize SSN for both local streams</span>
<span class="cm">		 * and peer&#39;s streams.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_ssnmap_clear</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="p">);</span>

		<span class="cm">/* Flush the ULP reassembly and ordered queue.</span>
<span class="cm">		 * Any data there will now be stale and will</span>
<span class="cm">		 * cause problems.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_ulpq_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ulpq</span><span class="p">);</span>

		<span class="cm">/* reset the overall association error count so</span>
<span class="cm">		 * that the restarted association doesn&#39;t get torn</span>
<span class="cm">		 * down on the next retransmission timer.</span>
<span class="cm">		 */</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">overall_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Add any peer addresses from the new association. */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">))</span>
				<span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">,</span>
						    <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">next_tsn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">adv_peer_ack_point</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ctsn_ack_point</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Move the ssnmap. */</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ssnmap</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">ssnmap</span><span class="p">;</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">ssnmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* get a new association id since we don&#39;t have one</span>
<span class="cm">			 * yet.</span>
<span class="cm">			 */</span>
			<span class="n">sctp_assoc_set_id</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* SCTP-AUTH: Save the peer parameters from the new assocaitions</span>
<span class="cm">	 * and also move the association shared keys over</span>
<span class="cm">	 */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_random</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_chunks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span><span class="p">);</span>
	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">peer_hmacs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sctp_auth_key_put</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asoc_shared_key</span><span class="p">);</span>
	<span class="n">sctp_auth_asoc_init_active_key</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Update the retran path for sending a retransmitted packet.</span>
<span class="cm"> * Round-robin through the active transports, else round-robin</span>
<span class="cm"> * through the inactive transports as this is the next best thing</span>
<span class="cm"> * we can try.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_update_retran_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Find the next transport in a round-robin fashion. */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">transports</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Skip the head. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">,</span> <span class="n">transports</span><span class="p">);</span>

		<span class="cm">/* We have exhausted the list, but didn&#39;t find any</span>
<span class="cm">		 * other active transports.  If so, use the next</span>
<span class="cm">		 * transport.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Try to find an active transport. */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ACTIVE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Keep track of the next transport in case</span>
<span class="cm">			 * we don&#39;t find any active transport.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_UNCONFIRMED</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next</span><span class="p">)</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">;</span>

	<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_assoc_update_retran_path:association&quot;</span>
				 <span class="s">&quot; %p addr: &quot;</span><span class="p">,</span>
				 <span class="s">&quot; port: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">asoc</span><span class="p">,</span>
				 <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">),</span>
				 <span class="n">ntohs</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Choose the transport for sending retransmit packet.  */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="nf">sctp_assoc_choose_alter_transport</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">last_sent_to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If this is the first time packet is sent, use the active path,</span>
<span class="cm">	 * else use the retran path. If the last packet was sent over the</span>
<span class="cm">	 * retran path, update the retran path and use it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_sent_to</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">active_path</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_sent_to</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">)</span>
			<span class="n">sctp_assoc_update_retran_path</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">retran_path</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Update the association&#39;s pmtu and frag_point by going through all the</span>
<span class="cm"> * transports. This routine is called when a transport&#39;s PMTU has changed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_sync_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pmtu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Get the lowest pmtu of all the transports. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">transport_addr_list</span><span class="p">,</span>
				<span class="n">transports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pmtu_pending</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_transport_update_pmtu</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dst_mtu</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">));</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">pmtu_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmtu</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">&lt;</span> <span class="n">pmtu</span><span class="p">))</span>
			<span class="n">pmtu</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span> <span class="o">=</span> <span class="n">pmtu</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span> <span class="o">=</span> <span class="n">sctp_frag_point</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">pmtu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: asoc:%p, pmtu:%d, frag_point:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">frag_point</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Should we send a SACK to update our peer? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_peer_needs_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCTP_STATE_ESTABLISHED</span>:
	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_PENDING</span>:
	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_RECEIVED</span>:
	<span class="k">case</span> <span class="n">SCTP_STATE_SHUTDOWN_SENT</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">&gt;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">-</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">&gt;&gt;</span> <span class="n">sctp_rwnd_upd_shift</span><span class="p">),</span>
			   <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Increase asoc&#39;s rwnd by len and send any window update SACK if needed. */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_rwnd_increase</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">+=</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span><span class="p">);</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we had window pressure, start recovering it</span>
<span class="cm">	 * once our rwnd had reached the accumulated pressure</span>
<span class="cm">	 * threshold.  The idea is to recover slowly, but up</span>
<span class="cm">	 * to the initial advertised window.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span> <span class="o">&amp;&amp;</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">change</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">pathmtu</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span><span class="p">);</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">+=</span> <span class="n">change</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span> <span class="o">-=</span> <span class="n">change</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: asoc %p rwnd increased by %d to (%u, %u) &quot;</span>
			  <span class="s">&quot;- %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">,</span>
			  <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">);</span>

	<span class="cm">/* Send a window update SACK if the rwnd has increased by at least the</span>
<span class="cm">	 * minimum of the association&#39;s PMTU and half of the receive buffer.</span>
<span class="cm">	 * The algorithm used is similar to the one described in</span>
<span class="cm">	 * Section 4.2.3.3 of RFC 1122.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_peer_needs_update</span><span class="p">(</span><span class="n">asoc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">;</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: Sending window update SACK- asoc: %p &quot;</span>
				  <span class="s">&quot;rwnd: %u a_rwnd: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				  <span class="n">asoc</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">a_rwnd</span><span class="p">);</span>
		<span class="n">sack</span> <span class="o">=</span> <span class="n">sctp_make_sack</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sack</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">sack_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">sctp_outq_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">outqueue</span><span class="p">,</span> <span class="n">sack</span><span class="p">);</span>

		<span class="cm">/* Stop the SACK timer.  */</span>
		<span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">timers</span><span class="p">[</span><span class="n">SCTP_EVENT_TIMEOUT_SACK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">del_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
			<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Decrease asoc&#39;s rwnd by len. */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_rwnd_decrease</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rx_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">,</span> <span class="s">&quot;rwnd zero&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>
	<span class="n">SCTP_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span><span class="p">,</span> <span class="s">&quot;rwnd_over not zero&quot;</span><span class="p">,</span> <span class="k">return</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rcvbuf_policy</span><span class="p">)</span>
		<span class="n">rx_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rmem_alloc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rx_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>

	<span class="cm">/* If we&#39;ve reached or overflowed our receive buffer, announce</span>
<span class="cm">	 * a 0 rwnd if rwnd would still be positive.  Store the</span>
<span class="cm">	 * the pottential pressure overflow so that the window can be restored</span>
<span class="cm">	 * back to original value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_count</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="n">over</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span> <span class="o">+=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">;</span>
			<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">;</span>
		<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: asoc %p rwnd decreased by %d to (%u, %u, %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">asoc</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd</span><span class="p">,</span>
			  <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_over</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rwnd_press</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Build the bind address list for the association based on info from the</span>
<span class="cm"> * local endpoint and the remote peer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sctp_assoc_set_bind_addr_from_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
				     <span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Use scoping rules to determine the subset of addresses from</span>
<span class="cm">	 * the endpoint.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">PF_INET6</span> <span class="o">==</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span> <span class="o">?</span> <span class="n">SCTP_ADDR6_ALLOWED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv4_address</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SCTP_ADDR4_PEERSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">ipv6_address</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SCTP_ADDR6_PEERSUPP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_bind_addr_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span>
				   <span class="n">scope</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Build the association&#39;s bind address list from the cookie.  */</span>
<span class="kt">int</span> <span class="nf">sctp_assoc_set_bind_addr_from_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_cookie</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
					 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">var_size2</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">peer_init</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">var_size3</span> <span class="o">=</span> <span class="n">cookie</span><span class="o">-&gt;</span><span class="n">raw_addr_list_len</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">peer_init</span> <span class="o">+</span> <span class="n">var_size2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sctp_raw_to_bind_addrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">var_size3</span><span class="p">,</span>
				      <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Lookup laddr in the bind address list of an association. */</span>
<span class="kt">int</span> <span class="nf">sctp_assoc_lookup_laddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span> <span class="o">==</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sctp_bind_addr_match</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span>
				 <span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">)))</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set an association id for a given association */</span>
<span class="kt">int</span> <span class="nf">sctp_assoc_set_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">assoc_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If the id is already assigned, keep it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id</span><span class="p">,</span> <span class="n">gfp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">,</span>
				    <span class="n">idr_low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">assoc_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idr_low</span> <span class="o">=</span> <span class="n">assoc_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idr_low</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span>
			<span class="n">idr_low</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">asoc</span><span class="o">-&gt;</span><span class="n">assoc_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_assoc_t</span><span class="p">)</span> <span class="n">assoc_id</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free the ASCONF queue */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_assoc_free_asconf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">asconf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">asconf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_chunk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asconf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">asconf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Free asconf_ack cache */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_assoc_free_asconf_acks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_ack_list</span><span class="p">,</span>
				<span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">ack</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Clean up the ASCONF_ACK queue */</span>
<span class="kt">void</span> <span class="nf">sctp_assoc_clean_asconf_ack_cache</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* We can remove all the entries from the queue up to</span>
<span class="cm">	 * the &quot;Peer-Sequence-Number&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_ack_list</span><span class="p">,</span>
				<span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">addip_hdr</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">==</span>
				<span class="n">htonl</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">addip_serial</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">transmitted_list</span><span class="p">);</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">ack</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Find the ASCONF_ACK whose serial number matches ASCONF */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="nf">sctp_assoc_lookup_asconf_ack</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="n">__be32</span> <span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">ack</span><span class="p">;</span>

	<span class="cm">/* Walk through the list of cached ASCONF-ACKs and find the</span>
<span class="cm">	 * ack chunk whose serial number matches that of the request.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">asconf_ack_list</span><span class="p">,</span> <span class="n">transmitted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">addip_hdr</span><span class="o">-&gt;</span><span class="n">serial</span> <span class="o">==</span> <span class="n">serial</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="n">ack</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ack</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_asconf_queue_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Free any cached ASCONF_ACK chunk. */</span>
	<span class="n">sctp_assoc_free_asconf_acks</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Free the ASCONF queue. */</span>
	<span class="n">sctp_assoc_free_asconf_queue</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Free any cached ASCONF chunk. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">)</span>
		<span class="n">sctp_chunk_free</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">addip_last_asconf</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
