<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › ulpevent.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ulpevent.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 Nokia, Inc.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * These functions manipulate an sctp event.   The struct ulpevent is used</span>
<span class="cm"> * to carry notifications and data to the ULP (sockets).</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    Jon Grimm             &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala     &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/sctp/structs.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sm.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_ulpevent_receive_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_ulpevent_release_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sctp_ulpevent_release_frag_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>


<span class="cm">/* Initialize an ULP event from an given skb.  */</span>
<span class="n">SCTP_STATIC</span> <span class="kt">void</span> <span class="nf">sctp_ulpevent_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">msg_flags</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span><span class="p">));</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">msg_flags</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">rmem_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create a new sctp_ulpevent.  */</span>
<span class="n">SCTP_STATIC</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_new</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg_flags</span><span class="p">,</span>
						    <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sctp_ulpevent_init</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">msg_flags</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is this a MSG_NOTIFICATION?  */</span>
<span class="kt">int</span> <span class="nf">sctp_ulpevent_is_notification</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MSG_NOTIFICATION</span> <span class="o">==</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_NOTIFICATION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Hold the association in case the msg_name needs read out of</span>
<span class="cm"> * the association.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Cast away the const, as we are just wanting to</span>
<span class="cm">	 * bump the reference count.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_association_hold</span><span class="p">((</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">)</span><span class="n">asoc</span><span class="p">;</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rmem_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rmem_alloc</span><span class="p">);</span>
	<span class="n">sctp_skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* A simple destructor to give up the reference to the association. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_ulpevent_release_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rmem_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rmem_alloc</span><span class="p">);</span>
	<span class="n">sctp_association_put</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize an SCTP_ASSOC_CHANGE event.</span>
<span class="cm"> *</span>
<span class="cm"> * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm"> *</span>
<span class="cm"> * Communication notifications inform the ULP that an SCTP association</span>
<span class="cm"> * has either begun or ended. The identifier for a new association is</span>
<span class="cm"> * provided by this notification.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: There is no field checking here.  If a field is unused it will be</span>
<span class="cm"> * zero&#39;d out.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span>  <span class="o">*</span><span class="nf">sctp_ulpevent_make_assoc_change</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">state</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">error</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">outbound</span><span class="p">,</span>
	<span class="n">__u16</span> <span class="n">inbound</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_change</span> <span class="o">*</span><span class="n">sac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* If the lower layer passed in the chunk, it will be</span>
<span class="cm">	 * an ABORT, so we need to include it in the sac_info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy the chunk data to a new skb and reserve enough</span>
<span class="cm">		 * head room to use as notification.</span>
<span class="cm">		 */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_copy_expand</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="cm">/* Embed the event fields inside the cloned skb.  */</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">sctp_ulpevent_init</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

		<span class="cm">/* Include the notification structure */</span>
		<span class="n">sac</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span><span class="p">));</span>

		<span class="cm">/* Trim the buffer to the right length.  */</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span><span class="p">)</span> <span class="o">+</span>
			 <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_chunkhdr_t</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">sac</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_assoc_change</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_type:</span>
<span class="cm">	 * It should be SCTP_ASSOC_CHANGE.</span>
<span class="cm">	 */</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_type</span> <span class="o">=</span> <span class="n">SCTP_ASSOC_CHANGE</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_state: 32 bits (signed integer)</span>
<span class="cm">	 * This field holds one of a number of values that communicate the</span>
<span class="cm">	 * event that happened to the association.</span>
<span class="cm">	 */</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 * Currently unused.</span>
<span class="cm">	 */</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_length: sizeof (__u32)</span>
<span class="cm">	 * This field is the total length of the notification data, including</span>
<span class="cm">	 * the notification header.</span>
<span class="cm">	 */</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_error:  32 bits (signed integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the state was reached due to a error condition (e.g.</span>
<span class="cm">	 * COMMUNICATION_LOST) any relevant error information is available in</span>
<span class="cm">	 * this field. This corresponds to the protocol error codes defined in</span>
<span class="cm">	 * [SCTP].</span>
<span class="cm">	 */</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_outbound_streams:  16 bits (unsigned integer)</span>
<span class="cm">	 * sac_inbound_streams:  16 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The maximum number of streams allowed in each direction are</span>
<span class="cm">	 * available in sac_outbound_streams and sac_inbound streams.</span>
<span class="cm">	 */</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_outbound_streams</span> <span class="o">=</span> <span class="n">outbound</span><span class="p">;</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_inbound_streams</span> <span class="o">=</span> <span class="n">inbound</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * sac_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The association id field, holds the identifier for the association.</span>
<span class="cm">	 * All notifications for a given association have the same association</span>
<span class="cm">	 * identifier.  For TCP style socket, this field is ignored.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sac_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize an SCTP_PEER_ADDR_CHANGE event.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket Extensions for SCTP - draft-01</span>
<span class="cm"> * 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm"> *</span>
<span class="cm"> * When a destination address on a multi-homed peer encounters a change</span>
<span class="cm"> * an interface details event is sent.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_peer_addr_change</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="o">*</span><span class="n">aaddr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paddr_change</span>  <span class="o">*</span><span class="n">spc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddr_change</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">spc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddr_change</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddr_change</span><span class="p">));</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_type:</span>
<span class="cm">	 *</span>
<span class="cm">	 *    It should be SCTP_PEER_ADDR_CHANGE.</span>
<span class="cm">	 */</span>
	<span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_type</span> <span class="o">=</span> <span class="n">SCTP_PEER_ADDR_CHANGE</span><span class="p">;</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_length: sizeof (__u32)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field is the total length of the notification data, including</span>
<span class="cm">	 * the notification header.</span>
<span class="cm">	 */</span>
	<span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_paddr_change</span><span class="p">);</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 * Currently unused.</span>
<span class="cm">	 */</span>
	<span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_state:  32 bits (signed integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field holds one of a number of values that communicate the</span>
<span class="cm">	 * event that happened to the address.</span>
<span class="cm">	 */</span>
	<span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_error:  32 bits (signed integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the state was reached due to any error condition (e.g.</span>
<span class="cm">	 * ADDRESS_UNREACHABLE) any relevant error information is available in</span>
<span class="cm">	 * this field.</span>
<span class="cm">	 */</span>
	<span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The association id field, holds the identifier for the association.</span>
<span class="cm">	 * All notifications for a given association have the same association</span>
<span class="cm">	 * identifier.  For TCP style socket, this field is ignored.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm">	 *</span>
<span class="cm">	 * spc_aaddr: sizeof (struct sockaddr_storage)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The affected address field, holds the remote peer&#39;s address that is</span>
<span class="cm">	 * encountering the change of state.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_aaddr</span><span class="p">,</span> <span class="n">aaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_storage</span><span class="p">));</span>

	<span class="cm">/* Map ipv4 address into v4-mapped-on-v6 address.  */</span>
	<span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr_v4map</span><span class="p">(</span>
					<span class="n">sctp_sk</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">),</span>
					<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">spc</span><span class="o">-&gt;</span><span class="n">spc_aaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize an SCTP_REMOTE_ERROR notification.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This assumes that the chunk-&gt;skb-&gt;data already points to the</span>
<span class="cm"> * operation error payload.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket Extensions for SCTP - draft-01</span>
<span class="cm"> * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm"> *</span>
<span class="cm"> * A remote peer may send an Operational Error message to its peer.</span>
<span class="cm"> * This message indicates a variety of error conditions on an</span>
<span class="cm"> * association. The entire error TLV as it appears on the wire is</span>
<span class="cm"> * included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP</span>
<span class="cm"> * specification [SCTP] and any extensions for a list of possible</span>
<span class="cm"> * error formats.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_remote_error</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_remote_error</span> <span class="o">*</span><span class="n">sre</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">cause</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elen</span><span class="p">;</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">sctp_errhdr_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">cause</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">cause</span><span class="p">;</span>
	<span class="n">elen</span> <span class="o">=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">);</span>

	<span class="cm">/* Pull off the ERROR header.  */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_errhdr_t</span><span class="p">));</span>

	<span class="cm">/* Copy the skb to a new skb with room for us to prepend</span>
<span class="cm">	 * notification with.</span>
<span class="cm">	 */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_copy_expand</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_remote_error</span><span class="p">),</span>
			      <span class="mi">0</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

	<span class="cm">/* Pull off the rest of the cause TLV from the chunk.  */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">elen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* Embed the event fields inside the cloned skb.  */</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sctp_ulpevent_init</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">sre</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_remote_error</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_remote_error</span><span class="p">));</span>

	<span class="cm">/* Trim the buffer to the right length.  */</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_remote_error</span><span class="p">)</span> <span class="o">+</span> <span class="n">elen</span><span class="p">);</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm">	 *</span>
<span class="cm">	 * sre_type:</span>
<span class="cm">	 *   It should be SCTP_REMOTE_ERROR.</span>
<span class="cm">	 */</span>
	<span class="n">sre</span><span class="o">-&gt;</span><span class="n">sre_type</span> <span class="o">=</span> <span class="n">SCTP_REMOTE_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm">	 *</span>
<span class="cm">	 * sre_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 *   Currently unused.</span>
<span class="cm">	 */</span>
	<span class="n">sre</span><span class="o">-&gt;</span><span class="n">sre_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm">	 *</span>
<span class="cm">	 * sre_length: sizeof (__u32)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field is the total length of the notification data,</span>
<span class="cm">	 * including the notification header.</span>
<span class="cm">	 */</span>
	<span class="n">sre</span><span class="o">-&gt;</span><span class="n">sre_length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm">	 *</span>
<span class="cm">	 * sre_error: 16 bits (unsigned integer)</span>
<span class="cm">	 * This value represents one of the Operational Error causes defined in</span>
<span class="cm">	 * the SCTP specification, in network byte order.</span>
<span class="cm">	 */</span>
	<span class="n">sre</span><span class="o">-&gt;</span><span class="n">sre_error</span> <span class="o">=</span> <span class="n">cause</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm">	 *</span>
<span class="cm">	 * sre_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The association id field, holds the identifier for the association.</span>
<span class="cm">	 * All notifications for a given association have the same association</span>
<span class="cm">	 * identifier.  For TCP style socket, this field is ignored.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sre</span><span class="o">-&gt;</span><span class="n">sre_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize a SCTP_SEND_FAILED notification.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket Extensions for SCTP - draft-01</span>
<span class="cm"> * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_send_failed</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">error</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_send_failed</span> <span class="o">*</span><span class="n">ssf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Pull off any padding. */</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/* Make skb with more room so we can prepend notification.  */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_copy_expand</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_send_failed</span><span class="p">),</span> <span class="cm">/* headroom */</span>
			      <span class="mi">0</span><span class="p">,</span>                               <span class="cm">/* tailroom */</span>
			      <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* Pull off the common chunk header and DATA header.  */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_data_chunk</span><span class="p">));</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_data_chunk</span><span class="p">);</span>

	<span class="cm">/* Embed the event fields inside the cloned skb.  */</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sctp_ulpevent_init</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">ssf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_send_failed</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_send_failed</span><span class="p">));</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm">	 *</span>
<span class="cm">	 * ssf_type:</span>
<span class="cm">	 * It should be SCTP_SEND_FAILED.</span>
<span class="cm">	 */</span>
	<span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_type</span> <span class="o">=</span> <span class="n">SCTP_SEND_FAILED</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm">	 *</span>
<span class="cm">	 * ssf_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 * The flag value will take one of the following values</span>
<span class="cm">	 *</span>
<span class="cm">	 * SCTP_DATA_UNSENT - Indicates that the data was never put on</span>
<span class="cm">	 *                    the wire.</span>
<span class="cm">	 *</span>
<span class="cm">	 * SCTP_DATA_SENT   - Indicates that the data was put on the wire.</span>
<span class="cm">	 *                    Note that this does not necessarily mean that the</span>
<span class="cm">	 *                    data was (or was not) successfully delivered.</span>
<span class="cm">	 */</span>
	<span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm">	 *</span>
<span class="cm">	 * ssf_length: sizeof (__u32)</span>
<span class="cm">	 * This field is the total length of the notification data, including</span>
<span class="cm">	 * the notification header.</span>
<span class="cm">	 */</span>
	<span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_send_failed</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_length</span><span class="p">);</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm">	 *</span>
<span class="cm">	 * ssf_error: 16 bits (unsigned integer)</span>
<span class="cm">	 * This value represents the reason why the send failed, and if set,</span>
<span class="cm">	 * will be a SCTP protocol error code as defined in [SCTP] section</span>
<span class="cm">	 * 3.3.10.</span>
<span class="cm">	 */</span>
	<span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm">	 *</span>
<span class="cm">	 * ssf_info: sizeof (struct sctp_sndrcvinfo)</span>
<span class="cm">	 * The original send information associated with the undelivered</span>
<span class="cm">	 * message.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">sinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">));</span>

	<span class="cm">/* Per TSVWG discussion with Randy. Allow the application to</span>
<span class="cm">	 * reassemble a fragmented message.</span>
<span class="cm">	 */</span>
	<span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_info</span><span class="p">.</span><span class="n">sinfo_flags</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm">	 *</span>
<span class="cm">	 * ssf_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 * The association id field, sf_assoc_id, holds the identifier for the</span>
<span class="cm">	 * association.  All notifications for a given association have the</span>
<span class="cm">	 * same association identifier.  For TCP style socket, this field is</span>
<span class="cm">	 * ignored.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">ssf</span><span class="o">-&gt;</span><span class="n">ssf_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize a SCTP_SHUTDOWN_EVENT notification.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket Extensions for SCTP - draft-01</span>
<span class="cm"> * 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_shutdown_event</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_shutdown_event</span> <span class="o">*</span><span class="n">sse</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_event</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">sse</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_event</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_event</span><span class="p">));</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm">	 *</span>
<span class="cm">	 * sse_type</span>
<span class="cm">	 * It should be SCTP_SHUTDOWN_EVENT</span>
<span class="cm">	 */</span>
	<span class="n">sse</span><span class="o">-&gt;</span><span class="n">sse_type</span> <span class="o">=</span> <span class="n">SCTP_SHUTDOWN_EVENT</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm">	 *</span>
<span class="cm">	 * sse_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 * Currently unused.</span>
<span class="cm">	 */</span>
	<span class="n">sse</span><span class="o">-&gt;</span><span class="n">sse_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm">	 *</span>
<span class="cm">	 * sse_length: sizeof (__u32)</span>
<span class="cm">	 * This field is the total length of the notification data, including</span>
<span class="cm">	 * the notification header.</span>
<span class="cm">	 */</span>
	<span class="n">sse</span><span class="o">-&gt;</span><span class="n">sse_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_shutdown_event</span><span class="p">);</span>

	<span class="cm">/* Socket Extensions for SCTP</span>
<span class="cm">	 * 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm">	 *</span>
<span class="cm">	 * sse_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 * The association id field, holds the identifier for the association.</span>
<span class="cm">	 * All notifications for a given association have the same association</span>
<span class="cm">	 * identifier.  For TCP style socket, this field is ignored.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sse</span><span class="o">-&gt;</span><span class="n">sse_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize a SCTP_ADAPTATION_INDICATION notification.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket Extensions for SCTP</span>
<span class="cm"> * 5.3.1.6 SCTP_ADAPTATION_INDICATION</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_adaptation_indication</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_adaptation_event</span> <span class="o">*</span><span class="n">sai</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_adaptation_event</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">sai</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_adaptation_event</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_adaptation_event</span><span class="p">));</span>

	<span class="n">sai</span><span class="o">-&gt;</span><span class="n">sai_type</span> <span class="o">=</span> <span class="n">SCTP_ADAPTATION_INDICATION</span><span class="p">;</span>
	<span class="n">sai</span><span class="o">-&gt;</span><span class="n">sai_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sai</span><span class="o">-&gt;</span><span class="n">sai_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_adaptation_event</span><span class="p">);</span>
	<span class="n">sai</span><span class="o">-&gt;</span><span class="n">sai_adaptation_ind</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">adaptation_ind</span><span class="p">;</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sai</span><span class="o">-&gt;</span><span class="n">sai_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A message has been received.  Package this message as a notification</span>
<span class="cm"> * to pass it to the upper layers.  Go ahead and calculate the sndrcvinfo</span>
<span class="cm"> * even if filtered out later.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket Extensions for SCTP</span>
<span class="cm"> * 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_rcvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">padding</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check to see if we need to make space for this</span>
<span class="cm">	 * new skb, expand the rcvbuffer if needed, or drop</span>
<span class="cm">	 * the frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rcvbuf_policy</span><span class="p">)</span>
		<span class="n">rx_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">rmem_alloc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rx_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_count</span> <span class="o">&gt;=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_RCVBUF_LOCK</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">sk_rmem_schedule</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clone the original skb, sharing the data.  */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* Now that all memory allocations for this chunk succeeded, we</span>
<span class="cm">	 * can mark it as received so the tsn_map is updated correctly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_tsnmap_mark</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">,</span>
			     <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">),</span>
			     <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_mark</span><span class="p">;</span>

	<span class="cm">/* First calculate the padding, so we don&#39;t inadvertently</span>
<span class="cm">	 * pass up the wrong length to the user.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RFC 2960 - Section 3.2  Chunk Field Descriptions</span>
<span class="cm">	 *</span>
<span class="cm">	 * The total length of a chunk(including Type, Length and Value fields)</span>
<span class="cm">	 * MUST be a multiple of 4 bytes.  If the length of the chunk is not a</span>
<span class="cm">	 * multiple of 4 bytes, the sender MUST pad the chunk with all zero</span>
<span class="cm">	 * bytes and this padding is not included in the chunk length field.</span>
<span class="cm">	 * The sender should never pad with more than 3 bytes.  The receiver</span>
<span class="cm">	 * MUST ignore the padding bytes.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">padding</span> <span class="o">=</span> <span class="n">WORD_ROUND</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Fixup cloned skb with just this chunks data.  */</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_end</span> <span class="o">-</span> <span class="n">padding</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Embed the event fields inside the cloned skb.  */</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Initialize event with flags 0  and correct length</span>
<span class="cm">	 * Since this is a clone of the original skb, only account for</span>
<span class="cm">	 * the data of this chunk as other chunks will be accounted separately.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_init</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">));</span>

	<span class="n">sctp_ulpevent_receive_data</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">ssn</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">ppid</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">ppid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCTP_DATA_UNORDERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCTP_UNORDERED</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">cumtsn</span> <span class="o">=</span> <span class="n">sctp_tsnmap_get_ctsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">tsn_map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tsn</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">subh</span><span class="p">.</span><span class="n">data_hdr</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">chunk_hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">iif</span> <span class="o">=</span> <span class="n">sctp_chunk_iif</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">fail_mark:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create a partial delivery related event.</span>
<span class="cm"> *</span>
<span class="cm"> * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT</span>
<span class="cm"> *</span>
<span class="cm"> *   When a receiver is engaged in a partial delivery of a</span>
<span class="cm"> *   message this notification will be used to indicate</span>
<span class="cm"> *   various events.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_pdapi</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">indication</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_pdapi_event</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_pdapi_event</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_pdapi_event</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_pdapi_event</span><span class="p">));</span>

	<span class="cm">/* pdapi_type</span>
<span class="cm">	 *   It should be SCTP_PARTIAL_DELIVERY_EVENT</span>
<span class="cm">	 *</span>
<span class="cm">	 * pdapi_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 *   Currently unused.</span>
<span class="cm">	 */</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pdapi_type</span> <span class="o">=</span> <span class="n">SCTP_PARTIAL_DELIVERY_EVENT</span><span class="p">;</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pdapi_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* pdapi_length: 32 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field is the total length of the notification data, including</span>
<span class="cm">	 * the notification header.  It will generally be sizeof (struct</span>
<span class="cm">	 * sctp_pdapi_event).</span>
<span class="cm">	 */</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pdapi_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_pdapi_event</span><span class="p">);</span>

	<span class="cm">/*  pdapi_indication: 32 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field holds the indication being sent to the application.</span>
<span class="cm">	 */</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pdapi_indication</span> <span class="o">=</span> <span class="n">indication</span><span class="p">;</span>

	<span class="cm">/*  pdapi_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The association id field, holds the identifier for the association.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pdapi_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_authkey</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">key_id</span><span class="p">,</span>
	<span class="n">__u32</span> <span class="n">indication</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_authkey_event</span> <span class="o">*</span><span class="n">ak</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkey_event</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">ak</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkey_event</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkey_event</span><span class="p">));</span>

	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_type</span> <span class="o">=</span> <span class="n">SCTP_AUTHENTICATION_EVENT</span><span class="p">;</span>
	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_authkey_event</span><span class="p">);</span>

	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_keynumber</span> <span class="o">=</span> <span class="n">key_id</span><span class="p">;</span>
	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_altkeynumber</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_indication</span> <span class="o">=</span> <span class="n">indication</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The association id field, holds the identifier for the association.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">ak</span><span class="o">-&gt;</span><span class="n">auth_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Socket Extensions for SCTP</span>
<span class="cm"> * 6.3.10. SCTP_SENDER_DRY_EVENT</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="nf">sctp_ulpevent_make_sender_dry_event</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sender_dry_event</span> <span class="o">*</span><span class="n">sdry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">sctp_ulpevent_new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sender_dry_event</span><span class="p">),</span>
				  <span class="n">MSG_NOTIFICATION</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">sdry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sender_dry_event</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sender_dry_event</span><span class="p">));</span>

	<span class="n">sdry</span><span class="o">-&gt;</span><span class="n">sender_dry_type</span> <span class="o">=</span> <span class="n">SCTP_SENDER_DRY_EVENT</span><span class="p">;</span>
	<span class="n">sdry</span><span class="o">-&gt;</span><span class="n">sender_dry_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdry</span><span class="o">-&gt;</span><span class="n">sender_dry_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sender_dry_event</span><span class="p">);</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sdry</span><span class="o">-&gt;</span><span class="n">sender_dry_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">asoc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the notification type, assuming this is a notification</span>
<span class="cm"> * event.</span>
<span class="cm"> */</span>
<span class="n">__u16</span> <span class="nf">sctp_ulpevent_get_notification_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_notification</span> <span class="o">*</span><span class="n">notification</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">notification</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_notification</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">notification</span><span class="o">-&gt;</span><span class="n">sn_header</span><span class="p">.</span><span class="n">sn_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Copy out the sndrcvinfo into a msghdr.  */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpevent_read_sndrcvinfo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msghdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="n">sinfo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_ulpevent_is_notification</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Sockets API Extensions for SCTP</span>
<span class="cm">	 * Section 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)</span>
<span class="cm">	 *</span>
<span class="cm">	 * sinfo_stream: 16 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * For recvmsg() the SCTP stack places the message&#39;s stream number in</span>
<span class="cm">	 * this value.</span>
<span class="cm">	*/</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_stream</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="cm">/* sinfo_ssn: 16 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * For recvmsg() this value contains the stream sequence number that</span>
<span class="cm">	 * the remote endpoint placed in the DATA chunk.  For fragmented</span>
<span class="cm">	 * messages this is the same number for all deliveries of the message</span>
<span class="cm">	 * (if more than one recvmsg() is needed to read the message).</span>
<span class="cm">	 */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_ssn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">;</span>
	<span class="cm">/* sinfo_ppid: 32 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * In recvmsg() this value is</span>
<span class="cm">	 * the same information that was passed by the upper layer in the peer</span>
<span class="cm">	 * application.  Please note that byte order issues are NOT accounted</span>
<span class="cm">	 * for and this information is passed opaquely by the SCTP stack from</span>
<span class="cm">	 * one end to the other.</span>
<span class="cm">	 */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_ppid</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ppid</span><span class="p">;</span>
	<span class="cm">/* sinfo_flags: 16 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field may contain any of the following flags and is composed of</span>
<span class="cm">	 * a bitwise OR of these values.</span>
<span class="cm">	 *</span>
<span class="cm">	 * recvmsg() flags:</span>
<span class="cm">	 *</span>
<span class="cm">	 * SCTP_UNORDERED - This flag is present when the message was sent</span>
<span class="cm">	 *                 non-ordered.</span>
<span class="cm">	 */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_flags</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* sinfo_tsn: 32 bit (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * For the receiving side, this field holds a TSN that was</span>
<span class="cm">	 * assigned to one of the SCTP Data Chunks.</span>
<span class="cm">	 */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_tsn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tsn</span><span class="p">;</span>
	<span class="cm">/* sinfo_cumtsn: 32 bit (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This field will hold the current cumulative TSN as</span>
<span class="cm">	 * known by the underlying SCTP layer.  Note this field is</span>
<span class="cm">	 * ignored when sending and only valid for a receive</span>
<span class="cm">	 * operation when sinfo_flags are set to SCTP_UNORDERED.</span>
<span class="cm">	 */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_cumtsn</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cumtsn</span><span class="p">;</span>
	<span class="cm">/* sinfo_assoc_id: sizeof (sctp_assoc_t)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The association handle field, sinfo_assoc_id, holds the identifier</span>
<span class="cm">	 * for the association announced in the COMMUNICATION_UP notification.</span>
<span class="cm">	 * All notifications for a given association have the same identifier.</span>
<span class="cm">	 * Ignored for one-to-one style sockets.</span>
<span class="cm">	 */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_assoc_id</span> <span class="o">=</span> <span class="n">sctp_assoc2id</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">);</span>

	<span class="cm">/* context value that is set via SCTP_CONTEXT socket option. */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_context</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">default_rcv_context</span><span class="p">;</span>

	<span class="cm">/* These fields are not used while receiving. */</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">sinfo_timetolive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">put_cmsg</span><span class="p">(</span><span class="n">msghdr</span><span class="p">,</span> <span class="n">IPPROTO_SCTP</span><span class="p">,</span> <span class="n">SCTP_SNDRCV</span><span class="p">,</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do accounting for bytes received and hold a reference to the association</span>
<span class="cm"> * for each skb.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpevent_receive_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="cm">/* Set the owner and charge rwnd for bytes received.  */</span>
	<span class="n">sctp_ulpevent_set_owner</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sctp_assoc_rwnd_decrease</span><span class="p">(</span><span class="n">asoc</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Note:  Not clearing the entire event struct as this is just a</span>
<span class="cm">	 * fragment of the real event.  However, we still need to do rwnd</span>
<span class="cm">	 * accounting.</span>
<span class="cm">	 * In general, the skb passed from IP can have only 1 level of</span>
<span class="cm">	 * fragments. But we allow multiple levels of fragments.</span>
<span class="cm">	 */</span>
	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag</span><span class="p">)</span>
		<span class="n">sctp_ulpevent_receive_data</span><span class="p">(</span><span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span> <span class="n">asoc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do accounting for bytes just read by user and release the references to</span>
<span class="cm"> * the association.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpevent_release_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Current stack structures assume that the rcv buffer is</span>
<span class="cm">	 * per socket.   For UDP style sockets this is not true as</span>
<span class="cm">	 * multiple associations may be on a single UDP-style socket.</span>
<span class="cm">	 * Use the local private area of the skb to track the owning</span>
<span class="cm">	 * association.</span>
<span class="cm">	 */</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t forget the fragments. */</span>
	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NOTE:  skb_shinfos are recursive. Although IP returns</span>
<span class="cm">		 * skb&#39;s with only 1 level of fragments, SCTP reassembly can</span>
<span class="cm">		 * increase the levels.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_ulpevent_release_frag_data</span><span class="p">(</span><span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">sctp_assoc_rwnd_increase</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">sctp_ulpevent_release_owner</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_ulpevent_release_frag_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t forget the fragments. */</span>
	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NOTE:  skb_shinfos are recursive. Although IP returns</span>
<span class="cm">		 * skb&#39;s with only 1 level of fragments, SCTP reassembly can</span>
<span class="cm">		 * increase the levels.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_ulpevent_release_frag_data</span><span class="p">(</span><span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">sctp_ulpevent_release_owner</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free a ulpevent that has an owner.  It includes releasing the reference</span>
<span class="cm"> * to the owner, updating the rwnd in case of a DATA event and freeing the</span>
<span class="cm"> * skb.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sctp_ulpevent_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_ulpevent_is_notification</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">sctp_ulpevent_release_owner</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sctp_ulpevent_release_data</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">sctp_event2skb</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Purge the skb lists holding ulpevents. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sctp_queue_purge_ulpevents</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_unread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">sctp_skb2event</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_ulpevent_is_notification</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">data_unread</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="n">sctp_ulpevent_free</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">data_unread</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
