<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sctp › protocol.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>protocol.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 Nokia, Inc.</span>
<span class="cm"> * Copyright (c) 2001 La Monte H.P. Yarroll</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Initialization/cleanup for SCTP protocol support.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Daisy Chang &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/protocol.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/sctp/sctp.h&gt;</span>
<span class="cp">#include &lt;net/addrconf.h&gt;</span>
<span class="cp">#include &lt;net/inet_common.h&gt;</span>
<span class="cp">#include &lt;net/inet_ecn.h&gt;</span>

<span class="cm">/* Global data structures. */</span>
<span class="k">struct</span> <span class="n">sctp_globals</span> <span class="n">sctp_globals</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">DEFINE_SNMP_STAT</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_mib</span><span class="p">,</span> <span class="n">sctp_statistics</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">struct</span> <span class="n">proc_dir_entry</span>	<span class="o">*</span><span class="n">proc_net_sctp</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">idr</span> <span class="n">sctp_assocs_id</span><span class="p">;</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sctp_assocs_id_lock</span><span class="p">);</span>

<span class="cm">/* This is the global socket data structure used for responding to</span>
<span class="cm"> * the Out-of-the-blue (OOTB) packets.  A control sock will be created</span>
<span class="cm"> * for this socket at the initialization time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sctp_ctl_sock</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_pf</span> <span class="o">*</span><span class="n">sctp_pf_inet6_specific</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_pf</span> <span class="o">*</span><span class="n">sctp_pf_inet_specific</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">sctp_af_v4_specific</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">sctp_af_v6_specific</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sctp_chunk_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sctp_bucket_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">long</span> <span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sysctl_sctp_rmem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sysctl_sctp_wmem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="cm">/* Return the address of the control sock. */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sctp_get_ctl_sock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sctp_ctl_sock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set up the proc fs entry for the SCTP protocol. */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">sctp_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_sctp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_net_sctp</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;sctp&quot;</span><span class="p">,</span> <span class="n">init_net</span><span class="p">.</span><span class="n">proc_net</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_sctp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_percpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_snmp_proc_init</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_snmp_proc_init</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_eps_proc_init</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_eps_proc_init</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_assocs_proc_init</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_assocs_proc_init</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_remaddr_proc_init</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_remaddr_proc_init</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_remaddr_proc_init:</span>
	<span class="n">sctp_assocs_proc_exit</span><span class="p">();</span>
<span class="nl">out_assocs_proc_init:</span>
	<span class="n">sctp_eps_proc_exit</span><span class="p">();</span>
<span class="nl">out_eps_proc_init:</span>
	<span class="n">sctp_snmp_proc_exit</span><span class="p">();</span>
<span class="nl">out_snmp_proc_init:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_net_sctp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_net_sctp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;sctp&quot;</span><span class="p">,</span> <span class="n">init_net</span><span class="p">.</span><span class="n">proc_net</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_free_percpu:</span>
	<span class="n">percpu_counter_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="nl">out_nomem:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clean up the proc fs entry for the SCTP protocol.</span>
<span class="cm"> * Note: Do not make this __exit as it is used in the init error</span>
<span class="cm"> * path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_proc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">sctp_snmp_proc_exit</span><span class="p">();</span>
	<span class="n">sctp_eps_proc_exit</span><span class="p">();</span>
	<span class="n">sctp_assocs_proc_exit</span><span class="p">();</span>
	<span class="n">sctp_remaddr_proc_exit</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_net_sctp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_net_sctp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;sctp&quot;</span><span class="p">,</span> <span class="n">init_net</span><span class="p">.</span><span class="n">proc_net</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">percpu_counter_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_sockets_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Private helper to extract ipv4 address and stash them in</span>
<span class="cm"> * the protocol structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_copy_addrlist</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">addrlist</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="n">ifa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ifa</span> <span class="o">=</span> <span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">ifa_list</span><span class="p">;</span> <span class="n">ifa</span><span class="p">;</span> <span class="n">ifa</span> <span class="o">=</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add the address to the local list.  */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">t_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_local</span><span class="p">;</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">addrlist</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Extract our IP addresses from the system and stash them in the</span>
<span class="cm"> * protocol structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_get_local_addr_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_netdev_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_address_families</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">af</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_af</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">af</span><span class="o">-&gt;</span><span class="n">copy_addrlist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Free the existing local addresses.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_free_local_addr_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Copy the local addresses which are valid for &#39;scope&#39; into &#39;bp&#39;.  */</span>
<span class="kt">int</span> <span class="nf">sctp_copy_local_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_in_scope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">scope</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Now that the address is in scope, check to see if</span>
<span class="cm">			 * the address type is really supported by the local</span>
<span class="cm">			 * sock as well as the remote peer.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((((</span><span class="n">AF_INET</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			      <span class="p">(</span><span class="n">copy_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_ADDR4_PEERSUPP</span><span class="p">)))</span> <span class="o">||</span>
			    <span class="p">(((</span><span class="n">AF_INET6</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			      <span class="p">(</span><span class="n">copy_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_ADDR6_ALLOWED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			      <span class="p">(</span><span class="n">copy_flags</span> <span class="o">&amp;</span> <span class="n">SCTP_ADDR6_PEERSUPP</span><span class="p">))))</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">sctp_add_bind_addr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span>
						    <span class="n">SCTP_ADDR_SRC</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">end_copy</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">end_copy:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize a sctp_addr from in incoming skb.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_from_skb</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">is_saddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>

	<span class="n">sh</span> <span class="o">=</span> <span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_saddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">port</span>  <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
		<span class="n">from</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
		<span class="n">from</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Initialize an sctp_addr from a socket. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_from_sk</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_rcv_saddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize sk-&gt;sk_rcv_saddr from sctp_addr. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_to_sk_saddr</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_rcv_saddr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize sk-&gt;sk_daddr from sctp_addr. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_to_sk_daddr</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_daddr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize a sctp_addr from an address parameter. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_from_addr_param</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				    <span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				    <span class="n">__be16</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize an address parameter from a sctp_addr and return the length</span>
<span class="cm"> * of the address parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_to_addr_param</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_ipv4addr_param_t</span><span class="p">);</span>

	<span class="n">param</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span><span class="p">;</span>
	<span class="n">param</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">param_hdr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="n">param</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize a sctp_addr from a dst_entry. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_dst_saddr</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span><span class="p">,</span>
			      <span class="n">__be16</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compare two addresses exactly. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_cmp_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr1</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">addr2</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr1</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">!=</span> <span class="n">addr2</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr1</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">!=</span> <span class="n">addr2</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize addr struct to INADDR_ANY. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_inaddr_any</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is this a wildcard address? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_is_any</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">)</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function checks if the address is a valid address to be used for</span>
<span class="cm"> * SCTP binding.</span>
<span class="cm"> *</span>
<span class="cm"> * Output:</span>
<span class="cm"> * Return 0 - If the address is a non-unicast or an illegal address.</span>
<span class="cm"> * Return 1 - If the address is a unicast.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_addr_valid</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* IPv4 addresses not allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&amp;&amp;</span> <span class="n">ipv6_only_sock</span><span class="p">(</span><span class="n">sctp_opt2sk</span><span class="p">(</span><span class="n">sp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Is this a non-unicast address or a unusable SCTP address? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_IPV4_UNUSABLE_ADDRESS</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Is this a broadcast address? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">skb_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_flags</span> <span class="o">&amp;</span> <span class="n">RTCF_BROADCAST</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Should this be available for binding?   */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_available</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">inet_addr_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">!=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="n">ret</span> <span class="o">!=</span> <span class="n">RTN_LOCAL</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">.</span><span class="n">freebind</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="n">sysctl_ip_nonlocal_bind</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_only_sock</span><span class="p">(</span><span class="n">sctp_opt2sk</span><span class="p">(</span><span class="n">sp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Checking the loopback, private and other address scopes as defined in</span>
<span class="cm"> * RFC 1918.   The IPv4 scoping is based on the draft for SCTP IPv4</span>
<span class="cm"> * scoping &lt;draft-stewart-tsvwg-sctp-ipv4-00.txt&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Level 0 - unusable SCTP addresses</span>
<span class="cm"> * Level 1 - loopback address</span>
<span class="cm"> * Level 2 - link-local addresses</span>
<span class="cm"> * Level 3 - private addresses.</span>
<span class="cm"> * Level 4 - global addresses</span>
<span class="cm"> * For INIT and INIT-ACK address list, let L be the level of</span>
<span class="cm"> * of requested destination address, sender and receiver</span>
<span class="cm"> * SHOULD include all of its addresses with level greater</span>
<span class="cm"> * than or equal to L.</span>
<span class="cm"> *</span>
<span class="cm"> * IPv4 scoping can be controlled through sysctl option</span>
<span class="cm"> * net.sctp.addr_scope_policy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sctp_scope_t</span> <span class="nf">sctp_v4_scope</span><span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_scope_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Check for unusable SCTP addresses. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_IPV4_UNUSABLE_ADDRESS</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span>  <span class="n">SCTP_SCOPE_UNUSABLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ipv4_is_loopback</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_SCOPE_LOOPBACK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ipv4_is_linklocal_169</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_SCOPE_LINK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ipv4_is_private_10</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span> <span class="o">||</span>
		   <span class="n">ipv4_is_private_172</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span> <span class="o">||</span>
		   <span class="n">ipv4_is_private_192</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_SCOPE_PRIVATE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">SCTP_SCOPE_GLOBAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns a valid dst cache entry for the given source and destination ip</span>
<span class="cm"> * addresses. If an association is passed, trys to get a dst entry with a</span>
<span class="cm"> * source address that matches an address in the bind address list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_get_dst</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">daddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ipaddr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">dst_saddr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">fl4</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">flowi4</span><span class="p">));</span>
	<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span>  <span class="o">=</span> <span class="n">daddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_dport</span> <span class="o">=</span> <span class="n">daddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">;</span>
	<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">flowi4_proto</span> <span class="o">=</span> <span class="n">IPPROTO_SCTP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">flowi4_tos</span> <span class="o">=</span> <span class="n">RT_CONN_FLAGS</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">flowi4_oif</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span><span class="p">;</span>
		<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_sport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">saddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
		<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_sport</span> <span class="o">=</span> <span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: DST:%pI4, SRC:%pI4 - &quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>

	<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">fl4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
		<span class="n">dst</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>

	<span class="cm">/* If there is no association or if a source address is passed, no</span>
<span class="cm">	 * more validation is required.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asoc</span> <span class="o">||</span> <span class="n">saddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">bind_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Walk through the bind address list and look for a bind</span>
<span class="cm">		 * address that matches the source address of the returned dst.</span>
<span class="cm">		 */</span>
		<span class="n">sctp_v4_dst_saddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_saddr</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">));</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">||</span> <span class="p">(</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ADDR_DEL</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCTP_ADDR_SRC</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">src_out_of_asoc_ok</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_v4_cmp_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="cm">/* None of the bound addresses match the source address of the</span>
<span class="cm">		 * dst. So release it.</span>
<span class="cm">		 */</span>
		<span class="n">dst_release</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
		<span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Walk through the bind address list and try to get a dst that</span>
<span class="cm">	 * matches a bind address as the source address.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">laddr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ADDR_SRC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">AF_INET</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
			<span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_sport</span> <span class="o">=</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span><span class="p">;</span>
			<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">fl4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dst</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;rt_dst:%pI4, rt_src:%pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;NO ROUTE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* For v4, the source address is cached in the route entry(dst). So no need</span>
<span class="cm"> * to cache it separately and hence this is an empty routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_get_saddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">saddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
		<span class="n">saddr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">saddr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* What interface did this skb arrive on? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_skb_iif</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_iif</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Was this packet marked by Explicit Congestion Notification? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_is_ce</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">INET_ECN_is_ce</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create and initialize a new sk for the socket returned by accept(). */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sctp_v4_create_accept_sk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">newinet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sock_init_data</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>

	<span class="n">sctp_copy_sock</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">asoc</span><span class="p">);</span>
	<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>

	<span class="n">newinet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>

	<span class="n">newinet</span><span class="o">-&gt;</span><span class="n">inet_daddr</span> <span class="o">=</span> <span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_addr</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>

	<span class="n">sk_refcnt_debug_inc</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">newsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk_common_release</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="n">newsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">newsk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Map address, empty for v4 family */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_addr_v4map</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Empty */</span>
<span class="p">}</span>

<span class="cm">/* Dump the v4 addr to the seq file. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_seq_dump_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%pI4 &quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_ecn_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INET_ECN_xmit</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_addr_wq_timeout_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addrw</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">addrw</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_addrwq_timo_handler: the first ent in wq %p is &quot;</span><span class="p">,</span>
		    <span class="s">&quot; for cmd %d at entry %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
		    <span class="n">addrw</span><span class="p">);</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="cm">/* Now we send an ASCONF for each association */</span>
		<span class="cm">/* Note. we currently don&#39;t handle link local IPv6 addressees */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">in6</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_addr_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">IPV6_ADDR_LINKLOCAL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">free_next</span><span class="p">;</span>

			<span class="n">in6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_chk_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">in6</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SCTP_ADDR_NEW</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo_val</span><span class="p">;</span>

				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_timo_handler: this is on DAD, trying %d sec later</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">SCTP_ADDRESS_TICK_DELAY</span><span class="p">);</span>
				<span class="n">timeo_val</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">timeo_val</span> <span class="o">+=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">SCTP_ADDRESS_TICK_DELAY</span><span class="p">);</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_timer</span><span class="p">,</span> <span class="n">timeo_val</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_auto_asconf_splist</span><span class="p">,</span> <span class="n">auto_asconf_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

			<span class="n">sk</span> <span class="o">=</span> <span class="n">sctp_opt2sk</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
			<span class="cm">/* ignore bound-specific endpoints */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_is_ep_boundall</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">sctp_bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sctp_asconf_mgmt</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">addrw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;sctp_addrwq_timo_handler: sctp_asconf_mgmt failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sctp_bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="nl">free_next:</span>
<span class="cp">#endif</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">addrw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_free_addr_wq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addrw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_timer</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">addrw</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">addrw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* lookup the entry for the same address in the addr_waitq</span>
<span class="cm"> * sctp_addr_wq MUST be locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="nf">sctp_addr_wq_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addrw</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">addrw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">==</span>
			    <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">addrw</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_addr_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">addrw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sctp_addr_wq_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addrw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo_val</span><span class="p">;</span>

	<span class="cm">/* first, we check if an opposite message already exist in the queue.</span>
<span class="cm">	 * If we found such message, it is removed.</span>
<span class="cm">	 * This operation is a bit stupid, but the DHCP client attaches the</span>
<span class="cm">	 * new address after a couple of addition and deletion of that address</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
	<span class="cm">/* Offsets existing events in addr_wq */</span>
	<span class="n">addrw</span> <span class="o">=</span> <span class="n">sctp_addr_wq_lookup</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_addr_wq_mgmt offsets existing entry for %d &quot;</span><span class="p">,</span>
			    <span class="s">&quot; in wq %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">addrw</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK, we have to add the new address to the wait queue */</span>
	<span class="n">addrw</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addrw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">);</span>
	<span class="n">SCTP_DEBUG_PRINTK_IPADDR</span><span class="p">(</span><span class="s">&quot;sctp_addr_wq_mgmt add new entry for cmd:%d &quot;</span><span class="p">,</span>
	    <span class="s">&quot; in wq %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addrw</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrw</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">timeo_val</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">timeo_val</span> <span class="o">+=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">SCTP_ADDRESS_TICK_DELAY</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_timer</span><span class="p">,</span> <span class="n">timeo_val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Event handler for inet address addition/deletion events.</span>
<span class="cm"> * The sctp_local_addr_list needs to be protocted by a spin lock since</span>
<span class="cm"> * multiple notifiers (say IPv4 and IPv6) may be running at the same</span>
<span class="cm"> * time and thus corrupt the list.</span>
<span class="cm"> * The reader side is protected with RCU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_inetaddr_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ev</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="n">ifa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_UP</span>:
		<span class="n">addr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_local</span><span class="p">;</span>
			<span class="n">addr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_lock</span><span class="p">);</span>
			<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">);</span>
			<span class="n">sctp_addr_wq_mgmt</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">SCTP_ADDR_NEW</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_DOWN</span>:
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET</span> <span class="o">&amp;&amp;</span>
					<span class="n">addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">==</span>
					<span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_local</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sctp_addr_wq_mgmt</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">SCTP_ADDR_DEL</span><span class="p">);</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">addr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the control inode/socket with a control endpoint data</span>
<span class="cm"> * structure.  This endpoint is reserved exclusively for the OOTB processing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_ctl_sock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">sa_family_t</span> <span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sctp_get_pf_specific</span><span class="p">(</span><span class="n">PF_INET6</span><span class="p">))</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_INET6</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inet_ctl_sock_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_ctl_sock</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span>
				   <span class="n">SOCK_SEQPACKET</span><span class="p">,</span> <span class="n">IPPROTO_SCTP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>

	<span class="cm">/* If IPv6 socket could not be created, try the IPv4 socket */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET6</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">inet_ctl_sock_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_ctl_sock</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span>
					   <span class="n">SOCK_SEQPACKET</span><span class="p">,</span> <span class="n">IPPROTO_SCTP</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to create the SCTP control socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Register address family specific functions. */</span>
<span class="kt">int</span> <span class="nf">sctp_register_af</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_af_v4_specific</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sctp_af_v4_specific</span> <span class="o">=</span> <span class="n">af</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_af_v6_specific</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sctp_af_v6_specific</span> <span class="o">=</span> <span class="n">af</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sctp_address_families</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the table of functions for manipulating a particular address</span>
<span class="cm"> * family.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="nf">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_family_t</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">sctp_af_v4_specific</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">sctp_af_v6_specific</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Common code to initialize a AF_INET msg_name. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_inet_msgname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msgname</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span><span class="p">;</span>

	<span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">msgname</span><span class="p">;</span>
	<span class="o">*</span><span class="n">addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
	<span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_zero</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_zero</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Copy the primary address of the peer primary address as the msg_name. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_inet_event_msgname</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msgname</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span><span class="p">,</span> <span class="o">*</span><span class="n">sinfrom</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msgname</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

		<span class="n">asoc</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">asoc</span><span class="p">;</span>
		<span class="n">sctp_inet_msgname</span><span class="p">(</span><span class="n">msgname</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>
		<span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">msgname</span><span class="p">;</span>
		<span class="n">sinfrom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">primary_addr</span><span class="p">.</span><span class="n">v4</span><span class="p">;</span>
		<span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">asoc</span><span class="o">-&gt;</span><span class="n">peer</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
		<span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">sinfrom</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Initialize and copy out a msgname from an inbound skb. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_inet_skb_msgname</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msgname</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msgname</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sh</span> <span class="o">=</span> <span class="n">sctp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">msgname</span><span class="p">;</span>

		<span class="n">sctp_inet_msgname</span><span class="p">(</span><span class="n">msgname</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
		<span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Do we support this AF? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_inet_af_supported</span><span class="p">(</span><span class="n">sa_family_t</span> <span class="n">family</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* PF_INET only supports AF_INET addresses. */</span>
	<span class="k">return</span> <span class="n">AF_INET</span> <span class="o">==</span> <span class="n">family</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Address matching with wildcards allowed. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_inet_cmp_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr2</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* PF_INET only supports AF_INET addresses. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr1</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">addr2</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">)</span> <span class="o">==</span> <span class="n">addr1</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">||</span>
	    <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">)</span> <span class="o">==</span> <span class="n">addr2</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr1</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">==</span> <span class="n">addr2</span><span class="o">-&gt;</span><span class="n">v4</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Verify that provided sockaddr looks bindable.  Common verification has</span>
<span class="cm"> * already been taken care of.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_inet_bind_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sctp_v4_available</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Verify that sockaddr looks sendable.  Common verification has already</span>
<span class="cm"> * been taken care of.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_inet_send_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fill in Supported Address Type information for INIT and INIT-ACK</span>
<span class="cm"> * chunks.  Returns number of addresses supported.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_inet_supported_addrs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span>
				     <span class="n">__be16</span> <span class="o">*</span><span class="n">types</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCTP_PARAM_IPV4_ADDRESS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wrapper routine that calls the ip transmit routine. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_v4_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">SCTP_DEBUG_PRINTK</span><span class="p">(</span><span class="s">&quot;%s: skb:%p, len:%d, src:%pI4, dst:%pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">daddr</span><span class="p">);</span>

	<span class="n">inet</span><span class="o">-&gt;</span><span class="n">pmtudisc</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">param_flags</span> <span class="o">&amp;</span> <span class="n">SPP_PMTUD_ENABLE</span> <span class="o">?</span>
			 <span class="n">IP_PMTUDISC_DO</span> <span class="o">:</span> <span class="n">IP_PMTUDISC_DONT</span><span class="p">;</span>

	<span class="n">SCTP_INC_STATS</span><span class="p">(</span><span class="n">SCTP_MIB_OUTSCTPPACKS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ip_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_af</span> <span class="n">sctp_af_inet</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_pf</span> <span class="n">sctp_pf_inet</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">event_msgname</span> <span class="o">=</span> <span class="n">sctp_inet_event_msgname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">skb_msgname</span>   <span class="o">=</span> <span class="n">sctp_inet_skb_msgname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">af_supported</span>  <span class="o">=</span> <span class="n">sctp_inet_af_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmp_addr</span>      <span class="o">=</span> <span class="n">sctp_inet_cmp_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind_verify</span>   <span class="o">=</span> <span class="n">sctp_inet_bind_verify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_verify</span>   <span class="o">=</span> <span class="n">sctp_inet_send_verify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">supported_addrs</span> <span class="o">=</span> <span class="n">sctp_inet_supported_addrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create_accept_sk</span> <span class="o">=</span> <span class="n">sctp_v4_create_accept_sk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">addr_v4map</span>	<span class="o">=</span> <span class="n">sctp_v4_addr_v4map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">af</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_af_inet</span>
<span class="p">};</span>

<span class="cm">/* Notifier for inetaddr addition/deletion events.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">sctp_inetaddr_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">sctp_inetaddr_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Socket operations.  */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">inet_seqpacket_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>		   <span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	   <span class="o">=</span> <span class="n">inet_release</span><span class="p">,</span>	<span class="cm">/* Needs to be wrapped... */</span>
	<span class="p">.</span><span class="n">bind</span>		   <span class="o">=</span> <span class="n">inet_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	   <span class="o">=</span> <span class="n">inet_dgram_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>	   <span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		   <span class="o">=</span> <span class="n">inet_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>	   <span class="o">=</span> <span class="n">inet_getname</span><span class="p">,</span>	<span class="cm">/* Semantics are different.  */</span>
	<span class="p">.</span><span class="n">poll</span>		   <span class="o">=</span> <span class="n">sctp_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		   <span class="o">=</span> <span class="n">inet_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span>		   <span class="o">=</span> <span class="n">sctp_inet_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	   <span class="o">=</span> <span class="n">inet_shutdown</span><span class="p">,</span>	<span class="cm">/* Looks harmless.  */</span>
	<span class="p">.</span><span class="n">setsockopt</span>	   <span class="o">=</span> <span class="n">sock_common_setsockopt</span><span class="p">,</span> <span class="cm">/* IP_SOL IP_OPTION is a problem */</span>
	<span class="p">.</span><span class="n">getsockopt</span>	   <span class="o">=</span> <span class="n">sock_common_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	   <span class="o">=</span> <span class="n">inet_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	   <span class="o">=</span> <span class="n">sock_common_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		   <span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span>	   <span class="o">=</span> <span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_setsockopt</span> <span class="o">=</span> <span class="n">compat_sock_common_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_getsockopt</span> <span class="o">=</span> <span class="n">compat_sock_common_getsockopt</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Registration with AF_INET family.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inet_protosw</span> <span class="n">sctp_seqpacket_protosw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span>       <span class="o">=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">protocol</span>   <span class="o">=</span> <span class="n">IPPROTO_SCTP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prot</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_prot</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ops</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">inet_seqpacket_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">no_check</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>      <span class="o">=</span> <span class="n">SCTP_PROTOSW_FLAG</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inet_protosw</span> <span class="n">sctp_stream_protosw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span>       <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">protocol</span>   <span class="o">=</span> <span class="n">IPPROTO_SCTP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prot</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">sctp_prot</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ops</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">inet_seqpacket_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">no_check</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>      <span class="o">=</span> <span class="n">SCTP_PROTOSW_FLAG</span>
<span class="p">};</span>

<span class="cm">/* Register with IP layer.  */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_protocol</span> <span class="n">sctp_protocol</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>     <span class="o">=</span> <span class="n">sctp_rcv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> <span class="o">=</span> <span class="n">sctp_v4_err</span><span class="p">,</span>
	<span class="p">.</span><span class="n">no_policy</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* IPv4 address related functions.  */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sctp_af</span> <span class="n">sctp_af_inet</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sa_family</span>	   <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sctp_xmit</span>	   <span class="o">=</span> <span class="n">sctp_v4_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	   <span class="o">=</span> <span class="n">ip_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	   <span class="o">=</span> <span class="n">ip_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_dst</span>	   <span class="o">=</span> <span class="n">sctp_v4_get_dst</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_saddr</span>	   <span class="o">=</span> <span class="n">sctp_v4_get_saddr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">copy_addrlist</span>	   <span class="o">=</span> <span class="n">sctp_v4_copy_addrlist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">from_skb</span>	   <span class="o">=</span> <span class="n">sctp_v4_from_skb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">from_sk</span>	   <span class="o">=</span> <span class="n">sctp_v4_from_sk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_sk_saddr</span>	   <span class="o">=</span> <span class="n">sctp_v4_to_sk_saddr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_sk_daddr</span>	   <span class="o">=</span> <span class="n">sctp_v4_to_sk_daddr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">from_addr_param</span>   <span class="o">=</span> <span class="n">sctp_v4_from_addr_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_addr_param</span>	   <span class="o">=</span> <span class="n">sctp_v4_to_addr_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmp_addr</span>	   <span class="o">=</span> <span class="n">sctp_v4_cmp_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">addr_valid</span>	   <span class="o">=</span> <span class="n">sctp_v4_addr_valid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">inaddr_any</span>	   <span class="o">=</span> <span class="n">sctp_v4_inaddr_any</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_any</span>		   <span class="o">=</span> <span class="n">sctp_v4_is_any</span><span class="p">,</span>
	<span class="p">.</span><span class="n">available</span>	   <span class="o">=</span> <span class="n">sctp_v4_available</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scope</span>		   <span class="o">=</span> <span class="n">sctp_v4_scope</span><span class="p">,</span>
	<span class="p">.</span><span class="n">skb_iif</span>	   <span class="o">=</span> <span class="n">sctp_v4_skb_iif</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_ce</span>		   <span class="o">=</span> <span class="n">sctp_v4_is_ce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">seq_dump_addr</span>	   <span class="o">=</span> <span class="n">sctp_v4_seq_dump_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ecn_capable</span>	   <span class="o">=</span> <span class="n">sctp_v4_ecn_capable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">net_header_len</span>	   <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">),</span>
	<span class="p">.</span><span class="n">sockaddr_len</span>	   <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_setsockopt</span> <span class="o">=</span> <span class="n">compat_ip_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_getsockopt</span> <span class="o">=</span> <span class="n">compat_ip_getsockopt</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_pf</span> <span class="o">*</span><span class="nf">sctp_get_pf_specific</span><span class="p">(</span><span class="n">sa_family_t</span> <span class="n">family</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_INET</span>:
		<span class="k">return</span> <span class="n">sctp_pf_inet_specific</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PF_INET6</span>:
		<span class="k">return</span> <span class="n">sctp_pf_inet6_specific</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Register the PF specific function table.  */</span>
<span class="kt">int</span> <span class="nf">sctp_register_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_pf</span> <span class="o">*</span><span class="n">pf</span><span class="p">,</span> <span class="n">sa_family_t</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_INET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_pf_inet_specific</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sctp_pf_inet_specific</span> <span class="o">=</span> <span class="n">pf</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PF_INET6</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sctp_pf_inet6_specific</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sctp_pf_inet6_specific</span> <span class="o">=</span> <span class="n">pf</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">init_sctp_mibs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snmp_mib_init</span><span class="p">((</span><span class="kt">void</span> <span class="n">__percpu</span> <span class="o">**</span><span class="p">)</span><span class="n">sctp_statistics</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_mib</span><span class="p">),</span>
			     <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_mib</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cleanup_sctp_mibs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snmp_mib_free</span><span class="p">((</span><span class="kt">void</span> <span class="n">__percpu</span> <span class="o">**</span><span class="p">)</span><span class="n">sctp_statistics</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_pf_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize the SCTP specific PF functions. */</span>
	<span class="n">sctp_register_pf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_pf_inet</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">);</span>
	<span class="n">sctp_register_af</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_af_inet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_pf_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_af_inet</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_protosw_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_prot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Register SCTP(UDP and TCP style) with socket layer.  */</span>
	<span class="n">inet_register_protosw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_seqpacket_protosw</span><span class="p">);</span>
	<span class="n">inet_register_protosw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_stream_protosw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_protosw_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inet_unregister_protosw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_stream_protosw</span><span class="p">);</span>
	<span class="n">inet_unregister_protosw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_seqpacket_protosw</span><span class="p">);</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_prot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sctp_v4_add_protocol</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Register notifier for inet address additions/deletions. */</span>
	<span class="n">register_inetaddr_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_inetaddr_notifier</span><span class="p">);</span>

	<span class="cm">/* Register SCTP with inet layer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_add_protocol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_protocol</span><span class="p">,</span> <span class="n">IPPROTO_SCTP</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sctp_v4_del_protocol</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inet_del_protocol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_protocol</span><span class="p">,</span> <span class="n">IPPROTO_SCTP</span><span class="p">);</span>
	<span class="n">unregister_inetaddr_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_inetaddr_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize the universe into something sensible.  */</span>
<span class="n">SCTP_STATIC</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">sctp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_share</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="cm">/* SCTP_DEBUG sanity check. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_sanity_check</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Allocate bind_bucket and chunk caches. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="n">sctp_bucket_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;sctp_bind_bucket&quot;</span><span class="p">,</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_bucket</span><span class="p">),</span>
					       <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
					       <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_bucket_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sctp_chunk_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;sctp_chunk&quot;</span><span class="p">,</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">),</span>
					       <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
					       <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_chunk_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_chunk_cachep</span><span class="p">;</span>

	<span class="cm">/* Allocate and initialise sctp mibs.  */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">init_sctp_mibs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_init_mibs</span><span class="p">;</span>

	<span class="cm">/* Initialize proc fs directory.  */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_proc_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_init_proc</span><span class="p">;</span>

	<span class="cm">/* Initialize object count debugging.  */</span>
	<span class="n">sctp_dbg_objcnt_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * 14. Suggested SCTP Protocol Parameter Values</span>
<span class="cm">	 */</span>
	<span class="cm">/* The following protocol parameters are RECOMMENDED:  */</span>
	<span class="cm">/* RTO.Initial              - 3  seconds */</span>
	<span class="n">sctp_rto_initial</span>		<span class="o">=</span> <span class="n">SCTP_RTO_INITIAL</span><span class="p">;</span>
	<span class="cm">/* RTO.Min                  - 1  second */</span>
	<span class="n">sctp_rto_min</span>	 		<span class="o">=</span> <span class="n">SCTP_RTO_MIN</span><span class="p">;</span>
	<span class="cm">/* RTO.Max                 -  60 seconds */</span>
	<span class="n">sctp_rto_max</span> 			<span class="o">=</span> <span class="n">SCTP_RTO_MAX</span><span class="p">;</span>
	<span class="cm">/* RTO.Alpha                - 1/8 */</span>
	<span class="n">sctp_rto_alpha</span>	        	<span class="o">=</span> <span class="n">SCTP_RTO_ALPHA</span><span class="p">;</span>
	<span class="cm">/* RTO.Beta                 - 1/4 */</span>
	<span class="n">sctp_rto_beta</span>			<span class="o">=</span> <span class="n">SCTP_RTO_BETA</span><span class="p">;</span>

	<span class="cm">/* Valid.Cookie.Life        - 60  seconds */</span>
	<span class="n">sctp_valid_cookie_life</span>		<span class="o">=</span> <span class="n">SCTP_DEFAULT_COOKIE_LIFE</span><span class="p">;</span>

	<span class="cm">/* Whether Cookie Preservative is enabled(1) or not(0) */</span>
	<span class="n">sctp_cookie_preserve_enable</span> 	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Max.Burst		    - 4 */</span>
	<span class="n">sctp_max_burst</span> 			<span class="o">=</span> <span class="n">SCTP_DEFAULT_MAX_BURST</span><span class="p">;</span>

	<span class="cm">/* Association.Max.Retrans  - 10 attempts</span>
<span class="cm">	 * Path.Max.Retrans         - 5  attempts (per destination address)</span>
<span class="cm">	 * Max.Init.Retransmits     - 8  attempts</span>
<span class="cm">	 */</span>
	<span class="n">sctp_max_retrans_association</span> 	<span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">sctp_max_retrans_path</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">sctp_max_retrans_init</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/* Sendbuffer growth	    - do per-socket accounting */</span>
	<span class="n">sctp_sndbuf_policy</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Rcvbuffer growth	    - do per-socket accounting */</span>
	<span class="n">sctp_rcvbuf_policy</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* HB.interval              - 30 seconds */</span>
	<span class="n">sctp_hb_interval</span>		<span class="o">=</span> <span class="n">SCTP_DEFAULT_TIMEOUT_HEARTBEAT</span><span class="p">;</span>

	<span class="cm">/* delayed SACK timeout */</span>
	<span class="n">sctp_sack_timeout</span>		<span class="o">=</span> <span class="n">SCTP_DEFAULT_TIMEOUT_SACK</span><span class="p">;</span>

	<span class="cm">/* Implementation specific variables. */</span>

	<span class="cm">/* Initialize default stream count setup information. */</span>
	<span class="n">sctp_max_instreams</span>    		<span class="o">=</span> <span class="n">SCTP_DEFAULT_INSTREAMS</span><span class="p">;</span>
	<span class="n">sctp_max_outstreams</span>   		<span class="o">=</span> <span class="n">SCTP_DEFAULT_OUTSTREAMS</span><span class="p">;</span>

	<span class="cm">/* Initialize maximum autoclose timeout. */</span>
	<span class="n">sctp_max_autoclose</span>		<span class="o">=</span> <span class="n">INT_MAX</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* Initialize handle used for association ids. */</span>
	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assocs_id</span><span class="p">);</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">nr_free_buffer_pages</span><span class="p">()</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="mi">128UL</span><span class="p">);</span>
	<span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Set per-socket limits to no more than 1/128 the pressure threshold*/</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">sysctl_sctp_mem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">max_share</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">4UL</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

	<span class="n">sysctl_sctp_rmem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">;</span> <span class="cm">/* give each asoc 1 page min */</span>
	<span class="n">sysctl_sctp_rmem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1500</span> <span class="o">*</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">sysctl_sctp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sysctl_sctp_rmem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_share</span><span class="p">);</span>

	<span class="n">sysctl_sctp_wmem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">;</span>
	<span class="n">sysctl_sctp_wmem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
	<span class="n">sysctl_sctp_wmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">max_share</span><span class="p">);</span>

	<span class="cm">/* Size and allocate the association hash table.</span>
<span class="cm">	 * The methodology is similar to that of the tcp hash tables.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="n">totalram_pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">22</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="n">totalram_pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">goal</span><span class="p">;</span> <span class="n">order</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sctp_assoc_hashsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hashbucket</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sctp_assoc_hashsize</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sctp_assoc_hashtable</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_hashtable</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_assoc_hashtable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed association hash alloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ahash_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sctp_assoc_hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assoc_hashtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_assoc_hashtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chain</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate and initialize the endpoint hash table.  */</span>
	<span class="n">sctp_ep_hashsize</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">sctp_ep_hashtable</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hashbucket</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_ep_hashtable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed endpoint_hash alloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ehash_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sctp_ep_hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_ep_hashtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_ep_hashtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chain</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate and initialize the SCTP port hash table.  */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sctp_port_hashsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sctp_port_hashsize</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sctp_port_hashtable</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_port_hashtable</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctp_port_hashtable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed bind hash alloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_bhash_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sctp_port_hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_port_hashtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_port_hashtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chain</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Hash tables configured (established %d bind %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sctp_assoc_hashsize</span><span class="p">,</span> <span class="n">sctp_port_hashsize</span><span class="p">);</span>

	<span class="cm">/* Disable ADDIP by default. */</span>
	<span class="n">sctp_addip_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sctp_addip_noauth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sctp_default_auto_asconf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable PR-SCTP by default. */</span>
	<span class="n">sctp_prsctp_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Disable AUTH by default. */</span>
	<span class="n">sctp_auth_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set SCOPE policy to enabled */</span>
	<span class="n">sctp_scope_policy</span> <span class="o">=</span> <span class="n">SCTP_SCOPE_POLICY_ENABLE</span><span class="p">;</span>

	<span class="cm">/* Set the default rwnd update threshold */</span>
	<span class="n">sctp_rwnd_upd_shift</span>		<span class="o">=</span> <span class="n">SCTP_DEFAULT_RWND_SHIFT</span><span class="p">;</span>

	<span class="n">sctp_sysctl_register</span><span class="p">();</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_address_families</span><span class="p">);</span>
	<span class="n">sctp_v4_pf_init</span><span class="p">();</span>
	<span class="n">sctp_v6_pf_init</span><span class="p">();</span>

	<span class="cm">/* Initialize the local address list. */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_local_addr_lock</span><span class="p">);</span>
	<span class="n">sctp_get_local_addr_list</span><span class="p">();</span>

	<span class="cm">/* Initialize the address event list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_waitq</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_auto_asconf_splist</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_lock</span><span class="p">);</span>
	<span class="n">sctp_addr_wq_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sctp_addr_wq_timer</span><span class="p">,</span> <span class="n">sctp_addr_wq_timeout_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_v4_protosw_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_protosw_init</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_v6_protosw_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_v6_protosw_init</span><span class="p">;</span>

	<span class="cm">/* Initialize the control inode/socket for handling OOTB packets.  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">sctp_ctl_sock_init</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to initialize the SCTP control sock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_ctl_sock_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_v4_add_protocol</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_add_protocol</span><span class="p">;</span>

	<span class="cm">/* Register SCTP with inet6 layer.  */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sctp_v6_add_protocol</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_v6_add_protocol</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">err_v6_add_protocol:</span>
	<span class="n">sctp_v4_del_protocol</span><span class="p">();</span>
<span class="nl">err_add_protocol:</span>
	<span class="n">inet_ctl_sock_destroy</span><span class="p">(</span><span class="n">sctp_ctl_sock</span><span class="p">);</span>
<span class="nl">err_ctl_sock_init:</span>
	<span class="n">sctp_v6_protosw_exit</span><span class="p">();</span>
<span class="nl">err_v6_protosw_init:</span>
	<span class="n">sctp_v4_protosw_exit</span><span class="p">();</span>
<span class="nl">err_protosw_init:</span>
	<span class="n">sctp_free_local_addr_list</span><span class="p">();</span>
	<span class="n">sctp_v4_pf_exit</span><span class="p">();</span>
	<span class="n">sctp_v6_pf_exit</span><span class="p">();</span>
	<span class="n">sctp_sysctl_unregister</span><span class="p">();</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sctp_port_hashtable</span><span class="p">,</span>
		   <span class="n">get_order</span><span class="p">(</span><span class="n">sctp_port_hashsize</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span><span class="p">)));</span>
<span class="nl">err_bhash_alloc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sctp_ep_hashtable</span><span class="p">);</span>
<span class="nl">err_ehash_alloc:</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sctp_assoc_hashtable</span><span class="p">,</span>
		   <span class="n">get_order</span><span class="p">(</span><span class="n">sctp_assoc_hashsize</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hashbucket</span><span class="p">)));</span>
<span class="nl">err_ahash_alloc:</span>
	<span class="n">sctp_dbg_objcnt_exit</span><span class="p">();</span>
	<span class="n">sctp_proc_exit</span><span class="p">();</span>
<span class="nl">err_init_proc:</span>
	<span class="n">cleanup_sctp_mibs</span><span class="p">();</span>
<span class="nl">err_init_mibs:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sctp_chunk_cachep</span><span class="p">);</span>
<span class="nl">err_chunk_cachep:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sctp_bucket_cachep</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Exit handler for the SCTP protocol.  */</span>
<span class="n">SCTP_STATIC</span> <span class="n">__exit</span> <span class="kt">void</span> <span class="nf">sctp_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* BUG.  This should probably do something useful like clean</span>
<span class="cm">	 * up all the remaining associations and all that memory.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Unregister with inet6/inet layers. */</span>
	<span class="n">sctp_v6_del_protocol</span><span class="p">();</span>
	<span class="n">sctp_v4_del_protocol</span><span class="p">();</span>
	<span class="n">sctp_free_addr_wq</span><span class="p">();</span>

	<span class="cm">/* Free the control endpoint.  */</span>
	<span class="n">inet_ctl_sock_destroy</span><span class="p">(</span><span class="n">sctp_ctl_sock</span><span class="p">);</span>

	<span class="cm">/* Free protosw registrations */</span>
	<span class="n">sctp_v6_protosw_exit</span><span class="p">();</span>
	<span class="n">sctp_v4_protosw_exit</span><span class="p">();</span>

	<span class="cm">/* Free the local address list.  */</span>
	<span class="n">sctp_free_local_addr_list</span><span class="p">();</span>

	<span class="cm">/* Unregister with socket layer. */</span>
	<span class="n">sctp_v6_pf_exit</span><span class="p">();</span>
	<span class="n">sctp_v4_pf_exit</span><span class="p">();</span>

	<span class="n">sctp_sysctl_unregister</span><span class="p">();</span>

	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sctp_assoc_hashtable</span><span class="p">,</span>
		   <span class="n">get_order</span><span class="p">(</span><span class="n">sctp_assoc_hashsize</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_hashbucket</span><span class="p">)));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sctp_ep_hashtable</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sctp_port_hashtable</span><span class="p">,</span>
		   <span class="n">get_order</span><span class="p">(</span><span class="n">sctp_port_hashsize</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span><span class="p">)));</span>

	<span class="n">sctp_dbg_objcnt_exit</span><span class="p">();</span>
	<span class="n">sctp_proc_exit</span><span class="p">();</span>
	<span class="n">cleanup_sctp_mibs</span><span class="p">();</span>

	<span class="n">rcu_barrier</span><span class="p">();</span> <span class="cm">/* Wait for completion of call_rcu()&#39;s */</span>

	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sctp_chunk_cachep</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">sctp_bucket_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">sctp_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sctp_exit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * __stringify doesn&#39;t likes enums, so use IPPROTO_SCTP value (132) directly.</span>
<span class="cm"> */</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;net-pf-&quot;</span> <span class="n">__stringify</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">)</span> <span class="s">&quot;-proto-132&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;net-pf-&quot;</span> <span class="n">__stringify</span><span class="p">(</span><span class="n">PF_INET6</span><span class="p">)</span> <span class="s">&quot;-proto-132&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Linux Kernel SCTP developers &lt;lksctp-developers@lists.sourceforge.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Support for the SCTP protocol (RFC2960)&quot;</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">no_checksums</span><span class="p">,</span> <span class="n">sctp_checksum_disable</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">no_checksums</span><span class="p">,</span> <span class="s">&quot;Disable checksums computing and verification&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
