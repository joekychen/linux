<!DOCTYPE html>
<html><head><title>joekychen/linux » net › wireless › reg.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>reg.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2002-2005, Instant802 Networks, Inc.</span>
<span class="cm"> * Copyright 2005-2006, Devicescape Software, Inc.</span>
<span class="cm"> * Copyright 2007	Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> * Copyright 2008-2011	Luis R. Rodriguez &lt;mcgrof@qca.qualcomm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission to use, copy, modify, and/or distribute this software for any</span>
<span class="cm"> * purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> * copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: Wireless regulatory infrastructure</span>
<span class="cm"> *</span>
<span class="cm"> * The usual implementation is for a driver to read a device EEPROM to</span>
<span class="cm"> * determine which regulatory domain it should be operating under, then</span>
<span class="cm"> * looking up the allowable channels in a driver-local table and finally</span>
<span class="cm"> * registering those channels in the wiphy structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Another set of compliance enforcement is for drivers to use their</span>
<span class="cm"> * own compliance limits which can be stored on the EEPROM. The host</span>
<span class="cm"> * driver or firmware may ensure these are used.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to all this we provide an extra layer of regulatory</span>
<span class="cm"> * conformance. For drivers which do not have any regulatory</span>
<span class="cm"> * information CRDA provides the complete regulatory solution.</span>
<span class="cm"> * For others it provides a community effort on further restrictions</span>
<span class="cm"> * to enhance compliance.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: When number of rules --&gt; infinity we will not be able to</span>
<span class="cm"> * index on alpha2 any more, instead we&#39;ll probably have to</span>
<span class="cm"> * rely on some SHA1 checksum of the regdomain for example.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/nl80211.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;net/cfg80211.h&gt;</span>
<span class="cp">#include &quot;core.h&quot;</span>
<span class="cp">#include &quot;reg.h&quot;</span>
<span class="cp">#include &quot;regdb.h&quot;</span>
<span class="cp">#include &quot;nl80211.h&quot;</span>

<span class="cp">#ifdef CONFIG_CFG80211_REG_DEBUG</span>
<span class="cp">#define REG_DBG_PRINT(format, args...)			\</span>
<span class="cp">	printk(KERN_DEBUG pr_fmt(format), ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define REG_DBG_PRINT(args...)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">regulatory_request</span> <span class="n">core_request_world</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intersect</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
	<span class="p">.</span><span class="n">processed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">.</span><span class="n">country_ie_env</span> <span class="o">=</span> <span class="n">ENVIRON_ANY</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Receipt of information from last regulatory request */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">last_request</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">core_request_world</span><span class="p">;</span>

<span class="cm">/* To trigger userspace events */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">reg_pdev</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">reg_device_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">uevent</span> <span class="o">=</span> <span class="n">reg_device_uevent</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Central wireless core regulatory domains, we only need two,</span>
<span class="cm"> * the current one and a world regulatory domain in case we have no</span>
<span class="cm"> * information to give us an alpha2</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">cfg80211_regdomain</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Protects static reg.c components:</span>
<span class="cm"> *     - cfg80211_world_regdom</span>
<span class="cm"> *     - cfg80211_regdom</span>
<span class="cm"> *     - last_request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">reg_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">assert_reg_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used to queue up regulatory hints */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">reg_requests_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">reg_requests_lock</span><span class="p">;</span>

<span class="cm">/* Used to queue up beacon hints for review */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">reg_pending_beacons</span><span class="p">);</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">reg_pending_beacons_lock</span><span class="p">;</span>

<span class="cm">/* Used to keep track of processed beacon hints */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">reg_beacon_list</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">reg_beacon</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="n">chan</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">reg_todo</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">reg_work</span><span class="p">,</span> <span class="n">reg_todo</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">reg_timeout_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">reg_timeout</span><span class="p">,</span> <span class="n">reg_timeout_work</span><span class="p">);</span>

<span class="cm">/* We keep a static world regulatory domain in case of the absence of CRDA */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="n">world_regdom</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">n_reg_rules</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alpha2</span> <span class="o">=</span>  <span class="s">&quot;00&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reg_rules</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* IEEE 802.11b/g, channels 1..11 */</span>
		<span class="n">REG_RULE</span><span class="p">(</span><span class="mi">2412</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2462</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="cm">/* IEEE 802.11b/g, channels 12..13. No HT40</span>
<span class="cm">		 * channel fits here. */</span>
		<span class="n">REG_RULE</span><span class="p">(</span><span class="mi">2467</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2472</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
			<span class="n">NL80211_RRF_PASSIVE_SCAN</span> <span class="o">|</span>
			<span class="n">NL80211_RRF_NO_IBSS</span><span class="p">),</span>
		<span class="cm">/* IEEE 802.11 channel 14 - Only JP enables</span>
<span class="cm">		 * this and for 802.11b only */</span>
		<span class="n">REG_RULE</span><span class="p">(</span><span class="mi">2484</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2484</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
			<span class="n">NL80211_RRF_PASSIVE_SCAN</span> <span class="o">|</span>
			<span class="n">NL80211_RRF_NO_IBSS</span> <span class="o">|</span>
			<span class="n">NL80211_RRF_NO_OFDM</span><span class="p">),</span>
		<span class="cm">/* IEEE 802.11a, channel 36..48 */</span>
		<span class="n">REG_RULE</span><span class="p">(</span><span class="mi">5180</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5240</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
                        <span class="n">NL80211_RRF_PASSIVE_SCAN</span> <span class="o">|</span>
                        <span class="n">NL80211_RRF_NO_IBSS</span><span class="p">),</span>

		<span class="cm">/* NB: 5260 MHz - 5700 MHz requies DFS */</span>

		<span class="cm">/* IEEE 802.11a, channel 149..165 */</span>
		<span class="n">REG_RULE</span><span class="p">(</span><span class="mi">5745</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5825</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
			<span class="n">NL80211_RRF_PASSIVE_SCAN</span> <span class="o">|</span>
			<span class="n">NL80211_RRF_NO_IBSS</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">cfg80211_world_regdom</span> <span class="o">=</span>
	<span class="o">&amp;</span><span class="n">world_regdom</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ieee80211_regdom</span> <span class="o">=</span> <span class="s">&quot;00&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">ieee80211_regdom</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ieee80211_regdom</span><span class="p">,</span> <span class="s">&quot;IEEE 802.11 regulatory domain code&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_regdomains</span><span class="p">(</span><span class="n">bool</span> <span class="n">full_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* avoid freeing static information or freeing something twice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg80211_regdomain</span> <span class="o">==</span> <span class="n">cfg80211_world_regdom</span><span class="p">)</span>
		<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg80211_world_regdom</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">world_regdom</span><span class="p">)</span>
		<span class="n">cfg80211_world_regdom</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg80211_regdomain</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">world_regdom</span><span class="p">)</span>
		<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">cfg80211_regdomain</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfg80211_world_regdom</span><span class="p">);</span>

	<span class="n">cfg80211_world_regdom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">world_regdom</span><span class="p">;</span>
	<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">full_reset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">core_request_world</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">last_request</span><span class="p">);</span>
	<span class="n">last_request</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">core_request_world</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dynamic world regulatory domain requested by the wireless</span>
<span class="cm"> * core upon initialization</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_world_regdomain</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">);</span>

	<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

	<span class="n">cfg80211_world_regdom</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
	<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">is_world_regdom</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_alpha2_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_unknown_alpha2</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Special case where regulatory domain was built by driver</span>
<span class="cm">	 * but a specific alpha2 cannot be determined</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;9&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_intersected_alpha2</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Special case where regulatory domain is the</span>
<span class="cm">	 * result of an intersection between two regulatory domain</span>
<span class="cm">	 * structures</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;9&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;8&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_an_alpha2</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">isalpha</span><span class="p">(</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">alpha2_equal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2_x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2_y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2_x</span> <span class="o">||</span> <span class="o">!</span><span class="n">alpha2_y</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha2_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha2_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		<span class="n">alpha2_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha2_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">regdom_changes</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg80211_regdomain</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha2_equal</span><span class="p">(</span><span class="n">cfg80211_regdomain</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">,</span> <span class="n">alpha2</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The NL80211_REGDOM_SET_BY_USER regdom alpha2 is cached, this lets</span>
<span class="cm"> * you know if a valid regulatory hint with NL80211_REGDOM_SET_BY_USER</span>
<span class="cm"> * has ever been issued.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_user_regdom_saved</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;9&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;7&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* This would indicate a mistake on the design */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">((</span><span class="o">!</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">user_alpha2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		  <span class="o">!</span><span class="n">is_an_alpha2</span><span class="p">(</span><span class="n">user_alpha2</span><span class="p">)),</span>
		 <span class="s">&quot;Unexpected user alpha2: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	         <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reg_copy_regd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">**</span><span class="n">dst_regd</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">src_regd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size_of_regd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">size_of_regd</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_regdomain</span><span class="p">)</span> <span class="o">+</span>
	  <span class="p">((</span><span class="n">src_regd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_reg_rule</span><span class="p">));</span>

	<span class="n">regd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size_of_regd</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">regd</span><span class="p">,</span> <span class="n">src_regd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_regdomain</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src_regd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regd</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">src_regd</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_reg_rule</span><span class="p">));</span>

	<span class="o">*</span><span class="n">dst_regd</span> <span class="o">=</span> <span class="n">regd</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CFG80211_INTERNAL_REGDB</span>
<span class="k">struct</span> <span class="n">reg_regdb_search_request</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">reg_regdb_search_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">reg_regdb_search_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_regdb_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reg_regdb_search_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">curdom</span><span class="p">,</span> <span class="o">*</span><span class="n">regdom</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_search_mutex</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_search_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">request</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_search_list</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">reg_regdb_search_request</span><span class="p">,</span>
					   <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">reg_regdb_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curdom</span> <span class="o">=</span> <span class="n">reg_regdb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">,</span> <span class="n">curdom</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">r</span> <span class="o">=</span> <span class="n">reg_copy_regd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regdom</span><span class="p">,</span> <span class="n">curdom</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
				<span class="n">set_regdom</span><span class="p">(</span><span class="n">regdom</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_search_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">reg_regdb_work</span><span class="p">,</span> <span class="n">reg_regdb_search</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_regdb_query</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reg_regdb_search_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">request</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reg_regdb_search_request</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">,</span> <span class="n">alpha2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_search_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_regdb_search_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_search_mutex</span><span class="p">);</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_regdb_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Feel free to add any other sanity checks here */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_regdb_size_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We should ideally BUILD_BUG_ON() but then random builds would fail */</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">reg_regdb_size</span><span class="p">,</span> <span class="s">&quot;db.txt is empty, you should update it...&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reg_regdb_size_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reg_regdb_query</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CFG80211_INTERNAL_REGDB */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This lets us keep regulatory code which is updated on a regulatory</span>
<span class="cm"> * basis in userspace. Country information is filled in by</span>
<span class="cm"> * reg_device_uevent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">call_crda</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_world_regdom</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">alpha2</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calling CRDA for country: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calling CRDA to update world regulatory domain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* query internal regulatory database (if it exists) */</span>
	<span class="n">reg_regdb_query</span><span class="p">(</span><span class="n">alpha2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used by nl80211 before kmalloc&#39;ing our regulatory domain */</span>
<span class="n">bool</span> <span class="nf">reg_is_valid_request</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">alpha2_equal</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">,</span> <span class="n">alpha2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Sanity check on a regulatory rule */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_valid_reg_rule</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">freq_diff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span> <span class="o">&gt;</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">freq_diff</span> <span class="o">=</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span> <span class="o">-</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span> <span class="o">&lt;=</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span> <span class="o">||</span>
			<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span> <span class="o">&gt;</span> <span class="n">freq_diff</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_valid_rd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">reg_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span> <span class="o">&gt;</span> <span class="n">NL80211_MAX_SUPP_REG_RULES</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_reg_rule</span><span class="p">(</span><span class="n">reg_rule</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">reg_does_bw_fit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">center_freq_khz</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">bw_khz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">start_freq_khz</span><span class="p">,</span> <span class="n">end_freq_khz</span><span class="p">;</span>

	<span class="n">start_freq_khz</span> <span class="o">=</span> <span class="n">center_freq_khz</span> <span class="o">-</span> <span class="p">(</span><span class="n">bw_khz</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">end_freq_khz</span> <span class="o">=</span> <span class="n">center_freq_khz</span> <span class="o">+</span> <span class="p">(</span><span class="n">bw_khz</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_freq_khz</span> <span class="o">&gt;=</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span> <span class="o">&amp;&amp;</span>
	    <span class="n">end_freq_khz</span> <span class="o">&lt;=</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * freq_in_rule_band - tells us if a frequency is in a frequency band</span>
<span class="cm"> * @freq_range: frequency rule we want to query</span>
<span class="cm"> * @freq_khz: frequency we are inquiring about</span>
<span class="cm"> *</span>
<span class="cm"> * This lets us know if a specific frequency rule is or is not relevant to</span>
<span class="cm"> * a specific frequency&#39;s band. Bands are device specific and artificial</span>
<span class="cm"> * definitions (the &quot;2.4 GHz band&quot; and the &quot;5 GHz band&quot;), however it is</span>
<span class="cm"> * safe for now to assume that a frequency rule should not be part of a</span>
<span class="cm"> * frequency&#39;s band if the start freq or end freq are off by more than 2 GHz.</span>
<span class="cm"> * This resolution can be lowered and should be considered as we add</span>
<span class="cm"> * regulatory rule support for other &quot;bands&quot;.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">freq_in_rule_band</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">freq_khz</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define ONE_GHZ_IN_KHZ	1000000</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">freq_khz</span> <span class="o">-</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ONE_GHZ_IN_KHZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">freq_khz</span> <span class="o">-</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ONE_GHZ_IN_KHZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#undef ONE_GHZ_IN_KHZ</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper for regdom_intersect(), this does the real</span>
<span class="cm"> * mathematical intersection fun</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reg_rules_intersect</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">rule1</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">rule2</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">intersected_rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range1</span><span class="p">,</span> <span class="o">*</span><span class="n">freq_range2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_power_rule</span> <span class="o">*</span><span class="n">power_rule1</span><span class="p">,</span> <span class="o">*</span><span class="n">power_rule2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_power_rule</span> <span class="o">*</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">freq_diff</span><span class="p">;</span>

	<span class="n">freq_range1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule1</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>
	<span class="n">freq_range2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule2</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>
	<span class="n">freq_range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intersected_rule</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>

	<span class="n">power_rule1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule1</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="n">power_rule2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule2</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="n">power_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intersected_rule</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>

	<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">freq_range1</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">,</span>
		<span class="n">freq_range2</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">);</span>
	<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">freq_range1</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">,</span>
		<span class="n">freq_range2</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">);</span>
	<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">freq_range1</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span><span class="p">,</span>
		<span class="n">freq_range2</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span><span class="p">);</span>

	<span class="n">freq_diff</span> <span class="o">=</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span> <span class="o">-</span> <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span> <span class="o">&gt;</span> <span class="n">freq_diff</span><span class="p">)</span>
		<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span> <span class="o">=</span> <span class="n">freq_diff</span><span class="p">;</span>

	<span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">power_rule1</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">,</span>
		<span class="n">power_rule2</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
	<span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">power_rule1</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">,</span>
		<span class="n">power_rule2</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">);</span>

	<span class="n">intersected_rule</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">rule1</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">rule2</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_reg_rule</span><span class="p">(</span><span class="n">intersected_rule</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * regdom_intersect - do the intersection between two regulatory domains</span>
<span class="cm"> * @rd1: first regulatory domain</span>
<span class="cm"> * @rd2: second regulatory domain</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to get the intersection between two regulatory domains.</span>
<span class="cm"> * Once completed we will mark the alpha2 for the rd as intersected, &quot;98&quot;,</span>
<span class="cm"> * as no one single alpha2 can represent this regulatory domain.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the regulatory domain structure which will hold the</span>
<span class="cm"> * resulting intersection of rules between rd1 and rd2. We will</span>
<span class="cm"> * kzalloc() this structure for you.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="nf">regdom_intersect</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd1</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">size_of_regd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_rules</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rule_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">rule1</span><span class="p">,</span> <span class="o">*</span><span class="n">rule2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">intersected_rule</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">;</span>
	<span class="cm">/* This is just a dummy holder to help us count */</span>
	<span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="n">irule</span><span class="p">;</span>

	<span class="cm">/* Uses the stack temporarily for counter arithmetic */</span>
	<span class="n">intersected_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irule</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">intersected_rule</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_reg_rule</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rd1</span> <span class="o">||</span> <span class="o">!</span><span class="n">rd2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First we get a count of the rules we&#39;ll need, then we actually</span>
<span class="cm">	 * build them. This is to so we can malloc() and free() a</span>
<span class="cm">	 * regdomain once. The reason we use reg_rules_intersect() here</span>
<span class="cm">	 * is it will return -EINVAL if the rule computed makes no sense.</span>
<span class="cm">	 * All rules that do check out OK are valid.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">rd1</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rule1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd1</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">rd2</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rule2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd2</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg_rules_intersect</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">rule2</span><span class="p">,</span>
					<span class="n">intersected_rule</span><span class="p">))</span>
				<span class="n">num_rules</span><span class="o">++</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">intersected_rule</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_reg_rule</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_rules</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size_of_regd</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_regdomain</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">num_rules</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_reg_rule</span><span class="p">));</span>

	<span class="n">rd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size_of_regd</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">rd1</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rule1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd1</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">rd2</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rule2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd2</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * This time around instead of using the stack lets</span>
<span class="cm">			 * write to the target rule directly saving ourselves</span>
<span class="cm">			 * a memcpy()</span>
<span class="cm">			 */</span>
			<span class="n">intersected_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">];</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">reg_rules_intersect</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">rule2</span><span class="p">,</span>
				<span class="n">intersected_rule</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * No need to memset here the intersected rule here as</span>
<span class="cm">			 * we&#39;re not using the stack anymore</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">rule_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rule_idx</span> <span class="o">!=</span> <span class="n">num_rules</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span> <span class="o">=</span> <span class="n">num_rules</span><span class="p">;</span>
	<span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span>
	<span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;8&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX: add support for the rest of enum nl80211_reg_rule_flags, we may</span>
<span class="cm"> * want to just have the channel structure use these</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">map_regdom_flags</span><span class="p">(</span><span class="n">u32</span> <span class="n">rd_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">channel_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rd_flags</span> <span class="o">&amp;</span> <span class="n">NL80211_RRF_PASSIVE_SCAN</span><span class="p">)</span>
		<span class="n">channel_flags</span> <span class="o">|=</span> <span class="n">IEEE80211_CHAN_PASSIVE_SCAN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rd_flags</span> <span class="o">&amp;</span> <span class="n">NL80211_RRF_NO_IBSS</span><span class="p">)</span>
		<span class="n">channel_flags</span> <span class="o">|=</span> <span class="n">IEEE80211_CHAN_NO_IBSS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rd_flags</span> <span class="o">&amp;</span> <span class="n">NL80211_RRF_DFS</span><span class="p">)</span>
		<span class="n">channel_flags</span> <span class="o">|=</span> <span class="n">IEEE80211_CHAN_RADAR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">channel_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">freq_reg_info_regd</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">center_freq</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">desired_bw_khz</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">**</span><span class="n">reg_rule</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">custom_regd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">band_rule_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bw_fits</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desired_bw_khz</span><span class="p">)</span>
		<span class="n">desired_bw_khz</span> <span class="o">=</span> <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="n">regd</span> <span class="o">=</span> <span class="n">custom_regd</span> <span class="o">?</span> <span class="n">custom_regd</span> <span class="o">:</span> <span class="n">cfg80211_regdomain</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Follow the driver&#39;s regulatory domain, if present, unless a country</span>
<span class="cm">	 * IE has been processed or a user wants to help complaince further</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">custom_regd</span> <span class="o">&amp;&amp;</span>
	    <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">)</span>
		<span class="n">regd</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">regd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">rr</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">fr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">rr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">regd</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">fr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rr</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We only need to know if one frequency rule was</span>
<span class="cm">		 * was in center_freq&#39;s band, that&#39;s enough, so lets</span>
<span class="cm">		 * not overwrite it once found</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">band_rule_found</span><span class="p">)</span>
			<span class="n">band_rule_found</span> <span class="o">=</span> <span class="n">freq_in_rule_band</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">center_freq</span><span class="p">);</span>

		<span class="n">bw_fits</span> <span class="o">=</span> <span class="n">reg_does_bw_fit</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span>
					  <span class="n">center_freq</span><span class="p">,</span>
					  <span class="n">desired_bw_khz</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">band_rule_found</span> <span class="o">&amp;&amp;</span> <span class="n">bw_fits</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">reg_rule</span> <span class="o">=</span> <span class="n">rr</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">band_rule_found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">freq_reg_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
		  <span class="n">u32</span> <span class="n">center_freq</span><span class="p">,</span>
		  <span class="n">u32</span> <span class="n">desired_bw_khz</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">**</span><span class="n">reg_rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">freq_reg_info_regd</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span>
				  <span class="n">center_freq</span><span class="p">,</span>
				  <span class="n">desired_bw_khz</span><span class="p">,</span>
				  <span class="n">reg_rule</span><span class="p">,</span>
				  <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">freq_reg_info</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CFG80211_REG_DEBUG</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">reg_initiator_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">initiator</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span>:
		<span class="k">return</span> <span class="s">&quot;Set by core&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span>:
		<span class="k">return</span> <span class="s">&quot;Set by user&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span>:
		<span class="k">return</span> <span class="s">&quot;Set by driver&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span>:
		<span class="k">return</span> <span class="s">&quot;Set by country IE&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="s">&quot;Set by bug&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">chan_reg_rule_print_dbg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">desired_bw_khz</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">reg_rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_power_rule</span> <span class="o">*</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">max_antenna_gain</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">power_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="n">freq_range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">max_antenna_gain</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;N/A&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">max_antenna_gain</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">);</span>

	<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Updating information on frequency %d MHz &quot;</span>
		      <span class="s">&quot;for a %d MHz width channel with regulatory rule:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">,</span>
		      <span class="n">KHZ_TO_MHZ</span><span class="p">(</span><span class="n">desired_bw_khz</span><span class="p">));</span>

	<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;%d KHz - %d KHz @ %d KHz), (%s mBi, %d mBm)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">,</span>
		      <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">,</span>
		      <span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span><span class="p">,</span>
		      <span class="n">max_antenna_gain</span><span class="p">,</span>
		      <span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">chan_reg_rule_print_dbg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">desired_bw_khz</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">reg_rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Note that right now we assume the desired channel bandwidth</span>
<span class="cm"> * is always 20 MHz for each individual channel (HT40 uses 20 MHz</span>
<span class="cm"> * per channel, the primary and the extension channel). To support</span>
<span class="cm"> * smaller custom bandwidths such as 5 MHz or 10 MHz we&#39;ll need a</span>
<span class="cm"> * new ieee80211_channel.target_bw and re run the regulatory check</span>
<span class="cm"> * on the wiphy with the target_bw specified. Then we can simply use</span>
<span class="cm"> * that below for the desired_bw_khz below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">initiator</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bw_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">desired_bw_khz</span> <span class="o">=</span> <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">reg_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_power_rule</span> <span class="o">*</span><span class="n">power_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">request_wiphy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="n">request_wiphy</span> <span class="o">=</span> <span class="n">wiphy_idx_to_wiphy</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">);</span>

	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chan_idx</span> <span class="o">&gt;=</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">);</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sband</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chan_idx</span><span class="p">];</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_flags</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">freq_reg_info</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span>
			  <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">),</span>
			  <span class="n">desired_bw_khz</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">reg_rule</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We will disable all channels that do not match our</span>
<span class="cm">		 * received regulatory rule unless the hint is coming</span>
<span class="cm">		 * from a Country IE and the Country IE had no information</span>
<span class="cm">		 * about a band. The IEEE 802.11 spec allows for an AP</span>
<span class="cm">		 * to send only a subset of the regulatory rules allowed,</span>
<span class="cm">		 * so an AP in the US that only supports 2.4 GHz may only send</span>
<span class="cm">		 * a country IE with information for the 2.4 GHz band</span>
<span class="cm">		 * while 5 GHz is still supported.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Disabling freq %d MHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">);</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IEEE80211_CHAN_DISABLED</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chan_reg_rule_print_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desired_bw_khz</span><span class="p">,</span> <span class="n">reg_rule</span><span class="p">);</span>

	<span class="n">power_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="n">freq_range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span> <span class="o">&lt;</span> <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
		<span class="n">bw_flags</span> <span class="o">=</span> <span class="n">IEEE80211_CHAN_NO_HT40</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">request_wiphy</span> <span class="o">&amp;&amp;</span> <span class="n">request_wiphy</span> <span class="o">==</span> <span class="n">wiphy</span> <span class="o">&amp;&amp;</span>
	    <span class="n">request_wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_STRICT_REGULATORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This guarantees the driver&#39;s requested regulatory domain</span>
<span class="cm">		 * will always be used as a base for further regulatory</span>
<span class="cm">		 * settings</span>
<span class="cm">		 */</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_flags</span> <span class="o">=</span>
			<span class="n">map_regdom_flags</span><span class="p">(</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">|</span> <span class="n">bw_flags</span><span class="p">;</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_mag</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">MBI_TO_DBI</span><span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">);</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_power</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_mpwr</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">MBM_TO_DBM</span><span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">beacon_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">bw_flags</span> <span class="o">|</span> <span class="n">map_regdom_flags</span><span class="p">(</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_mag</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">MBI_TO_DBI</span><span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">));</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_reg_power</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">MBM_TO_DBM</span><span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_power</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_power</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_reg_power</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_band</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">]);</span>
	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">handle_channel</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">initiator</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">ignore_reg_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Ignoring regulatory request %s since &quot;</span>
			      <span class="s">&quot;last_request is not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">reg_initiator_name</span><span class="p">(</span><span class="n">initiator</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_CUSTOM_REGULATORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Ignoring regulatory request %s &quot;</span>
			      <span class="s">&quot;since the driver uses its own custom &quot;</span>
			      <span class="s">&quot;regulatory domain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">reg_initiator_name</span><span class="p">(</span><span class="n">initiator</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * wiphy-&gt;regd will be set once the device has its own</span>
<span class="cm">	 * desired regulatory domain set</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_STRICT_REGULATORY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span> <span class="o">&amp;&amp;</span>
	    <span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Ignoring regulatory request %s &quot;</span>
			      <span class="s">&quot;since the driver requires its own regulatory &quot;</span>
			      <span class="s">&quot;domain to be set first</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">reg_initiator_name</span><span class="p">(</span><span class="n">initiator</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_reg_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan_idx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">reg_beacon</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">channel_changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="n">chan_before</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">band</span><span class="p">];</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sband</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chan_idx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">!=</span> <span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">center_freq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">beacon_found</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">beacon_found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_DISABLE_BEACON_HINTS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">chan_before</span><span class="p">.</span><span class="n">center_freq</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">;</span>
	<span class="n">chan_before</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_CHAN_PASSIVE_SCAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEEE80211_CHAN_PASSIVE_SCAN</span><span class="p">;</span>
		<span class="n">channel_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_CHAN_NO_IBSS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEEE80211_CHAN_NO_IBSS</span><span class="p">;</span>
		<span class="n">channel_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel_changed</span><span class="p">)</span>
		<span class="n">nl80211_send_beacon_hint_event</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chan_before</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when a scan on a wiphy finds a beacon on</span>
<span class="cm"> * new channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wiphy_update_new_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">reg_beacon</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">band</span><span class="p">])</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">band</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">handle_reg_beacon</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg_beacon</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called upon reg changes or a new wiphy is added</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wiphy_update_beacon_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">reg_beacon</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">band</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">band</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">handle_reg_beacon</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg_beacon</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">reg_is_world_roaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">cfg80211_regdomain</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span> <span class="o">&amp;&amp;</span> <span class="n">is_world_regdom</span><span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span> <span class="o">&amp;&amp;</span>
	    <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_CUSTOM_REGULATORY</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reap the advantages of previously found beacons */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_beacons</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Means we are just firing up cfg80211, so no beacons would</span>
<span class="cm">	 * have been processed yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg_is_world_roaming</span><span class="p">(</span><span class="n">wiphy</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">wiphy_update_beacon_reg</span><span class="p">(</span><span class="n">wiphy</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_ht40_not_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_CHAN_DISABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/* This would happen when regulatory rules disallow HT40 completely */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IEEE80211_CHAN_NO_HT40</span> <span class="o">==</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE80211_CHAN_NO_HT40</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_ht_flags_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
					 <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel_before</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">channel_after</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chan_idx</span> <span class="o">&gt;=</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sband</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chan_idx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_ht40_not_allowed</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IEEE80211_CHAN_NO_HT40</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to ensure the extension channels exist to</span>
<span class="cm">	 * be able to use HT40- or HT40+, this finds them (or not)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sband</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">==</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">-</span> <span class="mi">20</span><span class="p">))</span>
			<span class="n">channel_before</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">==</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">center_freq</span> <span class="o">+</span> <span class="mi">20</span><span class="p">))</span>
			<span class="n">channel_after</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Please note that this assumes target bandwidth is 20 MHz,</span>
<span class="cm">	 * if that ever changes we also need to change the below logic</span>
<span class="cm">	 * to include that as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ht40_not_allowed</span><span class="p">(</span><span class="n">channel_before</span><span class="p">))</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IEEE80211_CHAN_NO_HT40MINUS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEEE80211_CHAN_NO_HT40MINUS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_ht40_not_allowed</span><span class="p">(</span><span class="n">channel_after</span><span class="p">))</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IEEE80211_CHAN_NO_HT40PLUS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">channel</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEEE80211_CHAN_NO_HT40PLUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_ht_flags_band</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">]);</span>
	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">reg_process_ht_flags_channel</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_ht_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_BANDS</span><span class="p">;</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">])</span>
			<span class="n">reg_process_ht_flags_band</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">band</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wiphy_update_regulatory</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>

	<span class="n">assert_reg_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_reg_update</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">initiator</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">last_request</span><span class="o">-&gt;</span><span class="n">dfs_region</span> <span class="o">=</span> <span class="n">cfg80211_regdomain</span><span class="o">-&gt;</span><span class="n">dfs_region</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_BANDS</span><span class="p">;</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">])</span>
			<span class="n">handle_band</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">initiator</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">reg_process_beacons</span><span class="p">(</span><span class="n">wiphy</span><span class="p">);</span>
	<span class="n">reg_process_ht_flags</span><span class="p">(</span><span class="n">wiphy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">reg_notifier</span><span class="p">)</span>
		<span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">reg_notifier</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">last_request</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">regulatory_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">setby</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
	<span class="n">wiphy_update_regulatory</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">setby</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_all_wiphy_regulatory</span><span class="p">(</span><span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_registered_device</span> <span class="o">*</span><span class="n">rdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg80211_rdev_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wiphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">;</span>
		<span class="n">wiphy_update_regulatory</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">initiator</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Regulatory updates set by CORE are ignored for custom</span>
<span class="cm">		 * regulatory cards. Let us notify the changes to the driver,</span>
<span class="cm">		 * as some drivers used this to restore its orig_* reg domain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_CUSTOM_REGULATORY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">reg_notifier</span><span class="p">)</span>
			<span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">reg_notifier</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">last_request</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_channel_custom</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan_idx</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">desired_bw_khz</span> <span class="o">=</span> <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">bw_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">reg_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_power_rule</span> <span class="o">*</span><span class="n">power_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>

	<span class="n">assert_reg_lock</span><span class="p">();</span>

	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chan_idx</span> <span class="o">&gt;=</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">);</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sband</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">chan_idx</span><span class="p">];</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">freq_reg_info_regd</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span>
			       <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">),</span>
			       <span class="n">desired_bw_khz</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">reg_rule</span><span class="p">,</span>
			       <span class="n">regd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Disabling freq %d MHz as custom &quot;</span>
			      <span class="s">&quot;regd has no rule that fits a %d MHz &quot;</span>
			      <span class="s">&quot;wide channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">,</span>
			      <span class="n">KHZ_TO_MHZ</span><span class="p">(</span><span class="n">desired_bw_khz</span><span class="p">));</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IEEE80211_CHAN_DISABLED</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chan_reg_rule_print_dbg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">desired_bw_khz</span><span class="p">,</span> <span class="n">reg_rule</span><span class="p">);</span>

	<span class="n">power_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>
	<span class="n">freq_range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span> <span class="o">&lt;</span> <span class="n">MHZ_TO_KHZ</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
		<span class="n">bw_flags</span> <span class="o">=</span> <span class="n">IEEE80211_CHAN_NO_HT40</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">map_regdom_flags</span><span class="p">(</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">|</span> <span class="n">bw_flags</span><span class="p">;</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">MBI_TO_DBI</span><span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_power</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">MBM_TO_DBM</span><span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_band_custom</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">]);</span>
	<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">handle_channel_custom</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">regd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used by drivers prior to wiphy registration */</span>
<span class="kt">void</span> <span class="nf">wiphy_apply_custom_regulatory</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bands_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_BANDS</span><span class="p">;</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">handle_band_custom</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">regd</span><span class="p">);</span>
		<span class="n">bands_set</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * no point in calling this if it won&#39;t have any effect</span>
<span class="cm">	 * on your device&#39;s supportd bands.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bands_set</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wiphy_apply_custom_regulatory</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return value which can be used by ignore_request() to indicate</span>
<span class="cm"> * it has been determined we should intersect two regulatory domains</span>
<span class="cm"> */</span>
<span class="cp">#define REG_INTERSECT	1</span>

<span class="cm">/* This has the logic which determines when a new request</span>
<span class="cm"> * should be ignored. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ignore_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">pending_request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">last_wiphy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="cm">/* All initial requests are respected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span>:

		<span class="n">last_wiphy</span> <span class="o">=</span> <span class="n">wiphy_idx_to_wiphy</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">is_an_alpha2</span><span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span>
		    <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_wiphy</span> <span class="o">!=</span> <span class="n">wiphy</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Two cards with two APs claiming different</span>
<span class="cm">				 * Country IE alpha2s. We could</span>
<span class="cm">				 * intersect them, but that seems unlikely</span>
<span class="cm">				 * to be correct. Reject second one for now.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Two consecutive Country IE hints on the same wiphy.</span>
<span class="cm">			 * This should be picked up early by the driver/stack</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This would happen if you unplug and plug your card</span>
<span class="cm">		 * back in or if you add a new device for which the previously</span>
<span class="cm">		 * loaded card also agrees on the regulatory domain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">REG_INTERSECT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">REG_INTERSECT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the user knows better the user should set the regdom</span>
<span class="cm">		 * to their country before the IE is picked up</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span> <span class="o">&amp;&amp;</span>
			  <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">intersect</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Process user requests only after previous user/driver/core</span>
<span class="cm">		 * requests have been processed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span> <span class="o">||</span>
		    <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span> <span class="o">||</span>
		    <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_set_request_processed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">need_more_processing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">last_request</span><span class="o">-&gt;</span><span class="n">processed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">))</span>
		<span class="n">need_more_processing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span><span class="p">)</span>
		<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_timeout</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_more_processing</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __regulatory_hint - hint to the wireless core a regulatory domain</span>
<span class="cm"> * @wiphy: if the hint comes from country information from an AP, this</span>
<span class="cm"> *	is required to be set to the wiphy that received the information</span>
<span class="cm"> * @pending_request: the regulatory request currently being processed</span>
<span class="cm"> *</span>
<span class="cm"> * The Wireless subsystem can use this function to hint to the wireless core</span>
<span class="cm"> * what it believes should be the current regulatory domain.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if all went fine, %-EALREADY if a regulatory domain had</span>
<span class="cm"> * already been set or other standard error codes.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold &amp;cfg80211_mutex and &amp;reg_mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__regulatory_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">pending_request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">intersect</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">ignore_request</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">pending_request</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">REG_INTERSECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span>
		    <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">reg_copy_regd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">,</span> <span class="n">cfg80211_regdomain</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">pending_request</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">intersect</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the regulatory domain being requested by the</span>
<span class="cm">		 * driver has already been set just copy it to the</span>
<span class="cm">		 * wiphy</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">EALREADY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pending_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span>
		    <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">reg_copy_regd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">,</span> <span class="n">cfg80211_regdomain</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">pending_request</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">new_request</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pending_request</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">new_request:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">core_request_world</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">last_request</span><span class="p">);</span>

	<span class="n">last_request</span> <span class="o">=</span> <span class="n">pending_request</span><span class="p">;</span>
	<span class="n">last_request</span><span class="o">-&gt;</span><span class="n">intersect</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">;</span>

	<span class="n">pending_request</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* When r == REG_INTERSECT we do need to call CRDA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since CRDA will not be called in this case as we already</span>
<span class="cm">		 * have applied the requested regulatory domain before we just</span>
<span class="cm">		 * inform userspace we have processed the request</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nl80211_send_reg_change_event</span><span class="p">(</span><span class="n">last_request</span><span class="p">);</span>
			<span class="n">reg_set_request_processed</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">call_crda</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This processes *all* regulatory hints */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">reg_request</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">nl80211_reg_initiator</span> <span class="n">reg_initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wiphy_idx_valid</span><span class="p">(</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">))</span>
		<span class="n">wiphy</span> <span class="o">=</span> <span class="n">wiphy_idx_to_wiphy</span><span class="p">(</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">wiphy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reg_request</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__regulatory_hint</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">reg_request</span><span class="p">);</span>
	<span class="cm">/* This is required so that the orig_* parameters are saved */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">EALREADY</span> <span class="o">&amp;&amp;</span> <span class="n">wiphy</span> <span class="o">&amp;&amp;</span>
	    <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_STRICT_REGULATORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wiphy_update_regulatory</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">reg_initiator</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only time out user hints, given that they should be the only</span>
<span class="cm">	 * source of bogus requests.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EALREADY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">reg_initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_timeout</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">3142</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Processes regulatory hints, this is all the NL80211_REGDOM_SET_BY_*</span>
<span class="cm"> * Regulatory hints come on a first come first serve basis and we</span>
<span class="cm"> * must process each one atomically.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_pending_hints</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">reg_request</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="cm">/* When last_request-&gt;processed becomes true this will be rescheduled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">processed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Pending regulatory request, waiting &quot;</span>
			      <span class="s">&quot;for it to be processed...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reg_request</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">regulatory_request</span><span class="p">,</span>
				       <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="n">reg_process_hint</span><span class="p">(</span><span class="n">reg_request</span><span class="p">,</span> <span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Processes beacon hints -- this has nothing to do with country IEs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_process_pending_beacon_hints</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_registered_device</span> <span class="o">*</span><span class="n">rdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">pending_beacon</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to hold the reg_mutex here as we just touch wiphys</span>
<span class="cm">	 * and do not read or access regulatory variables.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>

	<span class="cm">/* This goes through the _pending_ beacon list */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">pending_beacon</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="cm">/* Applies the beacon hint to current wiphys */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg80211_rdev_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">wiphy_update_new_beacon</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">pending_beacon</span><span class="p">);</span>

		<span class="cm">/* Remembers the beacon hint for new wiphys or reg changes */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_todo</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg_process_pending_hints</span><span class="p">();</span>
	<span class="n">reg_process_pending_beacon_hints</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_regulatory_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Core regulatory hint -- happens during cfg80211_init()</span>
<span class="cm"> * and when we restore regulatory settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">regulatory_hint_core</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>

	<span class="n">request</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulatory_request</span><span class="p">),</span>
			  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">NL80211_REGDOM_SET_BY_CORE</span><span class="p">;</span>

	<span class="n">queue_regulatory_request</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* User hints */</span>
<span class="kt">int</span> <span class="nf">regulatory_hint_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">);</span>

	<span class="n">request</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulatory_request</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span> <span class="o">=</span> <span class="n">WIPHY_IDX_STALE</span><span class="p">;</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">NL80211_REGDOM_SET_BY_USER</span><span class="p">;</span>

	<span class="n">queue_regulatory_request</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Driver hints */</span>
<span class="kt">int</span> <span class="nf">regulatory_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">alpha2</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="p">);</span>

	<span class="n">request</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulatory_request</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span> <span class="o">=</span> <span class="n">get_wiphy_idx</span><span class="p">(</span><span class="n">wiphy</span><span class="p">);</span>

	<span class="cm">/* Must have registered wiphy first */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wiphy_idx_valid</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">));</span>

	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span><span class="p">;</span>

	<span class="n">queue_regulatory_request</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">regulatory_hint</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We hold wdev_lock() here so we cannot hold cfg80211_mutex() and</span>
<span class="cm"> * therefore cannot iterate over the rdev list here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">regulatory_hint_11d</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="o">*</span><span class="n">country_ie</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">country_ie_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">environment_cap</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ENVIRON_ANY</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* IE len must be evenly divisible by 2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">country_ie_len</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">country_ie_len</span> <span class="o">&lt;</span> <span class="n">IEEE80211_COUNTRY_IE_MIN_LEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">country_ie</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">country_ie</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">country_ie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;I&#39;</span><span class="p">)</span>
		<span class="n">env</span> <span class="o">=</span> <span class="n">ENVIRON_INDOOR</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">country_ie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;O&#39;</span><span class="p">)</span>
		<span class="n">env</span> <span class="o">=</span> <span class="n">ENVIRON_OUTDOOR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will run this only upon a successful connection on cfg80211.</span>
<span class="cm">	 * We leave conflict resolution to the workqueue, where can hold</span>
<span class="cm">	 * cfg80211_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span>
	    <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">wiphy_idx_valid</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">request</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulatory_request</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span> <span class="o">=</span> <span class="n">get_wiphy_idx</span><span class="p">(</span><span class="n">wiphy</span><span class="p">);</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">;</span>
	<span class="n">request</span><span class="o">-&gt;</span><span class="n">country_ie_env</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="n">queue_regulatory_request</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_alpha2</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reset_user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* indicates there is no alpha2 to consider for restoration */</span>
	<span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span>
	<span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;7&#39;</span><span class="p">;</span>

	<span class="cm">/* The user setting has precedence over the module parameter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_user_regdom_saved</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* Unless we&#39;re asked to ignore it and reset it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_user</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Restoring regulatory settings &quot;</span>
			       <span class="s">&quot;including user preference</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span>
			<span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;7&#39;</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;re ignoring user settings, we still need to</span>
<span class="cm">			 * check the module parameter to ensure we put things</span>
<span class="cm">			 * back as they were for a full restore.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">ieee80211_regdom</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Keeping preference on &quot;</span>
				       <span class="s">&quot;module parameter ieee80211_regdom: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				       <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Restoring regulatory settings &quot;</span>
			       <span class="s">&quot;while preserving user preference for: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">ieee80211_regdom</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Keeping preference on &quot;</span>
		       <span class="s">&quot;module parameter ieee80211_regdom: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ieee80211_regdom</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Restoring regulatory settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_custom_reg_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_BANDS</span><span class="p">;</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sband</span> <span class="o">=</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">band</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sband</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sband</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_flags</span><span class="p">;</span>
			<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_mag</span><span class="p">;</span>
			<span class="n">chan</span><span class="o">-&gt;</span><span class="n">max_power</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">orig_mpwr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restoring regulatory settings involves ingoring any</span>
<span class="cm"> * possibly stale country IE information and user regulatory</span>
<span class="cm"> * settings if so desired, this includes any beacon hints</span>
<span class="cm"> * learned as we could have traveled outside to another country</span>
<span class="cm"> * after disconnection. To restore regulatory settings we do</span>
<span class="cm"> * exactly what we did at bootup:</span>
<span class="cm"> *</span>
<span class="cm"> *   - send a core regulatory hint</span>
<span class="cm"> *   - send a user regulatory hint if applicable</span>
<span class="cm"> *</span>
<span class="cm"> * Device drivers that send a regulatory hint for a specific country</span>
<span class="cm"> * keep their own regulatory domain on wiphy-&gt;regd so that does does</span>
<span class="cm"> * not need to be remembered.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_regulatory_settings</span><span class="p">(</span><span class="n">bool</span> <span class="n">reset_user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">world_alpha2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="o">*</span><span class="n">btmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">reg_request</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_reg_req_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfg80211_registered_device</span> <span class="o">*</span><span class="n">rdev</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
	<span class="n">restore_alpha2</span><span class="p">(</span><span class="n">alpha2</span><span class="p">,</span> <span class="n">reset_user</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there&#39;s any pending requests we simply</span>
<span class="cm">	 * stash them to a temporary pending queue and</span>
<span class="cm">	 * add then after we&#39;ve restored regulatory</span>
<span class="cm">	 * settings.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_request</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span>
			    <span class="n">NL80211_REGDOM_SET_BY_USER</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_reg_req_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="cm">/* Clear beacon hints */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="n">btmp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="n">btmp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* First restore to the basic regulatory settings */</span>
	<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">cfg80211_world_regdom</span><span class="p">;</span>
	<span class="n">world_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfg80211_regdomain</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">world_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfg80211_regdomain</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg80211_rdev_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WIPHY_FLAG_CUSTOM_REGULATORY</span><span class="p">)</span>
			<span class="n">restore_custom_reg_settings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>

	<span class="n">regulatory_hint_core</span><span class="p">(</span><span class="n">world_alpha2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This restores the ieee80211_regdom module parameter</span>
<span class="cm">	 * preference or the last user requested regulatory</span>
<span class="cm">	 * settings, user regulatory settings takes precedence.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_an_alpha2</span><span class="p">(</span><span class="n">alpha2</span><span class="p">))</span>
		<span class="n">regulatory_hint_user</span><span class="p">(</span><span class="n">user_alpha2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_reg_req_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_request</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_reg_req_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Adding request for country %c%c back &quot;</span>
			      <span class="s">&quot;into the queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			      <span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>

	<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Kicking the queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">regulatory_hint_disconnect</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;All devices are disconnected, going to &quot;</span>
		      <span class="s">&quot;restore regulatory settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">restore_regulatory_settings</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">freq_is_chan_12_13_14</span><span class="p">(</span><span class="n">u16</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">==</span> <span class="n">ieee80211_channel_to_frequency</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">freq</span> <span class="o">==</span> <span class="n">ieee80211_channel_to_frequency</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">freq</span> <span class="o">==</span> <span class="n">ieee80211_channel_to_frequency</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="n">IEEE80211_BAND_2GHZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">regulatory_hint_found_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">beacon_chan</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">reg_beacon</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">beacon_chan</span><span class="o">-&gt;</span><span class="n">beacon_found</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">beacon_chan</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_CHAN_RADAR</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">beacon_chan</span><span class="o">-&gt;</span><span class="n">band</span> <span class="o">==</span> <span class="n">IEEE80211_BAND_2GHZ</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">freq_is_chan_12_13_14</span><span class="p">(</span><span class="n">beacon_chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">)))))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reg_beacon</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reg_beacon</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg_beacon</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Found new beacon on &quot;</span>
		      <span class="s">&quot;frequency: %d MHz (Ch %d) on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">beacon_chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">,</span>
		      <span class="n">ieee80211_frequency_to_channel</span><span class="p">(</span><span class="n">beacon_chan</span><span class="o">-&gt;</span><span class="n">center_freq</span><span class="p">),</span>
		      <span class="n">wiphy_name</span><span class="p">(</span><span class="n">wiphy</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="n">beacon_chan</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_channel</span><span class="p">));</span>


	<span class="cm">/*</span>
<span class="cm">	 * Since we can be called from BH or and non-BH context</span>
<span class="cm">	 * we must use spin_lock_bh()</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_rd_rules</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">*</span><span class="n">reg_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_freq_range</span> <span class="o">*</span><span class="n">freq_range</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_power_rule</span> <span class="o">*</span><span class="n">power_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">n_reg_rules</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">reg_rules</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">freq_range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">freq_range</span><span class="p">;</span>
		<span class="n">power_rule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_rule</span><span class="o">-&gt;</span><span class="n">power_rule</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * There may not be documentation for max antenna gain</span>
<span class="cm">		 * in certain regions</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  (%d KHz - %d KHz @ %d KHz), (%d mBi, %d mBm)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">,</span>
				<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">,</span>
				<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span><span class="p">,</span>
				<span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_antenna_gain</span><span class="p">,</span>
				<span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  (%d KHz - %d KHz @ %d KHz), (N/A, %d mBm)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">start_freq_khz</span><span class="p">,</span>
				<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">end_freq_khz</span><span class="p">,</span>
				<span class="n">freq_range</span><span class="o">-&gt;</span><span class="n">max_bandwidth_khz</span><span class="p">,</span>
				<span class="n">power_rule</span><span class="o">-&gt;</span><span class="n">max_eirp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">reg_supported_dfs_region</span><span class="p">(</span><span class="n">u8</span> <span class="n">dfs_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dfs_region</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NL80211_DFS_UNSET</span>:
	<span class="k">case</span> <span class="n">NL80211_DFS_FCC</span>:
	<span class="k">case</span> <span class="n">NL80211_DFS_ETSI</span>:
	<span class="k">case</span> <span class="n">NL80211_DFS_JP</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Ignoring uknown DFS master region: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">dfs_region</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_dfs_region</span><span class="p">(</span><span class="n">u8</span> <span class="n">dfs_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dfs_region</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dfs_region</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NL80211_DFS_FCC</span>:
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; DFS Master region FCC&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_DFS_ETSI</span>:
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; DFS Master region ETSI&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NL80211_DFS_JP</span>:
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; DFS Master region JP&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; DFS Master region Uknown&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_regdomain</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_intersected_alpha2</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span>
		    <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cfg80211_registered_device</span> <span class="o">*</span><span class="n">rdev</span><span class="p">;</span>
			<span class="n">rdev</span> <span class="o">=</span> <span class="n">cfg80211_rdev_by_wiphy_idx</span><span class="p">(</span>
				<span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Current regulatory domain updated by AP to: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">country_ie_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">country_ie_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Current regulatory domain intersected:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Current regulatory domain intersected:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;World regulatory domain updated:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_unknown_alpha2</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Regulatory domain changed to driver built-in settings (unknown country)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Regulatory domain changed to country: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">print_dfs_region</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dfs_region</span><span class="p">);</span>
	<span class="n">print_rd_rules</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_regdomain_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Regulatory domain: %c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">print_rd_rules</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Takes ownership of rd only if it doesn&#39;t fail */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__set_regdom</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">intersected_rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_registered_device</span> <span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">request_wiphy</span><span class="p">;</span>
	<span class="cm">/* Some basic sanity checks first */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">reg_is_valid_request</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">update_world_regdomain</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_alpha2_set</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_an_alpha2</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">is_unknown_alpha2</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lets only bother proceeding on the same alpha2 if the current</span>
<span class="cm">	 * rd is non static (it means CRDA was present and was used last)</span>
<span class="cm">	 * and the pending request came in from a country IE</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If someone else asked us to change the rd lets only bother</span>
<span class="cm">		 * checking if the alpha2 changes if CRDA was already called</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regdom_changes</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now lets set the regulatory domain, update all driver channels</span>
<span class="cm">	 * and finally inform them of what we have done, in case they want</span>
<span class="cm">	 * to review or adjust their own settings based on their own</span>
<span class="cm">	 * internal EEPROM data</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">reg_is_valid_request</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_rd</span><span class="p">(</span><span class="n">rd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Invalid regulatory domain detected:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_regdomain_info</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">request_wiphy</span> <span class="o">=</span> <span class="n">wiphy_idx_to_wiphy</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_wiphy</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span> <span class="o">||</span>
	     <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">intersect</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
			<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * For a driver hint, lets copy the regulatory domain the</span>
<span class="cm">		 * driver wanted to the wiphy to deal with conflicts</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Userspace could have sent two replies with only</span>
<span class="cm">		 * one kernel request.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">reg_copy_regd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request_wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
		<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Intersection requires a bit more work */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">NL80211_REGDOM_SET_BY_COUNTRY_IE</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">intersected_rd</span> <span class="o">=</span> <span class="n">regdom_intersect</span><span class="p">(</span><span class="n">rd</span><span class="p">,</span> <span class="n">cfg80211_regdomain</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intersected_rd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can trash what CRDA provided now.</span>
<span class="cm">		 * However if a driver requested this specific regulatory</span>
<span class="cm">		 * domain we keep it for its private use</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">==</span> <span class="n">NL80211_REGDOM_SET_BY_DRIVER</span><span class="p">)</span>
			<span class="n">request_wiphy</span><span class="o">-&gt;</span><span class="n">regd</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>

		<span class="n">rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
		<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">intersected_rd</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intersected_rd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rdev</span> <span class="o">=</span> <span class="n">wiphy_to_dev</span><span class="p">(</span><span class="n">request_wiphy</span><span class="p">);</span>

	<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">country_ie_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">country_ie_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">env</span> <span class="o">=</span> <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">country_ie_env</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">intersected_rd</span> <span class="o">==</span> <span class="n">rd</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
	<span class="n">rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">intersected_rd</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Use this call to set the current regulatory domain. Conflicts with</span>
<span class="cm"> * multiple drivers can be ironed out later. Caller must&#39;ve already</span>
<span class="cm"> * kmalloc&#39;d the rd structure. Caller must hold cfg80211_mutex</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">set_regdom</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">rd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="cm">/* Note that this doesn&#39;t update the wiphys, this is done below */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__set_regdom</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This would make this whole thing pointless */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">intersect</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rd</span> <span class="o">!=</span> <span class="n">cfg80211_regdomain</span><span class="p">);</span>

	<span class="cm">/* update all wiphys now with the new established regulatory domain */</span>
	<span class="n">update_all_wiphy_regulatory</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">);</span>

	<span class="n">print_regdomain</span><span class="p">(</span><span class="n">cfg80211_regdomain</span><span class="p">);</span>

	<span class="n">nl80211_send_reg_change_event</span><span class="p">(</span><span class="n">last_request</span><span class="p">);</span>

	<span class="n">reg_set_request_processed</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="kt">int</span> <span class="nf">reg_device_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">processed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;COUNTRY=%c%c&quot;</span><span class="p">,</span>
				   <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				   <span class="n">last_request</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">reg_device_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG */</span><span class="cp"></span>

<span class="cm">/* Caller must hold cfg80211_mutex */</span>
<span class="kt">void</span> <span class="nf">reg_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">request_wiphy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">assert_cfg80211_lock</span><span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">regd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_request</span><span class="p">)</span>
		<span class="n">request_wiphy</span> <span class="o">=</span> <span class="n">wiphy_idx_to_wiphy</span><span class="p">(</span><span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_wiphy</span> <span class="o">||</span> <span class="n">request_wiphy</span> <span class="o">!=</span> <span class="n">wiphy</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">last_request</span><span class="o">-&gt;</span><span class="n">wiphy_idx</span> <span class="o">=</span> <span class="n">WIPHY_IDX_STALE</span><span class="p">;</span>
	<span class="n">last_request</span><span class="o">-&gt;</span><span class="n">country_ie_env</span> <span class="o">=</span> <span class="n">ENVIRON_ANY</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reg_timeout_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">REG_DBG_PRINT</span><span class="p">(</span><span class="s">&quot;Timeout while waiting for CRDA to reply, &quot;</span>
		      <span class="s">&quot;restoring regulatory settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">restore_regulatory_settings</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">regulatory_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reg_pdev</span> <span class="o">=</span> <span class="n">platform_device_register_simple</span><span class="p">(</span><span class="s">&quot;regulatory&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">reg_pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">reg_pdev</span><span class="p">);</span>

	<span class="n">reg_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_device_type</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>

	<span class="n">reg_regdb_size_check</span><span class="p">();</span>

	<span class="n">cfg80211_regdomain</span> <span class="o">=</span> <span class="n">cfg80211_world_regdom</span><span class="p">;</span>

	<span class="n">user_alpha2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span>
	<span class="n">user_alpha2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;7&#39;</span><span class="p">;</span>

	<span class="cm">/* We always try to get an update for the static regdomain */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">regulatory_hint_core</span><span class="p">(</span><span class="n">cfg80211_regdomain</span><span class="o">-&gt;</span><span class="n">alpha2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * N.B. kobject_uevent_env() can fail mainly for when we&#39;re out</span>
<span class="cm">		 * memory which is handled and propagated appropriately above</span>
<span class="cm">		 * but it can also fail during a netlink_broadcast() or during</span>
<span class="cm">		 * early boot for call_usermodehelper(). For now treat these</span>
<span class="cm">		 * errors as non-fatal.</span>
<span class="cm">		 */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kobject_uevent_env() was unable to call CRDA during init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CFG80211_REG_DEBUG</span>
		<span class="cm">/* We want to find out exactly why when debugging */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, if the user set the module parameter treat it</span>
<span class="cm">	 * as a user hint.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_world_regdom</span><span class="p">(</span><span class="n">ieee80211_regdom</span><span class="p">))</span>
		<span class="n">regulatory_hint_user</span><span class="p">(</span><span class="n">ieee80211_regdom</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="cm">/* __init_or_exit */</span> <span class="n">regulatory_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">reg_request</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reg_beacon</span> <span class="o">*</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="o">*</span><span class="n">btmp</span><span class="p">;</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_work</span><span class="p">);</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_timeout</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>

	<span class="n">reset_regdomains</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">dev_set_uevent_suppress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">reg_pdev</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="n">btmp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">reg_pending_beacons</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_pending_beacons_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">,</span> <span class="n">btmp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">reg_beacon_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_beacon</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">reg_beacon</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg_request</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">reg_requests_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_request</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">reg_request</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_requests_lock</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg80211_mutex</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
