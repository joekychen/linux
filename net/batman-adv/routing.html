<!DOCTYPE html>
<html><head><title>joekychen/linux » net › batman-adv › routing.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>routing.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007-2012 B.A.T.M.A.N. contributors:</span>
<span class="cm"> *</span>
<span class="cm"> * Marek Lindner, Simon Wunderlich</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;main.h&quot;</span>
<span class="cp">#include &quot;routing.h&quot;</span>
<span class="cp">#include &quot;send.h&quot;</span>
<span class="cp">#include &quot;soft-interface.h&quot;</span>
<span class="cp">#include &quot;hard-interface.h&quot;</span>
<span class="cp">#include &quot;icmp_socket.h&quot;</span>
<span class="cp">#include &quot;translation-table.h&quot;</span>
<span class="cp">#include &quot;originator.h&quot;</span>
<span class="cp">#include &quot;vis.h&quot;</span>
<span class="cp">#include &quot;unicast.h&quot;</span>
<span class="cp">#include &quot;bridge_loop_avoidance.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">route_unicast_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">slide_own_bcast_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hashtable_t</span> <span class="o">*</span><span class="n">hash</span> <span class="o">=</span> <span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">orig_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">word</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">word_index</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hash</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
			<span class="n">word_index</span> <span class="o">=</span> <span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">if_num</span> <span class="o">*</span> <span class="n">NUM_WORDS</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_own</span><span class="p">[</span><span class="n">word_index</span><span class="p">]);</span>

			<span class="n">bit_get_packet</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_own_sum</span><span class="p">[</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">if_num</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">bitmap_weight</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">TQ_LOCAL_WINDOW_SIZE</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_update_route</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">curr_router</span><span class="p">;</span>

	<span class="n">curr_router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>

	<span class="cm">/* route deleted */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">curr_router</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_ROUTES</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span> <span class="s">&quot;Deleting route towards: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">);</span>
		<span class="n">tt_global_del_orig</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span>
				   <span class="s">&quot;Deleted route towards originator&quot;</span><span class="p">);</span>

	<span class="cm">/* route added */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">curr_router</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">neigh_node</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_ROUTES</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Adding route towards: %pM (via %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* route changed */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span> <span class="o">&amp;&amp;</span> <span class="n">curr_router</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_ROUTES</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Changing route towards: %pM (now via %pM - was via %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			<span class="n">curr_router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr_router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">curr_router</span><span class="p">);</span>

	<span class="cm">/* increase refcount of new best neighbor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="n">neigh_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">router</span><span class="p">,</span> <span class="n">neigh_node</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>

	<span class="cm">/* decrease refcount of previous best neighbor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr_router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">curr_router</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update_route</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">router</span> <span class="o">!=</span> <span class="n">neigh_node</span><span class="p">)</span>
		<span class="n">_update_route</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">neigh_node</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* caller must hold the neigh_list_lock */</span>
<span class="kt">void</span> <span class="nf">bonding_candidate_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* this neighbor is not part of our candidate list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">);</span>
	<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bond_candidates</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bonding_candidate_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">interference_candidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>

	<span class="cm">/* only consider if it has the same primary address ...  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
			 <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">primary_addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">candidate_del</span><span class="p">;</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">candidate_del</span><span class="p">;</span>

	<span class="cm">/* ... and is good enough to be considered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">&lt;</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">-</span> <span class="n">BONDING_TQ_THRESHOLD</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">candidate_del</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * check if we have another candidate with the same mac address or</span>
<span class="cm">	 * interface. If we do, we won&#39;t select this candidate because of</span>
<span class="cm">	 * possible interference.</span>
<span class="cm">	 */</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_neigh_node</span> <span class="o">==</span> <span class="n">neigh_node</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* we only care if the other candidate is even</span>
<span class="cm">		* considered as candidate. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">interference_candidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* don&#39;t care further if it is an interference candidate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interference_candidate</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">candidate_del</span><span class="p">;</span>

	<span class="cm">/* this neighbor already is part of our candidate list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bond_candidates</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">candidate_del:</span>
	<span class="n">bonding_candidate_del</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">neigh_node</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* copy primary address for bonding */</span>
<span class="kt">void</span> <span class="nf">bonding_save_primary</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_neigh_node</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PRIMARIES_FIRST_HOP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">primary_addr</span><span class="p">,</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* checks whether the host restarted and is in the protection time.</span>
<span class="cm"> * returns:</span>
<span class="cm"> *  0 if the packet is to be accepted</span>
<span class="cm"> *  1 if the packet is to be ignored.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">window_protected</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">seq_num_diff</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">last_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">seq_num_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">TQ_LOCAL_WINDOW_SIZE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">seq_num_diff</span> <span class="o">&gt;=</span> <span class="n">EXPECTED_SEQNO_RANGE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_timed_out</span><span class="p">(</span><span class="o">*</span><span class="n">last_reset</span><span class="p">,</span> <span class="n">RESET_PROTECTION_MS</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="o">*</span><span class="n">last_reset</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;old packet received, start protection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">check_management_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">header_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>

	<span class="cm">/* drop packet if it has not necessary minimum size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">header_len</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* packet with broadcast indication but unicast recipient */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* packet with broadcast sender address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* create a copy of the skb, if needed, to modify it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* keep skb linear */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">recv_my_icmp_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">icmp_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">primary_if</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmp_packet_rr</span> <span class="o">*</span><span class="n">icmp_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">icmp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* add data to device queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">!=</span> <span class="n">ECHO_REQUEST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_socket_receive_packet</span><span class="p">(</span><span class="n">icmp_packet</span><span class="p">,</span> <span class="n">icmp_len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">primary_if</span> <span class="o">=</span> <span class="n">primary_if_get_selected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* answer echo request (ping) */</span>
	<span class="cm">/* get routing information */</span>
	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* create a copy of the skb, if needed, to modify it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">icmp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">primary_if</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">ECHO_REPLY</span><span class="p">;</span>
	<span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="n">TTL</span><span class="p">;</span>

	<span class="n">send_skb_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">,</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">primary_if</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">recv_icmp_ttl_exceeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">primary_if</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmp_packet</span> <span class="o">*</span><span class="n">icmp_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">icmp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* send TTL exceeded if packet is an echo request (traceroute) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">!=</span> <span class="n">ECHO_REQUEST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Warning - can&#39;t forward icmp packet from %pM to %pM: ttl exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">primary_if</span> <span class="o">=</span> <span class="n">primary_if_get_selected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* get routing information */</span>
	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* create a copy of the skb, if needed, to modify it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">icmp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">primary_if</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">TTL_EXCEEDED</span><span class="p">;</span>
	<span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="n">TTL</span><span class="p">;</span>

	<span class="n">send_skb_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">,</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">primary_if</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">recv_icmp_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">icmp_packet_rr</span> <span class="o">*</span><span class="n">icmp_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * we truncate all incoming icmp packets if they don&#39;t match our size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span><span class="p">))</span>
		<span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span><span class="p">);</span>

	<span class="cm">/* drop packet if it has not necessary minimum size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* packet with unicast indication but broadcast recipient */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* packet with broadcast sender address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* not for me */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">icmp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* add record route information if not full */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hdr_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">rr_cur</span> <span class="o">&lt;</span> <span class="n">BAT_RR_LEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">rr_cur</span><span class="p">]),</span>
		       <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">rr_cur</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* packet for me */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">recv_my_icmp_packet</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">);</span>

	<span class="cm">/* TTL exceeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">recv_icmp_ttl_exceeded</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* get routing information */</span>
	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* create a copy of the skb, if needed, to modify it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">icmp_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp_packet_rr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* decrement ttl */</span>
	<span class="n">icmp_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* route it */</span>
	<span class="n">send_skb_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">,</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* In the bonding case, send the packets in a round</span>
<span class="cm"> * robin fashion over the remaining interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * This method rotates the bonding list and increases the</span>
<span class="cm"> * returned router&#39;s refcount. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="nf">find_bond_router</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">primary_orig</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">tmp_neigh_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">first_candidate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primary_orig</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">,</span>
				<span class="n">bonding_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_candidate</span><span class="p">)</span>
			<span class="n">first_candidate</span> <span class="o">=</span> <span class="n">tmp_neigh_node</span><span class="p">;</span>

		<span class="cm">/* recv_if == NULL on the first node. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">recv_if</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">router</span> <span class="o">=</span> <span class="n">tmp_neigh_node</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* use the first candidate if nothing was found. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="n">first_candidate</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_candidate</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="n">router</span> <span class="o">=</span> <span class="n">first_candidate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* selected should point to the next element</span>
<span class="cm">	 * after the current router */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_orig</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>
	<span class="cm">/* this is a list_move(), which unfortunately</span>
<span class="cm">	 * does not exist as rcu version */</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_orig</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_orig</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_orig</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">router</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Interface Alternating: Use the best of the</span>
<span class="cm"> * remaining candidates which are not using</span>
<span class="cm"> * this interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Increases the returned router&#39;s refcount */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="nf">find_ifalter_router</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">primary_orig</span><span class="p">,</span>
					      <span class="k">const</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">tmp_neigh_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">first_candidate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primary_orig</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">,</span>
				<span class="n">bonding_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_candidate</span><span class="p">)</span>
			<span class="n">first_candidate</span> <span class="o">=</span> <span class="n">tmp_neigh_node</span><span class="p">;</span>

		<span class="cm">/* recv_if == NULL on the first node. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">recv_if</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* if we don&#39;t have a router yet</span>
<span class="cm">		 * or this one is better, choose it. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">router</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">&gt;</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">tq_avg</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* decrement refcount of</span>
<span class="cm">			 * previously selected router */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
				<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>

			<span class="n">router</span> <span class="o">=</span> <span class="n">tmp_neigh_node</span><span class="p">;</span>
			<span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* use the first candidate if nothing was found. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="n">first_candidate</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_candidate</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="n">router</span> <span class="o">=</span> <span class="n">first_candidate</span><span class="p">;</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">router</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recv_tt_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tt_query_packet</span> <span class="o">*</span><span class="n">tt_query</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">tt_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>

	<span class="cm">/* drop packet if it has not necessary minimum size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tt_query_packet</span><span class="p">))))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* I could need to modify it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tt_query_packet</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* packet with unicast indication but broadcast recipient */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* packet with broadcast sender address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">tt_query</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tt_query_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TT_QUERY_TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TT_REQUEST</span>:
		<span class="cm">/* If we cannot provide an answer the tt_request is</span>
<span class="cm">		 * forwarded */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">send_tt_response</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">tt_query</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_TT</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
				<span class="s">&quot;Routing TT_REQUEST to %pM [%c]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span>
				<span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TT_FULL_TABLE</span> <span class="o">?</span> <span class="sc">&#39;F&#39;</span> <span class="o">:</span> <span class="sc">&#39;.&#39;</span><span class="p">));</span>
			<span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">route_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TT_RESPONSE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* packet needs to be linearized to access the TT</span>
<span class="cm">			 * changes */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="cm">/* skb_linearize() possibly changed skb-&gt;data */</span>
			<span class="n">tt_query</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tt_query_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

			<span class="n">tt_len</span> <span class="o">=</span> <span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tt_change</span><span class="p">);</span>

			<span class="cm">/* Ensure we have all the claimed data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tt_query_packet</span><span class="p">)</span> <span class="o">+</span> <span class="n">tt_len</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">handle_tt_response</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">tt_query</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_TT</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
				<span class="s">&quot;Routing TT_RESPONSE to %pM [%c]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span>
				<span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TT_FULL_TABLE</span> <span class="o">?</span> <span class="sc">&#39;F&#39;</span> <span class="o">:</span> <span class="sc">&#39;.&#39;</span><span class="p">));</span>
			<span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tt_query</span><span class="o">-&gt;</span><span class="n">tt_data</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">route_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* returning NET_RX_DROP will make the caller function kfree the skb */</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recv_roam_adv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">roam_adv_packet</span> <span class="o">*</span><span class="n">roam_adv_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>

	<span class="cm">/* drop packet if it has not necessary minimum size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">roam_adv_packet</span><span class="p">))))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* packet with unicast indication but broadcast recipient */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* packet with broadcast sender address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">roam_adv_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">roam_adv_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">roam_adv_packet</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">route_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>

	<span class="cm">/* check if it is a backbone gateway. we don&#39;t accept</span>
<span class="cm">	 * roaming advertisement from it, as it has the same</span>
<span class="cm">	 * entries as we have.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bla_is_backbone_gw_orig</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">roam_adv_packet</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">roam_adv_packet</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_TT</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
		<span class="s">&quot;Received ROAMING_ADV from %pM (client %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">roam_adv_packet</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">roam_adv_packet</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">);</span>

	<span class="n">tt_global_add</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">roam_adv_packet</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span>
		      <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_ttvn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* Roaming phase starts: I have new information but the ttvn has not</span>
<span class="cm">	 * been incremented yet. This flag will make me check all the incoming</span>
<span class="cm">	 * packets for the correct destination. */</span>
	<span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">tt_poss_change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="cm">/* returning NET_RX_DROP will make the caller function kfree the skb */</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* find a suitable router for this originator, and use</span>
<span class="cm"> * bonding if possible. increases the found neighbors</span>
<span class="cm"> * refcount.*/</span>
<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="nf">find_router</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">primary_orig_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">router_orig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">zero_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">bonding_enabled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* without bonding, the first node should</span>
<span class="cm">	 * always choose the default router. */</span>
	<span class="n">bonding_enabled</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">bonding</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/* select default router to output */</span>
	<span class="n">router_orig</span> <span class="o">=</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">orig_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">router_orig</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">recv_if</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">bonding_enabled</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">return_router</span><span class="p">;</span>

	<span class="cm">/* if we have something in the primary_addr, we can search</span>
<span class="cm">	 * for a potential bonding candidate. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">router_orig</span><span class="o">-&gt;</span><span class="n">primary_addr</span><span class="p">,</span> <span class="n">zero_mac</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">return_router</span><span class="p">;</span>

	<span class="cm">/* find the orig_node which has the primary interface. might</span>
<span class="cm">	 * even be the same as our router_orig in many cases */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">router_orig</span><span class="o">-&gt;</span><span class="n">primary_addr</span><span class="p">,</span> <span class="n">router_orig</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">primary_orig_node</span> <span class="o">=</span> <span class="n">router_orig</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">primary_orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span>
						   <span class="n">router_orig</span><span class="o">-&gt;</span><span class="n">primary_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary_orig_node</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">return_router</span><span class="p">;</span>

		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">primary_orig_node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* with less than 2 candidates, we can&#39;t do any</span>
<span class="cm">	 * bonding and prefer the original router. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_orig_node</span><span class="o">-&gt;</span><span class="n">bond_candidates</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">return_router</span><span class="p">;</span>

	<span class="cm">/* all nodes between should choose a candidate which</span>
<span class="cm">	 * is is not on the interface where the packet came</span>
<span class="cm">	 * in. */</span>

	<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bonding_enabled</span><span class="p">)</span>
		<span class="n">router</span> <span class="o">=</span> <span class="n">find_bond_router</span><span class="p">(</span><span class="n">primary_orig_node</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">router</span> <span class="o">=</span> <span class="n">find_ifalter_router</span><span class="p">(</span><span class="n">primary_orig_node</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>

<span class="nl">return_router:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">!=</span> <span class="n">IF_ACTIVE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">router</span><span class="p">;</span>
<span class="nl">err_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_unicast_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdr_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>

	<span class="cm">/* drop packet if it has not necessary minimum size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* packet with unicast indication but broadcast recipient */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* packet with broadcast sender address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* not for me */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">route_unicast_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="n">unicast_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new_skb</span><span class="p">;</span>

	<span class="n">unicast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* TTL exceeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Warning - can&#39;t forward unicast packet from %pM to %pM: ttl exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get routing information */</span>
	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* find_router() increases neigh_nodes refcount if found. */</span>
	<span class="n">neigh_node</span> <span class="o">=</span> <span class="n">find_router</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* create a copy of the skb, if needed, to modify it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">unicast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">packet_type</span> <span class="o">==</span> <span class="n">BAT_UNICAST</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">fragmentation</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">frag_send_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
				    <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">,</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">packet_type</span> <span class="o">==</span> <span class="n">BAT_UNICAST_FRAG</span> <span class="o">&amp;&amp;</span>
	    <span class="n">frag_can_reassemble</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">frag_reassemble_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NET_RX_DROP</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* packet was buffered for late merge */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">new_skb</span><span class="p">;</span>
		<span class="n">unicast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* decrement ttl */</span>
	<span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* route it */</span>
	<span class="n">send_skb_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">,</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_unicast_ttvn</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">curr_ttvn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">primary_if</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="n">unicast_packet</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tt_poss_change</span><span class="p">;</span>

	<span class="cm">/* I could need to modify it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">unicast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tt_poss_change</span> <span class="o">=</span> <span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">tt_poss_change</span><span class="p">;</span>
		<span class="n">curr_ttvn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">curr_ttvn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_ttvn</span><span class="p">);</span>
		<span class="n">tt_poss_change</span> <span class="o">=</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">tt_poss_change</span><span class="p">;</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check whether I have to reroute the packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq_before</span><span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">,</span> <span class="n">curr_ttvn</span><span class="p">)</span> <span class="o">||</span> <span class="n">tt_poss_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check if there is enough data before accessing it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span><span class="p">)</span> <span class="o">+</span>
				  <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span><span class="p">));</span>

		<span class="cm">/* we don&#39;t have an updated route for this client, so we should</span>
<span class="cm">		 * not try to reroute the packet!!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tt_global_client_is_roaming</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">orig_node</span> <span class="o">=</span> <span class="n">transtable_search</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_my_client</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">primary_if</span> <span class="o">=</span> <span class="n">primary_if_get_selected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary_if</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span>
			       <span class="n">primary_if</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">primary_if</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
			       <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">curr_ttvn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_ttvn</span><span class="p">);</span>
			<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_ROUTES</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;TTVN mismatch (old_ttvn %u new_ttvn %u)! Rerouting unicast packet (for %pM) to %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">,</span> <span class="n">curr_ttvn</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span>
			<span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>

		<span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span> <span class="o">=</span> <span class="n">curr_ttvn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recv_unicast_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="n">unicast_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">unicast_packet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_unicast_ttvn</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">unicast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* packet for me */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">interface_rx</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">route_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recv_ucast_frag_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unicast_frag_packet</span> <span class="o">*</span><span class="n">unicast_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">unicast_packet</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_unicast_ttvn</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">unicast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unicast_frag_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* packet for me */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">unicast_packet</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">frag_reassemble_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NET_RX_DROP</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

		<span class="cm">/* packet was buffered for late merge */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

		<span class="n">interface_rx</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">,</span> <span class="n">new_skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unicast_packet</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">route_unicast_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">recv_bcast_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcast_packet</span> <span class="o">*</span><span class="n">bcast_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bcast_packet</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">seq_diff</span><span class="p">;</span>

	<span class="cm">/* drop packet if it has not necessary minimum size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* packet with broadcast indication but unicast recipient */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* packet with broadcast sender address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* ignore broadcasts sent by myself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bcast_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bcast_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* ignore broadcasts originated by myself */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">bcast_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcast_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_hash_find</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">bcast_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_seqno_lock</span><span class="p">);</span>

	<span class="cm">/* check whether the packet is a duplicate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bat_test_bit</span><span class="p">(</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_bits</span><span class="p">,</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_bcast_seqno</span><span class="p">,</span>
			 <span class="n">ntohl</span><span class="p">(</span><span class="n">bcast_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">spin_unlock</span><span class="p">;</span>

	<span class="n">seq_diff</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">bcast_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">)</span> <span class="o">-</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_bcast_seqno</span><span class="p">;</span>

	<span class="cm">/* check whether the packet is old and the host just restarted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">window_protected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">seq_diff</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_seqno_reset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">spin_unlock</span><span class="p">;</span>

	<span class="cm">/* mark broadcast in flood history, update window position</span>
<span class="cm">	 * if required. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit_get_packet</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_bits</span><span class="p">,</span> <span class="n">seq_diff</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_bcast_seqno</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">bcast_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_seqno_lock</span><span class="p">);</span>

	<span class="cm">/* check whether this has been sent by another originator before */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bla_check_bcast_duplist</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">bcast_packet</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* rebroadcast packet */</span>
	<span class="n">add_bcast_packet_to_list</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* don&#39;t hand the broadcast up if it is from an originator</span>
<span class="cm">	 * from the same backbone.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bla_is_backbone_gw</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* broadcast for me */</span>
	<span class="n">interface_rx</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">recv_if</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">spin_unlock:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">bcast_seqno_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recv_vis_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">recv_if</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vis_packet</span> <span class="o">*</span><span class="n">vis_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">recv_if</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vis_packet</span><span class="p">);</span>

	<span class="cm">/* keep skb linear */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">vis_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vis_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* not for me */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="cm">/* ignore own packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">vis_packet</span><span class="o">-&gt;</span><span class="n">vis_orig</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_mac</span><span class="p">(</span><span class="n">vis_packet</span><span class="o">-&gt;</span><span class="n">sender_orig</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vis_packet</span><span class="o">-&gt;</span><span class="n">vis_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VIS_TYPE_SERVER_SYNC</span>:
		<span class="n">receive_server_sync_packet</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">vis_packet</span><span class="p">,</span>
					   <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VIS_TYPE_CLIENT_UPDATE</span>:
		<span class="n">receive_client_update_packet</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">vis_packet</span><span class="p">,</span>
					     <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>	<span class="cm">/* ignore unknown packet */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We take a copy of the data in the packet, so we should</span>
<span class="cm">	   always free the skbuf. */</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
