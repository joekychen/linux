<!DOCTYPE html>
<html><head><title>joekychen/linux » net › batman-adv › bat_iv_ogm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>bat_iv_ogm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007-2012 B.A.T.M.A.N. contributors:</span>
<span class="cm"> *</span>
<span class="cm"> * Marek Lindner, Simon Wunderlich</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;main.h&quot;</span>
<span class="cp">#include &quot;translation-table.h&quot;</span>
<span class="cp">#include &quot;ring_buffer.h&quot;</span>
<span class="cp">#include &quot;originator.h&quot;</span>
<span class="cp">#include &quot;routing.h&quot;</span>
<span class="cp">#include &quot;gateway_common.h&quot;</span>
<span class="cp">#include &quot;gateway_client.h&quot;</span>
<span class="cp">#include &quot;hard-interface.h&quot;</span>
<span class="cp">#include &quot;send.h&quot;</span>
<span class="cp">#include &quot;bat_algo.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="nf">bat_iv_ogm_neigh_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">neigh_addr</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_neigh</span><span class="p">,</span>
					       <span class="kt">uint32_t</span> <span class="n">seqno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span><span class="p">;</span>

	<span class="n">neigh_node</span> <span class="o">=</span> <span class="n">batadv_neigh_node_new</span><span class="p">(</span><span class="n">hard_iface</span><span class="p">,</span> <span class="n">neigh_addr</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">bonding_list</span><span class="p">);</span>

	<span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">orig_node</span> <span class="o">=</span> <span class="n">orig_neigh</span><span class="p">;</span>
	<span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">=</span> <span class="n">hard_iface</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">neigh_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bat_iv_ogm_iface_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">random_seqno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* randomize initial seqno to avoid collision */</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">random_seqno</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">random_seqno</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">,</span> <span class="n">random_seqno</span><span class="p">);</span>

	<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_len</span> <span class="o">=</span> <span class="n">BATMAN_OGM_HLEN</span><span class="p">;</span>
	<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">packet_type</span> <span class="o">=</span> <span class="n">BAT_IV_OGM</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">COMPAT_VERSION</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">NO_FLAGS</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span> <span class="o">=</span> <span class="n">TQ_MAX_VALUE</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_iface_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">);</span>
	<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_iface_update_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
	       <span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">prev_sender</span><span class="p">,</span>
	       <span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_primary_iface_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PRIMARIES_FIRST_HOP</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="n">TTL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* when do we schedule our own ogm to be sent */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bat_iv_ogm_emit_send_time</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">orig_interval</span><span class="p">)</span> <span class="o">-</span>
		   <span class="n">JITTER</span> <span class="o">+</span> <span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span><span class="o">*</span><span class="n">JITTER</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* when do we schedule a ogm packet to be sent */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bat_iv_ogm_fwd_send_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">JITTER</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* apply hop penalty for a normal link */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">hop_penalty</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">tq</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hop_penalty</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">hop_penalty</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tq</span> <span class="o">*</span> <span class="p">(</span><span class="n">TQ_MAX_VALUE</span> <span class="o">-</span> <span class="n">hop_penalty</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">TQ_MAX_VALUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* is there another aggregated packet here? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bat_iv_ogm_aggr_packet</span><span class="p">(</span><span class="kt">int</span> <span class="n">buff_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packet_len</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">tt_num_changes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">next_buff_pos</span> <span class="o">=</span> <span class="n">buff_pos</span> <span class="o">+</span> <span class="n">BATMAN_OGM_HLEN</span> <span class="o">+</span> <span class="n">tt_len</span><span class="p">(</span><span class="n">tt_num_changes</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">next_buff_pos</span> <span class="o">&lt;=</span> <span class="n">packet_len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">next_buff_pos</span> <span class="o">&lt;=</span> <span class="n">MAX_AGGREGATION_BYTES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* send a batman ogm to a given interface */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_send_to_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">forw_packet</span> <span class="o">*</span><span class="n">forw_packet</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fwd_str</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">packet_num</span><span class="p">;</span>
	<span class="kt">int16_t</span> <span class="n">buff_pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">!=</span> <span class="n">IF_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">packet_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buff_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* adjust all flags and log packets */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bat_iv_ogm_aggr_packet</span><span class="p">(</span><span class="n">buff_pos</span><span class="p">,</span> <span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">packet_len</span><span class="p">,</span>
				      <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* we might have aggregated direct link packets with an</span>
<span class="cm">		 * ordinary base packet */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">direct_link_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">packet_num</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">hard_iface</span><span class="p">))</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DIRECTLINK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DIRECTLINK</span><span class="p">;</span>

		<span class="n">fwd_str</span> <span class="o">=</span> <span class="p">(</span><span class="n">packet_num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Forwarding&quot;</span> <span class="o">:</span> <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">own</span> <span class="o">?</span>
							    <span class="s">&quot;Sending own&quot;</span> <span class="o">:</span>
							    <span class="s">&quot;Forwarding&quot;</span><span class="p">));</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;%s %spacket (originator %pM, seqno %u, TQ %d, TTL %d, IDF %s, ttvn %d) on interface %s [%pM]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fwd_str</span><span class="p">,</span> <span class="p">(</span><span class="n">packet_num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;aggregated &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
			<span class="n">ntohl</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">),</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">,</span>
			<span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIRECTLINK</span> <span class="o">?</span>
			 <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">),</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">,</span> <span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

		<span class="n">buff_pos</span> <span class="o">+=</span> <span class="n">BATMAN_OGM_HLEN</span> <span class="o">+</span>
				<span class="n">tt_len</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">);</span>
		<span class="n">packet_num</span><span class="o">++</span><span class="p">;</span>
		<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span>
					<span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">buff_pos</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* create clone because function is called more than once */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">send_skb_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hard_iface</span><span class="p">,</span> <span class="n">broadcast_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* send a batman ogm packet */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_emit</span><span class="p">(</span><span class="k">struct</span> <span class="n">forw_packet</span> <span class="o">*</span><span class="n">forw_packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">soft_iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">primary_if</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">directlink</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span>
						<span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">directlink</span> <span class="o">=</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIRECTLINK</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error - can&#39;t forward packet: incoming iface not specified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">soft_iface</span> <span class="o">=</span> <span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">;</span>
	<span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">soft_iface</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">!=</span> <span class="n">IF_ACTIVE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">primary_if</span> <span class="o">=</span> <span class="n">primary_if_get_selected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* multihomed peer assumed */</span>
	<span class="cm">/* non-primary OGMs are only broadcasted on their interface */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">directlink</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">own</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">!=</span> <span class="n">primary_if</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/* FIXME: what about aggregated packets ? */</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;%s packet (originator %pM, seqno %u, TTL %d) on interface %s [%pM]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">own</span> <span class="o">?</span> <span class="s">&quot;Sending own&quot;</span> <span class="o">:</span> <span class="s">&quot;Forwarding&quot;</span><span class="p">),</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
			<span class="n">ntohl</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">),</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">,</span>
			<span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

		<span class="cm">/* skb is only used once and than forw_packet is free&#39;d */</span>
		<span class="n">send_skb_packet</span><span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span><span class="p">,</span>
				<span class="n">broadcast_addr</span><span class="p">);</span>
		<span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* broadcast on every interface */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">hard_iface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hardif_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">soft_iface</span> <span class="o">!=</span> <span class="n">soft_iface</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">bat_iv_ogm_send_to_if</span><span class="p">(</span><span class="n">forw_packet</span><span class="p">,</span> <span class="n">hard_iface</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">primary_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* return true if new_packet can be aggregated with forw_packet */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">bat_iv_ogm_can_aggregate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">batman_ogm_packet</span>
							<span class="o">*</span><span class="n">new_batman_ogm_packet</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">packet_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_time</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">directlink</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">forw_packet</span> <span class="o">*</span><span class="n">forw_packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aggregated_bytes</span> <span class="o">=</span> <span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">packet_len</span> <span class="o">+</span> <span class="n">packet_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">primary_if</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * we can aggregate the current packet to this aggregated packet</span>
<span class="cm">	 * if:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - the send time is within our MAX_AGGREGATION_MS time</span>
<span class="cm">	 * - the resulting packet wont be bigger than</span>
<span class="cm">	 *   MAX_AGGREGATION_BYTES</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">send_time</span><span class="p">,</span> <span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">send_time</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_after_eq</span><span class="p">(</span><span class="n">send_time</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MAX_AGGREGATION_MS</span><span class="p">),</span>
					<span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">send_time</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">aggregated_bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_AGGREGATION_BYTES</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/**</span>
<span class="cm">		 * check aggregation compatibility</span>
<span class="cm">		 * -&gt; direct link packets are broadcasted on</span>
<span class="cm">		 *    their interface only</span>
<span class="cm">		 * -&gt; aggregate packet if the current packet is</span>
<span class="cm">		 *    a &quot;global&quot; packet as well as the base</span>
<span class="cm">		 *    packet</span>
<span class="cm">		 */</span>

		<span class="n">primary_if</span> <span class="o">=</span> <span class="n">primary_if_get_selected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary_if</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* packets without direct link flag and high TTL</span>
<span class="cm">		 * are flooded through the net  */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">directlink</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIRECTLINK</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>

		    <span class="cm">/* own packets originating non-primary</span>
<span class="cm">		     * interfaces leave only that interface */</span>
		    <span class="p">((</span><span class="o">!</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">own</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">primary_if</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if the incoming packet is sent via this one</span>
<span class="cm">		 * interface only - we still can aggregate */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">directlink</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">new_batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">if_incoming</span><span class="p">)</span> <span class="o">&amp;&amp;</span>

		    <span class="cm">/* packets from direct neighbors or</span>
<span class="cm">		     * own secondary interface packets</span>
<span class="cm">		     * (= secondary interface packets in general) */</span>
		    <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIRECTLINK</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">own</span> <span class="o">&amp;&amp;</span>
		      <span class="n">forw_packet</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">!=</span> <span class="n">primary_if</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">primary_if</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* create a new aggregated packet and add this packet to it */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_aggregate_new</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packet_buff</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">packet_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_time</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">direct_link</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">own_packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">forw_packet</span> <span class="o">*</span><span class="n">forw_packet_aggr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">skb_buff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* own packet should always be scheduled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">own_packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">batman_queue_left</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
				<span class="s">&quot;batman packet queue full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">forw_packet_aggr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">forw_packet_aggr</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forw_packet_aggr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">own_packet</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">batman_queue_left</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">aggregated_ogms</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">packet_len</span> <span class="o">&lt;</span> <span class="n">MAX_AGGREGATION_BYTES</span><span class="p">))</span>
		<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">MAX_AGGREGATION_BYTES</span> <span class="o">+</span>
						      <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">packet_len</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">own_packet</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">batman_queue_left</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">forw_packet_aggr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>

	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">skb_buff</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">);</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">packet_len</span> <span class="o">=</span> <span class="n">packet_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_buff</span><span class="p">,</span> <span class="n">packet_buff</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">);</span>

	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">own</span> <span class="o">=</span> <span class="n">own_packet</span><span class="p">;</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">=</span> <span class="n">if_incoming</span><span class="p">;</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">num_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">direct_link_flags</span> <span class="o">=</span> <span class="n">NO_FLAGS</span><span class="p">;</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">send_time</span> <span class="o">=</span> <span class="n">send_time</span><span class="p">;</span>

	<span class="cm">/* save packet direct link flag status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct_link</span><span class="p">)</span>
		<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">direct_link_flags</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* add new packet to packet list */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list_lock</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list_lock</span><span class="p">);</span>

	<span class="cm">/* start timer for this packet */</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">delayed_work</span><span class="p">,</span>
			  <span class="n">send_outstanding_bat_ogm_packet</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bat_event_workqueue</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">delayed_work</span><span class="p">,</span>
			   <span class="n">send_time</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">if_incoming</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* aggregate a new packet into the existing ogm packet */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_aggregate</span><span class="p">(</span><span class="k">struct</span> <span class="n">forw_packet</span> <span class="o">*</span><span class="n">forw_packet_aggr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packet_buff</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">packet_len</span><span class="p">,</span> <span class="n">bool</span> <span class="n">direct_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">skb_buff</span><span class="p">;</span>

	<span class="n">skb_buff</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_buff</span><span class="p">,</span> <span class="n">packet_buff</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">);</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">packet_len</span> <span class="o">+=</span> <span class="n">packet_len</span><span class="p">;</span>
	<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">num_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* save packet direct link flag status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct_link</span><span class="p">)</span>
		<span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">direct_link_flags</span> <span class="o">|=</span>
			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">forw_packet_aggr</span><span class="o">-&gt;</span><span class="n">num_packets</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_queue_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packet_buff</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">packet_len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">own_packet</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * _aggr -&gt; pointer to the packet we want to aggregate with</span>
<span class="cm">	 * _pos -&gt; pointer to the position in the queue</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">forw_packet</span> <span class="o">*</span><span class="n">forw_packet_aggr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">forw_packet_pos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">direct_link</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">packet_buff</span><span class="p">;</span>
	<span class="n">direct_link</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIRECTLINK</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* find position for the packet in the forward queue */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list_lock</span><span class="p">);</span>
	<span class="cm">/* own packets are not to be aggregated */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">aggregated_ogms</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">own_packet</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">forw_packet_pos</span><span class="p">,</span> <span class="n">tmp_node</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bat_iv_ogm_can_aggregate</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
						     <span class="n">bat_priv</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">,</span>
						     <span class="n">send_time</span><span class="p">,</span> <span class="n">direct_link</span><span class="p">,</span>
						     <span class="n">if_incoming</span><span class="p">,</span>
						     <span class="n">forw_packet_pos</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">forw_packet_aggr</span> <span class="o">=</span> <span class="n">forw_packet_pos</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* nothing to aggregate with - either aggregation disabled or no</span>
<span class="cm">	 * suitable aggregation packet found */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forw_packet_aggr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the following section can run without the lock */</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list_lock</span><span class="p">);</span>

		<span class="cm">/**</span>
<span class="cm">		 * if we could not aggregate this packet with one of the others</span>
<span class="cm">		 * we hold it back for a while, so that it might be aggregated</span>
<span class="cm">		 * later on</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">own_packet</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">aggregated_ogms</span><span class="p">)))</span>
			<span class="n">send_time</span> <span class="o">+=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MAX_AGGREGATION_MS</span><span class="p">);</span>

		<span class="n">bat_iv_ogm_aggregate_new</span><span class="p">(</span><span class="n">packet_buff</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">,</span>
					 <span class="n">send_time</span><span class="p">,</span> <span class="n">direct_link</span><span class="p">,</span>
					 <span class="n">if_incoming</span><span class="p">,</span> <span class="n">own_packet</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bat_iv_ogm_aggregate</span><span class="p">(</span><span class="n">forw_packet_aggr</span><span class="p">,</span> <span class="n">packet_buff</span><span class="p">,</span>
				     <span class="n">packet_len</span><span class="p">,</span> <span class="n">direct_link</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">forw_bat_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">is_single_hop_neigh</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">is_from_best_next_hop</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">tt_num_changes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span> <span class="s">&quot;ttl exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_from_best_next_hop</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mark the forwarded packet when it is not coming from our</span>
<span class="cm">		 * best next hop. We still need to forward the packet for our</span>
<span class="cm">		 * neighbor link quality detection to work in case the packet</span>
<span class="cm">		 * originated from a single hop neighbor. Otherwise we can</span>
<span class="cm">		 * simply drop the ogm.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_single_hop_neigh</span><span class="p">)</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NOT_BEST_NEXT_HOP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tt_num_changes</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">;</span>

	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="o">--</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">prev_sender</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="cm">/* apply hop penalty */</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span> <span class="o">=</span> <span class="n">hop_penalty</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">);</span>

	<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
		<span class="s">&quot;Forwarding packet: tq: %i, ttl: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">);</span>

	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span><span class="p">);</span>

	<span class="cm">/* switch of primaries first hop flag when forwarding */</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PRIMARIES_FIRST_HOP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_single_hop_neigh</span><span class="p">)</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DIRECTLINK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DIRECTLINK</span><span class="p">;</span>

	<span class="n">bat_iv_ogm_queue_add</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
			     <span class="n">BATMAN_OGM_HLEN</span> <span class="o">+</span> <span class="n">tt_len</span><span class="p">(</span><span class="n">tt_num_changes</span><span class="p">),</span>
			     <span class="n">if_incoming</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bat_iv_ogm_fwd_send_time</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">tt_num_changes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">primary_if</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vis_server</span><span class="p">;</span>

	<span class="n">vis_server</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">vis_mode</span><span class="p">);</span>
	<span class="n">primary_if</span> <span class="o">=</span> <span class="n">primary_if_get_selected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">);</span>

	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">;</span>

	<span class="cm">/* change sequence number to network order */</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">=</span>
			<span class="n">htonl</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">));</span>

	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">);</span>
	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span> <span class="o">=</span> <span class="n">htons</span><span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span>
						<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">tt_crc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tt_num_changes</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span> <span class="o">=</span> <span class="n">tt_num_changes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vis_server</span> <span class="o">==</span> <span class="n">VIS_TYPE_SERVER_SYNC</span><span class="p">)</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">VIS_SERVER</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VIS_SERVER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hard_iface</span> <span class="o">==</span> <span class="n">primary_if</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">gw_mode</span><span class="p">)</span> <span class="o">==</span> <span class="n">GW_MODE_SERVER</span><span class="p">))</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">gw_flags</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">gw_bandwidth</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">gw_flags</span> <span class="o">=</span> <span class="n">NO_FLAGS</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

	<span class="n">slide_own_bcast_window</span><span class="p">(</span><span class="n">hard_iface</span><span class="p">);</span>
	<span class="n">bat_iv_ogm_queue_add</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_buff</span><span class="p">,</span>
			     <span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">packet_len</span><span class="p">,</span> <span class="n">hard_iface</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">bat_iv_ogm_emit_send_time</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">primary_if</span><span class="p">)</span>
		<span class="n">hardif_free_ref</span><span class="p">(</span><span class="n">primary_if</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_orig_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">batman_ogm_packet</span>
							<span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tt_buff</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">is_duplicate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_neigh_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node_tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">bcast_own_sum_orig</span><span class="p">,</span> <span class="n">bcast_own_sum_neigh</span><span class="p">;</span>

	<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
		<span class="s">&quot;update_originator(): Searching and updating originator entry of received packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">if_incoming</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span>
				<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
			<span class="n">neigh_node</span> <span class="o">=</span> <span class="n">tmp_neigh_node</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_duplicate</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">lq_update_lock</span><span class="p">);</span>
		<span class="n">ring_buffer_set</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">tq_recv</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">tq_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">=</span>
			<span class="n">ring_buffer_avg</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">tq_recv</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">lq_update_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_tmp</span><span class="p">;</span>

		<span class="n">orig_tmp</span> <span class="o">=</span> <span class="n">get_orig_node</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_tmp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="n">neigh_node</span> <span class="o">=</span> <span class="n">bat_iv_ogm_neigh_new</span><span class="p">(</span><span class="n">if_incoming</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span>
						  <span class="n">orig_node</span><span class="p">,</span> <span class="n">orig_tmp</span><span class="p">,</span>
						  <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Updating existing last-hop neighbor of originator</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">last_seen</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">lq_update_lock</span><span class="p">);</span>
	<span class="n">ring_buffer_set</span><span class="p">(</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_recv</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_index</span><span class="p">,</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">);</span>
	<span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">=</span> <span class="n">ring_buffer_avg</span><span class="p">(</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_recv</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">lq_update_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_duplicate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_ttl</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">;</span>
		<span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">last_ttl</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bonding_candidate_add</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">neigh_node</span><span class="p">);</span>

	<span class="cm">/* if this neighbor already is our next hop there is nothing</span>
<span class="cm">	 * to change */</span>
	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span> <span class="o">==</span> <span class="n">neigh_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">update_tt</span><span class="p">;</span>

	<span class="cm">/* if this neighbor does not offer a better TQ we won&#39;t consider it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">&gt;</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_avg</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">update_tt</span><span class="p">;</span>

	<span class="cm">/* if the TQ is the same and the link not more symmetric we</span>
<span class="cm">	 * won&#39;t consider it either */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">==</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">tq_avg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">orig_node_tmp</span> <span class="o">=</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">orig_node</span><span class="p">;</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node_tmp</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
		<span class="n">bcast_own_sum_orig</span> <span class="o">=</span>
			<span class="n">orig_node_tmp</span><span class="o">-&gt;</span><span class="n">bcast_own_sum</span><span class="p">[</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_num</span><span class="p">];</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node_tmp</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>

		<span class="n">orig_node_tmp</span> <span class="o">=</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">orig_node</span><span class="p">;</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node_tmp</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
		<span class="n">bcast_own_sum_neigh</span> <span class="o">=</span>
			<span class="n">orig_node_tmp</span><span class="o">-&gt;</span><span class="n">bcast_own_sum</span><span class="p">[</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_num</span><span class="p">];</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node_tmp</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bcast_own_sum_orig</span> <span class="o">&gt;=</span> <span class="n">bcast_own_sum_neigh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">update_tt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">update_route</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">neigh_node</span><span class="p">);</span>

<span class="nl">update_tt:</span>
	<span class="cm">/* I have to check for transtable changes only if the OGM has been</span>
<span class="cm">	 * sent through a primary interface */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span> <span class="o">!=</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PRIMARIES_FIRST_HOP</span><span class="p">))</span>
		<span class="n">tt_update_orig</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">tt_buff</span><span class="p">,</span>
			       <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">,</span>
			       <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">,</span>
			       <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">gw_flags</span> <span class="o">!=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">gw_flags</span><span class="p">)</span>
		<span class="n">gw_node_update</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span>
			       <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">gw_flags</span><span class="p">);</span>

	<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">gw_flags</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">gw_flags</span><span class="p">;</span>

	<span class="cm">/* restart gateway selection if fast or late switching was enabled */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">gw_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">gw_mode</span><span class="p">)</span> <span class="o">==</span> <span class="n">GW_MODE_CLIENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">gw_sel_class</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">gw_check_election</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bat_iv_ogm_calc_tq</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_neigh_node</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">neigh_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_neigh_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">total_count</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">orig_eq_count</span><span class="p">,</span> <span class="n">neigh_rq_count</span><span class="p">,</span> <span class="n">tq_own</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tq_asym_penalty</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* find corresponding one hop neighbor */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">neigh_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">!=</span> <span class="n">if_incoming</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">neigh_node</span> <span class="o">=</span> <span class="n">tmp_neigh_node</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="n">neigh_node</span> <span class="o">=</span> <span class="n">bat_iv_ogm_neigh_new</span><span class="p">(</span><span class="n">if_incoming</span><span class="p">,</span>
						  <span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
						  <span class="n">orig_neigh_node</span><span class="p">,</span>
						  <span class="n">orig_neigh_node</span><span class="p">,</span>
						  <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* if orig_node is direct neighbor update neigh_node last_seen */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_node</span> <span class="o">==</span> <span class="n">orig_neigh_node</span><span class="p">)</span>
		<span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">last_seen</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_seen</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* find packet count of corresponding one hop neighbor */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
	<span class="n">orig_eq_count</span> <span class="o">=</span> <span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">bcast_own_sum</span><span class="p">[</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_num</span><span class="p">];</span>
	<span class="n">neigh_rq_count</span> <span class="o">=</span> <span class="n">neigh_node</span><span class="o">-&gt;</span><span class="n">real_packet_count</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>

	<span class="cm">/* pay attention to not get a value bigger than 100 % */</span>
	<span class="n">total_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_eq_count</span> <span class="o">&gt;</span> <span class="n">neigh_rq_count</span> <span class="o">?</span>
		       <span class="n">neigh_rq_count</span> <span class="o">:</span> <span class="n">orig_eq_count</span><span class="p">);</span>

	<span class="cm">/* if we have too few packets (too less data) we set tq_own to zero */</span>
	<span class="cm">/* if we receive too few packets it is not considered bidirectional */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">total_count</span> <span class="o">&lt;</span> <span class="n">TQ_LOCAL_BIDRECT_SEND_MINIMUM</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">neigh_rq_count</span> <span class="o">&lt;</span> <span class="n">TQ_LOCAL_BIDRECT_RECV_MINIMUM</span><span class="p">))</span>
		<span class="n">tq_own</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* neigh_node-&gt;real_packet_count is never zero as we</span>
<span class="cm">		 * only purge old information when getting new</span>
<span class="cm">		 * information */</span>
		<span class="n">tq_own</span> <span class="o">=</span> <span class="p">(</span><span class="n">TQ_MAX_VALUE</span> <span class="o">*</span> <span class="n">total_count</span><span class="p">)</span> <span class="o">/</span>	<span class="n">neigh_rq_count</span><span class="p">;</span>

	<span class="cm">/* 1 - ((1-x) ** 3), normalized to TQ_MAX_VALUE this does</span>
<span class="cm">	 * affect the nearly-symmetric links only a little, but</span>
<span class="cm">	 * punishes asymmetric links more.  This will give a value</span>
<span class="cm">	 * between 0 and TQ_MAX_VALUE</span>
<span class="cm">	 */</span>
	<span class="n">tq_asym_penalty</span> <span class="o">=</span> <span class="n">TQ_MAX_VALUE</span> <span class="o">-</span> <span class="p">(</span><span class="n">TQ_MAX_VALUE</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">TQ_LOCAL_WINDOW_SIZE</span> <span class="o">-</span> <span class="n">neigh_rq_count</span><span class="p">)</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">TQ_LOCAL_WINDOW_SIZE</span> <span class="o">-</span> <span class="n">neigh_rq_count</span><span class="p">)</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">TQ_LOCAL_WINDOW_SIZE</span> <span class="o">-</span> <span class="n">neigh_rq_count</span><span class="p">))</span> <span class="o">/</span>
					<span class="p">(</span><span class="n">TQ_LOCAL_WINDOW_SIZE</span> <span class="o">*</span>
					 <span class="n">TQ_LOCAL_WINDOW_SIZE</span> <span class="o">*</span>
					 <span class="n">TQ_LOCAL_WINDOW_SIZE</span><span class="p">);</span>

	<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span> <span class="o">=</span> <span class="p">((</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span> <span class="o">*</span> <span class="n">tq_own</span>
							<span class="o">*</span> <span class="n">tq_asym_penalty</span><span class="p">)</span> <span class="o">/</span>
						<span class="p">(</span><span class="n">TQ_MAX_VALUE</span> <span class="o">*</span> <span class="n">TQ_MAX_VALUE</span><span class="p">));</span>

	<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
		<span class="s">&quot;bidirectional: orig = %-15pM neigh = %-15pM =&gt; own_bcast = %2i, real recv = %2i, local tq: %3i, asym_penalty: %3i, total tq: %3i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="n">total_count</span><span class="p">,</span>
		<span class="n">neigh_rq_count</span><span class="p">,</span> <span class="n">tq_own</span><span class="p">,</span>	<span class="n">tq_asym_penalty</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">);</span>

	<span class="cm">/* if link has the minimum required transmission quality</span>
<span class="cm">	 * consider it bidirectional */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span> <span class="o">&gt;=</span> <span class="n">TQ_TOTAL_BIDRECT_LIMIT</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh_node</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">neigh_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* processes a batman packet for all interfaces, adjusts the sequence number and</span>
<span class="cm"> * finds out whether it is a duplicate.</span>
<span class="cm"> * returns:</span>
<span class="cm"> *   1 the packet is a duplicate</span>
<span class="cm"> *   0 the packet has not yet been received</span>
<span class="cm"> *  -1 the packet is old and has been received while the seqno window</span>
<span class="cm"> *     was protected. Caller should drop it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bat_iv_ogm_update_seqnos</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">batman_ogm_packet</span>
							<span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">tmp_neigh_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_duplicate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">seq_diff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set_mark</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">get_orig_node</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
	<span class="n">seq_diff</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">-</span> <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_real_seqno</span><span class="p">;</span>

	<span class="cm">/* signalize caller that the packet is to be dropped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">window_protected</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">seq_diff</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">batman_seqno_reset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">neigh_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">is_duplicate</span> <span class="o">|=</span> <span class="n">bat_test_bit</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">real_bits</span><span class="p">,</span>
					     <span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_real_seqno</span><span class="p">,</span>
					     <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">if_incoming</span> <span class="o">==</span> <span class="n">if_incoming</span><span class="p">))</span>
			<span class="n">set_mark</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">set_mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* if the window moved, set the update flag. */</span>
		<span class="n">need_update</span> <span class="o">|=</span> <span class="n">bit_get_packet</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span>
					      <span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">real_bits</span><span class="p">,</span>
					      <span class="n">seq_diff</span><span class="p">,</span> <span class="n">set_mark</span><span class="p">);</span>

		<span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">real_packet_count</span> <span class="o">=</span>
			<span class="n">bitmap_weight</span><span class="p">(</span><span class="n">tmp_neigh_node</span><span class="o">-&gt;</span><span class="n">real_bits</span><span class="p">,</span>
				      <span class="n">TQ_LOCAL_WINDOW_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_update</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;updating last_seqno: old %u, new %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_real_seqno</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_real_seqno</span> <span class="o">=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">is_duplicate</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
	<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bat_iv_ogm_process</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tt_buff</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">hard_iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">orig_node</span> <span class="o">*</span><span class="n">orig_neigh_node</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">router_router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_node</span> <span class="o">*</span><span class="n">orig_neigh_router</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">has_directlink_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_my_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_my_orig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_my_oldorig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_broadcast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_bidirectional</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_single_hop_neigh</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_from_best_next_hop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_duplicate</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_incoming_seqno</span><span class="p">;</span>

	<span class="cm">/* Silently drop when the batman packet is actually not a</span>
<span class="cm">	 * correct packet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This might happen if a packet is padded (e.g. Ethernet has a</span>
<span class="cm">	 * minimum frame length of 64 byte) and the aggregation interprets</span>
<span class="cm">	 * it as an additional length.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: A more sane solution would be to have a bit in the</span>
<span class="cm">	 * batman_ogm_packet to detect whether the packet is the last</span>
<span class="cm">	 * packet in an aggregation.  Here we expect that the padding</span>
<span class="cm">	 * is always zero (or not 0x01)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">packet_type</span> <span class="o">!=</span> <span class="n">BAT_IV_OGM</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* could be changed by schedule_own_packet() */</span>
	<span class="n">if_incoming_seqno</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>

	<span class="n">has_directlink_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIRECTLINK</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">))</span>
		<span class="n">is_single_hop_neigh</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
		<span class="s">&quot;Received BATMAN packet via NB: %pM, IF: %s [%pM] (from OG: %pM, via prev OG: %pM, seqno %u, ttvn %u, crc %u, changes %u, td %d, TTL %d, V %d, IDF %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">prev_sender</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">,</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">ttvn</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span><span class="p">,</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">,</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">,</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">version</span><span class="p">,</span> <span class="n">has_directlink_flag</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">hard_iface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hardif_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">!=</span> <span class="n">IF_ACTIVE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">soft_iface</span> <span class="o">!=</span> <span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span>
				<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span>
			<span class="n">is_my_addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
				<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span>
			<span class="n">is_my_orig</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">prev_sender</span><span class="p">,</span>
				<span class="n">hard_iface</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span>
			<span class="n">is_my_oldorig</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">))</span>
			<span class="n">is_broadcast</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">version</span> <span class="o">!=</span> <span class="n">COMPAT_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: incompatible batman version (%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: received my own broadcast (sender: %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: ignoring all packets with broadcast source addr (sender: %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_orig</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">word</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">orig_neigh_node</span> <span class="o">=</span> <span class="n">get_orig_node</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_neigh_node</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* neighbor has to indicate direct link and it has to</span>
<span class="cm">		 * come via the corresponding interface */</span>
		<span class="cm">/* save packet seqno for bidirectional check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_directlink_flag</span> <span class="o">&amp;&amp;</span>
		    <span class="n">compare_eth</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
				<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_num</span> <span class="o">*</span> <span class="n">NUM_WORDS</span><span class="p">;</span>

			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">bcast_own</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
			<span class="n">bat_set_bit</span><span class="p">(</span><span class="n">word</span><span class="p">,</span>
				    <span class="n">if_incoming_seqno</span> <span class="o">-</span>
						<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">bcast_own_sum</span><span class="p">[</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">if_num</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">bitmap_weight</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">TQ_LOCAL_WINDOW_SIZE</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_neigh_node</span><span class="o">-&gt;</span><span class="n">ogm_cnt_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: originator packet from myself (via neighbor)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_neigh_node</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_my_oldorig</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: ignoring all rebroadcast echos (sender: %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOT_BEST_NEXT_HOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: ignoring all packets not forwarded from the best next hop (sender: %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">orig_node</span> <span class="o">=</span> <span class="n">get_orig_node</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_node</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">is_duplicate</span> <span class="o">=</span> <span class="n">bat_iv_ogm_update_seqnos</span><span class="p">(</span><span class="n">ethhdr</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="p">,</span>
						<span class="n">if_incoming</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_duplicate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: packet within seqno protection time (sender: %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: originator packet with tq equal 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">router_router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">orig_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="n">router</span><span class="o">-&gt;</span><span class="n">tq_avg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">)))</span>
		<span class="n">is_from_best_next_hop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* avoid temporary routing loops */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span> <span class="o">&amp;&amp;</span> <span class="n">router_router</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">prev_sender</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span>
			  <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">prev_sender</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">compare_eth</span><span class="p">(</span><span class="n">router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">router_router</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: ignoring all rebroadcast packets that may make me loop (sender: %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if sender is a direct neighbor the sender mac equals</span>
<span class="cm">	 * originator mac */</span>
	<span class="n">orig_neigh_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_single_hop_neigh</span> <span class="o">?</span>
			   <span class="n">orig_node</span> <span class="o">:</span>
			   <span class="n">get_orig_node</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">ethhdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_neigh_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">orig_neigh_router</span> <span class="o">=</span> <span class="n">orig_node_get_router</span><span class="p">(</span><span class="n">orig_neigh_node</span><span class="p">);</span>

	<span class="cm">/* drop packet if sender is not a direct neighbor and if we</span>
<span class="cm">	 * don&#39;t route towards it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_single_hop_neigh</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_neigh_router</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: OGM via unknown neighbor!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_neigh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">is_bidirectional</span> <span class="o">=</span> <span class="n">bat_iv_ogm_calc_tq</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">orig_neigh_node</span><span class="p">,</span>
					      <span class="n">batman_ogm_packet</span><span class="p">,</span> <span class="n">if_incoming</span><span class="p">);</span>

	<span class="n">bonding_save_primary</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">orig_neigh_node</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="p">);</span>

	<span class="cm">/* update ranking if it is not a duplicate or has the same</span>
<span class="cm">	 * seqno and similar ttl as the non-duplicate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_bidirectional</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">is_duplicate</span> <span class="o">||</span>
	     <span class="p">((</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_real_seqno</span> <span class="o">==</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="p">(</span><span class="n">orig_node</span><span class="o">-&gt;</span><span class="n">last_ttl</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ttl</span><span class="p">))))</span>
		<span class="n">bat_iv_ogm_orig_update</span><span class="p">(</span><span class="n">bat_priv</span><span class="p">,</span> <span class="n">orig_node</span><span class="p">,</span> <span class="n">ethhdr</span><span class="p">,</span>
				       <span class="n">batman_ogm_packet</span><span class="p">,</span> <span class="n">if_incoming</span><span class="p">,</span>
				       <span class="n">tt_buff</span><span class="p">,</span> <span class="n">is_duplicate</span><span class="p">);</span>

	<span class="cm">/* is single hop (direct) neighbor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_single_hop_neigh</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* mark direct link on incoming interface */</span>
		<span class="n">bat_iv_ogm_forward</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">ethhdr</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="p">,</span>
				   <span class="n">is_single_hop_neigh</span><span class="p">,</span> <span class="n">is_from_best_next_hop</span><span class="p">,</span>
				   <span class="n">if_incoming</span><span class="p">);</span>

		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Forwarding packet: rebroadcast neighbor packet with direct link flag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_neigh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* multihop originator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_bidirectional</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: not received via bidirectional link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_neigh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_duplicate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
			<span class="s">&quot;Drop packet: duplicate packet received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_neigh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bat_dbg</span><span class="p">(</span><span class="n">DBG_BATMAN</span><span class="p">,</span> <span class="n">bat_priv</span><span class="p">,</span>
		<span class="s">&quot;Forwarding packet: rebroadcast originator packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">bat_iv_ogm_forward</span><span class="p">(</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">ethhdr</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="p">,</span>
			   <span class="n">is_single_hop_neigh</span><span class="p">,</span> <span class="n">is_from_best_next_hop</span><span class="p">,</span>
			   <span class="n">if_incoming</span><span class="p">);</span>

<span class="nl">out_neigh:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">orig_neigh_node</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">is_single_hop_neigh</span><span class="p">))</span>
		<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_neigh_node</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">router_router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">router_router</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_neigh_router</span><span class="p">)</span>
		<span class="n">neigh_node_free_ref</span><span class="p">(</span><span class="n">orig_neigh_router</span><span class="p">);</span>

	<span class="n">orig_node_free_ref</span><span class="p">(</span><span class="n">orig_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bat_iv_ogm_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">hard_iface</span> <span class="o">*</span><span class="n">if_incoming</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bat_priv</span> <span class="o">*</span><span class="n">bat_priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">if_incoming</span><span class="o">-&gt;</span><span class="n">soft_iface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="n">batman_ogm_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">ethhdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buff_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tt_buff</span><span class="p">,</span> <span class="o">*</span><span class="n">packet_buff</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_management_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">if_incoming</span><span class="p">,</span> <span class="n">BATMAN_OGM_HLEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="cm">/* did we receive a B.A.T.M.A.N. IV OGM packet on an interface</span>
<span class="cm">	 * that does not have B.A.T.M.A.N. IV enabled ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bat_priv</span><span class="o">-&gt;</span><span class="n">bat_algo_ops</span><span class="o">-&gt;</span><span class="n">bat_ogm_emit</span> <span class="o">!=</span> <span class="n">bat_iv_ogm_emit</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">packet_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ethhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">packet_buff</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span><span class="n">packet_buff</span><span class="p">;</span>

	<span class="cm">/* unpack the aggregated packets and process them one by one */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* network to host order for our 32bit seqno and the</span>
<span class="cm">		   orig_interval */</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">);</span>
		<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_crc</span><span class="p">);</span>

		<span class="n">tt_buff</span> <span class="o">=</span> <span class="n">packet_buff</span> <span class="o">+</span> <span class="n">buff_pos</span> <span class="o">+</span> <span class="n">BATMAN_OGM_HLEN</span><span class="p">;</span>

		<span class="n">bat_iv_ogm_process</span><span class="p">(</span><span class="n">ethhdr</span><span class="p">,</span> <span class="n">batman_ogm_packet</span><span class="p">,</span>
				   <span class="n">tt_buff</span><span class="p">,</span> <span class="n">if_incoming</span><span class="p">);</span>

		<span class="n">buff_pos</span> <span class="o">+=</span> <span class="n">BATMAN_OGM_HLEN</span> <span class="o">+</span>
				<span class="n">tt_len</span><span class="p">(</span><span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">);</span>

		<span class="n">batman_ogm_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">batman_ogm_packet</span> <span class="o">*</span><span class="p">)</span>
						<span class="p">(</span><span class="n">packet_buff</span> <span class="o">+</span> <span class="n">buff_pos</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bat_iv_ogm_aggr_packet</span><span class="p">(</span><span class="n">buff_pos</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">,</span>
					<span class="n">batman_ogm_packet</span><span class="o">-&gt;</span><span class="n">tt_num_changes</span><span class="p">));</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bat_algo_ops</span> <span class="n">batman_iv</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;BATMAN IV&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bat_iface_enable</span> <span class="o">=</span> <span class="n">bat_iv_ogm_iface_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bat_iface_disable</span> <span class="o">=</span> <span class="n">bat_iv_ogm_iface_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bat_iface_update_mac</span> <span class="o">=</span> <span class="n">bat_iv_ogm_iface_update_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bat_primary_iface_set</span> <span class="o">=</span> <span class="n">bat_iv_ogm_primary_iface_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bat_ogm_schedule</span> <span class="o">=</span> <span class="n">bat_iv_ogm_schedule</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bat_ogm_emit</span> <span class="o">=</span> <span class="n">bat_iv_ogm_emit</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">bat_iv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* batman originator packet */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv_handler_register</span><span class="p">(</span><span class="n">BAT_IV_OGM</span><span class="p">,</span> <span class="n">bat_iv_ogm_receive</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">bat_algo_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batman_iv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">handler_unregister</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">handler_unregister:</span>
	<span class="n">recv_handler_unregister</span><span class="p">(</span><span class="n">BAT_IV_OGM</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
