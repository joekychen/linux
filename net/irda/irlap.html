<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irlap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irlap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irlap.c</span>
<span class="cm"> * Version:       1.0</span>
<span class="cm"> * Description:   IrLAP implementation for Linux</span>
<span class="cm"> * Status:        Stable</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Mon Aug  4 20:40:53 1997</span>
<span class="cm"> * Modified at:   Tue Dec 14 09:26:44 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-1999 Dag Brattli, All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> *     GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public License</span>
<span class="cm"> *     along with this program; if not, write to the Free Software</span>
<span class="cm"> *     Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<span class="cm"> *     MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irda_device.h&gt;</span>
<span class="cp">#include &lt;net/irda/irqueue.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp_frame.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap_frame.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/timer.h&gt;</span>
<span class="cp">#include &lt;net/irda/qos.h&gt;</span>

<span class="k">static</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">irlap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_slot_timeout</span> <span class="o">=</span> <span class="n">SLOT_TIMEOUT</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>

<span class="cm">/* This is the delay of missed pf period before generating an event</span>
<span class="cm"> * to the application. The spec mandate 3 seconds, but in some cases</span>
<span class="cm"> * it&#39;s way too long. - Jean II */</span>
<span class="kt">int</span> <span class="n">sysctl_warn_noreply_time</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">irlap_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__irlap_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irlap_init_qos_capabilities</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos_user</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IRDA_DEBUG</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">lap_reasons</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;ERROR, NOT USED&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_DISC_INDICATION&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_NO_RESPONSE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_RESET_INDICATION&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_FOUND_NONE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_MEDIA_BUSY&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_PRIMARY_CONFLICT&quot;</span><span class="p">,</span>
	<span class="s">&quot;ERROR, NOT USED&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_IRDA_DEBUG */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">irlap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check if the compiler did its job properly.</span>
<span class="cm">	 * May happen on some ARM configuration, check with Russell King. */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xid_frame</span><span class="p">)</span> <span class="o">==</span> <span class="mi">14</span><span class="p">,</span> <span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">test_frame</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">,</span> <span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ua_frame</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">,</span> <span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">snrm_frame</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span><span class="p">,</span> <span class="p">;);</span>

	<span class="cm">/* Allocate master array */</span>
	<span class="n">irlap</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irlap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t allocate irlap hashbin!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlap_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irlap</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">__irlap_close</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_open (driver)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize IrLAP layer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="nf">irlap_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Initialize the irlap structure. */</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">LAP_MAGIC</span><span class="p">;</span>

	<span class="cm">/* Make a binding between the layers */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_dev</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>
	<span class="cm">/* Copy hardware name */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hw_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">hw_name</span><span class="p">,</span> <span class="n">hw_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">hw_name</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">hw_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: should we get our own field? */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atalk_ptr</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">LAP_OFFLINE</span><span class="p">;</span>

	<span class="cm">/* Initialize transmit queue */</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq_ultra</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">);</span>

	<span class="cm">/* My unique IrLAP device address! */</span>
	<span class="cm">/* We don&#39;t want the broadcast address, neither the NULL address</span>
<span class="cm">	 * (most often used to signify &quot;invalid&quot;), and we don&#39;t want an</span>
<span class="cm">	 * address already in use (otherwise connect won&#39;t be able</span>
<span class="cm">	 * to select the proper link). - Jean II */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">==</span> <span class="n">BROADCAST</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">hashbin_lock_find</span><span class="p">(</span><span class="n">irlap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">);</span>
	<span class="cm">/* Copy to the driver */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">slot_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">backoff_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy_timer</span><span class="p">);</span>

	<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">N3</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* # connections attempts to try before giving up */</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">LAP_NDM</span><span class="p">;</span>

	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlap</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">irlmp_register_link</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlap_open</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function __irlap_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove IrLAP and all allocated memory. Stop any pending timers.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__irlap_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Stop timers */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">slot_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">backoff_timer</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy_timer</span><span class="p">);</span>

	<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove IrLAP instance</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* We used to send a LAP_DISC_INDICATION here, but this was</span>
<span class="cm">	 * racy. This has been move within irlmp_unregister_link()</span>
<span class="cm">	 * itself. Jean II */</span>

	<span class="cm">/* Kill the LAP and all LSAPs on top of it */</span>
	<span class="n">irlmp_unregister_link</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Be sure that we manage to remove ourself from the hash */</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">irlap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Didn&#39;t find myself!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__irlap_close</span><span class="p">(</span><span class="n">lap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlap_close</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_connect_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Another device is attempting to make a connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_connect_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irlap_init_qos_capabilities</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="cm">/* No user QoS! */</span>

	<span class="n">irlmp_link_connect_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
				      <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_connect_response (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Service user has accepted incoming connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_connect_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CONNECT_RESPONSE</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_connect_request (self, daddr, qos_user, sniff)</span>
<span class="cm"> *</span>
<span class="cm"> *    Request connection with another device, sniffing is not implemented</span>
<span class="cm"> *    yet.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_connect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">daddr</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos_user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sniff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), daddr=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If the service user specifies QoS values for this connection,</span>
<span class="cm">	 *  then use them</span>
<span class="cm">	 */</span>
	<span class="n">irlap_init_qos_capabilities</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">qos_user</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LAP_NDM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy</span><span class="p">)</span>
		<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">connect_pending</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_connect_confirm (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Connection request has been accepted</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_connect_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irlmp_link_connect_confirm</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_data_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Received data frames from IR-port, so we just pass them up to</span>
<span class="cm"> *    IrLMP for further processing</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_data_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">unreliable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Hide LAP header from IrLMP layer */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LAP_ADDR_HEADER</span><span class="o">+</span><span class="n">LAP_CTRL_HEADER</span><span class="p">);</span>

	<span class="n">irlmp_link_data_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">unreliable</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function irlap_data_request (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Queue data for transmission, must wait until XMIT state</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_data_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">unreliable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">LAP_ADDR_HEADER</span><span class="o">+</span><span class="n">LAP_CTRL_HEADER</span><span class="p">),</span>
		    <span class="k">return</span><span class="p">;);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LAP_ADDR_HEADER</span><span class="o">+</span><span class="n">LAP_CTRL_HEADER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Must set frame format now so that the rest of the code knows</span>
<span class="cm">	 *  if its dealing with an I or an UI frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unreliable</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">UI_FRAME</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">I_FRAME</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t forget to refcount it - see irlmp_connect_request(). */</span>
	<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Add at the end of the queue (keep ordering) - Jean II */</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Send event if this frame only if we are in the right state</span>
<span class="cm">	 *  FIXME: udata should be sent first! (skb_queue_head?)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LAP_XMIT_P</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LAP_XMIT_S</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If we are not already processing the Tx queue, trigger</span>
<span class="cm">		 * transmission immediately - Jean II */</span>
		<span class="k">if</span><span class="p">((</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">local_busy</span><span class="p">))</span>
			<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">DATA_REQUEST</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Otherwise, the packets will be sent normally at the</span>
<span class="cm">		 * next pf-poll - Jean II */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_unitdata_request (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send Ultra data. This is data that must be sent outside any connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="kt">void</span> <span class="nf">irlap_unitdata_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">LAP_ADDR_HEADER</span><span class="o">+</span><span class="n">LAP_CTRL_HEADER</span><span class="p">),</span>
	       <span class="k">return</span><span class="p">;);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LAP_ADDR_HEADER</span><span class="o">+</span><span class="n">LAP_CTRL_HEADER</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CBROADCAST</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">UI_FRAME</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t need to refcount, see irlmp_connless_data_request() */</span>

	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq_ultra</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">SEND_UI_FRAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_udata_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Receive Ultra data. This is data that is received outside any connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="kt">void</span> <span class="nf">irlap_unitdata_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Hide LAP header from IrLMP layer */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LAP_ADDR_HEADER</span><span class="o">+</span><span class="n">LAP_CTRL_HEADER</span><span class="p">);</span>

	<span class="n">irlmp_link_unitdata_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_disconnect_request (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Request to disconnect connection by service user</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_disconnect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Don&#39;t disconnect until all data frames are successfully sent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we are in the right state for disconnecting */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LAP_XMIT_P</span>:        <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_XMIT_S</span>:        <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_CONN</span>:          <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_RESET_WAIT</span>:    <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_RESET_CHECK</span>:
		<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">DISCONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), disconnect pending!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_disconnect_indication (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Disconnect request from other device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_disconnect_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_REASON</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">lap_reasons</span><span class="p">[</span><span class="n">reason</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Flush queues */</span>
	<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LAP_RESET_INDICATION</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Sending reset request!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RESET_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAP_NO_RESPONSE</span>:	   <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_DISC_INDICATION</span>:  <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_FOUND_NONE</span>:       <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_MEDIA_BUSY</span>:
		<span class="n">irlmp_link_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
						 <span class="n">reason</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: Unknown reason %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_discovery_request (gen_addr_bit)</span>
<span class="cm"> *</span>
<span class="cm"> *    Start one single discovery operation.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_discovery_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">discovery_t</span> <span class="o">*</span><span class="n">discovery</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_info</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">discovery</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), nslots = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">discovery</span><span class="o">-&gt;</span><span class="n">nslots</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">((</span><span class="n">discovery</span><span class="o">-&gt;</span><span class="n">nslots</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">discovery</span><span class="o">-&gt;</span><span class="n">nslots</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">discovery</span><span class="o">-&gt;</span><span class="n">nslots</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">discovery</span><span class="o">-&gt;</span><span class="n">nslots</span> <span class="o">==</span> <span class="mi">16</span><span class="p">),</span>
		    <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Discovery is only possible in NDM mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LAP_NDM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), discovery only possible in NDM mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlap_discovery_confirm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Note : in theory, if we are not in NDM, we could postpone</span>
<span class="cm">		 * the discovery like we do for connection request.</span>
<span class="cm">		 * In practice, it&#39;s not worth it. If the media was busy,</span>
<span class="cm">		 * it&#39;s likely next time around it won&#39;t be busy. If we are</span>
<span class="cm">		 * in REPLY state, we will get passive discovery info &amp; event.</span>
<span class="cm">		 * Jean II */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if last discovery request finished in time, or if</span>
<span class="cm">	 * it was aborted due to the media busy flag. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">kfree</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All operations will occur at predictable time, no need to lock */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_NOLOCK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), Unable to allocate discovery log!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="p">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">discovery</span><span class="o">-&gt;</span><span class="n">nslots</span><span class="p">;</span> <span class="cm">/* Number of slots */</span>
	<span class="n">info</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Current slot */</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span> <span class="o">=</span> <span class="n">discovery</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">discovery</span> <span class="o">=</span> <span class="n">discovery</span><span class="p">;</span>

	<span class="cm">/* sysctl_slot_timeout bounds are checked in irsysctl.c - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">slot_timeout</span> <span class="o">=</span> <span class="n">sysctl_slot_timeout</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">DISCOVERY_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_discovery_confirm (log)</span>
<span class="cm"> *</span>
<span class="cm"> *    A device has been discovered in front of this station, we</span>
<span class="cm"> *    report directly to LMP.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_discovery_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">discovery_log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for successful discovery, since we are then allowed to clear</span>
<span class="cm">	 * the media busy condition (IrLAP 6.13.4 - p.94). This should allow</span>
<span class="cm">	 * us to make connection attempts much faster and easier (i.e. no</span>
<span class="cm">	 * collisions).</span>
<span class="cm">	 * Setting media busy to false will also generate an event allowing</span>
<span class="cm">	 * to process pending events in NDM state machine.</span>
<span class="cm">	 * Note : the spec doesn&#39;t define what&#39;s a successful discovery is.</span>
<span class="cm">	 * If we want Ultra to work, it&#39;s successful even if there is</span>
<span class="cm">	 * nobody discovered - Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">discovery_log</span><span class="p">)</span>
		<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

	<span class="cm">/* Inform IrLMP */</span>
	<span class="n">irlmp_link_discovery_confirm</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">discovery_log</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_discovery_indication (log)</span>
<span class="cm"> *</span>
<span class="cm"> *    Somebody is trying to discover us!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_discovery_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">discovery_t</span> <span class="o">*</span><span class="n">discovery</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">discovery</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* A device is very likely to connect immediately after it performs</span>
<span class="cm">	 * a successful discovery. This means that in our case, we are much</span>
<span class="cm">	 * more likely to receive a connection request over the medium.</span>
<span class="cm">	 * So, we backoff to avoid collisions.</span>
<span class="cm">	 * IrLAP spec 6.13.4 suggest 100ms...</span>
<span class="cm">	 * Note : this little trick actually make a *BIG* difference. If I set</span>
<span class="cm">	 * my Linux box with discovery enabled and one Ultra frame sent every</span>
<span class="cm">	 * second, my Palm has no trouble connecting to it every time !</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">);</span>

	<span class="n">irlmp_link_discovery_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">discovery</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_status_indication (quality_of_link)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_status_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quality_of_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">quality_of_link</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUS_NO_ACTIVITY</span>:
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;IrLAP, no activity on link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STATUS_NOISY</span>:
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;IrLAP, noisy link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">irlmp_status_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
				<span class="n">quality_of_link</span><span class="p">,</span> <span class="n">LOCK_NO_CHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_reset_indication (void)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_reset_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LAP_RESET_WAIT</span><span class="p">)</span>
		<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RESET_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RESET_RESPONSE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_reset_confirm (void)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_reset_confirm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_generate_rand_time_slot (S, s)</span>
<span class="cm"> *</span>
<span class="cm"> *    Generate a random time slot between s and S-1 where</span>
<span class="cm"> *    S = Number of slots (0 -&gt; S-1)</span>
<span class="cm"> *    s = Current slot</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlap_generate_rand_time_slot</span><span class="p">(</span><span class="kt">int</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">rand</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">((</span><span class="n">S</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="n">rand</span> <span class="o">+=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">rand</span> <span class="o">^=</span> <span class="p">(</span><span class="n">rand</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">rand</span> <span class="o">^=</span> <span class="p">(</span><span class="n">rand</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">rand</span> <span class="o">%</span> <span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">s</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">((</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">S</span><span class="p">),</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_update_nr_received (nr)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove all acknowledged frames in current window queue. This code is</span>
<span class="cm"> *    not intuitive and you should not try to change it. If you think it</span>
<span class="cm"> *    contains bugs, please mail a patch to the author instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_update_nr_received</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove all the ack-ed frames from the window queue.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Optimize for the common case. It is most likely that the receiver</span>
<span class="cm">	 *  will acknowledge all the frames we have sent! So in that case we</span>
<span class="cm">	 *  delete all frames stored in window.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* The last acked frame is the next to send minus one */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Remove all acknowledged frames in current window */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nr</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Advance window */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">window_size</span> <span class="o">-</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_validate_ns_received (ns)</span>
<span class="cm"> *</span>
<span class="cm"> *    Validate the next to send (ns) field from received frame.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlap_validate_ns_received</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  ns as expected?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NS_EXPECTED</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Stations are allowed to treat invalid NS as unexpected NS</span>
<span class="cm">	 *  IrLAP, Recv ... with-invalid-Ns. p. 84</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">NS_UNEXPECTED</span><span class="p">;</span>

	<span class="cm">/* return NR_INVALID; */</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Function irlap_validate_nr_received (nr)</span>
<span class="cm"> *</span>
<span class="cm"> *    Validate the next to receive (nr) field from received frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlap_validate_nr_received</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  nr as expected?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), expected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NR_EXPECTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  unexpected nr? (but within current window), first we check if the</span>
<span class="cm">	 *  ns numbers of the frames in the current window wrap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NR_UNEXPECTED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NR_UNEXPECTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Invalid nr!  */</span>
	<span class="k">return</span> <span class="n">NR_INVALID</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_initiate_connection_state ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize the connection state parameters</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_initiate_connection_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Next to send and next to receive */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Last frame which got acked (0 - 1) % 8 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_wait_min_turn_around (self, qos)</span>
<span class="cm"> *</span>
<span class="cm"> *    Wait negotiated minimum turn around time, this function actually sets</span>
<span class="cm"> *    the number of BOS&#39;s that must be sent before the next transmitted</span>
<span class="cm"> *    frame in order to delay for the specified amount of time. This is</span>
<span class="cm"> *    done to avoid using timers, and the forbidden udelay!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_wait_min_turn_around</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">min_turn_time</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">speed</span><span class="p">;</span>

	<span class="cm">/* Get QoS values.  */</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="n">min_turn_time</span> <span class="o">=</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* No need to calculate XBOFs for speeds over 115200 bps */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">mtt_required</span> <span class="o">=</span> <span class="n">min_turn_time</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Send additional BOF&#39;s for the next frame for the requested</span>
<span class="cm">	 *  min turn time, so now we must calculate how many chars (XBOF&#39;s) we</span>
<span class="cm">	 *  must send for the requested time period (min turn time)</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs_delay</span> <span class="o">=</span> <span class="n">irlap_min_turn_time_in_bytes</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">min_turn_time</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_flush_all_queues (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Flush all queues</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_flush_all_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Free transmission queue */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq_ultra</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Free sliding window buffered packets */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_setspeed (self, speed)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change the speed of the IrDA port</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlap_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), setting speed to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

	<span class="cm">/* Change speed now, or just piggyback speed on frames */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Send down empty frame to trigger speed change */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">irlap_queue_xmit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_init_qos_capabilities (self, qos)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize QoS for this IrLAP session, What we do is to compute the</span>
<span class="cm"> *    intersection of the QoS capabilities for the user, driver and for</span>
<span class="cm"> *    IrLAP itself. Normally, IrLAP will not specify any values, but it can</span>
<span class="cm"> *    be used to restrict certain values.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlap_init_qos_capabilities</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos_user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Start out with the maximum QoS support possible */</span>
	<span class="n">irda_init_max_qos_capabilies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>

	<span class="cm">/* Apply drivers QoS capabilities */</span>
	<span class="n">irda_qos_compute_intersection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check for user supplied QoS parameters. The service user is only</span>
<span class="cm">	 *  allowed to supply these values. We check each parameter since the</span>
<span class="cm">	 *  user may not have set all of them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Found user specified QoS!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="n">qos_user</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Use 500ms in IrLAP for now */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="cm">/* Set data size */</span>
	<span class="cm">/*self-&gt;qos_rx.data_size.bits &amp;= 0x03;*/</span>

	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_apply_default_connection_parameters (void, now)</span>
<span class="cm"> *</span>
<span class="cm"> *    Use the default connection and transmission parameters</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* xbofs : Default value in NDM */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">next_bofs</span>   <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">bofs_count</span>  <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="cm">/* NDM Speed is 9600 */</span>
	<span class="n">irlap_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">9600</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

	<span class="cm">/* Set mbusy when going to NDM state */</span>
	<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate random connection address for this session, which must</span>
<span class="cm">	 * be 7 bits wide and different from 0x00 and 0xfe</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span> <span class="o">==</span> <span class="mh">0xfe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">));</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span> <span class="o">&amp;=</span> <span class="mh">0xfe</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Use default values until connection has been negitiated */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">slot_timeout</span> <span class="o">=</span> <span class="n">sysctl_slot_timeout</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span> <span class="o">=</span> <span class="n">FINAL_TIMEOUT</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span> <span class="o">=</span> <span class="n">POLL_TIMEOUT</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span> <span class="o">=</span> <span class="n">WD_TIMEOUT</span><span class="p">;</span>

	<span class="cm">/* Set some default values */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connect_pending</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_apply_connection_parameters (qos, now)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize IrLAP with the negotiated QoS values</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;now&#39; is false, the speed and xbofs will be changed after the next</span>
<span class="cm"> * frame is sent.</span>
<span class="cm"> * If &#39;now&#39; is true, the speed and xbofs is changed immediately</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_apply_connection_parameters</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Set the negotiated xbofs value */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">next_bofs</span>   <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">bofs_count</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">next_bofs</span><span class="p">;</span>

	<span class="cm">/* Set the negotiated link speed (may need the new xbofs value) */</span>
	<span class="n">irlap_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span>      <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IRDA_DYNAMIC_WINDOW</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Calculate how many bytes it is possible to transmit before the</span>
<span class="cm">	 *  link must be turned around</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">line_capacity</span> <span class="o">=</span>
		<span class="n">irlap_max_line_capacity</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">line_capacity</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>


	<span class="cm">/*</span>
<span class="cm">	 *  Initialize timeout values, some of the rules are listed on</span>
<span class="cm">	 *  page 92 in IrLAP.</span>
<span class="cm">	 */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="cm">/* The poll timeout applies only to the primary station.</span>
<span class="cm">	 * It defines the maximum time the primary stay in XMIT mode</span>
<span class="cm">	 * before timeout and turning the link around (sending a RR).</span>
<span class="cm">	 * Or, this is how much we can keep the pf bit in primary mode.</span>
<span class="cm">	 * Therefore, it must be lower or equal than our *OWN* max turn around.</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="cm">/* The Final timeout applies only to the primary station.</span>
<span class="cm">	 * It defines the maximum time the primary wait (mostly in RECV mode)</span>
<span class="cm">	 * for an answer from the secondary station before polling it again.</span>
<span class="cm">	 * Therefore, it must be greater or equal than our *PARTNER*</span>
<span class="cm">	 * max turn around time - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="cm">/* The Watchdog Bit timeout applies only to the secondary station.</span>
<span class="cm">	 * It defines the maximum time the secondary wait (mostly in RECV mode)</span>
<span class="cm">	 * for poll from the primary station before getting annoyed.</span>
<span class="cm">	 * Therefore, it must be greater or equal than our *PARTNER*</span>
<span class="cm">	 * max turn around time - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * N1 and N2 are maximum retry count for *both* the final timer</span>
<span class="cm">	 * and the wd timer (with a factor 2) as defined above.</span>
<span class="cm">	 * After N1 retry of a timer, we give a warning to the user.</span>
<span class="cm">	 * After N2 retry, we consider the link dead and disconnect it.</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set N1 to 0 if Link Disconnect/Threshold Time = 3 and set it to</span>
<span class="cm">	 *  3 seconds otherwise. See page 71 in IrLAP for more details.</span>
<span class="cm">	 *  Actually, it&#39;s not always 3 seconds, as we allow to set</span>
<span class="cm">	 *  it via sysctl... Max maxtt is 500ms, and N1 need to be multiple</span>
<span class="cm">	 *  of 2, so 1 second is minimum we can allow. - Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">sysctl_warn_noreply_time</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we set N1 to 0, it will trigger immediately, which is</span>
<span class="cm">		 * not what we want. What we really want is to disable it,</span>
<span class="cm">		 * Jean II</span>
<span class="cm">		 */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">N1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="cm">/* Disable - Need to be multiple of 2*/</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">N1</span> <span class="o">=</span> <span class="n">sysctl_warn_noreply_time</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span>
		  <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Setting N1 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N1</span><span class="p">);</span>

	<span class="cm">/* Set N2 to match our own disconnect time */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">N2</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Setting N2 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">struct</span> <span class="n">irlap_iter_state</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlap_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="cm">/* Protect our access to the tsap list */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlap</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlap</span><span class="p">);</span>
	     <span class="n">self</span><span class="p">;</span> <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlap_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlap_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlap</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">irlap_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;irlap%d &quot;</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">irlap_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">]);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  device name: %s, &quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">?</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;bug&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;hardware name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">hw_name</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  caddr: %#02x, &quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;saddr: %#08x, &quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;daddr: %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  win size: %d, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;win: %d, &quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IRDA_DYNAMIC_WINDOW</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;line capacity: %d, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">line_capacity</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;bytes left: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  tx queue len: %d &quot;</span><span class="p">,</span>
		   <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;win queue len: %d &quot;</span><span class="p">,</span>
		   <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;rbusy: %s&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">?</span>
		   <span class="s">&quot;TRUE&quot;</span> <span class="o">:</span> <span class="s">&quot;FALSE&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot; mbusy: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy</span> <span class="o">?</span>
		   <span class="s">&quot;TRUE&quot;</span> <span class="o">:</span> <span class="s">&quot;FALSE&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  retrans: %d &quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;vs: %d &quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;vr: %d &quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;va: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  qos</span><span class="se">\t</span><span class="s">bps</span><span class="se">\t</span><span class="s">maxtt</span><span class="se">\t</span><span class="s">dsize</span><span class="se">\t</span><span class="s">winsize</span><span class="se">\t</span><span class="s">addbofs</span><span class="se">\t</span><span class="s">mintt</span><span class="se">\t</span><span class="s">ldisc</span><span class="se">\t</span><span class="s">comp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  tx</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  rx</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">irlap_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">irlap_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">irlap_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">irlap_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">irlap_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irlap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlap_seq_ops</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_iter_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">irlap_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">irlap_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
