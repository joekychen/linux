<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irlmp_frame.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irlmp_frame.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irlmp_frame.c</span>
<span class="cm"> * Version:       0.9</span>
<span class="cm"> * Description:   IrLMP frame implementation</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Tue Aug 19 02:09:59 1997</span>
<span class="cm"> * Modified at:   Mon Dec 13 13:41:12 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-1999 Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/timer.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp_frame.h&gt;</span>
<span class="cp">#include &lt;net/irda/discovery.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">irlmp_find_lsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dlsap</span><span class="p">,</span>
				       <span class="n">__u8</span> <span class="n">slsap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="p">);</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irlmp_send_data_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dlsap</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">slsap</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">expedited</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlsap</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slsap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expedited</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), sending expedited data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlap_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">irlap_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_send_lcf_pdu (dlsap, slsap, opcode,skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send Link Control Frame to IrLAP</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_send_lcf_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dlsap</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">slsap</span><span class="p">,</span>
			<span class="n">__u8</span> <span class="n">opcode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlsap</span> <span class="o">|</span> <span class="n">CONTROL_BIT</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slsap</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">opcode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">DISCONNECT</span><span class="p">)</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* Service user request */</span>
	<span class="k">else</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* rsvd */</span>

	<span class="n">irlap_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_input (skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Used by IrLAP to pass received data frames to IrLMP layer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_link_data_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">unreliable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">slsap_sel</span><span class="p">;</span>   <span class="cm">/* Source (this) LSAP address */</span>
	<span class="n">__u8</span>   <span class="n">dlsap_sel</span><span class="p">;</span>   <span class="cm">/* Destination LSAP address */</span>
	<span class="n">__u8</span>   <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  The next statements may be confusing, but we do this so that</span>
<span class="cm">	 *  destination LSAP of received frame is source LSAP in our view</span>
<span class="cm">	 */</span>
	<span class="n">slsap_sel</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">LSAP_MASK</span><span class="p">;</span>
	<span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if this is an incoming connection, since we must deal with</span>
<span class="cm">	 *  it in a different way than other established connections.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CONTROL_BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">CONNECT_CMD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), incoming connection, &quot;</span>
			   <span class="s">&quot;source LSAP=%d, dest LSAP=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="n">dlsap_sel</span><span class="p">);</span>

		<span class="cm">/* Try to find LSAP among the unconnected LSAPs */</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="n">irlmp_find_lsap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dlsap_sel</span><span class="p">,</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="n">CONNECT_CMD</span><span class="p">,</span>
				       <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">);</span>

		<span class="cm">/* Maybe LSAP was already connected, so try one more time */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), incoming connection for LSAP already connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">lsap</span> <span class="o">=</span> <span class="n">irlmp_find_lsap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dlsap_sel</span><span class="p">,</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="n">irlmp_find_lsap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dlsap_sel</span><span class="p">,</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lsap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;IrLMP, Sorry, no LSAP for received frame!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), slsap_sel = %02x, dlsap_sel = %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="n">dlsap_sel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CONTROL_BIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), received control frame %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), received data frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if we received a control frame?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CONTROL_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CONNECT_CMD</span>:
			<span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
			<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">LM_CONNECT_INDICATION</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CONNECT_CNF</span>:
			<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">LM_CONNECT_CONFIRM</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DISCONNECT</span>:
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), Disconnect indication!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">LM_DISCONNECT_INDICATION</span><span class="p">,</span>
					    <span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ACCESSMODE_CMD</span>:
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Access mode cmd not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ACCESSMODE_CNF</span>:
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Access mode cnf not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown control frame %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unreliable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Optimize and bypass the state machine if possible */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lsap_state</span> <span class="o">==</span> <span class="n">LSAP_DATA_TRANSFER_READY</span><span class="p">)</span>
			<span class="n">irlmp_udata_indication</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">LM_UDATA_INDICATION</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Optimize and bypass the state machine if possible */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lsap_state</span> <span class="o">==</span> <span class="n">LSAP_DATA_TRANSFER_READY</span><span class="p">)</span>
			<span class="n">irlmp_data_indication</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">LM_DATA_INDICATION</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_link_unitdata_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="kt">void</span> <span class="nf">irlmp_link_unitdata_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">slsap_sel</span><span class="p">;</span>   <span class="cm">/* Source (this) LSAP address */</span>
	<span class="n">__u8</span>   <span class="n">dlsap_sel</span><span class="p">;</span>   <span class="cm">/* Destination LSAP address */</span>
	<span class="n">__u8</span>   <span class="n">pid</span><span class="p">;</span>         <span class="cm">/* Protocol identifier */</span>
	<span class="n">__u8</span>   <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  The next statements may be confusing, but we do this so that</span>
<span class="cm">	 *  destination LSAP of received frame is source LSAP in our view</span>
<span class="cm">	 */</span>
	<span class="n">slsap_sel</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">LSAP_MASK</span><span class="p">;</span>
	<span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">pid</span>       <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), extension in PID not supp!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if frame is addressed to the connectionless LSAP */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">slsap_sel</span> <span class="o">!=</span> <span class="n">LSAP_CONNLESS</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dlsap_sel</span> <span class="o">!=</span> <span class="n">LSAP_CONNLESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), dropping frame!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Search the connectionless LSAP */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lsap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lsap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Check if source LSAP and dest LSAP selectors and PID match.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">slsap_sel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">==</span> <span class="n">dlsap_sel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lsap</span><span class="p">)</span>
		<span class="n">irlmp_connless_data_indication</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), found no matching LSAP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_link_disconnect_indication (reason, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    IrLAP has disconnected</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_link_disconnect_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">irlap</span><span class="p">,</span>
				      <span class="n">LAP_REASON</span> <span class="n">reason</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>

	<span class="cm">/* FIXME: must do something with the skb if any */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Inform station state machine</span>
<span class="cm">	 */</span>
	<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_link_connect_indication (qos)</span>
<span class="cm"> *</span>
<span class="cm"> *    Incoming LAP connection!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_link_connect_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span>
				   <span class="n">__u32</span> <span class="n">daddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Copy QoS settings for this session */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>

	<span class="cm">/* Update destination device address */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">==</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_INDICATION</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_link_connect_confirm (qos)</span>
<span class="cm"> *</span>
<span class="cm"> *    LAP connection confirmed!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_link_connect_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">qos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Don&#39;t need use the skb for now */</span>

	<span class="cm">/* Copy QoS settings for this session */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>

	<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_link_discovery_indication (self, log)</span>
<span class="cm"> *</span>
<span class="cm"> *    Device is discovering us</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s not an answer to our own discoveries, just another device trying</span>
<span class="cm"> * to perform discovery, but we don&#39;t want to miss the opportunity</span>
<span class="cm"> * to exploit this information, because :</span>
<span class="cm"> *	o We may not actively perform discovery (just passive discovery)</span>
<span class="cm"> *	o This type of discovery is much more reliable. In some cases, it</span>
<span class="cm"> *	  seem that less than 50% of our discoveries get an answer, while</span>
<span class="cm"> *	  we always get ~100% of these.</span>
<span class="cm"> *	o Make faster discovery, statistically divide time of discovery</span>
<span class="cm"> *	  events by 2 (important for the latency aspect and user feel)</span>
<span class="cm"> *	o Even is we do active discovery, the other node might not</span>
<span class="cm"> *	  answer our discoveries (ex: Palm). The Palm will just perform</span>
<span class="cm"> *	  one active discovery and connect directly to us.</span>
<span class="cm"> *</span>
<span class="cm"> * However, when both devices discover each other, they might attempt to</span>
<span class="cm"> * connect to each other following the discovery event, and it would create</span>
<span class="cm"> * collisions on the medium (SNRM battle).</span>
<span class="cm"> * The &quot;fix&quot; for that is to disable all connection requests in IrLAP</span>
<span class="cm"> * for 100ms after a discovery indication by setting the media_busy flag.</span>
<span class="cm"> * Previously, we used to postpone the event which was quite ugly. Now</span>
<span class="cm"> * that IrLAP takes care of this problem, just pass the event up...</span>
<span class="cm"> *</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_link_discovery_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				     <span class="n">discovery_t</span> <span class="o">*</span><span class="n">discovery</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Add to main log, cleanup */</span>
	<span class="n">irlmp_add_discovery</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">discovery</span><span class="p">);</span>

	<span class="cm">/* Just handle it the same way as a discovery confirm,</span>
<span class="cm">	 * bypass the LM_LAP state machine (see below) */</span>
	<span class="n">irlmp_discovery_confirm</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">DISCOVERY_PASSIVE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_link_discovery_confirm (self, log)</span>
<span class="cm"> *</span>
<span class="cm"> *    Called by IrLAP with a list of discoveries after the discovery</span>
<span class="cm"> *    request has been carried out. A NULL log is received if IrLAP</span>
<span class="cm"> *    was unable to carry out the discovery request</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_link_discovery_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Add to main log, cleanup */</span>
	<span class="n">irlmp_add_discovery_log</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>

	<span class="cm">/* Propagate event to various LSAPs registered for it.</span>
<span class="cm">	 * We bypass the LM_LAP state machine because</span>
<span class="cm">	 *	1) We do it regardless of the LM_LAP state</span>
<span class="cm">	 *	2) It doesn&#39;t affect the LM_LAP state</span>
<span class="cm">	 *	3) Faster, slimer, simpler, ...</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">irlmp_discovery_confirm</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">DISCOVERY_ACTIVE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irlmp_update_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Prevent concurrent read to get garbage */</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="cm">/* Update cache entry */</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">lsap</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">slsap_sel</span> <span class="o">=</span> <span class="n">lsap</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">lsap</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_find_handle (self, dlsap_sel, slsap_sel, status, queue)</span>
<span class="cm"> *</span>
<span class="cm"> *    Find handle associated with destination and source LSAP</span>
<span class="cm"> *</span>
<span class="cm"> * Any IrDA connection (LSAP/TSAP) is uniquely identified by</span>
<span class="cm"> * 3 parameters, the local lsap, the remote lsap and the remote address.</span>
<span class="cm"> * We may initiate multiple connections to the same remote service</span>
<span class="cm"> * (they will have different local lsap), a remote device may initiate</span>
<span class="cm"> * multiple connections to the same local service (they will have</span>
<span class="cm"> * different remote lsap), or multiple devices may connect to the same</span>
<span class="cm"> * service and may use the same remote lsap (and they will have</span>
<span class="cm"> * different remote address).</span>
<span class="cm"> * So, where is the remote address ? Each LAP connection is made with</span>
<span class="cm"> * a single remote device, so imply a specific remote address.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="nf">irlmp_find_lsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dlsap_sel</span><span class="p">,</span>
				       <span class="n">__u8</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span>
				       <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Optimize for the common case. We assume that the last frame</span>
<span class="cm">	 *  received is in the same connection as the last one, so check in</span>
<span class="cm">	 *  cache first to avoid the linear search</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">slsap_sel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">dlsap_sel</span> <span class="o">==</span> <span class="n">dlsap_sel</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">lsap</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">lsap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lsap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If this is an incoming connection, then the destination</span>
<span class="cm">		 *  LSAP selector may have been specified as LM_ANY so that</span>
<span class="cm">		 *  any client can connect. In that case we only need to check</span>
<span class="cm">		 *  if the source LSAP (in our view!) match!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="n">CONNECT_CMD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">slsap_sel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">==</span> <span class="n">LSAP_ANY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This is where the dest lsap sel is set on incoming</span>
<span class="cm">			 * lsaps */</span>
			<span class="n">lsap</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">dlsap_sel</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Check if source LSAP and dest LSAP selectors match.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">slsap_sel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">==</span> <span class="n">dlsap_sel</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">lsap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
	<span class="k">if</span><span class="p">(</span><span class="n">lsap</span><span class="p">)</span>
		<span class="n">irlmp_update_cache</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">lsap</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Return what we&#39;ve found or NULL */</span>
	<span class="k">return</span> <span class="n">lsap</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
