<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irlap_event.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irlap_event.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irlap_event.c</span>
<span class="cm"> * Version:       0.9</span>
<span class="cm"> * Description:   IrLAP state machine implementation</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dag@brattli.net&gt;</span>
<span class="cm"> * Created at:    Sat Aug 16 00:59:29 1997</span>
<span class="cm"> * Modified at:   Sat Dec 25 21:07:57 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dag@brattli.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-2000 Dag Brattli &lt;dag@brattli.net&gt;,</span>
<span class="cm"> *     Copyright (c) 1998      Thomas Davis &lt;ratbert@radiks.net&gt;</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap_event.h&gt;</span>

<span class="cp">#include &lt;net/irda/timer.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap_frame.h&gt;</span>
<span class="cp">#include &lt;net/irda/qos.h&gt;</span>
<span class="cp">#include &lt;net/irda/parameters.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;		</span><span class="cm">/* irlmp_flow_indication(), ... */</span><span class="cp"></span>

<span class="cp">#include &lt;net/irda/irda_device.h&gt;</span>

<span class="cp">#ifdef CONFIG_IRDA_FAST_RR</span>
<span class="kt">int</span> <span class="n">sysctl_fast_poll_increase</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_ndm</span>    <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_query</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_reply</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_conn</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_setup</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_xmit_p</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_pclose</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_nrm_p</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_reset_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_reset</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_nrm_s</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_xmit_s</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_sclose</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_state_reset_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IRDA_DEBUG</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlap_event</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;DISCOVERY_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;CONNECT_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;CONNECT_RESPONSE&quot;</span><span class="p">,</span>
	<span class="s">&quot;DISCONNECT_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;DATA_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;RESET_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;RESET_RESPONSE&quot;</span><span class="p">,</span>
	<span class="s">&quot;SEND_I_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;SEND_UI_FRAME&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_DISCOVERY_XID_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_DISCOVERY_XID_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_SNRM_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_TEST_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_TEST_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_UA_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_DM_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_RD_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_I_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_I_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_UI_FRAME&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_FRMR_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_RR_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_RR_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_RNR_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_RNR_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_REJ_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_REJ_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_SREJ_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_SREJ_RSP&quot;</span><span class="p">,</span>
	<span class="s">&quot;RECV_DISC_CMD&quot;</span><span class="p">,</span>
	<span class="s">&quot;SLOT_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;QUERY_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;FINAL_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;POLL_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;DISCOVERY_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;WD_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;BACKOFF_TIMER_EXPIRED&quot;</span><span class="p">,</span>
	<span class="s">&quot;MEDIA_BUSY_TIMER_EXPIRED&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_IRDA_DEBUG */</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlap_state</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;LAP_NDM&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_QUERY&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_REPLY&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_CONN&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_SETUP&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_OFFLINE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_XMIT_P&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_PCLOSE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_NRM_P&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_RESET_WAIT&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_RESET&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_NRM_S&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_XMIT_S&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_SCLOSE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_RESET_CHECK&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">[])(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="n">irlap_state_ndm</span><span class="p">,</span>
	<span class="n">irlap_state_query</span><span class="p">,</span>
	<span class="n">irlap_state_reply</span><span class="p">,</span>
	<span class="n">irlap_state_conn</span><span class="p">,</span>
	<span class="n">irlap_state_setup</span><span class="p">,</span>
	<span class="n">irlap_state_offline</span><span class="p">,</span>
	<span class="n">irlap_state_xmit_p</span><span class="p">,</span>
	<span class="n">irlap_state_pclose</span><span class="p">,</span>
	<span class="n">irlap_state_nrm_p</span><span class="p">,</span>
	<span class="n">irlap_state_reset_wait</span><span class="p">,</span>
	<span class="n">irlap_state_reset</span><span class="p">,</span>
	<span class="n">irlap_state_nrm_s</span><span class="p">,</span>
	<span class="n">irlap_state_xmit_s</span><span class="p">,</span>
	<span class="n">irlap_state_sclose</span><span class="p">,</span>
	<span class="n">irlap_state_reset_check</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_poll_timer_expired (data)</span>
<span class="cm"> *</span>
<span class="cm"> *    Poll timer has expired. Normally we must now send a RR frame to the</span>
<span class="cm"> *    remote device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlap_poll_timer_expired</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">POLL_TIMER_EXPIRED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate and set time before we will have to send back the pf bit</span>
<span class="cm"> * to the peer. Use in primary.</span>
<span class="cm"> * Make sure that state is XMIT_P/XMIT_S when calling this function</span>
<span class="cm"> * (and that nobody messed up with the state). - Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlap_start_poll_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

<span class="cp">#ifdef CONFIG_IRDA_FAST_RR</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send out the RR frames faster if our own transmit queue is empty, or</span>
<span class="cm">	 * if the peer is busy. The effect is a much faster conversation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="o">||</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Assert that the fast poll timer has not reached the</span>
<span class="cm">			 *  normal poll timer yet</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR_timeout</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *  FIXME: this should be a more configurable</span>
<span class="cm">				 *         function</span>
<span class="cm">				 */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR_timeout</span> <span class="o">+=</span>
					<span class="p">(</span><span class="n">sysctl_fast_poll_increase</span> <span class="o">*</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>

				<span class="cm">/* Use this fast(er) timeout instead */</span>
				<span class="n">timeout</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR_timeout</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

			<span class="cm">/* Start with just 0 ms */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), timeout=%d (%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_FAST_RR */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">irlap_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">POLL_TIMER_EXPIRED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irda_start_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timer</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
				 <span class="n">irlap_poll_timer_expired</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_do_event (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    Rushes through the state machine without any delay. If state == XMIT</span>
<span class="cm"> *    then send queued data frames.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlap_do_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span> <span class="o">||</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">LAP_MAGIC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), event = %s, state = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">irlap_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">]);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">])(</span><span class="n">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if there are any pending events that needs to be executed</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LAP_XMIT_P</span>: <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">LAP_XMIT_S</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We just received the pf bit and are at the beginning</span>
<span class="cm">		 * of a new LAP transmit window.</span>
<span class="cm">		 * Check if there are any queued data frames, and do not</span>
<span class="cm">		 * try to disconnect link if we send any data frames, since</span>
<span class="cm">		 * that will change the state away form XMIT</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() : queue len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Prevent race conditions with irlap_data_request() */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">local_busy</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

			<span class="cm">/* Theory of operation.</span>
<span class="cm">			 * We send frames up to when we fill the window or</span>
<span class="cm">			 * reach line capacity. Those frames will queue up</span>
<span class="cm">			 * in the device queue, and the driver will slowly</span>
<span class="cm">			 * send them.</span>
<span class="cm">			 * After each frame that we send, we poll the higher</span>
<span class="cm">			 * layer for more data. It&#39;s the right time to do</span>
<span class="cm">			 * that because the link layer need to perform the mtt</span>
<span class="cm">			 * and then send the first frame, so we can afford</span>
<span class="cm">			 * to send a bit of time in kernel space.</span>
<span class="cm">			 * The explicit flow indication allow to minimise</span>
<span class="cm">			 * buffers (== lower latency), to avoid higher layer</span>
<span class="cm">			 * polling via timers (== less context switches) and</span>
<span class="cm">			 * to implement a crude scheduler - Jean II */</span>

			<span class="cm">/* Try to send away all queued data frames */</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Send one frame */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">])(</span><span class="n">self</span><span class="p">,</span> <span class="n">SEND_I_CMD</span><span class="p">,</span>
							    <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="cm">/* Drop reference count.</span>
<span class="cm">				 * It will be increase as needed in</span>
<span class="cm">				 * irlap_send_data_xxx() */</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

				<span class="cm">/* Poll the higher layers for one more frame */</span>
				<span class="n">irlmp_flow_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						      <span class="n">FLOW_START</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span> <span class="cm">/* Try again later! */</span>
			<span class="p">}</span>
			<span class="cm">/* Finished transmitting */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">local_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">])(</span><span class="n">self</span><span class="p">,</span> <span class="n">DISCONNECT_REQUEST</span><span class="p">,</span>
						    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cm">/*	case LAP_NDM: */</span>
<span class="cm">/*	case LAP_CONN: */</span>
<span class="cm">/*	case LAP_RESET_WAIT: */</span>
<span class="cm">/*	case LAP_RESET_CHECK: */</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_ndm (event, skb, frame)</span>
<span class="cm"> *</span>
<span class="cm"> *    NDM (Normal Disconnected Mode) state</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_ndm</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">discovery_t</span> <span class="o">*</span><span class="n">discovery_rsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CONNECT_REQUEST</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Note : this will never happen, because we test</span>
<span class="cm">			 * media busy in irlap_connect_request() and</span>
<span class="cm">			 * postpone the event... - Jean II */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), CONNECT_REQUEST: media busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>

			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_MEDIA_BUSY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">irlap_send_snrm_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>

			<span class="cm">/* Start Final-bit timer */</span>
			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>

			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_SETUP</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_SNRM_CMD</span>:
		<span class="cm">/* Check if the frame contains and I field */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">;</span>

			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_CONN</span><span class="p">);</span>

			<span class="n">irlap_connect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), SNRM frame does not &quot;</span>
				   <span class="s">&quot;contain an I field!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISCOVERY_REQUEST</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), DISCOVERY_REQUEST: media busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="cm">/* irlap-&gt;log.condition = MEDIA_BUSY; */</span>

			<span class="cm">/* This will make IrLMP try again */</span>
			<span class="n">irlap_discovery_confirm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="cm">/* Note : the discovery log is not cleaned up here,</span>
<span class="cm">			 * it will be done in irlap_discovery_request()</span>
<span class="cm">			 * Jean II */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">S</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">;</span>
		<span class="n">irlap_send_discovery_xid_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span>
					       <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">frame_sent</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>

		<span class="n">irlap_start_slot_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slot_timeout</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_QUERY</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DISCOVERY_XID_CMD</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="cm">/* Assert that this is not the final slot */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">irlap_generate_rand_time_slot</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span>
								   <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">discovery_rsp</span> <span class="o">=</span> <span class="n">irlmp_get_discovery_response</span><span class="p">();</span>
				<span class="n">discovery_rsp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>

				<span class="n">irlap_send_discovery_xid_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span>
							       <span class="n">self</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span>
							       <span class="n">FALSE</span><span class="p">,</span>
							       <span class="n">discovery_rsp</span><span class="p">);</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">frame_sent</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">frame_sent</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Go to reply state until end of discovery to</span>
<span class="cm">			 * inhibit our own transmissions. Set the timer</span>
<span class="cm">			 * to not stay forever there... Jean II</span>
<span class="cm">			 */</span>
			<span class="n">irlap_start_query_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_REPLY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* This is the final slot. How is it possible ?</span>
<span class="cm">		 * This would happen is both discoveries are just slightly</span>
<span class="cm">		 * offset (if they are in sync, all packets are lost).</span>
<span class="cm">		 * Most often, all the discovery requests will be received</span>
<span class="cm">		 * in QUERY state (see my comment there), except for the</span>
<span class="cm">		 * last frame that will come here.</span>
<span class="cm">		 * The big trouble when it happen is that active discovery</span>
<span class="cm">		 * doesn&#39;t happen, because nobody answer the discoveries</span>
<span class="cm">		 * frame of the other guy, so the log shows up empty.</span>
<span class="cm">		 * What should we do ?</span>
<span class="cm">		 * Not much. It&#39;s too late to answer those discovery frames,</span>
<span class="cm">		 * so we just pass the info to IrLMP who will put it in the</span>
<span class="cm">		 * log (and post an event).</span>
<span class="cm">		 * Another cause would be devices that do discovery much</span>
<span class="cm">		 * slower than us, however the latest fixes should minimise</span>
<span class="cm">		 * those cases...</span>
<span class="cm">		 * Jean II</span>
<span class="cm">		 */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Receiving final discovery request, missed the discovery slots :-(</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="cm">/* Last discovery request -&gt; in the log */</span>
			<span class="n">irlap_discovery_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEDIA_BUSY_TIMER_EXPIRED</span>:
		<span class="cm">/* A bunch of events may be postponed because the media is</span>
<span class="cm">		 * busy (usually immediately after we close a connection),</span>
<span class="cm">		 * or while we are doing discovery (state query/reply).</span>
<span class="cm">		 * In all those cases, the media busy flag will be cleared</span>
<span class="cm">		 * when it&#39;s OK for us to process those postponed events.</span>
<span class="cm">		 * This event is not mentioned in the state machines in the</span>
<span class="cm">		 * IrLAP spec. It&#39;s because they didn&#39;t consider Ultra and</span>
<span class="cm">		 * postponing connection request is optional.</span>
<span class="cm">		 * Jean II */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
		<span class="cm">/* Send any pending Ultra frames if any */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq_ultra</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* We don&#39;t send the frame, just post an event.</span>
<span class="cm">			 * Also, previously this code was in timer.c...</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">])(</span><span class="n">self</span><span class="p">,</span> <span class="n">SEND_UI_FRAME</span><span class="p">,</span>
						    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>
		<span class="cm">/* Check if we should try to connect.</span>
<span class="cm">		 * This code was previously in irlap_do_event() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connect_pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">connect_pending</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

			<span class="cm">/* This one *should* not pend in this state, except</span>
<span class="cm">			 * if a socket try to connect and immediately</span>
<span class="cm">			 * disconnect. - clear - Jean II */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span><span class="p">)</span>
				<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">])(</span><span class="n">self</span><span class="p">,</span>
							    <span class="n">CONNECT_REQUEST</span><span class="p">,</span>
							    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Note : one way to test if this code works well (including</span>
<span class="cm">		 * media busy and small busy) is to create a user space</span>
<span class="cm">		 * application generating an Ultra packet every 3.05 sec (or</span>
<span class="cm">		 * 2.95 sec) and to see how it interact with discovery.</span>
<span class="cm">		 * It&#39;s fairly easy to check that no packet is lost, that the</span>
<span class="cm">		 * packets are postponed during discovery and that after</span>
<span class="cm">		 * discovery indication you have a 100ms &quot;gap&quot;.</span>
<span class="cm">		 * As connection request and Ultra are now processed the same</span>
<span class="cm">		 * way, this avoid the tedious job of trying IrLAP connection</span>
<span class="cm">		 * in all those cases...</span>
<span class="cm">		 * Jean II */</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
	<span class="k">case</span> <span class="n">SEND_UI_FRAME</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* Only allowed to repeat an operation twice */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">((</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media_busy</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">));</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq_ultra</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">irlap_send_ui_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">CBROADCAST</span><span class="p">,</span>
						    <span class="n">CMD_FRAME</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* irlap_send_ui_frame() won&#39;t increase skb reference</span>
<span class="cm">			 * count, so no dev_kfree_skb() - Jean II */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Force us to listen 500 ms again */</span>
			<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">RECV_UI_FRAME</span>:
		<span class="cm">/* Only accept broadcast frames in NDM mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">caddr</span> <span class="o">!=</span> <span class="n">CBROADCAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), not a broadcast frame!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">irlap_unitdata_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>
	<span class="k">case</span> <span class="n">RECV_TEST_CMD</span>:
		<span class="cm">/* Remove test frame header */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">test_frame</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Send response. This skb will not be sent out again, and</span>
<span class="cm">		 * will only be used to send out the same info as the cmd</span>
<span class="cm">		 */</span>
		<span class="n">irlap_send_test_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CBROADCAST</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_TEST_RSP</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_query (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    QUERY state</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RECV_DISCOVERY_XID_RSP</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), daddr=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">daddr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: discovery log is gone! &quot;</span>
				     <span class="s">&quot;maybe the discovery timeout has been set&quot;</span>
				     <span class="s">&quot; too short?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="p">,</span>
			       <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/* Keep state */</span>
		<span class="cm">/* irlap_next_state(self, LAP_QUERY);  */</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DISCOVERY_XID_CMD</span>:
		<span class="cm">/* Yes, it is possible to receive those frames in this mode.</span>
<span class="cm">		 * Note that most often the last discovery request won&#39;t</span>
<span class="cm">		 * occur here but in NDM state (see my comment there).</span>
<span class="cm">		 * What should we do ?</span>
<span class="cm">		 * Not much. We are currently performing our own discovery,</span>
<span class="cm">		 * therefore we can&#39;t answer those frames. We don&#39;t want</span>
<span class="cm">		 * to change state either. We just pass the info to</span>
<span class="cm">		 * IrLMP who will put it in the log (and post an event).</span>
<span class="cm">		 * Jean II</span>
<span class="cm">		 */</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Receiving discovery request (s = %d) while performing discovery :-(</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>

		<span class="cm">/* Last discovery request ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="n">irlap_discovery_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SLOT_TIMER_EXPIRED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Wait a little longer if we detect an incoming frame. This</span>
<span class="cm">		 * is not mentioned in the spec, but is a good thing to do,</span>
<span class="cm">		 * since we want to work even with devices that violate the</span>
<span class="cm">		 * timing requirements.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irda_device_is_receiving</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">add_wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), device is slow to answer, &quot;</span>
				   <span class="s">&quot;waiting some more!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlap_start_slot_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">add_wait</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">add_wait</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_send_discovery_xid_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span>
						       <span class="n">self</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span>
						       <span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>
			<span class="n">irlap_start_slot_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slot_timeout</span><span class="p">);</span>

			<span class="cm">/* Keep state */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_QUERY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* This is the final slot! */</span>
			<span class="n">irlap_send_discovery_xid_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
						       <span class="n">TRUE</span><span class="p">,</span>
						       <span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">);</span>

			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  We are now finished with the discovery procedure,</span>
<span class="cm">			 *  so now we must return the results</span>
<span class="cm">			 */</span>
			<span class="n">irlap_discovery_confirm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span><span class="p">);</span>

			<span class="cm">/* IrLMP should now have taken care of the log */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">discovery_log</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_reply (self, event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    REPLY, we have received a XID discovery frame from a device and we</span>
<span class="cm"> *    are waiting for the right time slot to send a response XID frame</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">discovery_t</span> <span class="o">*</span><span class="n">discovery_rsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">QUERY_TIMER_EXPIRED</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), QUERY_TIMER_EXPIRED &lt;%ld&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DISCOVERY_XID_CMD</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="cm">/* Last frame? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_timer</span><span class="p">);</span>

			<span class="cm">/* info-&gt;log.condition = REMOTE; */</span>

			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

			<span class="n">irlap_discovery_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* If it&#39;s our slot, send our reply */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">frame_sent</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">discovery_rsp</span> <span class="o">=</span> <span class="n">irlmp_get_discovery_response</span><span class="p">();</span>
				<span class="n">discovery_rsp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>

				<span class="n">irlap_send_discovery_xid_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span>
							       <span class="n">self</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span>
							       <span class="n">FALSE</span><span class="p">,</span>
							       <span class="n">discovery_rsp</span><span class="p">);</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">frame_sent</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Readjust our timer to accommodate devices</span>
<span class="cm">			 * doing faster or slower discovery than us...</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">irlap_start_query_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>

			<span class="cm">/* Keep state */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>irlap<em>next</em>state(self, LAP_REPLY);</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">event</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_conn (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    CONN, we have received a SNRM command and is waiting for the upper</span>
<span class="cm"> *    layer to accept or refuse connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span> <span class="n">event</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CONNECT_RESPONSE</span>:
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">snrm_frame</span><span class="p">));</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">irlap_qos_negotiate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">irlap_initiate_connection_state</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Applying the parameters now will make sure we change speed</span>
<span class="cm">		 * *after* we have sent the next frame</span>
<span class="cm">		 */</span>
		<span class="n">irlap_apply_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sending this frame will force a speed change after it has</span>
<span class="cm">		 * been sent (i.e. the frame will be sent at 9600).</span>
<span class="cm">		 */</span>
		<span class="n">irlap_send_ua_response_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/*</span>
<span class="c">		 * We are allowed to send two frames, but this may increase</span>
<span class="c">		 * the connect latency, so lets not do it for now.</span>
<span class="c">		 */</span>
<span class="c">		/* This is full of good intentions, but doesn&#39;t work in</span>
<span class="c">		 * practice.</span>
<span class="c">		 * After sending the first UA response, we switch the</span>
<span class="c">		 * dongle to the negotiated speed, which is usually</span>
<span class="c">		 * different than 9600 kb/s.</span>
<span class="c">		 * From there, there is two solutions :</span>
<span class="c">		 * 1) The other end has received the first UA response :</span>
<span class="c">		 * it will set up the connection, move to state LAP_NRM_P,</span>
<span class="c">		 * and will ignore and drop the second UA response.</span>
<span class="c">		 * Actually, it&#39;s even worse : the other side will almost</span>
<span class="c">		 * immediately send a RR that will likely collide with the</span>
<span class="c">		 * UA response (depending on negotiated turnaround).</span>
<span class="c">		 * 2) The other end has not received the first UA response,</span>
<span class="c">		 * will stay at 9600 and will never see the second UA response.</span>
<span class="c">		 * Jean II */</span>
<span class="c">		irlap_send_ua_response_frame(self, &amp;self-&gt;qos_rx);</span>
<span class="cp">#endif</span>

		<span class="cm">/*</span>
<span class="cm">		 *  The WD-timer could be set to the duration of the P-timer</span>
<span class="cm">		 *  for this case, but it is recommended to use twice the</span>
<span class="cm">		 *  value (note 3 IrLAP p. 60).</span>
<span class="cm">		 */</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DISCOVERY_XID_CMD</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), event RECV_DISCOVER_XID_CMD!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISCONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Disconnect request!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlap_send_dm_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>
		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">event</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_setup (event, skb, frame)</span>
<span class="cm"> *</span>
<span class="cm"> *    SETUP state, The local layer has transmitted a SNRM command frame to</span>
<span class="cm"> *    a remote peer layer and is awaiting a reply .</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FINAL_TIMER_EXPIRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N3</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> *  Perform random backoff, Wait a random number of time units, minimum</span>
<span class="cm"> *  duration half the time taken to transmitt a SNRM frame, maximum duration</span>
<span class="cm"> *  1.5 times the time taken to transmit a SNRM frame. So this time should</span>
<span class="cm"> *  between 15 msecs and 45 msecs.</span>
<span class="cm"> */</span>
			<span class="n">irlap_start_backoff_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span> <span class="o">+</span>
							<span class="p">(</span><span class="n">jiffies</span> <span class="o">%</span> <span class="mi">30</span><span class="p">)));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_FOUND_NONE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BACKOFF_TIMER_EXPIRED</span>:
		<span class="n">irlap_send_snrm_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_SNRM_CMD</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), SNRM battle!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  The device with the largest device address wins the battle</span>
<span class="cm">		 *  (both have sent a SNRM command!)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
			<span class="n">irlap_initiate_connection_state</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">snrm_frame</span><span class="p">));</span>

			<span class="n">irlap_qos_negotiate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="cm">/* Send UA frame and then change link settings */</span>
			<span class="n">irlap_apply_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
			<span class="n">irlap_send_ua_response_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>

			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
			<span class="n">irlap_connect_confirm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  The WD-timer could be set to the duration of the</span>
<span class="cm">			 *  P-timer for this case, but it is recommended</span>
<span class="cm">			 *  to use twice the value (note 3 IrLAP p. 60).</span>
<span class="cm">			 */</span>
			<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We just ignore the other device! */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_SETUP</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_UA_RSP</span>:
		<span class="cm">/* Stop F-timer */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

		<span class="cm">/* Initiate connection state */</span>
		<span class="n">irlap_initiate_connection_state</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/* Negotiate connection parameters */</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ua_frame</span><span class="p">));</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">irlap_qos_negotiate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* Set the new link setting *now* (before the rr frame) */</span>
		<span class="n">irlap_apply_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Wait for turnaround time to give a chance to the other</span>
<span class="cm">		 * device to be ready to receive us.</span>
<span class="cm">		 * Note : the time to switch speed is typically larger</span>
<span class="cm">		 * than the turnaround time, but as we don&#39;t have the other</span>
<span class="cm">		 * side speed switch time, that&#39;s our best guess...</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

		<span class="cm">/* This frame will actually be sent at the new speed */</span>
		<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>

		<span class="cm">/* The timer is set to half the normal timer to quickly</span>
<span class="cm">		 * detect a failure to negotiate the new connection</span>
<span class="cm">		 * parameters. IrLAP 6.11.3.2, note 3.</span>
<span class="cm">		 * Note that currently we don&#39;t process this failure</span>
<span class="cm">		 * properly, as we should do a quick disconnect.</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>

		<span class="n">irlap_connect_confirm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DM_RSP</span>:     <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">RECV_DISC_CMD</span>:
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">event</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_offline (self, event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    OFFLINE state, not used for now!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_xmit_p (self, event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    XMIT, Only the primary station has right to transmit, and we</span>
<span class="cm"> *    therefore do not expect to receive any transmissions from other</span>
<span class="cm"> *    stations.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_xmit_p</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEND_I_CMD</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Only send frame if send-window &gt; 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nextfit</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IRDA_DYNAMIC_WINDOW</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_next</span><span class="p">;</span>

			<span class="cm">/* With DYNAMIC_WINDOW, we keep the window size</span>
<span class="cm">			 * maximum, and adapt on the packets we are sending.</span>
<span class="cm">			 * At 115k, we can send only 2 packets of 2048 bytes</span>
<span class="cm">			 * in a 500 ms turnaround. Without this option, we</span>
<span class="cm">			 * would always limit the window to 2. With this</span>
<span class="cm">			 * option, if we send smaller packets, we can send</span>
<span class="cm">			 * up to 7 of them (always depending on QoS).</span>
<span class="cm">			 * Jean II */</span>

			<span class="cm">/* Look at the next skb. This is safe, as we are</span>
<span class="cm">			 * the only consumer of the Tx queue (if we are not,</span>
<span class="cm">			 * we have other problems) - Jean II */</span>
			<span class="n">skb_next</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>

			<span class="cm">/* Check if a subsequent skb exist and would fit in</span>
<span class="cm">			 * the current window (with respect to turnaround</span>
<span class="cm">			 * time).</span>
<span class="cm">			 * This allow us to properly mark the current packet</span>
<span class="cm">			 * with the pf bit, to avoid falling back on the</span>
<span class="cm">			 * second test below, and avoid waiting the</span>
<span class="cm">			 * end of the window and sending a extra RR.</span>
<span class="cm">			 * Note : (skb_next != NULL) &lt;=&gt; (skb_queue_len() &gt; 0)</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">nextfit</span> <span class="o">=</span> <span class="p">((</span><span class="n">skb_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">((</span><span class="n">skb_next</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;=</span>
				    <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * The current packet may not fit ! Because of test</span>
<span class="cm">			 * above, this should not happen any more !!!</span>
<span class="cm">			 *  Test if we have transmitted more bytes over the</span>
<span class="cm">			 *  link than its possible to do with the current</span>
<span class="cm">			 *  speed and turn-around-time.</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">((</span><span class="o">!</span><span class="n">nextfit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Not allowed to transmit&quot;</span>
					   <span class="s">&quot; more bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="cm">/* Requeue the skb */</span>
				<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
				<span class="cm">/*</span>
<span class="cm">				 *  We should switch state to LAP_NRM_P, but</span>
<span class="cm">				 *  that is not possible since we must be sure</span>
<span class="cm">				 *  that we poll the other side. Since we have</span>
<span class="cm">				 *  used up our time, the poll timer should</span>
<span class="cm">				 *  trigger anyway now, so we just wait for it</span>
<span class="cm">				 *  DB</span>
<span class="cm">				 */</span>
				<span class="cm">/*</span>
<span class="cm">				 * Sorry, but that&#39;s not totally true. If</span>
<span class="cm">				 * we send 2000B packets, we may wait another</span>
<span class="cm">				 * 1000B until our turnaround expire. That&#39;s</span>
<span class="cm">				 * why we need to be proactive in avoiding</span>
<span class="cm">				 * coming here. - Jean II</span>
<span class="cm">				 */</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Subtract space used by this skb */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="cp">#else	</span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
			<span class="cm">/* Window has been adjusted for the max packet</span>
<span class="cm">			 * size, so much simpler... - Jean II */</span>
			<span class="n">nextfit</span> <span class="o">=</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
			<span class="cm">/*</span>
<span class="cm">			 *  Send data with poll bit cleared only if window &gt; 1</span>
<span class="cm">			 *  and there is more frames after this one to be sent</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nextfit</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* More packet to send in current window */</span>
				<span class="n">irlap_send_data_primary</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Final packet of window */</span>
				<span class="n">irlap_send_data_primary_poll</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Make sure state machine does not try to send</span>
<span class="cm">				 * any more frames</span>
<span class="cm">				 */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#ifdef CONFIG_IRDA_FAST_RR</span>
			<span class="cm">/* Peer may want to reply immediately */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_FAST_RR */</span><span class="cp"></span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to send! remote busy?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 *  The next ret is important, because it tells</span>
<span class="cm">			 *  irlap_next_state _not_ to deliver more frames</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">POLL_TIMER_EXPIRED</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), POLL_TIMER_EXPIRED &lt;%ld&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">__func__</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
		<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
		<span class="cm">/* Return to NRM properly - Jean II  */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IRDA_DYNAMIC_WINDOW</span>
		<span class="cm">/* Allowed to transmit a maximum number of bytes again. */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">line_capacity</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISCONNECT_REQUEST</span>:
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timer</span><span class="p">);</span>
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_send_disc_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_PCLOSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATA_REQUEST</span>:
		<span class="cm">/* Nothing to do, irlap_do_event() will send the packet</span>
<span class="cm">		 * when we return... - Jean II */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_pclose (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    PCLOSE state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_pclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RECV_UA_RSP</span>: <span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">RECV_DM_RSP</span>:
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

		<span class="cm">/* Set new link parameters */</span>
		<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/* Always switch state before calling upper layers */</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FINAL_TIMER_EXPIRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_disc_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* Keep state */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="cm">/*  Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NO_RESPONSE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_nrm_p (self, event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *   NRM_P (Normal Response Mode as Primary), The primary station has given</span>
<span class="cm"> *   permissions to a secondary station to transmit IrLAP resonse frames</span>
<span class="cm"> *   (by sending a frame with the P bit set). The primary station will not</span>
<span class="cm"> *   transmit any frames and is expecting to receive frames only from the</span>
<span class="cm"> *   secondary to which transmission permissions has been given.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_nrm_p</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ns_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_status</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RECV_I_RSP</span>: <span class="cm">/* Optimize for the common case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">LAP_ADDR_HEADER</span> <span class="o">+</span> <span class="n">LAP_CTRL_HEADER</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Input validation check: a stir4200/mcp2150</span>
<span class="cm">			 * combination sometimes results in an empty i:rsp.</span>
<span class="cm">			 * This makes no sense; we can just ignore the frame</span>
<span class="cm">			 * and send an rr:cmd immediately. This happens before</span>
<span class="cm">			 * changing nr or ns so triggers a retransmit</span>
<span class="cm">			 */</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
			<span class="cm">/* Keep state */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIXME: must check for remote_busy below */</span>
<span class="cp">#ifdef CONFIG_IRDA_FAST_RR</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Reset the fast_RR so we can use the fast RR code with</span>
<span class="cm">		 *  full speed the next time since peer may have more frames</span>
<span class="cm">		 *  to transmitt</span>
<span class="cm">		 */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">fast_RR</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_FAST_RR */</span><span class="cp"></span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">ns_status</span> <span class="o">=</span> <span class="n">irlap_validate_ns_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
		<span class="n">nr_status</span> <span class="o">=</span> <span class="n">irlap_validate_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Check for expected I(nformation) frame</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_EXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_EXPECTED</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Update Vr (next frame for us to receive) */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

			<span class="cm">/* Update Nr received, cleanup our retry queue */</span>
			<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  Got expected NR, so reset the</span>
<span class="cm">			 *  retry_count. This is not done by IrLAP spec,</span>
<span class="cm">			 *  which is strange!</span>
<span class="cm">			 */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

			<span class="cm">/*  poll bit cleared?  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Keep state, do not move this line */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>

				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* No longer waiting for pf */</span>
				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

				<span class="cm">/* Call higher layer *before* changing state</span>
<span class="cm">				 * to give them a chance to send data in the</span>
<span class="cm">				 * next LAP frame.</span>
<span class="cm">				 * Jean II */</span>
				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

				<span class="cm">/* XMIT states are the most dangerous state</span>
<span class="cm">				 * to be in, because user requests are</span>
<span class="cm">				 * processed directly and may change state.</span>
<span class="cm">				 * On the other hand, in NDM_P, those</span>
<span class="cm">				 * requests are queued and we will process</span>
<span class="cm">				 * them when we return to irlap_do_event().</span>
<span class="cm">				 * Jean II</span>
<span class="cm">				 */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>

				<span class="cm">/* This is the last frame.</span>
<span class="cm">				 * Make sure it&#39;s always called in XMIT state.</span>
<span class="cm">				 * - Jean II */</span>
				<span class="n">irlap_start_poll_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="cm">/* Unexpected next to send (Ns) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_UNEXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_EXPECTED</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 *  Wait until the last frame before doing</span>
<span class="cm">				 *  anything</span>
<span class="cm">				 */</span>

				<span class="cm">/* Keep state */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>
				       <span class="s">&quot;%s(), missing or duplicate frame!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">__func__</span><span class="p">);</span>

				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
				<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

				<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Unexpected next to receive (Nr)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_EXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_UNEXPECTED</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="cm">/* Resend rejected frames */</span>
				<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

				<span class="cm">/* Make sure we account for the time</span>
<span class="cm">				 * to transmit our frames. See comemnts</span>
<span class="cm">				 * in irlap_send_data_primary_poll().</span>
<span class="cm">				 * Jean II */</span>
				<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>

				<span class="cm">/* Keep state, do not move this line */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>

				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *  Do not resend frames until the last</span>
<span class="cm">				 *  frame has arrived from the other</span>
<span class="cm">				 *  device. This is not documented in</span>
<span class="cm">				 *  IrLAP!!</span>
<span class="cm">				 */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

				<span class="cm">/* Keep state, do not move this line!*/</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>

				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Unexpected next to send (Ns) and next to receive (Nr)</span>
<span class="cm">		 *  Not documented by IrLAP!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_UNEXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_UNEXPECTED</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), unexpected nr and ns!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Resend rejected frames */</span>
				<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>

				<span class="cm">/* Give peer some time to retransmit!</span>
<span class="cm">				 * But account for our own Tx. */</span>
				<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>

				<span class="cm">/* Keep state, do not move this line */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Update Nr received */</span>
				<span class="cm">/* irlap_update_nr_received( info-&gt;nr); */</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Invalid NR or NS</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_INVALID</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_INVALID</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_WAIT</span><span class="p">);</span>

				<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_INDICATION</span><span class="p">);</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">xmitflag</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

				<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_INDICATION</span><span class="p">);</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">xmitflag</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s, ns_status=%d, nr_status=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">ns_status</span><span class="p">,</span> <span class="n">nr_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_UI_FRAME</span>:
		<span class="cm">/* Poll bit cleared? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
			<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: RECV_UI_FRAME: next state %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">]);</span>
			<span class="n">irlap_start_poll_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_RR_RSP</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  If you get a RR, the remote isn&#39;t busy anymore,</span>
<span class="cm">		 *  no matter what the NR</span>
<span class="cm">		 */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="cm">/* Stop final timer */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Nr as expected?</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">irlap_validate_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NR_EXPECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Update Nr received */</span>
			<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  Got expected NR, so reset the retry_count. This</span>
<span class="cm">			 *  is not done by the IrLAP standard , which is</span>
<span class="cm">			 *  strange! DB.</span>
<span class="cm">			 */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>

			<span class="cm">/* Start poll timer */</span>
			<span class="n">irlap_start_poll_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NR_UNEXPECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Unexpected nr!</span>
<span class="cm">			 */</span>

			<span class="cm">/* Update Nr received */</span>
			<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;RECV_RR_FRAME: Retrans:%d, nr=%d, va=%d, &quot;</span>
			      <span class="s">&quot;vs=%d, vr=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">va</span><span class="p">,</span>
			      <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span><span class="p">);</span>

			<span class="cm">/* Resend rejected frames */</span>
			<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_P</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NR_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Received RR with &quot;</span>
				   <span class="s">&quot;invalid nr !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_WAIT</span><span class="p">);</span>

			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_INDICATION</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">xmitflag</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_RNR_RSP</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="cm">/* Stop final timer */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

		<span class="cm">/* Update Nr received */</span>
		<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>

		<span class="cm">/* Start poll timer */</span>
		<span class="n">irlap_start_poll_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_FRMR_RSP</span>:
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">xmitflag</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_WAIT</span><span class="p">);</span>
		<span class="n">irlap_reset_indication</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FINAL_TIMER_EXPIRED</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  We are allowed to wait for additional 300 ms if</span>
<span class="cm">		 *  final timer expires when we are in the middle</span>
<span class="cm">		 *  of receiving a frame (page 45, IrLAP). Check that</span>
<span class="cm">		 *  we only do this once for each frame.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irda_device_is_receiving</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">add_wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;FINAL_TIMER_EXPIRED when receiving a &quot;</span>
			      <span class="s">&quot;frame! Waiting a little bit more!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">300</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 *  Don&#39;t allow this to happen one more time in a row,</span>
<span class="cm">			 *  or else we can get a pretty tight loop here if</span>
<span class="cm">			 *  if we only receive half a frame. DB.</span>
<span class="cm">			 */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">add_wait</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">add_wait</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="cm">/* N2 is the disconnect timer. Until we reach it, we retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wx_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Retry sending the pf bit to the secondary */</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;nrm_p: resending rr&quot;</span><span class="p">);</span>
				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
				<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;nrm_p: resend frames&quot;</span><span class="p">);</span>
				<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;irlap_state_nrm_p: FINAL_TIMER_EXPIRED:&quot;</span>
				   <span class="s">&quot; retry_count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="p">);</span>

			<span class="cm">/* Early warning event. I&#39;m using a pretty liberal</span>
<span class="cm">			 * interpretation of the spec and generate an event</span>
<span class="cm">			 * every time the timer is multiple of N1 (and not</span>
<span class="cm">			 * only the first time). This allow application</span>
<span class="cm">			 * to know precisely if connectivity restart...</span>
<span class="cm">			 * Jean II */</span>
			<span class="k">if</span><span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">%</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">irlap_status_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>
							<span class="n">STATUS_NO_ACTIVITY</span><span class="p">);</span>

			<span class="cm">/* Keep state */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>
			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NO_RESPONSE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_REJ_RSP</span>:
		<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_SREJ_RSP</span>:
		<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">irlap_resend_rejected_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">CMD_FRAME</span><span class="p">);</span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_RD_RSP</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), RECV_RD_RSP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>
		<span class="cm">/* Call back the LAP state machine to do a proper disconnect */</span>
		<span class="n">irlap_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_reset_wait (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    We have informed the service user of a reset condition, and is</span>
<span class="cm"> *    awaiting reset of disconnect request.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_reset_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), event = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RESET_REQUEST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">xmitflag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_snrm_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISCONNECT_REQUEST</span>:
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_send_disc_frame</span><span class="p">(</span> <span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_flush_all_queues</span><span class="p">(</span> <span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_start_final_timer</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">irlap_next_state</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="n">LAP_PCLOSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_reset (self, event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    We have sent a SNRM reset command to the peer layer, and is awaiting</span>
<span class="cm"> *    reply.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), event = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RECV_DISC_CMD</span>:
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

		<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/* Always switch state before calling upper layers */</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NO_RESPONSE</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_UA_RSP</span>:
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timer</span><span class="p">);</span>

		<span class="cm">/* Initiate connection state */</span>
		<span class="n">irlap_initiate_connection_state</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">irlap_reset_confirm</span><span class="p">();</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_P</span><span class="p">);</span>

		<span class="n">irlap_start_poll_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">poll_timeout</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FINAL_TIMER_EXPIRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

			<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
			<span class="n">irlap_send_snrm_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_dev</span><span class="p">);</span>

			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Experimental!! */</span>

			<span class="n">irlap_start_final_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">final_timeout</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">N3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NO_RESPONSE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_SNRM_CMD</span>:
		<span class="cm">/*</span>
<span class="cm">		 * SNRM frame is not allowed to contain an I-field in this</span>
<span class="cm">		 * state</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), RECV_SNRM_CMD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlap_initiate_connection_state</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_ua_response_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>
			<span class="n">irlap_reset_confirm</span><span class="p">();</span>
			<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
				   <span class="s">&quot;%s(), SNRM frame contained an I field!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_xmit_s (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *   XMIT_S, The secondary station has been given the right to transmit,</span>
<span class="cm"> *   and we therefore do not expect to receive any transmissions from other</span>
<span class="cm"> *   stations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_xmit_s</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEND_I_CMD</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Send frame only if send window &gt; 0</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nextfit</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IRDA_DYNAMIC_WINDOW</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_next</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Same deal as in irlap_state_xmit_p(), so see</span>
<span class="cm">			 * the comments at that point.</span>
<span class="cm">			 * We are the secondary, so there are only subtle</span>
<span class="cm">			 * differences. - Jean II</span>
<span class="cm">			 */</span>

			<span class="cm">/* Check if a subsequent skb exist and would fit in</span>
<span class="cm">			 * the current window (with respect to turnaround</span>
<span class="cm">			 * time). - Jean II */</span>
			<span class="n">skb_next</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
			<span class="n">nextfit</span> <span class="o">=</span> <span class="p">((</span><span class="n">skb_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">((</span><span class="n">skb_next</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;=</span>
				    <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 *  Test if we have transmitted more bytes over the</span>
<span class="cm">			 *  link than its possible to do with the current</span>
<span class="cm">			 *  speed and turn-around-time.</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">((</span><span class="o">!</span><span class="n">nextfit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Not allowed to transmit&quot;</span>
					   <span class="s">&quot; more bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="cm">/* Requeue the skb */</span>
				<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

				<span class="cm">/*</span>
<span class="cm">				 *  Switch to NRM_S, this is only possible</span>
<span class="cm">				 *  when we are in secondary mode, since we</span>
<span class="cm">				 *  must be sure that we don&#39;t miss any RR</span>
<span class="cm">				 *  frames</span>
<span class="cm">				 */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">;</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">line_capacity</span><span class="p">;</span>
				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
				<span class="cm">/* Slight difference with primary :</span>
<span class="cm">				 * here we would wait for the other side to</span>
<span class="cm">				 * expire the turnaround. - Jean II */</span>

				<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span> <span class="cm">/* Try again later */</span>
			<span class="p">}</span>
			<span class="cm">/* Subtract space used by this skb */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="cp">#else	</span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
			<span class="cm">/* Window has been adjusted for the max packet</span>
<span class="cm">			 * size, so much simpler... - Jean II */</span>
			<span class="n">nextfit</span> <span class="o">=</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
			<span class="cm">/*</span>
<span class="cm">			 *  Send data with final bit cleared only if window &gt; 1</span>
<span class="cm">			 *  and there is more frames to be sent</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nextfit</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">irlap_send_data_secondary</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_S</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">irlap_send_data_secondary_final</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Make sure state machine does not try to send</span>
<span class="cm">				 * any more frames</span>
<span class="cm">				 */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to send!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISCONNECT_REQUEST</span>:
		<span class="n">irlap_send_rd_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_SCLOSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATA_REQUEST</span>:
		<span class="cm">/* Nothing to do, irlap_do_event() will send the packet</span>
<span class="cm">		 * when we return... - Jean II */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_nrm_s (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    NRM_S (Normal Response Mode as Secondary) state, in this state we are</span>
<span class="cm"> *    expecting to receive frames from the primary station</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_nrm_s</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ns_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span> <span class="n">event</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RECV_I_CMD</span>: <span class="cm">/* Optimize for the common case */</span>
		<span class="cm">/* FIXME: must check for remote_busy below */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s nr=%d, vs=%d, ns=%d, &quot;</span>
			   <span class="s">&quot;vr=%d, pf=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span>
			   <span class="n">self</span><span class="o">-&gt;</span><span class="n">vs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">);</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ns_status</span> <span class="o">=</span> <span class="n">irlap_validate_ns_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
		<span class="n">nr_status</span> <span class="o">=</span> <span class="n">irlap_validate_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Check for expected I(nformation) frame</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_EXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_EXPECTED</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Update Vr (next frame for us to receive) */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

			<span class="cm">/* Update Nr received */</span>
			<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  poll bit cleared?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 *  Starting WD-timer here is optional, but</span>
<span class="cm">				 *  not recommended. Note 6 IrLAP p. 83</span>
<span class="cm">				 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">				irda_start_timer(WD_TIMER, self-&gt;wd_timeout);</span>
<span class="cp">#endif</span>
				<span class="cm">/* Keep state, do not move this line */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>

				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *  We should wait before sending RR, and</span>
<span class="cm">				 *  also before changing to XMIT_S</span>
<span class="cm">				 *  state. (note 1, IrLAP p. 82)</span>
<span class="cm">				 */</span>
				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Give higher layers a chance to</span>
<span class="cm">				 * immediately reply with some data before</span>
<span class="cm">				 * we decide if we should send a RR frame</span>
<span class="cm">				 * or not</span>
<span class="cm">				 */</span>
				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

				<span class="cm">/* Any pending data requests?  */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

					<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>

					<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_S</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
					<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>
							     <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

					<span class="cm">/* Keep the state */</span>
					<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Check for Unexpected next to send (Ns)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_UNEXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_EXPECTED</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="cm">/* Unexpected next to send, with final bit cleared */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
				<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>

				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Unexpected Next to Receive(NR) ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ns_status</span> <span class="o">==</span> <span class="n">NS_EXPECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_UNEXPECTED</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;RECV_I_RSP: frame(s) lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="cm">/* Resend rejected frames */</span>
				<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>

				<span class="cm">/* Keep state, do not move this line */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>

				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 *  This is not documented in IrLAP!! Unexpected NR</span>
<span class="cm">			 *  with poll bit cleared</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

				<span class="cm">/* Keep state, do not move this line */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>

				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NR_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;NRM_S, NR_INVALID not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NS_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;NRM_S, NS_INVALID not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_UI_FRAME</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  poll bit cleared?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span> <span class="cm">/* Keep state */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Any pending data requests?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>

				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_S</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">irlap_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

				<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

				<span class="cm">/* Keep the state */</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_RR_CMD</span>:
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Nr as expected?</span>
<span class="cm">		 */</span>
		<span class="n">nr_status</span> <span class="o">=</span> <span class="n">irlap_validate_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_EXPECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>

				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
				<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_XMIT_S</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
				<span class="cm">/* Update Nr received */</span>
				<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
				<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
				<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

				<span class="cm">/* Note : if the link is idle (this case),</span>
<span class="cm">				 * we never go in XMIT_S, so we never get a</span>
<span class="cm">				 * chance to process any DISCONNECT_REQUEST.</span>
<span class="cm">				 * Do it now ! - Jean II */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pending</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Disconnect */</span>
					<span class="n">irlap_send_rd_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
					<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

					<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_SCLOSE</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Just send back pf bit */</span>
					<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>

					<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nr_status</span> <span class="o">==</span> <span class="n">NR_UNEXPECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
			<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>

			<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

			<span class="cm">/* Keep state */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), invalid nr not implemented!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_SNRM_CMD</span>:
		<span class="cm">/* SNRM frame is not allowed to contain an I-field */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), received SNRM cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_RESET_CHECK</span><span class="p">);</span>

			<span class="n">irlap_reset_indication</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
				   <span class="s">&quot;%s(), SNRM frame contained an I-field!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_REJ_CMD</span>:
		<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">irlap_resend_rejected_frames</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_SREJ_CMD</span>:
		<span class="n">irlap_update_nr_received</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">irlap_resend_rejected_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WD_TIMER_EXPIRED</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Wait until retry_count * n matches negotiated threshold/</span>
<span class="cm">		 *  disconnect time (note 2 in IrLAP p. 82)</span>
<span class="cm">		 *</span>
<span class="cm">		 * Similar to irlap_state_nrm_p() -&gt; FINAL_TIMER_EXPIRED</span>
<span class="cm">		 * Note : self-&gt;wd_timeout = (self-&gt;final_timeout * 2),</span>
<span class="cm">		 *   which explain why we use (self-&gt;N2 / 2) here !!!</span>
<span class="cm">		 * Jean II</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), retry_count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">N2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* No retry, just wait for primary */</span>
			<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span><span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">%</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">N1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">irlap_status_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>
							<span class="n">STATUS_NO_ACTIVITY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="cm">/* Always switch state before calling upper layers */</span>
			<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>
			<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NO_RESPONSE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DISC_CMD</span>:
		<span class="cm">/* Always switch state before calling upper layers */</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="cm">/* Send disconnect response */</span>
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_send_ua_response_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
		<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="cm">/* Set default link parameters */</span>
		<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DISCOVERY_XID_CMD</span>:
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_send_rr_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">RSP_FRAME</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ack_required</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_TEST_CMD</span>:
		<span class="cm">/* Remove test frame header (only LAP header in NRM) */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LAP_ADDR_HEADER</span> <span class="o">+</span> <span class="n">LAP_CTRL_HEADER</span><span class="p">);</span>

		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>

		<span class="cm">/* Send response (info will be copied) */</span>
		<span class="n">irlap_send_test_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d, (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">event</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_state_sclose (self, event, skb, info)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_sclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RECV_DISC_CMD</span>:
		<span class="cm">/* Always switch state before calling upper layers */</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="cm">/* Send disconnect response */</span>
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_send_ua_response_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
		<span class="cm">/* Set default link parameters */</span>
		<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RECV_DM_RSP</span>:
		<span class="cm">/* IrLAP-1.1 p.82: in SCLOSE, S and I type RSP frames</span>
<span class="cm">		 * shall take us down into default NDM state, like DM_RSP</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="n">RECV_RR_RSP</span>:
	<span class="k">case</span> <span class="n">RECV_RNR_RSP</span>:
	<span class="k">case</span> <span class="n">RECV_REJ_RSP</span>:
	<span class="k">case</span> <span class="n">RECV_SREJ_RSP</span>:
	<span class="k">case</span> <span class="n">RECV_I_RSP</span>:
		<span class="cm">/* Always switch state before calling upper layers */</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
		<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WD_TIMER_EXPIRED</span>:
		<span class="cm">/* Always switch state before calling upper layers */</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NDM</span><span class="p">);</span>

		<span class="n">irlap_apply_default_connection_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">irlap_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* IrLAP-1.1 p.82: in SCLOSE, basically any received frame</span>
<span class="cm">		 * with pf=1 shall restart the wd-timer and resend the rd:rsp</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span>  <span class="o">&amp;&amp;</span>  <span class="n">info</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timer</span><span class="p">);</span>
			<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
			<span class="n">irlap_send_rd_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">wd_timeout</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>		<span class="cm">/* stay in SCLOSE */</span>
		<span class="p">}</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d, (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">event</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_state_reset_check</span><span class="p">(</span> <span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">irlap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RESET_RESPONSE</span>:
		<span class="n">irlap_send_ua_response_frame</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>
		<span class="n">irlap_initiate_connection_state</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">WD_TIMEOUT</span><span class="p">);</span>
		<span class="n">irlap_flush_all_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_NRM_S</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISCONNECT_REQUEST</span>:
		<span class="n">irlap_wait_min_turn_around</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
		<span class="n">irlap_send_rd_frame</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlap_start_wd_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">WD_TIMEOUT</span><span class="p">);</span>
		<span class="n">irlap_next_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_SCLOSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %d, (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">event</span><span class="p">,</span> <span class="n">irlap_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
