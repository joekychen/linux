<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › qos.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>qos.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      qos.c</span>
<span class="cm"> * Version:       1.0</span>
<span class="cm"> * Description:   IrLAP QoS parameter negotiation</span>
<span class="cm"> * Status:        Stable</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Tue Sep  9 00:00:26 1997</span>
<span class="cm"> * Modified at:   Sun Jan 30 14:29:16 2000</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;,</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2001 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> *     GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public License</span>
<span class="cm"> *     along with this program; if not, write to the Free Software</span>
<span class="cm"> *     Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<span class="cm"> *     MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/parameters.h&gt;</span>
<span class="cp">#include &lt;net/irda/qos.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap_frame.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum values of the baud rate we negotiate with the other end.</span>
<span class="cm"> * Most often, you don&#39;t have to change that, because Linux-IrDA will</span>
<span class="cm"> * use the maximum offered by the link layer, which usually works fine.</span>
<span class="cm"> * In some very rare cases, you may want to limit it to lower speeds...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_max_baud_rate</span> <span class="o">=</span> <span class="mi">16000000</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Maximum value of the lap disconnect timer we negotiate with the other end.</span>
<span class="cm"> * Most often, the value below represent the best compromise, but some user</span>
<span class="cm"> * may want to keep the LAP alive longer or shorter in case of link failure.</span>
<span class="cm"> * Remember that the threshold time (early warning) is fixed to 3s...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_max_noreply_time</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Minimum turn time to be applied before transmitting to the peer.</span>
<span class="cm"> * Nonzero values (usec) are used as lower limit to the per-connection</span>
<span class="cm"> * mtt value which was announced by the other end during negotiation.</span>
<span class="cm"> * Might be helpful if the peer device provides too short mtt.</span>
<span class="cm"> * Default is 10us which means using the unmodified value given by the</span>
<span class="cm"> * peer except if it&#39;s 0 (0 is likely a bug in the other stack).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_min_tx_turn_time</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Maximum data size to be used in transmission in payload of LAP frame.</span>
<span class="cm"> * There is a bit of confusion in the IrDA spec :</span>
<span class="cm"> * The LAP spec defines the payload of a LAP frame (I field) to be</span>
<span class="cm"> * 2048 bytes max (IrLAP 1.1, chapt 6.6.5, p40).</span>
<span class="cm"> * On the other hand, the PHY mention frames of 2048 bytes max (IrPHY</span>
<span class="cm"> * 1.2, chapt 5.3.2.1, p41). But, this number includes the LAP header</span>
<span class="cm"> * (2 bytes), and CRC (32 bits at 4 Mb/s). So, for the I field (LAP</span>
<span class="cm"> * payload), that&#39;s only 2042 bytes. Oups !</span>
<span class="cm"> * My nsc-ircc hardware has troubles receiving 2048 bytes frames at 4 Mb/s,</span>
<span class="cm"> * so adjust to 2042... I don&#39;t know if this bug applies only for 2048</span>
<span class="cm"> * bytes frames or all negotiated frame sizes, but you can use the sysctl</span>
<span class="cm"> * to play with this value anyway.</span>
<span class="cm"> * Jean II */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_max_tx_data_size</span> <span class="o">=</span> <span class="mi">2042</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Maximum transmit window, i.e. number of LAP frames between turn-around.</span>
<span class="cm"> * This allow to override what the peer told us. Some peers are buggy and</span>
<span class="cm"> * don&#39;t always support what they tell us.</span>
<span class="cm"> * Jean II */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_max_tx_window</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_baud_rate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_link_disconnect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">parm</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_max_turn_time</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_data_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_window_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_additional_bofs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">parm</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlap_param_min_turn_time</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_IRDA_DYNAMIC_WINDOW</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">irlap_requested_line_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="n">min_turn_times</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span> <span class="cm">/* us */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">baud_rates</span><span class="p">[]</span>      <span class="o">=</span> <span class="p">{</span> <span class="mi">2400</span><span class="p">,</span> <span class="mi">9600</span><span class="p">,</span> <span class="mi">19200</span><span class="p">,</span> <span class="mi">38400</span><span class="p">,</span> <span class="mi">57600</span><span class="p">,</span> <span class="mi">115200</span><span class="p">,</span> <span class="mi">576000</span><span class="p">,</span>
				   <span class="mi">1152000</span><span class="p">,</span> <span class="mi">4000000</span><span class="p">,</span> <span class="mi">16000000</span> <span class="p">};</span>           <span class="cm">/* bps */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">data_sizes</span><span class="p">[]</span>      <span class="o">=</span> <span class="p">{</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">2048</span> <span class="p">};</span>        <span class="cm">/* bytes */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">add_bofs</span><span class="p">[]</span>        <span class="o">=</span> <span class="p">{</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>            <span class="cm">/* bytes */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">max_turn_times</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span> <span class="p">};</span>                    <span class="cm">/* ms */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="n">link_disc_times</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span> <span class="p">};</span>         <span class="cm">/* secs */</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="n">max_line_capacities</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
       <span class="cm">/* 500 ms     250 ms  100 ms  50 ms (max turn time) */</span>
	<span class="p">{</span>    <span class="mi">100</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span> <span class="p">},</span> <span class="cm">/*     2400 bps */</span>
	<span class="p">{</span>    <span class="mi">400</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span> <span class="p">},</span> <span class="cm">/*     9600 bps */</span>
	<span class="p">{</span>    <span class="mi">800</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span> <span class="p">},</span> <span class="cm">/*    19200 bps */</span>
	<span class="p">{</span>   <span class="mi">1600</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span> <span class="p">},</span> <span class="cm">/*    38400 bps */</span>
	<span class="p">{</span>   <span class="mi">2360</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span> <span class="p">},</span> <span class="cm">/*    57600 bps */</span>
	<span class="p">{</span>   <span class="mi">4800</span><span class="p">,</span>   <span class="mi">2400</span><span class="p">,</span>    <span class="mi">960</span><span class="p">,</span>   <span class="mi">480</span> <span class="p">},</span> <span class="cm">/*   115200 bps */</span>
	<span class="p">{</span>  <span class="mi">28800</span><span class="p">,</span>  <span class="mi">11520</span><span class="p">,</span>   <span class="mi">5760</span><span class="p">,</span>  <span class="mi">2880</span> <span class="p">},</span> <span class="cm">/*   576000 bps */</span>
	<span class="p">{</span>  <span class="mi">57600</span><span class="p">,</span>  <span class="mi">28800</span><span class="p">,</span>  <span class="mi">11520</span><span class="p">,</span>  <span class="mi">5760</span> <span class="p">},</span> <span class="cm">/*  1152000 bps */</span>
	<span class="p">{</span> <span class="mi">200000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span>  <span class="mi">40000</span><span class="p">,</span> <span class="mi">20000</span> <span class="p">},</span> <span class="cm">/*  4000000 bps */</span>
	<span class="p">{</span> <span class="mi">800000</span><span class="p">,</span> <span class="mi">400000</span><span class="p">,</span> <span class="mi">160000</span><span class="p">,</span> <span class="mi">80000</span> <span class="p">},</span> <span class="cm">/* 16000000 bps */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">pi_minor_info_t</span> <span class="n">pi_minor_call_table_type_0</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cm">/* 01 */</span><span class="p">{</span> <span class="n">irlap_param_baud_rate</span><span class="p">,</span>       <span class="n">PV_INTEGER</span> <span class="o">|</span> <span class="n">PV_LITTLE_ENDIAN</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cm">/* 08 */</span><span class="p">{</span> <span class="n">irlap_param_link_disconnect</span><span class="p">,</span> <span class="n">PV_INT_8_BITS</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">pi_minor_info_t</span> <span class="n">pi_minor_call_table_type_1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cm">/* 82 */</span><span class="p">{</span> <span class="n">irlap_param_max_turn_time</span><span class="p">,</span>   <span class="n">PV_INT_8_BITS</span> <span class="p">},</span>
<span class="cm">/* 83 */</span><span class="p">{</span> <span class="n">irlap_param_data_size</span><span class="p">,</span>       <span class="n">PV_INT_8_BITS</span> <span class="p">},</span>
<span class="cm">/* 84 */</span><span class="p">{</span> <span class="n">irlap_param_window_size</span><span class="p">,</span>     <span class="n">PV_INT_8_BITS</span> <span class="p">},</span>
<span class="cm">/* 85 */</span><span class="p">{</span> <span class="n">irlap_param_additional_bofs</span><span class="p">,</span> <span class="n">PV_INT_8_BITS</span> <span class="p">},</span>
<span class="cm">/* 86 */</span><span class="p">{</span> <span class="n">irlap_param_min_turn_time</span><span class="p">,</span>   <span class="n">PV_INT_8_BITS</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">pi_major_info_t</span> <span class="n">pi_major_call_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">pi_minor_call_table_type_0</span><span class="p">,</span> <span class="mi">9</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">pi_minor_call_table_type_1</span><span class="p">,</span> <span class="mi">7</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">pi_param_info_t</span> <span class="n">irlap_param_info</span> <span class="o">=</span> <span class="p">{</span> <span class="n">pi_major_call_table</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>

<span class="cm">/* ---------------------- LOCAL SUBROUTINES ---------------------- */</span>
<span class="cm">/* Note : we start with a bunch of local subroutines.</span>
<span class="cm"> * As the compiler is &quot;one pass&quot;, this is the only way to get them to</span>
<span class="cm"> * inline properly...</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Function value_index (value, array, size)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns the index to the value in the specified array</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">value_index</span><span class="p">(</span><span class="n">__u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function index_value (index, array)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns value to index in array, easy!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">index_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function msb_index (word)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns index to most significant bit (MSB) in word</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msb_index</span> <span class="p">(</span><span class="n">__u16</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">msb</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>   <span class="cm">/* Current MSB */</span>

	<span class="cm">/* Check for buggy peers.</span>
<span class="cm">	 * Note : there is a small probability that it could be us, but I</span>
<span class="cm">	 * would expect driver authors to catch that pretty early and be</span>
<span class="cm">	 * able to check precisely what&#39;s going on. If a end user sees this,</span>
<span class="cm">	 * it&#39;s very likely the peer. - Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">word</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), Detected buggy peer, adjust null PV to 0x1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* The only safe choice (we don&#39;t know the array size) */</span>
		<span class="n">word</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">msb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="n">msb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>   <span class="cm">/* Found it! */</span>
		<span class="n">msb</span> <span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">index</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function value_lower_bits (value, array)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns a bit field marking all possibility lower than value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">value_lower_bits</span><span class="p">(</span><span class="n">__u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">result</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add the current value to the bit field, shift mask */</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Finished ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Send back a valid index */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
	  <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Last item */</span>
	<span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function value_highest_bit (value, array)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns a bit field marking the highest possibility lower than value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">value_highest_bit</span><span class="p">(</span><span class="n">__u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">result</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Finished ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Shift mask */</span>
		<span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set the current value to the bit field */</span>
	<span class="n">result</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="cm">/* Send back a valid index */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
	  <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Last item */</span>
	<span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -------------------------- MAIN CALLS -------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_qos_compute_intersection (qos, new)</span>
<span class="cm"> *</span>
<span class="cm"> *    Compute the intersection of the old QoS capabilities with new ones</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irda_qos_compute_intersection</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">qos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">new</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Apply */</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span>       <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span>     <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span>   <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span>   <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span>       <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span>  <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>

	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="n">qos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_init_max_qos_capabilies (qos)</span>
<span class="cm"> *</span>
<span class="cm"> *    The purpose of this function is for layers and drivers to be able to</span>
<span class="cm"> *    set the maximum QoS possible and then &quot;and in&quot; their own limitations</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irda_init_max_qos_capabilies</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  These are the maximum supported values as specified on pages</span>
<span class="cm">	 *  39-43 in IrLAP</span>
<span class="cm">	 */</span>

	<span class="cm">/* Use sysctl to set some configurable values... */</span>
	<span class="cm">/* Set configured max speed */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">value_lower_bits</span><span class="p">(</span><span class="n">sysctl_max_baud_rate</span><span class="p">,</span> <span class="n">baud_rates</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">sysctl_max_baud_rate</span> <span class="o">=</span> <span class="n">index_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">baud_rates</span><span class="p">);</span>

	<span class="cm">/* Set configured max disc time */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">value_lower_bits</span><span class="p">(</span><span class="n">sysctl_max_noreply_time</span><span class="p">,</span> <span class="n">link_disc_times</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">sysctl_max_noreply_time</span> <span class="o">=</span> <span class="n">index_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">link_disc_times</span><span class="p">);</span>

	<span class="cm">/* LSB is first byte, MSB is second byte */</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span>    <span class="o">&amp;=</span> <span class="mh">0x03ff</span><span class="p">;</span>

	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span>     <span class="o">=</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span>   <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span>   <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span>       <span class="o">=</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irda_init_max_qos_capabilies</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_adjust_qos_settings (qos)</span>
<span class="cm"> *</span>
<span class="cm"> *     Adjust QoS settings in case some values are not possible to use because</span>
<span class="cm"> *     of other settings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlap_adjust_qos_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">line_capacity</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the mintt is sensible.</span>
<span class="cm">	 * Main culprit : Ericsson T39. - Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_min_tx_turn_time</span> <span class="o">&gt;</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), Detected buggy peer, adjust mtt to %dus!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">sysctl_min_tx_turn_time</span><span class="p">);</span>

		<span class="cm">/* We don&#39;t really need bits, but easier this way */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">value_highest_bit</span><span class="p">(</span><span class="n">sysctl_min_tx_turn_time</span><span class="p">,</span> <span class="n">min_turn_times</span><span class="p">,</span>
				      <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
		<span class="n">sysctl_min_tx_turn_time</span> <span class="o">=</span> <span class="n">index_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">min_turn_times</span><span class="p">);</span>
		<span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">sysctl_min_tx_turn_time</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not allowed to use a max turn time less than 500 ms if the baudrate</span>
<span class="cm">	 * is less than 115200</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">115200</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
			   <span class="s">&quot;%s(), adjusting max turn time from %d to 500 ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
		<span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The data size must be adjusted according to the baud rate and max</span>
<span class="cm">	 * turn time</span>
<span class="cm">	 */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">value_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">data_sizes</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">line_capacity</span> <span class="o">=</span> <span class="n">irlap_max_line_capacity</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
						<span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IRDA_DYNAMIC_WINDOW</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">line_capacity</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">data_sizes</span><span class="p">[</span><span class="n">index</span><span class="o">--</span><span class="p">];</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), reducing data size to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* Use method described in section 6.6.11 of IrLAP */</span><span class="cp"></span>
	<span class="k">while</span> <span class="p">(</span><span class="n">irlap_requested_line_capacity</span><span class="p">(</span><span class="n">qos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">line_capacity</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

		<span class="cm">/* Must be able to send at least one frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), reducing window size to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">data_sizes</span><span class="p">[</span><span class="n">index</span><span class="o">--</span><span class="p">];</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), reducing data size to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), nothing more we can do!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_DYNAMIC_WINDOW */</span><span class="cp"></span>
	<span class="cm">/*</span>
<span class="cm">	 * Fix tx data size according to user limits - Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">sysctl_max_tx_data_size</span><span class="p">)</span>
		<span class="cm">/* Allow non discrete adjustement to avoid losing capacity */</span>
		<span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">sysctl_max_tx_data_size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Override Tx window if user request it. - Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">sysctl_max_tx_window</span><span class="p">)</span>
		<span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">sysctl_max_tx_window</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_negotiate (qos_device, qos_session, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate QoS values, not really that much negotiation :-)</span>
<span class="cm"> *    We just set the QoS capabilities for the peer station</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlap_qos_negotiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_extract_all</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>

	<span class="cm">/* Convert the negotiated bits to values */</span>
	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>
	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">);</span>

	<span class="n">irlap_adjust_qos_settings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting BAUD_RATE to %d bps.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting DATA_SIZE to %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting WINDOW_SIZE to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting XBOFS to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting MAX_TURN_TIME to %d ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting MIN_TURN_TIME to %d usecs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Setting LINK_DISC to %d secs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_insert_negotiation_params (qos, fp)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert QoS negotiaion pararameters into frame</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlap_insert_qos_negotiation_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Insert data rate */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_BAUD_RATE</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Insert max turnaround time */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_MAX_TURN_TIME</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Insert data size */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_DATA_SIZE</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Insert window size */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_WINDOW_SIZE</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Insert additional BOFs */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_ADD_BOFS</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Insert minimum turnaround time */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_MIN_TURN_TIME</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Insert link disconnect/threshold time */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">PI_LINK_DISC</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				<span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">irlap_param_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_baud_rate (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate data-rate</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_baud_rate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">final</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), baud rate = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Stations must agree on baud rate, so calculate</span>
<span class="cm">		 *  intersection</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Requested BAUD_RATE: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Final BAUD_RATE: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">final</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">final</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">final</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_link_disconnect (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate link disconnect/threshold time.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_link_disconnect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">final</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Stations must agree on link disconnect/threshold</span>
<span class="cm">		 *  time.</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;LINK_DISC: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Final LINK_DISC: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">final</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">final</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">final</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_max_turn_time (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate the maximum turnaround time. This is a type 1 parameter and</span>
<span class="cm"> *    will be negotiated independently for each station</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_max_turn_time</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_data_size (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate the data size. This is a type 1 parameter and</span>
<span class="cm"> *    will be negotiated independently for each station</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_data_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_window_size (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate the window size. This is a type 1 parameter and</span>
<span class="cm"> *    will be negotiated independently for each station</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_window_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_additional_bofs (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate additional BOF characters. This is a type 1 parameter and</span>
<span class="cm"> *    will be negotiated independently for each station.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_additional_bofs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_param_min_turn_time (instance, param, get)</span>
<span class="cm"> *</span>
<span class="cm"> *    Negotiate the minimum turn around time. This is a type 1 parameter and</span>
<span class="cm"> *    will be negotiated independently for each station</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlap_param_min_turn_time</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_rx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlap_max_line_capacity (speed, max_turn_time, min_turn_time)</span>
<span class="cm"> *</span>
<span class="cm"> *    Calculate the maximum line capacity</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">__u32</span> <span class="nf">irlap_max_line_capacity</span><span class="p">(</span><span class="n">__u32</span> <span class="n">speed</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_turn_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">line_capacity</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), speed=%d, max_turn_time=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">max_turn_time</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">value_index</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">baud_rates</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">j</span> <span class="o">=</span> <span class="n">value_index</span><span class="p">(</span><span class="n">max_turn_time</span><span class="p">,</span> <span class="n">max_turn_times</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(((</span><span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span><span class="mi">10</span><span class="p">)),</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(((</span><span class="n">j</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span><span class="mi">4</span><span class="p">)),</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="n">line_capacity</span> <span class="o">=</span> <span class="n">max_line_capacities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), line capacity=%d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">line_capacity</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">line_capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_IRDA_DYNAMIC_WINDOW</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="nf">irlap_requested_line_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">line_capacity</span><span class="p">;</span>

	<span class="n">line_capacity</span> <span class="o">=</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">*</span>
		<span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">qos</span><span class="o">-&gt;</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">irlap_min_turn_time_in_bytes</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
					     <span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), requested line capacity=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">line_capacity</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">line_capacity</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">irda_qos_bits_to_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">qos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">baud_rates</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">data_sizes</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">min_turn_times</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">max_turn_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">max_turn_times</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">link_disc_time</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">link_disc_times</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">msb_index</span><span class="p">(</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="n">qos</span><span class="o">-&gt;</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">add_bofs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irda_qos_bits_to_value</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
