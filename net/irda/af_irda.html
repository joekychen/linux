<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › af_irda.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>af_irda.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      af_irda.c</span>
<span class="cm"> * Version:       0.9</span>
<span class="cm"> * Description:   IrDA sockets implementation</span>
<span class="cm"> * Status:        Stable</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sun May 31 10:12:43 1998</span>
<span class="cm"> * Modified at:   Sat Dec 25 21:10:23 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dag@brattli.net&gt;</span>
<span class="cm"> * Sources:       af_netroom.c, af_ax25.c, af_rose.c, af_x25.c etc.</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1999 Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *     Copyright (c) 1999-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> *     GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public License</span>
<span class="cm"> *     along with this program; if not, write to the Free Software</span>
<span class="cm"> *     Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<span class="cm"> *     MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> *     Linux-IrDA now supports four different types of IrDA sockets:</span>
<span class="cm"> *</span>
<span class="cm"> *     o SOCK_STREAM:    TinyTP connections with SAR disabled. The</span>
<span class="cm"> *                       max SDU size is 0 for conn. of this type</span>
<span class="cm"> *     o SOCK_SEQPACKET: TinyTP connections with SAR enabled. TTP may</span>
<span class="cm"> *                       fragment the messages, but will preserve</span>
<span class="cm"> *                       the message boundaries</span>
<span class="cm"> *     o SOCK_DGRAM:     IRDAPROTO_UNITDATA: TinyTP connections with Unitdata</span>
<span class="cm"> *                       (unreliable) transfers</span>
<span class="cm"> *                       IRDAPROTO_ULTRA: Connectionless and unreliable data</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/irda.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>

<span class="cp">#include &lt;asm/ioctls.h&gt;		</span><span class="cm">/* TIOCOUTQ, TIOCINQ */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>

<span class="cp">#include &lt;net/irda/af_irda.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irda_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_stream_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_seqpacket_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_dgram_ops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_ultra_ops</span><span class="p">;</span>
<span class="cp">#define ULTRA_MAX_DATA 382</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cp">#define IRDA_MAX_HEADER (TTP_MAX_HEADER)</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_data_indication (instance, sap, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Received some data from TinyTP. Just queue it on the receive queue</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_data_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), error: no more mem!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">=</span> <span class="n">FLOW_STOP</span><span class="p">;</span>

		<span class="cm">/* When we return error, TTP will need to requeue the skb */</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_disconnect_indication (instance, sap, reason, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Connection has been closed. Check reason to find out why</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_disconnect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				       <span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t care about it, but let&#39;s not leak it */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(%p) : BUG : sk is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent race conditions with irda_release() and irda_shutdown() */</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>     <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">SEND_SHUTDOWN</span><span class="p">;</span>

		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* Close our TSAP.</span>
<span class="cm">		 * If we leave it open, IrLMP put it back into the list of</span>
<span class="cm">		 * unconnected LSAPs. The problem is that any incoming request</span>
<span class="cm">		 * can then be matched to this socket (and it will be, because</span>
<span class="cm">		 * it is at the head of the list). This would prevent any</span>
<span class="cm">		 * listening socket waiting on the same TSAP to get those</span>
<span class="cm">		 * requests. Some apps forget to close sockets, or hang to it</span>
<span class="cm">		 * a bit too long, so we may stay in this dead state long</span>
<span class="cm">		 * enough to be noticed...</span>
<span class="cm">		 * Note : all socket function do check sk-&gt;sk_state, so we are</span>
<span class="cm">		 * safe...</span>
<span class="cm">		 * Jean II</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Note : once we are there, there is not much you want to do</span>
<span class="cm">	 * with the socket anymore, apart from closing it.</span>
<span class="cm">	 * For example, bind() and connect() won&#39;t reset sk-&gt;sk_err,</span>
<span class="cm">	 * sk-&gt;sk_shutdown and sk-&gt;sk_flags to valid values...</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_connect_confirm (instance, sap, qos, max_sdu_size, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Connections has been confirmed by the remote device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_connect_confirm</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span>
				 <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">max_header_size</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Should be ??? skb<em>queue</em>tail(&amp;sk->sk<em>receive</em>queue, skb);</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* How much header space do we need to reserve */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">max_header_size</span><span class="p">;</span>

	<span class="cm">/* IrTTP max SDU size in transmit direction */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_tx</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>

	<span class="cm">/* Find out what the largest chunk of data that we can transmit is */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">max_sdu_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: max_sdu_size must be 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">irttp_get_max_seg_size</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">max_sdu_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: max_sdu_size cannot be 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">irttp_get_max_seg_size</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), max_data_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">,</span> <span class="n">qos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span><span class="p">));</span>

	<span class="cm">/* We are now connected! */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_connect_indication(instance, sap, qos, max_sdu_size, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    Incoming connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_connect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
				    <span class="n">__u8</span> <span class="n">max_header_size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* How much header space do we need to reserve */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">max_header_size</span><span class="p">;</span>

	<span class="cm">/* IrTTP max SDU size in transmit direction */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_tx</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>

	<span class="cm">/* Find out what the largest chunk of data that we can transmit is */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">max_sdu_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: max_sdu_size must be 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">irttp_get_max_seg_size</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">max_sdu_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: max_sdu_size cannot be 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">irttp_get_max_seg_size</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), max_data_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">,</span> <span class="n">qos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span><span class="p">));</span>

	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_connect_response (handle)</span>
<span class="cm"> *</span>
<span class="cm"> *    Accept incoming connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_connect_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">,</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() Unable to allocate sk_buff!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve space for MUX_CONTROL and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IRDA_MAX_HEADER</span><span class="p">);</span>

	<span class="n">irttp_connect_response</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_flow_indication (instance, sap, flow)</span>
<span class="cm"> *</span>
<span class="cm"> *    Used by TinyTP to tell us if it can accept more data or not</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_flow_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="n">LOCAL_FLOW</span> <span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flow</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FLOW_STOP</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), IrTTP wants us to slow down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">=</span> <span class="n">flow</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FLOW_START</span>:
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">=</span> <span class="n">flow</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), IrTTP wants us to start again</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown flow command!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Unknown flow command, better stop */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">=</span> <span class="n">flow</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_getvalue_confirm (obj_id, value, priv)</span>
<span class="cm"> *</span>
<span class="cm"> *    Got answer from remote LM-IAS, just pass object to requester...</span>
<span class="cm"> *</span>
<span class="cm"> * Note : duplicate from above, but we need our own version that</span>
<span class="cm"> * doesn&#39;t touch the dtsap_sel and save the full value structure...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_getvalue_confirm</span><span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">obj_id</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ias_value</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: lost myself!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="cm">/* We probably don&#39;t need to make any more queries */</span>
	<span class="n">iriap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check if request succeeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">IAS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), IAS query failed! (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">result</span><span class="p">);</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>	<span class="cm">/* We really need it later */</span>

		<span class="cm">/* Wake up any processes waiting for result */</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pass the object to the caller (so the caller must delete it) */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wake up any processes waiting for result */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_selective_discovery_indication (discovery)</span>
<span class="cm"> *</span>
<span class="cm"> *    Got a selective discovery indication from IrLMP.</span>
<span class="cm"> *</span>
<span class="cm"> * IrLMP is telling us that this node is new and matching our hint bit</span>
<span class="cm"> * filter. Wake up any process waiting for answer...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_selective_discovery_indication</span><span class="p">(</span><span class="n">discinfo_t</span> <span class="o">*</span><span class="n">discovery</span><span class="p">,</span>
						<span class="n">DISCOVERY_MODE</span> <span class="n">mode</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: lost myself!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pass parameter to the caller */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span> <span class="o">=</span> <span class="n">discovery</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>

	<span class="cm">/* Wake up process if its waiting for device to be discovered */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_discovery_timeout (priv)</span>
<span class="cm"> *</span>
<span class="cm"> *    Timeout in the selective discovery process</span>
<span class="cm"> *</span>
<span class="cm"> * We were waiting for a node to be discovered, but nothing has come up</span>
<span class="cm"> * so far. Wake up the user and tell him that we failed...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_discovery_timeout</span><span class="p">(</span><span class="n">u_long</span> <span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="p">)</span> <span class="n">priv</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Nothing for the caller */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">cachelog</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>

	<span class="cm">/* Wake up process if its still waiting... */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_open_tsap (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Open local Transport Service Access Point (TSAP)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_open_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">tsap_sel</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">notify_t</span> <span class="n">notify</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize callbacks to be used by the IrDA stack */</span>
	<span class="n">irda_notify_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="p">);</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span>       <span class="o">=</span> <span class="n">irda_connect_confirm</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span>    <span class="o">=</span> <span class="n">irda_connect_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span> <span class="o">=</span> <span class="n">irda_disconnect_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">data_indication</span>       <span class="o">=</span> <span class="n">irda_data_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span>	     <span class="o">=</span> <span class="n">irda_data_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span>       <span class="o">=</span> <span class="n">irda_flow_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">NOTIFY_MAX_NAME</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span> <span class="o">=</span> <span class="n">irttp_open_tsap</span><span class="p">(</span><span class="n">tsap_sel</span><span class="p">,</span> <span class="n">DEFAULT_INITIAL_CREDIT</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">notify</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to allocate TSAP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Remember which TSAP selector we actually got */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_open_lsap (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Open local Link Service Access Point (LSAP). Used for opening Ultra</span>
<span class="cm"> *    sockets</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_open_lsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">notify_t</span> <span class="n">notify</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize callbacks to be used by the IrDA stack */</span>
	<span class="n">irda_notify_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="p">);</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span>	<span class="o">=</span> <span class="n">irda_data_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Ultra&quot;</span><span class="p">,</span> <span class="n">NOTIFY_MAX_NAME</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">irlmp_open_lsap</span><span class="p">(</span><span class="n">LSAP_CONNLESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">notify</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to allocate LSAP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_find_lsap_sel (self, name)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to lookup LSAP selector in remote LM-IAS</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, we start a IAP query, and then go to sleep. When the query</span>
<span class="cm"> * return, irda_getvalue_confirm will wake us up, and we can examine the</span>
<span class="cm"> * result of the query...</span>
<span class="cm"> * Note that in some case, the query fail even before we go to sleep,</span>
<span class="cm"> * creating some races...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_find_lsap_sel</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p, %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(): busy with a previous query</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">=</span> <span class="n">iriap_open</span><span class="p">(</span><span class="n">LSAP_ANY</span><span class="p">,</span> <span class="n">IAS_CLIENT</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
				 <span class="n">irda_getvalue_confirm</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Treat unexpected wakeup as disconnect */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>

	<span class="cm">/* Query remote LM-IAS */</span>
	<span class="n">iriap_getvaluebyclass_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
				      <span class="n">name</span><span class="p">,</span> <span class="s">&quot;IrDA:TinyTP:LsapSel&quot;</span><span class="p">);</span>

	<span class="cm">/* Wait for answer, if not yet finished (or failed) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">,</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)))</span>
		<span class="cm">/* Treat signals as disconnect */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>

	<span class="cm">/* Check what happened */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Requested object/attribute doesn&#39;t exist */</span>
		<span class="k">if</span><span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">==</span> <span class="n">IAS_CLASS_UNKNOWN</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">==</span> <span class="n">IAS_ATTRIB_UNKNOWN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the remote TSAP selector */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IAS_INTEGER</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() int=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">integer</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">integer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">integer</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), bad type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="p">)</span>
		<span class="n">irias_delete_value</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_discover_daddr_and_lsap_sel (self, name)</span>
<span class="cm"> *</span>
<span class="cm"> *    This try to find a device with the requested service.</span>
<span class="cm"> *</span>
<span class="cm"> * It basically look into the discovery log. For each address in the list,</span>
<span class="cm"> * it queries the LM-IAS of the device to find if this device offer</span>
<span class="cm"> * the requested service.</span>
<span class="cm"> * If there is more than one node supporting the service, we complain</span>
<span class="cm"> * to the user (it should move devices around).</span>
<span class="cm"> * The, we set both the destination address and the lsap selector to point</span>
<span class="cm"> * on the service on the unique device we have found.</span>
<span class="cm"> *</span>
<span class="cm"> * Note : this function fails if there is more than one device in range,</span>
<span class="cm"> * because IrLMP doesn&#39;t disconnect the LAP when the last LSAP is closed.</span>
<span class="cm"> * Moreover, we would need to wait the LAP disconnection...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_discover_daddr_and_lsap_sel</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">discinfo_t</span> <span class="o">*</span><span class="n">discoveries</span><span class="p">;</span>	<span class="cm">/* Copy of the discovery log */</span>
	<span class="kt">int</span>	<span class="n">number</span><span class="p">;</span>			<span class="cm">/* Number of nodes in the log */</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>	<span class="cm">/* Address we found the service on */</span>
	<span class="n">__u8</span>	<span class="n">dtsap_sel</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>	<span class="cm">/* TSAP associated with it */</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), name=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Ask lmp for the current discovery log</span>
<span class="cm">	 * Note : we have to use irlmp_get_discoveries(), as opposed</span>
<span class="cm">	 * to play with the cachelog directly, because while we are</span>
<span class="cm">	 * making our ias query, le log might change... */</span>
	<span class="n">discoveries</span> <span class="o">=</span> <span class="n">irlmp_get_discoveries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span><span class="p">,</span>
					    <span class="n">self</span><span class="o">-&gt;</span><span class="n">nslots</span><span class="p">);</span>
	<span class="cm">/* Check if the we got some results */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">discoveries</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">;</span>	<span class="cm">/* No nodes discovered */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now, check all discovered devices (if any), and connect</span>
<span class="cm">	 * client only about the services that the client is</span>
<span class="cm">	 * interested in...</span>
<span class="cm">	 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Try the address in the log */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">discoveries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">daddr</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), trying daddr = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

		<span class="cm">/* Query remote LM-IAS for this service */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">irda_find_lsap_sel</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="cm">/* We found the requested service */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">daddr</span> <span class="o">!=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), discovered service &#39;&#39;%s&#39;&#39; in two different devices !!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">discoveries</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOTUNIQ</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* First time we found that one, save it ! */</span>
			<span class="n">daddr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
			<span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span>:
			<span class="cm">/* Requested service simply doesn&#39;t exist on this node */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* Something bad did happen :-( */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unexpected IAS query failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">discoveries</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Cleanup our copy of the discovery log */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">discoveries</span><span class="p">);</span>

	<span class="cm">/* Check out what we found */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">daddr</span> <span class="o">==</span> <span class="n">DEV_ADDR_ANY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), cannot discover service &#39;&#39;%s&#39;&#39; in any device !!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Revert back to discovered device &amp; service */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">dtsap_sel</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), discovered requested service &#39;&#39;%s&#39;&#39; at address %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_getname (sock, uaddr, uaddr_len, peer)</span>
<span class="cm"> *</span>
<span class="cm"> *    Return the our own, or peers socket address (sockaddr_irda)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="n">saddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

		<span class="n">saddr</span><span class="p">.</span><span class="n">sir_family</span> <span class="o">=</span> <span class="n">AF_IRDA</span><span class="p">;</span>
		<span class="n">saddr</span><span class="p">.</span><span class="n">sir_lsap_sel</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span><span class="p">;</span>
		<span class="n">saddr</span><span class="p">.</span><span class="n">sir_addr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">saddr</span><span class="p">.</span><span class="n">sir_family</span> <span class="o">=</span> <span class="n">AF_IRDA</span><span class="p">;</span>
		<span class="n">saddr</span><span class="p">.</span><span class="n">sir_lsap_sel</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">;</span>
		<span class="n">saddr</span><span class="p">.</span><span class="n">sir_addr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), tsap_sel = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">saddr</span><span class="p">.</span><span class="n">sir_lsap_sel</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), addr = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">saddr</span><span class="p">.</span><span class="n">sir_addr</span><span class="p">);</span>

	<span class="cm">/* uaddr_len come to us uninitialised */</span>
	<span class="o">*</span><span class="n">uaddr_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_irda</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_listen (sock, backlog)</span>
<span class="cm"> *</span>
<span class="cm"> *    Just move to the listen state</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_DGRAM</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span> <span class="o">=</span> <span class="n">backlog</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>           <span class="o">=</span> <span class="n">TCP_LISTEN</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_bind (sock, uaddr, addr_len)</span>
<span class="cm"> *</span>
<span class="cm"> *    Used by servers to register their well known TSAP</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="o">*</span><span class="p">)</span> <span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_irda</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
	<span class="cm">/* Special care for Ultra sockets */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span> <span class="o">==</span> <span class="n">IRDAPROTO_ULTRA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_lsap_sel</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), extension in PID not supp!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">irda_open_lsap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Pretend we are connected */</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>   <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span> <span class="o">=</span> <span class="n">irias_new_object</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_name</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">irda_open_tsap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_lsap_sel</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irias_delete_object</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Register with LM-IAS */</span>
	<span class="n">irias_add_integer_attrib</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">,</span> <span class="s">&quot;IrDA:TinyTP:LsapSel&quot;</span><span class="p">,</span>
				 <span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">,</span> <span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
	<span class="n">irias_insert_object</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_accept (sock, newsock, flags)</span>
<span class="cm"> *</span>
<span class="cm"> *    Wait for incoming connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">irda_create</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">newsock</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_DGRAM</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	The read queue this time is holding sockets ready to use</span>
<span class="cm">	 *	hooked into the SABM we saved</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can perform the accept only if there is incoming data</span>
<span class="cm">	 * on the listening socket.</span>
<span class="cm">	 * So, we will block the caller until we receive any data.</span>
<span class="cm">	 * If the caller was waiting on select() or poll() before</span>
<span class="cm">	 * calling us, the data is waiting for us ;-)</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Non blocking operation */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">)),</span>
					<span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">newsk</span> <span class="o">=</span> <span class="n">newsock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>

	<span class="cm">/* Now attach up the new socket */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">tsap</span> <span class="o">=</span> <span class="n">irttp_dup</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span> <span class="cm">/* value does not seem to make sense. -arnd */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), dup failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">stsap_sel</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">irttp_get_saddr</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">irttp_get_daddr</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">max_sdu_size_tx</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_tx</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">max_data_size</span>   <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos_tx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">qos_info</span><span class="p">));</span>

	<span class="cm">/* Clean up the original one to keep it in listen state */</span>
	<span class="n">irttp_listen</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="o">--</span><span class="p">;</span>

	<span class="n">newsock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>

	<span class="n">irda_connect_response</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_connect (sock, uaddr, addr_len, flags)</span>
<span class="cm"> *</span>
<span class="cm"> *    Connect to a IrDA device</span>
<span class="cm"> *</span>
<span class="cm"> * The main difference with a &quot;standard&quot; connect is that with IrDA we need</span>
<span class="cm"> * to resolve the service name into a TSAP selector (in TCP, port number</span>
<span class="cm"> * doesn&#39;t have to be resolved).</span>
<span class="cm"> * Because of this service name resoltion, we can offer &quot;auto-connect&quot;,</span>
<span class="cm"> * where we connect to a service without specifying a destination address.</span>
<span class="cm"> *</span>
<span class="cm"> * Note : by consulting &quot;errno&quot;, the user space caller may learn the cause</span>
<span class="cm"> * of the failure. Most of them are visible in the function, others may come</span>
<span class="cm"> * from subroutines called and are listed here :</span>
<span class="cm"> *	o EBUSY : already processing a connect</span>
<span class="cm"> *	o EHOSTUNREACH : bad addr-&gt;sir_addr argument</span>
<span class="cm"> *	o EADDRNOTAVAIL : bad addr-&gt;sir_name argument</span>
<span class="cm"> *	o ENOTUNIQ : more than one node has addr-&gt;sir_name (auto-connect)</span>
<span class="cm"> *	o ENETUNREACH : no node found on the network (auto-connect)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">addr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="o">*</span><span class="p">)</span> <span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t allow connect for Ultra sockets */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span> <span class="o">==</span> <span class="n">IRDAPROTO_ULTRA</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>   <span class="cm">/* Connect completed during a ERESTARTSYS event */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>      <span class="cm">/* No reconnect on a seqpacket socket */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>   <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_irda</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Check if user supplied any destination device address */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_addr</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_addr</span> <span class="o">==</span> <span class="n">DEV_ADDR_ANY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Try to find one suitable */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">irda_discover_daddr_and_lsap_sel</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), auto-connect failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Use the one provided by the user */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_addr</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), daddr = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

		<span class="cm">/* If we don&#39;t have a valid service name, we assume the</span>
<span class="cm">		 * user want to connect on a specific LSAP. Prevent</span>
<span class="cm">		 * the use of invalid LSAPs (IrLMP 1.1 p10). Jean II */</span>
		<span class="k">if</span><span class="p">((</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_lsap_sel</span> <span class="o">&gt;=</span> <span class="mh">0x70</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Query remote LM-IAS using service name */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">irda_find_lsap_sel</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), connect failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Directly connect to the remote LSAP</span>
<span class="cm">			 * specified by the sir_lsap field.</span>
<span class="cm">			 * Please use with caution, in IrDA LSAPs are</span>
<span class="cm">			 * dynamic and there is no &quot;well-known&quot; LSAP. */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_lsap_sel</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we have opened a local TSAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">)</span>
		<span class="n">irda_open_tsap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_ANY</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_name</span><span class="p">);</span>

	<span class="cm">/* Move to connecting socket, start sending Connect Requests */</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTING</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>   <span class="o">=</span> <span class="n">TCP_SYN_SENT</span><span class="p">;</span>

	<span class="cm">/* Connect to remote device */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">irttp_connect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span><span class="p">,</span>
				    <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), connect failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now the loop */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">)),</span>
				     <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_SYN_SENT</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>

	<span class="cm">/* At this point, IrLMP has assigned our source address */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">irttp_get_saddr</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">irda_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	  <span class="o">=</span> <span class="s">&quot;IRDA&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>	  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_create (sock, protocol)</span>
<span class="cm"> *</span>
<span class="cm"> *    Create IrDA socket</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="cm">/* Check for valid socket type */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:     <span class="cm">/* For TTP connections with SAR disabled */</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:  <span class="cm">/* For TTP connections with SAR enabled */</span>
	<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:      <span class="cm">/* For TTP Unitdata or LMP Ultra transfers */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate networking socket */</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">PF_IRDA</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irda_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() : self is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irda_stream_ops</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span> <span class="o">=</span> <span class="n">TTP_SAR_DISABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irda_seqpacket_ops</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span> <span class="o">=</span> <span class="n">TTP_SAR_UNBOUND</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
		<span class="k">case</span> <span class="n">IRDAPROTO_ULTRA</span>:
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irda_ultra_ops</span><span class="p">;</span>
			<span class="cm">/* Initialise now, because we may send on unbound</span>
<span class="cm">			 * sockets. Jean II */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">ULTRA_MAX_DATA</span> <span class="o">-</span> <span class="n">LMP_PID_HEADER</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">IRDA_MAX_HEADER</span> <span class="o">+</span> <span class="n">LMP_PID_HEADER</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>
		<span class="k">case</span> <span class="n">IRDAPROTO_UNITDATA</span>:
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irda_dgram_ops</span><span class="p">;</span>
			<span class="cm">/* We let Unitdata conn. be like seqpack conn. */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span> <span class="o">=</span> <span class="n">TTP_SAR_UNBOUND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialise networking socket struct */</span>
	<span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>	<span class="cm">/* Note : set sk-&gt;sk_refcnt to 1 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">=</span> <span class="n">PF_IRDA</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>

	<span class="cm">/* Register as a client with IrLMP */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">ckey</span> <span class="o">=</span> <span class="n">irlmp_register_client</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">=</span> <span class="n">FLOW_START</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">nslots</span> <span class="o">=</span> <span class="n">DISCOVERY_DEFAULT_SLOTS</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>	<span class="cm">/* Until we get connected */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>		<span class="cm">/* so IrLMP assign us any link */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_destroy_socket (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Destroy socket</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_destroy_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Unregister with IrLMP */</span>
	<span class="n">irlmp_unregister_client</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ckey</span><span class="p">);</span>
	<span class="n">irlmp_unregister_service</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">skey</span><span class="p">);</span>

	<span class="cm">/* Unregister with LM-IAS */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irias_delete_object</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iriap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">P_NORMAL</span><span class="p">);</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irlmp_close_lsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_release (sock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>       <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span>   <span class="o">|=</span> <span class="n">SEND_SHUTDOWN</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Destroy IrDA socket */</span>
	<span class="n">irda_destroy_socket</span><span class="p">(</span><span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

	<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span>   <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Purge queues (see sock_init_data()) */</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

	<span class="cm">/* Destroy networking socket if we are the last reference on it,</span>
<span class="cm">	 * i.e. if(sk-&gt;sk_refcnt == 0) -&gt; sk_free(sk) */</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Notes on socket locking and deallocation... - Jean II</span>
<span class="cm">	 * In theory we should put pairs of sock_hold() / sock_put() to</span>
<span class="cm">	 * prevent the socket to be destroyed whenever there is an</span>
<span class="cm">	 * outstanding request or outstanding incoming packet or event.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) This may include IAS request, both in connect and getsockopt.</span>
<span class="cm">	 * Unfortunately, the situation is a bit more messy than it looks,</span>
<span class="cm">	 * because we close iriap and kfree(self) above.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2) This may include selective discovery in getsockopt.</span>
<span class="cm">	 * Same stuff as above, irlmp registration and self are gone.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Probably 1 and 2 may not matter, because it&#39;s all triggered</span>
<span class="cm">	 * by a process and the socket layer already prevent the</span>
<span class="cm">	 * socket to go away while a process is holding it, through</span>
<span class="cm">	 * sockfd_put() and fput()...</span>
<span class="cm">	 *</span>
<span class="cm">	 * 3) This may include deferred TSAP closure. In particular,</span>
<span class="cm">	 * we may receive a late irda_disconnect_indication()</span>
<span class="cm">	 * Fortunately, (tsap_cb *)-&gt;close_pend should protect us</span>
<span class="cm">	 * from that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * I did some testing on SMP, and it looks solid. And the socket</span>
<span class="cm">	 * memory leak is now gone... - Jean II</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_sendmsg (iocb, sock, msg, len)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send message down to TinyTP. This function is used for both STREAM and</span>
<span class="cm"> *    SEQPACK services. This is possible since it forces the client to</span>
<span class="cm"> *    fragment the message if necessary</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), len=%zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Note : socket.c set MSG_EOR on SEQPACKET sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MSG_DONTWAIT</span> <span class="o">|</span> <span class="n">MSG_EOR</span> <span class="o">|</span> <span class="n">MSG_CMSG_COMPAT</span> <span class="o">|</span>
			       <span class="n">MSG_NOSIGNAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Check if IrTTP is wants us to slow down */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">)),</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">!=</span> <span class="n">FLOW_STOP</span>  <span class="o">||</span>  <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we are still connected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that we don&#39;t send out too big frames */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Chopping frame from %zd to %d bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span>
				  <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just send the message to TinyTP, and let it deal with possible</span>
<span class="cm">	 * errors. No need to duplicate all that here</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">irttp_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Tell client how much data we actually sent */</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sk_stream_error</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_recvmsg_dgram (iocb, sock, msg, size, flags)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to receive message and copy it to user. The frame is discarded</span>
<span class="cm"> *    after being read, regardless of how much the user actually read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_recvmsg_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_DONTWAIT</span><span class="p">,</span>
				<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Received truncated frame (%zd &lt; %zd)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if we have previously stopped IrTTP and we know</span>
<span class="cm">	 *  have more free space in our rx_queue. If so tell IrTTP</span>
<span class="cm">	 *  to start delivering frames again before our rx_queue gets</span>
<span class="cm">	 *  empty</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">==</span> <span class="n">FLOW_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Starting IrTTP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">=</span> <span class="n">FLOW_START</span><span class="p">;</span>
			<span class="n">irttp_flow_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">FLOW_START</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_recvmsg_stream (iocb, sock, msg, size, flags)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_recvmsg_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">noblock</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__SO_ACCEPTCON</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">sock_rcvlowat</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_WAITALL</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">noblock</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *	POSIX 1003.1g mandates this order.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">noblock</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="cm">/* Wait process until data arrives */</span>
				<span class="n">schedule</span><span class="p">();</span>

			<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">chunk</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcpy_toiovec</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>

		<span class="cm">/* Mark read part of skb as used */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

			<span class="cm">/* put the skb back if we didn&#39;t use it up.. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), back on q!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">__func__</span><span class="p">);</span>
				<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() questionable!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="cm">/* put message back and return */</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if we have previously stopped IrTTP and we know</span>
<span class="cm">	 *  have more free space in our rx_queue. If so tell IrTTP</span>
<span class="cm">	 *  to start delivering frames again before our rx_queue gets</span>
<span class="cm">	 *  empty</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">==</span> <span class="n">FLOW_STOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Starting IrTTP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">=</span> <span class="n">FLOW_START</span><span class="p">;</span>
			<span class="n">irttp_flow_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">FLOW_START</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_sendmsg_dgram (iocb, sock, msg, len)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send message down to TinyTP for the unreliable sequenced</span>
<span class="cm"> *    packet service...</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_sendmsg_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), len=%zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MSG_DONTWAIT</span><span class="o">|</span><span class="n">MSG_CMSG_COMPAT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that we don&#39;t send out too big frames. This is an unreliable</span>
<span class="cm">	 * service, so we have no fragmentation and no coalescence</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Warning to much data! &quot;</span>
			   <span class="s">&quot;Chopping frame from %zd to %d bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">,</span>
				  <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), appending user data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just send the message to TinyTP, and let it deal with possible</span>
<span class="cm">	 * errors. No need to duplicate all that here</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">irttp_udata_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_sendmsg_ultra (iocb, sock, msg, len)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send message down to IrLMP for the unreliable Ultra</span>
<span class="cm"> *    packet service...</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_sendmsg_ultra</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), len=%zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MSG_DONTWAIT</span><span class="o">|</span><span class="n">MSG_CMSG_COMPAT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Check if an address was specified with sendto. Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_irda</span> <span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* Check address, extract pid. Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_family</span> <span class="o">!=</span> <span class="n">AF_IRDA</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">pid</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sir_lsap_sel</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), extension in PID not supp!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check that the socket is properly bound to an Ultra</span>
<span class="cm">		 * port. Jean II */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), socket not bound to Ultra PID.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Use PID from socket */</span>
		<span class="n">bound</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that we don&#39;t send out too big frames. This is an unreliable</span>
<span class="cm">	 * service, so we have no fragmentation and no coalescence</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Warning to much data! &quot;</span>
			   <span class="s">&quot;Chopping frame from %zd to %d bytes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">,</span>
				  <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), appending user data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">irlmp_connless_data_request</span><span class="p">((</span><span class="n">bound</span> <span class="o">?</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">),</span>
					  <span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_shutdown (sk, how)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>       <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span>   <span class="o">|=</span> <span class="n">SEND_SHUTDOWN</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iriap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">P_NORMAL</span><span class="p">);</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* A few cleanup so the socket look as good as new... */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_flow</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">=</span> <span class="n">FLOW_START</span><span class="p">;</span>	<span class="cm">/* needed ??? */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>	<span class="cm">/* Until we get re-connected */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>		<span class="cm">/* so IrLMP assign us any link */</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_poll (file, sock, wait)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">irda_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Exceptional events? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), POLLHUP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Readable? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Socket is readable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Connection-based need to check for termination and startup */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), POLLHUP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">==</span> <span class="n">FLOW_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_flow</span> <span class="o">==</span> <span class="n">FLOW_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_ioctl (sock, cmd, arg)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), cmd=%#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCOUTQ</span>: <span class="p">{</span>
		<span class="kt">long</span> <span class="n">amount</span><span class="p">;</span>

		<span class="n">amount</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">TIOCINQ</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
		<span class="cm">/* These two are safe on a single CPU system as only user tasks fiddle here */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SIOCGSTAMP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sock_get_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFDSTADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFDSTADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFBRDADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFBRDADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFNETMASK</span>:
	<span class="k">case</span> <span class="n">SIOCSIFNETMASK</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMETRIC</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMETRIC</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), doing device ioctl!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_ioctl (sock, cmd, arg)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * All IRDA&#39;s ioctl are standard ones.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_setsockopt (sock, level, optname, optval, optlen)</span>
<span class="cm"> *</span>
<span class="cm"> *    Set some options for the socket</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irda_ias_set</span>    <span class="o">*</span><span class="n">ias_opt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ias_object</span>      <span class="o">*</span><span class="n">ias_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ias_attrib</span> <span class="o">*</span>	<span class="n">ias_attr</span><span class="p">;</span>	<span class="cm">/* Attribute in IAS object */</span>
	<span class="kt">int</span> <span class="n">opt</span><span class="p">,</span> <span class="n">free_ias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_IRLMP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRLMP_IAS_SET</span>:
		<span class="cm">/* The user want to add an attribute to an existing IAS object</span>
<span class="cm">		 * (in the IAS database) or to create a new object with this</span>
<span class="cm">		 * attribute.</span>
<span class="cm">		 * We first query IAS to know if the object exist, and then</span>
<span class="cm">		 * create the right attribute...</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ias_opt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ias_opt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy query to the driver. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find the object we target.</span>
<span class="cm">		 * If the user gives us an empty string, we use the object</span>
<span class="cm">		 * associated with this socket. This will workaround</span>
<span class="cm">		 * duplicated class name - Jean II */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">irias_find_object</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">);</span>

		<span class="cm">/* Only ROOT can mess with the global IAS database.</span>
<span class="cm">		 * Users can only add attributes to the object associated</span>
<span class="cm">		 * with the socket they own - Jean II */</span>
		<span class="k">if</span><span class="p">((</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">((</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ias_obj</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If the object doesn&#39;t exist, create it */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ias_object</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Create a new object */</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">irias_new_object</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">,</span>
						   <span class="n">jiffies</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">free_ias</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Do we have the attribute already ? */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">irias_find_attrib</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">,</span> <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">free_ias</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_obj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Look at the type */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IAS_INTEGER</span>:
			<span class="cm">/* Add an integer attribute */</span>
			<span class="n">irias_add_integer_attrib</span><span class="p">(</span>
				<span class="n">ias_obj</span><span class="p">,</span>
				<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">,</span>
				<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_int</span><span class="p">,</span>
				<span class="n">IAS_USER_ATTR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IAS_OCT_SEQ</span>:
			<span class="cm">/* Check length */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_octet_seq</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span>
			   <span class="n">IAS_MAX_OCTET_STRING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">free_ias</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">ias_obj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Add an octet sequence attribute */</span>
			<span class="n">irias_add_octseq_attrib</span><span class="p">(</span>
			      <span class="n">ias_obj</span><span class="p">,</span>
			      <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">,</span>
			      <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_octet_seq</span><span class="p">.</span><span class="n">octet_seq</span><span class="p">,</span>
			      <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_octet_seq</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			      <span class="n">IAS_USER_ATTR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IAS_STRING</span>:
			<span class="cm">/* Should check charset &amp; co */</span>
			<span class="cm">/* Check length */</span>
			<span class="cm">/* The length is encoded in a __u8, and</span>
<span class="cm">			 * IAS_MAX_STRING == 256, so there is no way</span>
<span class="cm">			 * userspace can pass us a string too large.</span>
<span class="cm">			 * Jean II */</span>
			<span class="cm">/* NULL terminate the string (avoid troubles) */</span>
			<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">string</span><span class="p">[</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="cm">/* Add a string attribute */</span>
			<span class="n">irias_add_string_attrib</span><span class="p">(</span>
				<span class="n">ias_obj</span><span class="p">,</span>
				<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">,</span>
				<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">string</span><span class="p">,</span>
				<span class="n">IAS_USER_ATTR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">default</span> <span class="o">:</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">free_ias</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_obj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">irias_insert_object</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_IAS_DEL</span>:
		<span class="cm">/* The user want to delete an object from our local IAS</span>
<span class="cm">		 * database. We just need to query the IAS, check is the</span>
<span class="cm">		 * object is not owned by the kernel and delete it.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ias_opt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ias_opt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy query to the driver. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find the object we target.</span>
<span class="cm">		 * If the user gives us an empty string, we use the object</span>
<span class="cm">		 * associated with this socket. This will workaround</span>
<span class="cm">		 * duplicated class name - Jean II */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">irias_find_object</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ias_object</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Only ROOT can mess with the global IAS database.</span>
<span class="cm">		 * Users can only del attributes from the object associated</span>
<span class="cm">		 * with the socket they own - Jean II */</span>
		<span class="k">if</span><span class="p">((</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">((</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ias_obj</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find the attribute (in the object) we target */</span>
		<span class="n">ias_attr</span> <span class="o">=</span> <span class="n">irias_find_attrib</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">,</span>
					     <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_attr</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ias_attrib</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check is the user space own the object */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_attr</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">IAS_USER_ATTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), attempting to delete a kernel attribute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Remove the attribute (and maybe the object) */</span>
		<span class="n">irias_delete_attrib</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">,</span> <span class="n">ias_attr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_MAX_SDU_SIZE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Only possible for a seqpacket service (TTP with SAR) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), setting max_sdu_size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size_rx</span> <span class="o">=</span> <span class="n">opt</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: not allowed to set MAXSDUSIZE for this socket type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_HINTS_SET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The input is really a (__u8 hints[2]), easier as an int */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Unregister any old registration */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">skey</span><span class="p">)</span>
			<span class="n">irlmp_unregister_service</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">skey</span><span class="p">);</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">skey</span> <span class="o">=</span> <span class="n">irlmp_register_service</span><span class="p">((</span><span class="n">__u16</span><span class="p">)</span> <span class="n">opt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_HINT_MASK_SET</span>:
		<span class="cm">/* As opposed to the previous case which set the hint bits</span>
<span class="cm">		 * that we advertise, this one set the filter we use when</span>
<span class="cm">		 * making a discovery (nodes which don&#39;t match any hint</span>
<span class="cm">		 * bit in the mask are not reported).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The input is really a (__u8 hints[2]), easier as an int */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set the new hint mask */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)</span> <span class="n">opt</span><span class="p">;</span>
		<span class="cm">/* Mask out extension bits */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span> <span class="o">&amp;=</span> <span class="mh">0x7f7f</span><span class="p">;</span>
		<span class="cm">/* Check if no bits */</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_extract_ias_value(ias_opt, ias_value)</span>
<span class="cm"> *</span>
<span class="cm"> *    Translate internal IAS value structure to the user space representation</span>
<span class="cm"> *</span>
<span class="cm"> * The external representation of IAS values, as we exchange them with</span>
<span class="cm"> * user space program is quite different from the internal representation,</span>
<span class="cm"> * as stored in the IAS database (because we need a flat structure for</span>
<span class="cm"> * crossing kernel boundary).</span>
<span class="cm"> * This function transform the former in the latter. We also check</span>
<span class="cm"> * that the value type is valid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_extract_ias_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span> <span class="o">*</span><span class="n">ias_opt</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ias_value</span> <span class="o">*</span><span class="n">ias_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Look at the type */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IAS_INTEGER</span>:
		<span class="cm">/* Copy the integer */</span>
		<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_int</span> <span class="o">=</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">integer</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IAS_OCT_SEQ</span>:
		<span class="cm">/* Set length */</span>
		<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_octet_seq</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="cm">/* Copy over */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_octet_seq</span><span class="p">.</span><span class="n">octet_seq</span><span class="p">,</span>
		       <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">oct_seq</span><span class="p">,</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IAS_STRING</span>:
		<span class="cm">/* Set length */</span>
		<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">charset</span> <span class="o">=</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">;</span>
		<span class="cm">/* Copy over */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">string</span><span class="p">,</span>
		       <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">string</span><span class="p">,</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="cm">/* NULL terminate the string (avoid troubles) */</span>
		<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">.</span><span class="n">irda_attrib_string</span><span class="p">.</span><span class="n">string</span><span class="p">[</span><span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IAS_MISSING</span>:
	<span class="k">default</span> <span class="o">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy type over */</span>
	<span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_type</span> <span class="o">=</span> <span class="n">ias_value</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irda_getsockopt (sock, level, optname, optval, optlen)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_sock</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">irda_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irda_device_list</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_device_info</span> <span class="o">*</span><span class="n">discoveries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_ias_set</span> <span class="o">*</span>	<span class="n">ias_opt</span><span class="p">;</span>	<span class="cm">/* IAS get/query params */</span>
	<span class="k">struct</span> <span class="n">ias_object</span> <span class="o">*</span>	<span class="n">ias_obj</span><span class="p">;</span>	<span class="cm">/* Object in IAS */</span>
	<span class="k">struct</span> <span class="n">ias_attrib</span> <span class="o">*</span>	<span class="n">ias_attr</span><span class="p">;</span>	<span class="cm">/* Attribute in IAS object */</span>
	<span class="kt">int</span> <span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>	<span class="cm">/* Dest address for IAS queries */</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_IRLMP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRLMP_ENUMDEVICES</span>:

		<span class="cm">/* Offset to first device entry */</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_device_list</span><span class="p">)</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_device_info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ask lmp for the current discovery log */</span>
		<span class="n">discoveries</span> <span class="o">=</span> <span class="n">irlmp_get_discoveries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span><span class="p">,</span>
						    <span class="n">self</span><span class="o">-&gt;</span><span class="n">nslots</span><span class="p">);</span>
		<span class="cm">/* Check if the we got some results */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">discoveries</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>		<span class="cm">/* Didn&#39;t find any devices */</span>
		<span class="p">}</span>

		<span class="cm">/* Write total list length back to client */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* Copy the list itself - watch for overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">total</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_device_info</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">total</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">discoveries</span><span class="p">,</span> <span class="n">total</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* Write total number of bytes used back to client */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">bed:</span>
		<span class="cm">/* Free up our buffer */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">discoveries</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_MAX_SDU_SIZE</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_IAS_GET</span>:
		<span class="cm">/* The user want an object from our local IAS database.</span>
<span class="cm">		 * We just need to query the IAS and return the value</span>
<span class="cm">		 * that we found */</span>

		<span class="cm">/* Check that the user has allocated the right space for us */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ias_opt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ias_opt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy query to the driver. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find the object we target.</span>
<span class="cm">		 * If the user gives us an empty string, we use the object</span>
<span class="cm">		 * associated with this socket. This will workaround</span>
<span class="cm">		 * duplicated class name - Jean II */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_obj</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ias_obj</span> <span class="o">=</span> <span class="n">irias_find_object</span><span class="p">(</span><span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_obj</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ias_object</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find the attribute (in the object) we target */</span>
		<span class="n">ias_attr</span> <span class="o">=</span> <span class="n">irias_find_attrib</span><span class="p">(</span><span class="n">ias_obj</span><span class="p">,</span>
					     <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ias_attr</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ias_attrib</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Translate from internal to user structure */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">irda_extract_ias_value</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">,</span> <span class="n">ias_attr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy reply to the user */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">ias_opt</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Note : don&#39;t need to put optlen, we checked it */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_IAS_QUERY</span>:
		<span class="cm">/* The user want an object from a remote IAS database.</span>
<span class="cm">		 * We need to use IAP to query the remote database and</span>
<span class="cm">		 * then wait for the answer to come back. */</span>

		<span class="cm">/* Check that the user has allocated the right space for us */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ias_opt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ias_opt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy query to the driver. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* At this point, there are two cases...</span>
<span class="cm">		 * 1) the socket is connected - that&#39;s the easy case, we</span>
<span class="cm">		 *	just query the device we are connected to...</span>
<span class="cm">		 * 2) the socket is not connected - the user doesn&#39;t want</span>
<span class="cm">		 *	to connect and/or may not have a valid service name</span>
<span class="cm">		 *	(so can&#39;t create a fake connection). In this case,</span>
<span class="cm">		 *	we assume that the user pass us a valid destination</span>
<span class="cm">		 *	address in the requesting structure...</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">!=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We are connected - reuse known daddr */</span>
			<span class="n">daddr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We are not connected, we must specify a valid</span>
<span class="cm">			 * destination address */</span>
			<span class="n">daddr</span> <span class="o">=</span> <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
			<span class="k">if</span><span class="p">((</span><span class="o">!</span><span class="n">daddr</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">daddr</span> <span class="o">==</span> <span class="n">DEV_ADDR_ANY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Check that we can proceed with IAP */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: busy with a previous query</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">=</span> <span class="n">iriap_open</span><span class="p">(</span><span class="n">LSAP_ANY</span><span class="p">,</span> <span class="n">IAS_CLIENT</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
					 <span class="n">irda_getvalue_confirm</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Treat unexpected wakeup as disconnect */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>

		<span class="cm">/* Query remote LM-IAS */</span>
		<span class="n">iriap_getvaluebyclass_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span><span class="p">,</span>
					      <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span>
					      <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_class_name</span><span class="p">,</span>
					      <span class="n">ias_opt</span><span class="o">-&gt;</span><span class="n">irda_attrib_name</span><span class="p">);</span>

		<span class="cm">/* Wait for answer, if not yet finished (or failed) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">iriap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* pending request uses copy of ias_opt-content</span>
<span class="cm">			 * we can free it regardless! */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="cm">/* Treat signals as disconnect */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check what happened */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="cm">/* Requested object/attribute doesn&#39;t exist */</span>
			<span class="k">if</span><span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">==</span> <span class="n">IAS_CLASS_UNKNOWN</span><span class="p">)</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">==</span> <span class="n">IAS_ATTRIB_UNKNOWN</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Translate from internal to user structure */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">irda_extract_ias_value</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="p">)</span>
			<span class="n">irias_delete_value</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ias_result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy reply to the user */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">ias_opt</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_ias_set</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Note : don&#39;t need to put optlen, we checked it */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ias_opt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLMP_WAITDEVICE</span>:
		<span class="cm">/* This function is just another way of seeing life ;-)</span>
<span class="cm">		 * IRLMP_ENUMDEVICES assumes that you have a static network,</span>
<span class="cm">		 * and that you just want to pick one of the devices present.</span>
<span class="cm">		 * On the other hand, in here we assume that no device is</span>
<span class="cm">		 * present and that at some point in the future a device will</span>
<span class="cm">		 * come into range. When this device arrive, we just wake</span>
<span class="cm">		 * up the caller, so that he has time to connect to it before</span>
<span class="cm">		 * the device goes away...</span>
<span class="cm">		 * Note : once the node has been discovered for more than a</span>
<span class="cm">		 * few second, it won&#39;t trigger this function, unless it</span>
<span class="cm">		 * goes away and come back changes its hint bits (so we</span>
<span class="cm">		 * might call it IRLMP_WAITNEWDEVICE).</span>
<span class="cm">		 */</span>

		<span class="cm">/* Check that the user is passing us an int */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Get timeout in ms (max time we block the caller) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Tell IrLMP we want to be notified */</span>
		<span class="n">irlmp_update_client</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ckey</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span><span class="p">,</span>
				    <span class="n">irda_selective_discovery_indication</span><span class="p">,</span>
				    <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">);</span>

		<span class="cm">/* Do some discovery (and also return cached results) */</span>
		<span class="n">irlmp_discovery_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">nslots</span><span class="p">);</span>

		<span class="cm">/* Wait until a node is discovered */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), nothing discovered yet, going to sleep...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="cm">/* Set watchdog timer to expire in &lt;val&gt; ms. */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">,</span> <span class="n">irda_discovery_timeout</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">,</span>
				  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>

			<span class="cm">/* Wait for IR-LMP to call us back */</span>
			<span class="n">__wait_event_interruptible</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">query_wait</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">errno</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">),</span>
						   <span class="n">err</span><span class="p">);</span>

			<span class="cm">/* If watchdog is still activated, kill it! */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">)))</span>
				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">));</span>

			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), ...waking up !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), found immediately !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Tell IrLMP that we have been notified */</span>
		<span class="n">irlmp_update_client</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ckey</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">word</span><span class="p">,</span>
				    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/* Check if the we got some results */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>		<span class="cm">/* Didn&#39;t find any devices */</span>
		<span class="n">daddr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span><span class="p">;</span>
		<span class="cm">/* Cleanup */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">cachedaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* We return the daddr of the device that trigger the</span>
<span class="cm">		 * wakeup. As irlmp pass us only the new devices, we</span>
<span class="cm">		 * are sure that it&#39;s not an old device.</span>
<span class="cm">		 * If the user want more details, he should query</span>
<span class="cm">		 * the whole discovery log and pick one device...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">daddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="n">irda_family_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">PF_IRDA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">irda_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_stream_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_IRDA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">irda_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">irda_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">irda_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">irda_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">irda_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">irda_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">irda_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>	<span class="n">irda_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">irda_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">irda_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">irda_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">irda_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">irda_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">irda_recvmsg_stream</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_seqpacket_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_IRDA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">irda_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">irda_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">irda_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">irda_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">irda_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">datagram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">irda_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>	<span class="n">irda_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">irda_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">irda_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">irda_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">irda_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">irda_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">irda_recvmsg_dgram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_dgram_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_IRDA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">irda_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">irda_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">irda_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">irda_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">irda_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">datagram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">irda_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>	<span class="n">irda_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">irda_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">irda_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">irda_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">irda_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">irda_sendmsg_dgram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">irda_recvmsg_dgram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">irda_ultra_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_IRDA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">irda_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">irda_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">sock_no_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">sock_no_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">irda_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">datagram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">irda_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>	<span class="n">irda_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">sock_no_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">irda_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">irda_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">irda_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">irda_sendmsg_ultra</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">irda_recvmsg_dgram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irsock_init (pro)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize IrDA protocol</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">irsock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irda_proto</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sock_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irda_family_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irsock_cleanup (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove IrDA protocol</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irsock_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_unregister</span><span class="p">(</span><span class="n">PF_IRDA</span><span class="p">);</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irda_proto</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
