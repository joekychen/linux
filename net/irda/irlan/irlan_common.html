<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irlan › irlan_common.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>irlan_common.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irlan_common.c</span>
<span class="cm"> * Version:       0.9</span>
<span class="cm"> * Description:   IrDA LAN Access Protocol Implementation</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sun Aug 31 20:14:37 1997</span>
<span class="cm"> * Modified at:   Sun Dec 26 21:53:10 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1997, 1999 Dag Brattli &lt;dagb@cs.uit.no&gt;,</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irttp.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/iriap.h&gt;</span>
<span class="cp">#include &lt;net/irda/timer.h&gt;</span>

<span class="cp">#include &lt;net/irda/irlan_common.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlan_client.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlan_provider.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlan_eth.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlan_filter.h&gt;</span>


<span class="cm">/* extern char sysctl_devname[]; */</span>

<span class="cm">/*</span>
<span class="cm"> *  Master structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">irlans</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ckey</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">skey</span><span class="p">;</span>

<span class="cm">/* Module parameters */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">eth</span><span class="p">;</span>   <span class="cm">/* Use &quot;eth&quot; or &quot;irlan&quot; name for devices */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">access</span> <span class="o">=</span> <span class="n">ACCESS_PEER</span><span class="p">;</span> <span class="cm">/* PEER, DIRECT or HOSTED */</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlan_access</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;UNKNOWN&quot;</span><span class="p">,</span>
	<span class="s">&quot;DIRECT&quot;</span><span class="p">,</span>
	<span class="s">&quot;PEER&quot;</span><span class="p">,</span>
	<span class="s">&quot;HOSTED&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlan_media</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;UNKNOWN&quot;</span><span class="p">,</span>
	<span class="s">&quot;802.3&quot;</span><span class="p">,</span>
	<span class="s">&quot;802.5&quot;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_irda</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irlan_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">irlan_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">irlan_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_irda</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">irlan_open</span><span class="p">(</span><span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">daddr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__irlan_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__irlan_insert_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				<span class="n">__u8</span> <span class="n">value_byte</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value_short</span><span class="p">,</span>
				<span class="n">__u8</span> <span class="o">*</span><span class="n">value_array</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value_len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irlan_open_unicast_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irlan_get_unicast_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irlan_close_tsaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_init (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize IrLAN layer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">irlan_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">hints</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="p">{</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span>
	<span class="n">proc</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;irlan&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">proc_irda</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlan_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;irlan_init: can&#39;t create /proc entry!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
	<span class="n">hints</span> <span class="o">=</span> <span class="n">irlmp_service_to_hint</span><span class="p">(</span><span class="n">S_LAN</span><span class="p">);</span>

	<span class="cm">/* Register with IrLMP as a client */</span>
	<span class="n">ckey</span> <span class="o">=</span> <span class="n">irlmp_register_client</span><span class="p">(</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlan_client_discovery_indication</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ckey</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ckey</span><span class="p">;</span>

	<span class="cm">/* Register with IrLMP as a service */</span>
	<span class="n">skey</span> <span class="o">=</span> <span class="n">irlmp_register_service</span><span class="p">(</span><span class="n">hints</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skey</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_skey</span><span class="p">;</span>

	<span class="cm">/* Start the master IrLAN instance (the only one for now) */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">irlan_open</span><span class="p">(</span><span class="n">DEV_ADDR_ANY</span><span class="p">,</span> <span class="n">DEV_ADDR_ANY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_open</span><span class="p">;</span>

	<span class="cm">/* The master will only open its (listen) control TSAP */</span>
	<span class="n">irlan_provider_open_ctrl_tsap</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="cm">/* Do some fast discovery! */</span>
	<span class="n">irlmp_discovery_request</span><span class="p">(</span><span class="n">DISCOVERY_DEFAULT_SLOTS</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_open:</span>
	<span class="n">irlmp_unregister_service</span><span class="p">(</span><span class="n">skey</span><span class="p">);</span>
<span class="nl">err_skey:</span>
	<span class="n">irlmp_unregister_client</span><span class="p">(</span><span class="n">ckey</span><span class="p">);</span>
<span class="nl">err_ckey:</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;irlan&quot;</span><span class="p">,</span> <span class="n">proc_irda</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">irlan_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">irlmp_unregister_client</span><span class="p">(</span><span class="n">ckey</span><span class="p">);</span>
	<span class="n">irlmp_unregister_service</span><span class="p">(</span><span class="n">skey</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;irlan&quot;</span><span class="p">,</span> <span class="n">proc_irda</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

	<span class="cm">/* Cleanup any leftover network devices */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlans</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__irlan_close</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_open (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Open new instance of a client/provider, we should only register the</span>
<span class="cm"> *    network device if this instance is ment for a particular client/provider</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="nf">irlan_open</span><span class="p">(</span><span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">daddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="cm">/* Create network device with irlan */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_irlandev</span><span class="p">(</span><span class="n">eth</span> <span class="o">?</span> <span class="s">&quot;eth%d&quot;</span> <span class="o">:</span> <span class="s">&quot;irlan%d&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Initialize local device structure</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">IRLAN_MAGIC</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">saddr</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>

	<span class="cm">/* Provider access can only be PEER, DIRECT, or HOSTED */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">access_type</span> <span class="o">=</span> <span class="n">access</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">==</span> <span class="n">ACCESS_DIRECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since we are emulating an IrLAN sever we will have to</span>
<span class="cm">		 * give ourself an ethernet address!</span>
<span class="cm">		 */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">media</span> <span class="o">=</span> <span class="n">MEDIA_802_3</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_reason</span> <span class="o">=</span> <span class="n">LM_USER_REQUEST</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">kick_timer</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">txq</span><span class="p">);</span>

	<span class="n">irlan_next_client_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAN_IDLE</span><span class="p">);</span>
	<span class="n">irlan_next_provider_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAN_IDLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), register_netdev() failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span> <span class="p">);</span>
		<span class="n">self</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlans</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Function __irlan_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    This function closes and deallocates the IrLAN client instances. Be</span>
<span class="cm"> *    aware that other functions which calls client_close() must</span>
<span class="cm"> *    remove self from irlans list first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__irlan_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">kick_timer</span><span class="p">);</span>

	<span class="cm">/* Close all open connections and remove TSAPs */</span>
	<span class="n">irlan_close_tsaps</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">iriap</span><span class="p">)</span>
		<span class="n">iriap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">iriap</span><span class="p">);</span>

	<span class="cm">/* Remove frames queued on the control channel */</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">txq</span><span class="p">);</span>

	<span class="cm">/* Unregister and free self via destructor */</span>
	<span class="n">unregister_netdevice</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find any instance of irlan, used for client discovery wakeup */</span>
<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="nf">irlan_get_any</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlans</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_connect_indication (instance, sap, qos, max_sdu_size, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Here we receive the connect indication for the data channel</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_connect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span>
				     <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
				     <span class="n">__u8</span> <span class="n">max_header_size</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">tsap</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">tsap</span> <span class="o">=</span> <span class="n">sap</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">tsap</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="p">,</span><span class="k">return</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">max_header_size</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: We are now connected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="cm">/* If you want to pass the skb to *both* state machines, you will</span>
<span class="cm">	 * need to skb_clone() it, so that you don&#39;t free it twice.</span>
<span class="cm">	 * As the state machines don&#39;t need it, git rid of it here...</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">irlan_do_provider_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAN_DATA_CONNECT_INDICATION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">irlan_do_client_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAN_DATA_CONNECT_INDICATION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">access_type</span> <span class="o">==</span> <span class="n">ACCESS_PEER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Data channel is open, so we are now allowed to</span>
<span class="cm">		 * configure the remote filter</span>
<span class="cm">		 */</span>
		<span class="n">irlan_get_unicast_addr</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">irlan_open_unicast_addr</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Ready to transfer Ethernet frames (at last) */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span> <span class="cm">/* Clear reason */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_connect_confirm</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span>
				  <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
				  <span class="n">__u8</span> <span class="n">max_header_size</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_sdu_size</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">max_header_size</span><span class="p">;</span>

	<span class="cm">/* TODO: we could set the MTU depending on the max_sdu_size */</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: We are now connected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Data channel is open, so we are now allowed to configure the remote</span>
<span class="cm">	 * filter</span>
<span class="cm">	 */</span>
	<span class="n">irlan_get_unicast_addr</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="n">irlan_open_unicast_addr</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Open broadcast and multicast filter by default */</span>
	<span class="n">irlan_set_broadcast_filter</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
	<span class="n">irlan_set_multicast_filter</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

	<span class="cm">/* Ready to transfer Ethernet frames */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Clear reason */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_client_disconnect_indication (handle)</span>
<span class="cm"> *</span>
<span class="cm"> *    Callback function for the IrTTP layer. Indicates a disconnection of</span>
<span class="cm"> *    the specified connection (handle)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_disconnect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">tsap</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), reason=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span> <span class="n">reason</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">tsap</span> <span class="o">=</span> <span class="n">sap</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">tsap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">tsap</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;IrLAN, data channel disconnected by peer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Save reason so we know if we should try to reconnect or not */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_reason</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_USER_REQUEST</span>: <span class="cm">/* User request */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), User requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT</span>: <span class="cm">/* Unexpected IrLAP disconnect */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unexpected IrLAP disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_FAILURE</span>: <span class="cm">/* Failed to establish IrLAP connection */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), IrLAP connect failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_RESET</span>:  <span class="cm">/* IrLAP reset */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), IrLAP reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_INIT_DISCONNECT</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), IrLMP connect failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), Unknown disconnect reason</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If you want to pass the skb to *both* state machines, you will</span>
<span class="cm">	 * need to skb_clone() it, so that you don&#39;t free it twice.</span>
<span class="cm">	 * As the state machines don&#39;t need it, git rid of it here...</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

	<span class="n">irlan_do_client_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAN_LMP_DISCONNECT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">irlan_do_provider_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLAN_LMP_DISCONNECT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlan_open_data_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">tsap</span><span class="p">;</span>
	<span class="n">notify_t</span> <span class="n">notify</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Check if already open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">irda_notify_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="p">);</span>

	<span class="n">notify</span><span class="p">.</span><span class="n">data_indication</span>       <span class="o">=</span> <span class="n">irlan_eth_receive</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span>      <span class="o">=</span> <span class="n">irlan_eth_receive</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span>    <span class="o">=</span> <span class="n">irlan_connect_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span>       <span class="o">=</span> <span class="n">irlan_connect_confirm</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span>       <span class="o">=</span> <span class="n">irlan_eth_flow_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span> <span class="o">=</span> <span class="n">irlan_disconnect_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">instance</span>              <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;IrLAN data&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>

	<span class="n">tsap</span> <span class="o">=</span> <span class="n">irttp_open_tsap</span><span class="p">(</span><span class="n">LSAP_ANY</span><span class="p">,</span> <span class="n">DEFAULT_INITIAL_CREDIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">notify</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Got no tsap!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span> <span class="o">=</span> <span class="n">tsap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  This is the data TSAP selector which we will pass to the client</span>
<span class="cm">	 *  when the client ask for it.</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel_data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlan_close_tsaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Disconnect and close all open TSAP connections */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">P_NORMAL</span><span class="p">);</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tsap_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="n">P_NORMAL</span><span class="p">);</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="n">P_NORMAL</span><span class="p">);</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">tsap_ctrl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_reason</span> <span class="o">=</span> <span class="n">LM_USER_REQUEST</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_ias_register (self, tsap_sel)</span>
<span class="cm"> *</span>
<span class="cm"> *    Register with LM-IAS</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlan_ias_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">tsap_sel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ias_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ias_value</span> <span class="o">*</span><span class="n">new_value</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if object has already been registered by a previous provider.</span>
<span class="cm">	 * If that is the case, we just change the value of the attribute</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irias_find_object</span><span class="p">(</span><span class="s">&quot;IrLAN&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">irias_new_object</span><span class="p">(</span><span class="s">&quot;IrLAN&quot;</span><span class="p">,</span> <span class="n">IAS_IRLAN_ID</span><span class="p">);</span>
		<span class="n">irias_add_integer_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;IrDA:TinyTP:LsapSel&quot;</span><span class="p">,</span> <span class="n">tsap_sel</span><span class="p">,</span>
					 <span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
		<span class="n">irias_insert_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_value</span> <span class="o">=</span> <span class="n">irias_new_integer_value</span><span class="p">(</span><span class="n">tsap_sel</span><span class="p">);</span>
		<span class="n">irias_object_change_attribute</span><span class="p">(</span><span class="s">&quot;IrLAN&quot;</span><span class="p">,</span> <span class="s">&quot;IrDA:TinyTP:LsapSel&quot;</span><span class="p">,</span>
					      <span class="n">new_value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Register PnP object only if not registered before */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irias_find_object</span><span class="p">(</span><span class="s">&quot;PnP&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">irias_new_object</span><span class="p">(</span><span class="s">&quot;PnP&quot;</span><span class="p">,</span> <span class="n">IAS_PNP_ID</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		irias_add_string_attrib(obj, &quot;Name&quot;, sysctl_devname,</span>
<span class="c">					IAS_KERNEL_ATTR);</span>
<span class="cp">#else</span>
		<span class="n">irias_add_string_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;Name&quot;</span><span class="p">,</span> <span class="s">&quot;Linux&quot;</span><span class="p">,</span> <span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">irias_add_string_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;DeviceID&quot;</span><span class="p">,</span> <span class="s">&quot;HWP19F0&quot;</span><span class="p">,</span>
					<span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
		<span class="n">irias_add_integer_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;CompCnt&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">access_type</span> <span class="o">==</span> <span class="n">ACCESS_PEER</span><span class="p">)</span>
			<span class="n">irias_add_string_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;Comp#01&quot;</span><span class="p">,</span> <span class="s">&quot;PNP8389&quot;</span><span class="p">,</span>
						<span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">irias_add_string_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;Comp#01&quot;</span><span class="p">,</span> <span class="s">&quot;PNP8294&quot;</span><span class="p">,</span>
						<span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>

		<span class="n">irias_add_string_attrib</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;Manufacturer&quot;</span><span class="p">,</span>
					<span class="s">&quot;Linux-IrDA Project&quot;</span><span class="p">,</span> <span class="n">IAS_KERNEL_ATTR</span><span class="p">);</span>
		<span class="n">irias_insert_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_run_ctrl_tx_queue (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to send the next command in the control transmit queue</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlan_run_ctrl_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irda_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tx_busy</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">txq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tx_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that it&#39;s really possible to send commands */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">IRLAN_IDLE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tx_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), sending ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="k">return</span> <span class="n">irttp_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_ctrl_data_request (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    This function makes sure that commands on the control channel is being</span>
<span class="cm"> *    sent in a command/response fashion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_ctrl_data_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="cm">/* Queue command */</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">txq</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Try to send command */</span>
	<span class="n">irlan_run_ctrl_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_get_provider_info (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send Get Provider Information command to peer IrLAN layer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlan_get_provider_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span><span class="p">,</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for TTP, LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_GET_PROVIDER_INFO</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>                 <span class="cm">/* Zero parameters */</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_open_data_channel (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send an Open Data Command to provider</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlan_open_data_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;MEDIA&quot;</span><span class="p">,</span> <span class="s">&quot;802.3&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;ACCESS_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;DIRECT&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Build frame */</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_OPEN_DATA_CHANNEL</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span> <span class="cm">/* Two parameters */</span>

	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;MEDIA&quot;</span><span class="p">,</span> <span class="s">&quot;802.3&quot;</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;ACCESS_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;DIRECT&quot;</span><span class="p">);</span>
	<span class="cm">/* irlan_insert_string_param(skb, &quot;MODE&quot;, &quot;UNRELIABLE&quot;); */</span>

<span class="cm">/* 	self-&gt;use_udata = TRUE; */</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlan_close_data_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Check if the TSAP is still there */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">tsap_ctrl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_BYTE_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;DATA_CHAN&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Build frame */</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_CLOSE_DATA_CHAN</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* One parameter */</span>

	<span class="n">irlan_insert_byte_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;DATA_CHAN&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel_data</span><span class="p">);</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_open_unicast_addr (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Make IrLAN provider accept ethernet frames addressed to the unicast</span>
<span class="cm"> *    address.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_open_unicast_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_BYTE_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;DATA_CHAN&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;DIRECTED&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;FILTER&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for TTP, LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_FILTER_OPERATION</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>                 <span class="cm">/* Three parameters */</span>
	<span class="n">irlan_insert_byte_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;DATA_CHAN&quot;</span> <span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel_data</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;DIRECTED&quot;</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;FILTER&quot;</span><span class="p">);</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_set_broadcast_filter (self, status)</span>
<span class="cm"> *</span>
<span class="cm"> *    Make IrLAN provider accept ethernet frames addressed to the broadcast</span>
<span class="cm"> *    address. Be careful with the use of this one, since there may be a lot</span>
<span class="cm"> *    of broadcast traffic out there. We can still function without this</span>
<span class="cm"> *    one but then _we_ have to initiate all communication with other</span>
<span class="cm"> *    hosts, since ARP request for this host will not be answered.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlan_set_broadcast_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_BYTE_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;DATA_CHAN&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;BROADCAST&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="cm">/* We may waste one byte here...*/</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;FILTER&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for TTP, LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_FILTER_OPERATION</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>                 <span class="cm">/* Three parameters */</span>
	<span class="n">irlan_insert_byte_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;DATA_CHAN&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel_data</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;BROADCAST&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;FILTER&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;NONE&quot;</span><span class="p">);</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_set_multicast_filter (self, status)</span>
<span class="cm"> *</span>
<span class="cm"> *    Make IrLAN provider accept ethernet frames addressed to the multicast</span>
<span class="cm"> *    address.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlan_set_multicast_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_BYTE_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;DATA_CHAN&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;MULTICAST&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="cm">/* We may waste one byte here...*/</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;NONE&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for TTP, LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_FILTER_OPERATION</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>                 <span class="cm">/* Three parameters */</span>
	<span class="n">irlan_insert_byte_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;DATA_CHAN&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel_data</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;MULTICAST&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;ALL&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_MODE&quot;</span><span class="p">,</span> <span class="s">&quot;NONE&quot;</span><span class="p">);</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_get_unicast_addr (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Retrieves the unicast address from the IrLAN provider. This address</span>
<span class="cm"> *    will be inserted into the devices structure, so the ethernet layer</span>
<span class="cm"> *    can construct its packets.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_get_unicast_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_BYTE_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;DATA_CHAN&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;DIRECTED&quot;</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;FILTER_OPERATION&quot;</span><span class="p">,</span>
						   <span class="s">&quot;DYNAMIC&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for TTP, LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_FILTER_OPERATION</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>                 <span class="cm">/* Three parameters */</span>
	<span class="n">irlan_insert_byte_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;DATA_CHAN&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel_data</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_TYPE&quot;</span><span class="p">,</span> <span class="s">&quot;DIRECTED&quot;</span><span class="p">);</span>
	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;FILTER_OPERATION&quot;</span><span class="p">,</span> <span class="s">&quot;DYNAMIC&quot;</span><span class="p">);</span>

	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_get_media_char (self)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlan_get_media_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">IRLAN_MAX_HEADER</span> <span class="o">+</span> <span class="n">IRLAN_CMD_HEADER</span> <span class="o">+</span>
			<span class="n">IRLAN_STRING_PARAMETER_LEN</span><span class="p">(</span><span class="s">&quot;MEDIA&quot;</span><span class="p">,</span> <span class="s">&quot;802.3&quot;</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for TTP, LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">max_header_size</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Build frame */</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CMD_GET_MEDIA_CHAR</span><span class="p">;</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* One parameter */</span>

	<span class="n">irlan_insert_string_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="s">&quot;MEDIA&quot;</span><span class="p">,</span> <span class="s">&quot;802.3&quot;</span><span class="p">);</span>
	<span class="n">irlan_ctrl_data_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function insert_byte_param (skb, param, value)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert byte parameter into frame</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlan_insert_byte_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__irlan_insert_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">IRLAN_BYTE</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">irlan_insert_short_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__irlan_insert_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">IRLAN_SHORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function insert_string (skb, param, value)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert string parameter into frame</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlan_insert_string_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">string_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__irlan_insert_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">IRLAN_ARRAY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span>
				    <span class="n">string_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function insert_array_param(skb, param, value, len_value)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert array parameter into frame</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlan_insert_array_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span>
			     <span class="n">__u16</span> <span class="n">array_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__irlan_insert_param</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">IRLAN_ARRAY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span>
				    <span class="n">array_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function insert_param (skb, param, value, byte)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert parameter at end of buffer, structure of a parameter is:</span>
<span class="cm"> *</span>
<span class="cm"> *    -----------------------------------------------------------------------</span>
<span class="cm"> *    | Name Length[1] | Param Name[1..255] | Val Length[2] | Value[0..1016]|</span>
<span class="cm"> *    -----------------------------------------------------------------------</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__irlan_insert_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				<span class="n">__u8</span> <span class="n">value_byte</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value_short</span><span class="p">,</span>
				<span class="n">__u8</span> <span class="o">*</span><span class="n">value_array</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">param_len</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">tmp_le</span><span class="p">;</span> <span class="cm">/* Temporary value in little endian format */</span>
	<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Got NULL skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">param_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRLAN_BYTE</span>:
		<span class="n">value_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLAN_SHORT</span>:
		<span class="n">value_len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLAN_ARRAY</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">value_array</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">value_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown parameter type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Insert at end of sk-buffer */</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Make space for data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">param_len</span><span class="o">+</span><span class="n">value_len</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), No more space at end of skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">param_len</span><span class="o">+</span><span class="n">value_len</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>

	<span class="cm">/* Insert parameter length */</span>
	<span class="n">frame</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_len</span><span class="p">;</span>

	<span class="cm">/* Insert parameter */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">frame</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">param_len</span><span class="p">);</span> <span class="n">n</span> <span class="o">+=</span> <span class="n">param_len</span><span class="p">;</span>

	<span class="cm">/* Insert value length (2 byte little endian format, LSB first) */</span>
	<span class="n">tmp_le</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">frame</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_le</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* To avoid alignment problems */</span>

	<span class="cm">/* Insert value */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRLAN_BYTE</span>:
		<span class="n">frame</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_byte</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLAN_SHORT</span>:
		<span class="n">tmp_le</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value_short</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">frame</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_le</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRLAN_ARRAY</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">frame</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">value_array</span><span class="p">,</span> <span class="n">value_len</span><span class="p">);</span> <span class="n">n</span><span class="o">+=</span><span class="n">value_len</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">param_len</span><span class="o">+</span><span class="n">value_len</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="k">return</span> <span class="n">param_len</span><span class="o">+</span><span class="n">value_len</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlan_extract_param (buf, name, value, len)</span>
<span class="cm"> *</span>
<span class="cm"> *    Extracts a single parameter name/value pair from buffer and updates</span>
<span class="cm"> *    the buffer pointer to point to the next name/value pair.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlan_extract_param</span><span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">val_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="cm">/* get length of parameter name (1 byte) */</span>
	<span class="n">name_len</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&gt;</span> <span class="mi">254</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), name_len &gt; 254</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">RSP_INVALID_COMMAND_FORMAT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get parameter name */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="n">name</span><span class="p">[</span><span class="n">name_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">n</span><span class="o">+=</span><span class="n">name_len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get length of parameter value (2 bytes in little endian</span>
<span class="cm">	 *  format)</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val_len</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* To avoid alignment problems */</span>
	<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val_len</span><span class="p">);</span> <span class="n">n</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val_len</span> <span class="o">&gt;=</span> <span class="mi">1016</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), parameter length to long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">RSP_INVALID_COMMAND_FORMAT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">val_len</span><span class="p">;</span>

	<span class="cm">/* get parameter value */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">val_len</span><span class="p">);</span>
	<span class="n">value</span><span class="p">[</span><span class="n">val_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">n</span><span class="o">+=</span><span class="n">val_len</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Parameter: %s &quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Value: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="cm">/*</span>
<span class="cm"> * Start of reading /proc entries.</span>
<span class="cm"> * Return entry at pos,</span>
<span class="cm"> *	or start_token to indicate print header line</span>
<span class="cm"> *	or NULL if end of file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlan_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">seq_list_start_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlans</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return entry after v, and increment pos */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlan_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlans</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* End of reading /proc file */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlan_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Show one entry in /proc file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlan_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">irlans</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;IrLAN instances:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">irlan_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irlan_cb</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRLAN_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;ifname: %s,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">self</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;client state: %s, &quot;</span><span class="p">,</span>
			       <span class="n">irlan_state</span><span class="p">[</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">state</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;provider state: %s,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">irlan_state</span><span class="p">[</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">provider</span><span class="p">.</span><span class="n">state</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;saddr: %#08x, &quot;</span><span class="p">,</span>
			       <span class="n">self</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;daddr: %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;version: %d.%d,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">self</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;access type: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">irlan_access</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">access_type</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;media: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">irlan_media</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">media</span><span class="p">]);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;local filter:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;remote filter: &quot;</span><span class="p">);</span>
		<span class="n">irlan_print_filter</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">.</span><span class="n">filter_type</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="s">&quot;tx busy: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;TRUE&quot;</span> <span class="o">:</span> <span class="s">&quot;FALSE&quot;</span><span class="p">);</span>

		<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">irlan_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">irlan_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">irlan_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">irlan_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">irlan_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlan_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlan_seq_ops</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;The Linux IrDA LAN protocol&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">eth</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">eth</span><span class="p">,</span> <span class="s">&quot;Name devices ethX (0) or irlanX (1)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">access</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">access</span><span class="p">,</span> <span class="s">&quot;Access type DIRECT=1, PEER=2, HOSTED=3&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">irlan_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">irlan_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
