<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irlmp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irlmp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irlmp.c</span>
<span class="cm"> * Version:       1.0</span>
<span class="cm"> * Description:   IrDA Link Management Protocol (LMP) layer</span>
<span class="cm"> * Status:        Stable.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sun Aug 17 20:54:32 1997</span>
<span class="cm"> * Modified at:   Wed Jan  5 11:26:03 2000</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;,</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/timer.h&gt;</span>
<span class="cp">#include &lt;net/irda/qos.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/iriap.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp_frame.h&gt;</span>

<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="k">static</span> <span class="n">__u8</span> <span class="n">irlmp_find_free_slsap</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_slsap_inuse</span><span class="p">(</span><span class="n">__u8</span> <span class="n">slsap_sel</span><span class="p">);</span>

<span class="cm">/* Master structure */</span>
<span class="k">struct</span> <span class="n">irlmp_cb</span> <span class="o">*</span><span class="n">irlmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* These can be altered by the sysctl interface */</span>
<span class="kt">int</span>  <span class="n">sysctl_discovery</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span>  <span class="n">sysctl_discovery_timeout</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 3 seconds by default */</span>
<span class="kt">int</span>  <span class="n">sysctl_discovery_slots</span>   <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="cm">/* 6 slots by default */</span>
<span class="kt">int</span>  <span class="n">sysctl_lap_keepalive_time</span> <span class="o">=</span> <span class="n">LM_IDLE_TIMEOUT</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">sysctl_devname</span><span class="p">[</span><span class="mi">65</span><span class="p">];</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">irlmp_reasons</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;ERROR, NOT USED&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_USER_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_DISCONNECT&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_CONNECT_FAILURE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_RESET&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_INIT_DISCONNECT&quot;</span><span class="p">,</span>
	<span class="s">&quot;ERROR, NOT USED&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_init (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Create (allocate) the main IrLMP structure</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">irlmp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="cm">/* Initialize the irlmp structure. */</span>
	<span class="n">irlmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlmp_cb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irlmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">LMP_MAGIC</span><span class="p">;</span>

	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_NOLOCK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>

	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">last_lsap_sel</span> <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span> <span class="cm">/* Reserved 0x00-0x0f */</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">sysctl_devname</span><span class="p">,</span> <span class="s">&quot;Linux&quot;</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_timer</span><span class="p">);</span>

	<span class="cm">/* Do discovery every 3 seconds, conditionally */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_discovery</span><span class="p">)</span>
		<span class="n">irlmp_start_discovery_timer</span><span class="p">(</span><span class="n">irlmp</span><span class="p">,</span>
					    <span class="n">sysctl_discovery_timeout</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_cleanup (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove IrLMP layer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check for main structure */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_timer</span><span class="p">);</span>

	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">kfree</span><span class="p">);</span>
	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">kfree</span><span class="p">);</span>
	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">kfree</span><span class="p">);</span>
	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">kfree</span><span class="p">);</span>
	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">kfree</span><span class="p">);</span>

	<span class="cm">/* De-allocate main structure */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">irlmp</span><span class="p">);</span>
	<span class="n">irlmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_open_lsap (slsap, notify)</span>
<span class="cm"> *</span>
<span class="cm"> *   Register with IrLMP and create a local LSAP,</span>
<span class="cm"> *   returns handle to LSAP.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="nf">irlmp_open_lsap</span><span class="p">(</span><span class="n">__u8</span> <span class="n">slsap_sel</span><span class="p">,</span> <span class="n">notify_t</span> <span class="o">*</span><span class="n">notify</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">notify</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="cm">/*  Does the client care which Source LSAP selector it gets?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">LSAP_ANY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slsap_sel</span> <span class="o">=</span> <span class="n">irlmp_find_free_slsap</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slsap_sel</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">irlmp_slsap_inuse</span><span class="p">(</span><span class="n">slsap_sel</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Allocate new instance of a LSAP connection */</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">=</span> <span class="n">slsap_sel</span><span class="p">;</span>

	<span class="cm">/* Fix connectionless LSAP&#39;s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">LSAP_CONNLESS</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">LSAP_CONNLESS</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">LSAP_ANY</span><span class="p">;</span>
	<span class="cm">/* self-&gt;connected = FALSE; -&gt; already NULL via memset() */</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span> <span class="o">=</span> <span class="o">*</span><span class="n">notify</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span> <span class="o">=</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">;</span>

	<span class="cm">/* Insert into queue of unconnected LSAPs */</span>
	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_open_lsap</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function __irlmp_close_lsap (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove an instance of LSAP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__irlmp_close_lsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set some of the variables to preset values</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span> <span class="cm">/* Important! */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_close_lsap (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Close and remove LSAP</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_close_lsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Find out if we should remove this LSAP from a link or from the</span>
<span class="cm">	 *  list of unconnected lsaps (not associated with a link)</span>
<span class="cm">	 */</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
		<span class="cm">/* We might close a LSAP before it has completed the</span>
<span class="cm">		 * connection setup. In those case, higher layers won&#39;t</span>
<span class="cm">		 * send a proper disconnect request. Harmless, except</span>
<span class="cm">		 * that we will forget to close LAP... - Jean II */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span> <span class="o">!=</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span> <span class="o">=</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">;</span>
			<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span>
					   <span class="n">LM_LAP_DISCONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Now, remove from the link */</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
		<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Check if we found the LSAP! If not then try the unconnected lsaps */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span>
				      <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
		     <span class="s">&quot;%s(), Looks like somebody has removed me already!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__irlmp_close_lsap</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_close_lsap</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_register_irlap (saddr, notify)</span>
<span class="cm"> *</span>
<span class="cm"> *    Register IrLAP layer with IrLMP. There is possible to have multiple</span>
<span class="cm"> *    instances of the IrLAP layer, each connected to different IrDA ports</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_register_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlap_cb</span> <span class="o">*</span><span class="n">irlap</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">notify_t</span> <span class="o">*</span><span class="n">notify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">notify</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate new instance of a LSAP connection</span>
<span class="cm">	 */</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: unable to kmalloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="n">irlap</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">saddr</span><span class="p">;</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), unable to kmalloc lsaps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lap</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lap</span><span class="o">-&gt;</span><span class="n">lap_state</span> <span class="o">=</span> <span class="n">LAP_STANDBY</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Insert into queue of LMP links</span>
<span class="cm">	 */</span>
	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">lap</span><span class="p">,</span> <span class="n">lap</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  We set only this variable so IrLAP can tell us on which link the</span>
<span class="cm">	 *  different events happened on</span>
<span class="cm">	 */</span>
	<span class="n">irda_notify_init</span><span class="p">(</span><span class="n">notify</span><span class="p">);</span>
	<span class="n">notify</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">=</span> <span class="n">lap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_unregister_irlap (saddr)</span>
<span class="cm"> *</span>
<span class="cm"> *    IrLAP layer has been removed!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_unregister_link</span><span class="p">(</span><span class="n">__u32</span> <span class="n">saddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* We must remove ourselves from the hashbin *first*. This ensure</span>
<span class="cm">	 * that no more LSAPs will be open on this link and no discovery</span>
<span class="cm">	 * will be triggered anymore. Jean II */</span>
	<span class="n">link</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

		<span class="cm">/* Kill all the LSAPs on this link. Jean II */</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">=</span> <span class="n">LAP_DISC_INDICATION</span><span class="p">;</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">;</span>
		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/* Remove all discoveries discovered at this link */</span>
		<span class="n">irlmp_expire_discoveries</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

		<span class="cm">/* Final cleanup */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">);</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">__irlmp_close_lsap</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_connect_request (handle, dlsap, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    Connect with a peer LSAP</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_connect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dlsap_sel</span><span class="p">,</span>
			  <span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">daddr</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
	      <span class="s">&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x, saddr=%08x, daddr=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">dlsap_sel</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Client must supply destination device address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">daddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Any userdata? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">LMP_MAX_HEADER</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">LMP_MAX_HEADER</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make room for MUX control header (3 bytes) */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">dlsap_sel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the link to where we should try to connect since there may</span>
<span class="cm">	 * be more than one IrDA port on this machine. If the client has</span>
<span class="cm">	 * passed us the saddr (and already knows which link to use), then</span>
<span class="cm">	 * we use that to find the link, if not then we have to look in the</span>
<span class="cm">	 * discovery log and check if any of the links has discovered a</span>
<span class="cm">	 * device with the given daddr</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">saddr</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">saddr</span> <span class="o">==</span> <span class="n">DEV_ADDR_ANY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">discovery_t</span> <span class="o">*</span><span class="n">discovery</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">daddr</span> <span class="o">!=</span> <span class="n">DEV_ADDR_ANY</span><span class="p">)</span>
			<span class="n">discovery</span> <span class="o">=</span> <span class="n">hashbin_find</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), no daddr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">discovery</span> <span class="o">=</span> <span class="p">(</span><span class="n">discovery_t</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">discovery</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">saddr</span> <span class="o">=</span> <span class="n">discovery</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">saddr</span><span class="p">;</span>
			<span class="n">daddr</span> <span class="o">=</span> <span class="n">discovery</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="n">hashbin_lock_find</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to find a usable link!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if LAP is disconnected or already connected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">==</span> <span class="n">DEV_ADDR_ANY</span><span class="p">)</span>
		<span class="n">lap</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">!=</span> <span class="n">daddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if some LSAPs are active on this LAP */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No active connection, but LAP hasn&#39;t been</span>
<span class="cm">			 * disconnected yet (waiting for timeout in LAP).</span>
<span class="cm">			 * Maybe we could give LAP a bit of help in this case.</span>
<span class="cm">			 */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), sorry, but I&#39;m waiting for LAP to timeout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* LAP is already connected to a different node, and LAP</span>
<span class="cm">		 * can only talk to one node at a time */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), sorry, but link is busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="n">lap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove LSAP from list of unconnected LSAPs and insert it into the</span>
<span class="cm">	 *  list of connected LSAPs for the particular link</span>
<span class="cm">	 */</span>
	<span class="n">lsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span>
		       <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">);</span>	<span class="cm">/* TRUE */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  User supplied qos specifications?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="o">*</span><span class="n">qos</span><span class="p">;</span>

	<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_CONNECT_REQUEST</span><span class="p">,</span> <span class="n">tx_skb</span><span class="p">);</span>

	<span class="cm">/* Drop reference count - see irlap_data_request(). */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="cm">/* Cleanup */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_connect_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_connect_indication (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Incoming connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_connect_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_seg_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lap_header_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_header_size</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">);</span>

	<span class="cm">/* Note : self-&gt;lap is set in irlmp_link_data_indication(),</span>
<span class="cm">	 * (case CONNECT_CMD:) because we have no way to set it here.</span>
<span class="cm">	 * Similarly, self-&gt;dlsap_sel is usually set in irlmp_find_lsap().</span>
<span class="cm">	 * Jean II */</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="o">*</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">;</span>

	<span class="n">max_seg_size</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="o">-</span><span class="n">LMP_HEADER</span><span class="p">;</span>
	<span class="n">lap_header_size</span> <span class="o">=</span> <span class="n">IRLAP_GET_HEADER_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
	<span class="n">max_header_size</span> <span class="o">=</span> <span class="n">LMP_HEADER</span> <span class="o">+</span> <span class="n">lap_header_size</span><span class="p">;</span>

	<span class="cm">/* Hide LMP_CONTROL_HEADER header from layer above */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t forget to refcount it - see irlap_driver_rcv(). */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">,</span> <span class="n">max_seg_size</span><span class="p">,</span>
						<span class="n">max_header_size</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_connect_response (handle, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    Service user is accepting connection</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_connect_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">userdata</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* We set the connected bit and move the lsap to the connected list</span>
<span class="cm">	 * in the state machine itself. Jean II */</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">);</span>

	<span class="cm">/* Make room for MUX control header (3 bytes) */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">);</span>

	<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_CONNECT_RESPONSE</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>

	<span class="cm">/* Drop reference count - see irlap_data_request(). */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_connect_response</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_connect_confirm (handle, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    LSAP connection confirmed peer device!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_connect_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_header_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lap_header_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_seg_size</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="o">*</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">;</span>

	<span class="n">max_seg_size</span>    <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">qos</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">.</span><span class="n">value</span><span class="o">-</span><span class="n">LMP_HEADER</span><span class="p">;</span>
	<span class="n">lap_header_size</span> <span class="o">=</span> <span class="n">IRLAP_GET_HEADER_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
	<span class="n">max_header_size</span> <span class="o">=</span> <span class="n">LMP_HEADER</span> <span class="o">+</span> <span class="n">lap_header_size</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), max_header_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">max_header_size</span><span class="p">);</span>

	<span class="cm">/* Hide LMP_CONTROL_HEADER header from layer above */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t forget to refcount it - see irlap_driver_rcv() */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">,</span> <span class="n">max_seg_size</span><span class="p">,</span>
					     <span class="n">max_header_size</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_dup (orig, instance)</span>
<span class="cm"> *</span>
<span class="cm"> *    Duplicate LSAP, can be used by servers to confirm a connection on a</span>
<span class="cm"> *    new LSAP so it can keep listening on the old one.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="nf">irlmp_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Only allowed to duplicate unconnected LSAP&#39;s, and only LSAPs</span>
<span class="cm">	 * that have received a connect indication. Jean II */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">hashbin_find</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">orig</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), invalid LSAP (wrong state)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span>
				       <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a new instance */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unable to kmalloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span>
				       <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* new-&gt;lap = orig-&gt;lap; =&gt; done in the memcpy() */</span>
	<span class="cm">/* new-&gt;slsap_sel = orig-&gt;slsap_sel; =&gt; done in the memcpy() */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Not everything is the same */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">new</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">new</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
	<span class="cm">/* Make sure that we invalidate the LSAP cache */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_CACHE_LAST_LSAP */</span><span class="cp"></span>

	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_disconnect_request (handle, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    The service user is requesting disconnection, this will not remove the</span>
<span class="cm"> *    LSAP, but only mark it as disconnected</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_disconnect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">userdata</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Already disconnected ?</span>
<span class="cm">	 * There is a race condition between irlmp_disconnect_indication()</span>
<span class="cm">	 * and us that might mess up the hashbins below. This fixes it.</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), already disconnected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">LMP_CONTROL_HEADER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Do the event before the other stuff since we must know</span>
<span class="cm">	 *  which lap layer that the frame should be transmitted on</span>
<span class="cm">	 */</span>
	<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_DISCONNECT_REQUEST</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>

	<span class="cm">/* Drop reference count - see irlap_data_request(). */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove LSAP from list of connected LSAPs for the particular link</span>
<span class="cm">	 *  and insert it into the list of unconnected LSAPs</span>
<span class="cm">	 */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">lsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">self</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Reset some values */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">LSAP_ANY</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_disconnect_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_disconnect_indication (reason, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    LSAP is being closed!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_disconnect_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_reasons</span><span class="p">[</span><span class="n">reason</span><span class="p">]);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(), slsap_sel=%02x, dlsap_sel=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">);</span>

	<span class="cm">/* Already disconnected ?</span>
<span class="cm">	 * There is a race condition between irlmp_disconnect_request()</span>
<span class="cm">	 * and us that might mess up the hashbins below. This fixes it.</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), already disconnected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove association between this LSAP and the link it used</span>
<span class="cm">	 */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">lsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IRDA_CACHE_LAST_LSAP</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">self</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">lsap</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">lsap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">LSAP_ANY</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Inform service user</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t forget to refcount it - see irlap_driver_rcv(). */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						   <span class="n">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), no handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_do_expiry (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Do a cleanup of the discovery log (remove old entries)</span>
<span class="cm"> *</span>
<span class="cm"> * Note : separate from irlmp_do_discovery() so that we can handle</span>
<span class="cm"> * passive discovery properly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_do_expiry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Expire discovery on all links which are *not* connected.</span>
<span class="cm">	 * On links which are connected, we can&#39;t do discovery</span>
<span class="cm">	 * anymore and can&#39;t refresh the log, so we freeze the</span>
<span class="cm">	 * discovery log to keep info about the device we are</span>
<span class="cm">	 * connected to.</span>
<span class="cm">	 * This info is mandatory if we want irlmp_connect_request()</span>
<span class="cm">	 * to work properly. - Jean II</span>
<span class="cm">	 */</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lap_state</span> <span class="o">==</span> <span class="n">LAP_STANDBY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Expire discoveries discovered on this link */</span>
			<span class="n">irlmp_expire_discoveries</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">lap</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						 <span class="n">FALSE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_do_discovery (nslots)</span>
<span class="cm"> *</span>
<span class="cm"> *    Do some discovery on all links</span>
<span class="cm"> *</span>
<span class="cm"> * Note : log expiry is done above.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_do_discovery</span><span class="p">(</span><span class="kt">int</span> <span class="n">nslots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="o">*</span><span class="n">data_hintsp</span><span class="p">;</span>

	<span class="cm">/* Make sure the value is sane */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nslots</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nslots</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nslots</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nslots</span> <span class="o">!=</span> <span class="mi">16</span><span class="p">)){</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: invalid value for number of slots!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="n">nslots</span> <span class="o">=</span> <span class="n">sysctl_discovery_slots</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Construct new discovery info to be used by IrLAP, */</span>
	<span class="n">data_hintsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">hints</span><span class="p">;</span>
	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span><span class="p">,</span> <span class="n">data_hintsp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set character set for device name (we use ASCII), and</span>
<span class="cm">	 *  copy device name. Remember to make room for a \0 at the</span>
<span class="cm">	 *  end</span>
<span class="cm">	 */</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">charset</span> <span class="o">=</span> <span class="n">CS_ASCII</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">info</span><span class="p">,</span> <span class="n">sysctl_devname</span><span class="p">,</span>
		<span class="n">NICKNAME_MAX_LEN</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">.</span><span class="n">nslots</span> <span class="o">=</span> <span class="n">nslots</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to send discovery packets on all links</span>
<span class="cm">	 */</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lap_state</span> <span class="o">==</span> <span class="n">LAP_STANDBY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Try to discover */</span>
			<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_DISCOVERY_REQUEST</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_discovery_request (nslots)</span>
<span class="cm"> *</span>
<span class="cm"> *    Do a discovery of devices in front of the computer</span>
<span class="cm"> *</span>
<span class="cm"> * If the caller has registered a client discovery callback, this</span>
<span class="cm"> * allow him to receive the full content of the discovery log through</span>
<span class="cm"> * this callback (as normally he will receive only new discoveries).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_discovery_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">nslots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Return current cached discovery log (in full) */</span>
	<span class="n">irlmp_discovery_confirm</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">DISCOVERY_LOG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start a single discovery operation if discovery is not already</span>
<span class="cm">	 * running</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_discovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if user wants to override the default */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nslots</span> <span class="o">==</span> <span class="n">DISCOVERY_DEFAULT_SLOTS</span><span class="p">)</span>
			<span class="n">nslots</span> <span class="o">=</span> <span class="n">sysctl_discovery_slots</span><span class="p">;</span>

		<span class="n">irlmp_do_discovery</span><span class="p">(</span><span class="n">nslots</span><span class="p">);</span>
		<span class="cm">/* Note : we never do expiry here. Expiry will run on the</span>
<span class="cm">		 * discovery timer regardless of the state of sysctl_discovery</span>
<span class="cm">		 * Jean II */</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_discovery_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_get_discoveries (pn, mask, slots)</span>
<span class="cm"> *</span>
<span class="cm"> *    Return the current discovery log</span>
<span class="cm"> *</span>
<span class="cm"> * If discovery is not enabled, you should call this function again</span>
<span class="cm"> * after 1 or 2 seconds (i.e. after discovery has been done).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irda_device_info</span> <span class="o">*</span><span class="nf">irlmp_get_discoveries</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">pn</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nslots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If discovery is not enabled, it&#39;s likely that the discovery log</span>
<span class="cm">	 * will be empty. So, we trigger a single discovery, so that next</span>
<span class="cm">	 * time the user call us there might be some results in the log.</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_discovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if user wants to override the default */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nslots</span> <span class="o">==</span> <span class="n">DISCOVERY_DEFAULT_SLOTS</span><span class="p">)</span>
			<span class="n">nslots</span> <span class="o">=</span> <span class="n">sysctl_discovery_slots</span><span class="p">;</span>

		<span class="cm">/* Start discovery - will complete sometime later */</span>
		<span class="n">irlmp_do_discovery</span><span class="p">(</span><span class="n">nslots</span><span class="p">);</span>
		<span class="cm">/* Note : we never do expiry here. Expiry will run on the</span>
<span class="cm">		 * discovery timer regardless of the state of sysctl_discovery</span>
<span class="cm">		 * Jean II */</span>
	<span class="p">}</span>

	<span class="cm">/* Return current cached discovery log */</span>
	<span class="k">return</span> <span class="n">irlmp_copy_discoveries</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">cachelog</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_get_discoveries</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_notify_client (log)</span>
<span class="cm"> *</span>
<span class="cm"> *    Notify all about discovered devices</span>
<span class="cm"> *</span>
<span class="cm"> * Clients registered with IrLMP are :</span>
<span class="cm"> *	o IrComm</span>
<span class="cm"> *	o IrLAN</span>
<span class="cm"> *	o Any socket (in any state - ouch, that may be a lot !)</span>
<span class="cm"> * The client may have defined a callback to be notified in case of</span>
<span class="cm"> * partial/selective discovery based on the hints that it passed to IrLMP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irlmp_notify_client</span><span class="p">(</span><span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
		    <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">DISCOVERY_MODE</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">discinfo_t</span> <span class="o">*</span><span class="n">discoveries</span><span class="p">;</span>	<span class="cm">/* Copy of the discovery log */</span>
	<span class="kt">int</span>	<span class="n">number</span><span class="p">;</span>			<span class="cm">/* Number of nodes in the log */</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Check if client wants or not partial/selective log (optimisation) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">disco_callback</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locking notes :</span>
<span class="cm">	 * the old code was manipulating the log directly, which was</span>
<span class="cm">	 * very racy. Now, we use copy_discoveries, that protects</span>
<span class="cm">	 * itself while dumping the log for us.</span>
<span class="cm">	 * The overhead of the copy is compensated by the fact that</span>
<span class="cm">	 * we only pass new discoveries in normal mode and don&#39;t</span>
<span class="cm">	 * pass the same old entry every 3s to the caller as we used</span>
<span class="cm">	 * to do (virtual function calling is expensive).</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now, check all discovered devices (if any), and notify client</span>
<span class="cm">	 * only about the services that the client is interested in</span>
<span class="cm">	 * We also notify only about the new devices unless the caller</span>
<span class="cm">	 * explicitly request a dump of the log. Jean II</span>
<span class="cm">	 */</span>
	<span class="n">discoveries</span> <span class="o">=</span> <span class="n">irlmp_copy_discoveries</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">,</span>
					     <span class="n">client</span><span class="o">-&gt;</span><span class="n">hint_mask</span><span class="p">.</span><span class="n">word</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DISCOVERY_LOG</span><span class="p">));</span>
	<span class="cm">/* Check if the we got some results */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">discoveries</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>	<span class="cm">/* No nodes discovered */</span>

	<span class="cm">/* Pass all entries to the listener */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">disco_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">discoveries</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">mode</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Free up our buffer */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">discoveries</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_discovery_confirm ( self, log)</span>
<span class="cm"> *</span>
<span class="cm"> *    Some device(s) answered to our discovery request! Check to see which</span>
<span class="cm"> *    device it is, and give indication to the client(s)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_discovery_confirm</span><span class="p">(</span><span class="n">hashbin_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">DISCOVERY_MODE</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client_next</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">log</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">log</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* For each client - notify callback may touch client list */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">irlmp_client_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">hashbin_find_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">client_next</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if we should notify client */</span>
		<span class="n">irlmp_notify_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

		<span class="n">client</span> <span class="o">=</span> <span class="n">client_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_discovery_expiry (expiry)</span>
<span class="cm"> *</span>
<span class="cm"> *	This device is no longer been discovered, and therefore it is being</span>
<span class="cm"> *	purged from the discovery log. Inform all clients who have</span>
<span class="cm"> *	registered for this event...</span>
<span class="cm"> *</span>
<span class="cm"> *	Note : called exclusively from discovery.c</span>
<span class="cm"> *	Note : this is no longer called under discovery spinlock, so the</span>
<span class="cm"> *		client can do whatever he wants in the callback.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_discovery_expiry</span><span class="p">(</span><span class="n">discinfo_t</span> <span class="o">*</span><span class="n">expiries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client_next</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">expiries</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* For each client - notify callback may touch client list */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">irlmp_client_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">hashbin_find_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">client_next</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Pass all entries to the listener */</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Check if we should notify client */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">expir_callback</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">hint_mask</span><span class="p">.</span><span class="n">word</span> <span class="o">&amp;</span>
			     <span class="n">get_unaligned</span><span class="p">((</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span><span class="n">expiries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hints</span><span class="p">)</span>
			     <span class="o">&amp;</span> <span class="mh">0x7f7f</span><span class="p">)</span> <span class="p">)</span>
				<span class="n">client</span><span class="o">-&gt;</span><span class="n">expir_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">expiries</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
						       <span class="n">EXPIRY_TIMEOUT</span><span class="p">,</span>
						       <span class="n">client</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Next client */</span>
		<span class="n">client</span> <span class="o">=</span> <span class="n">client_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_get_discovery_response ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Used by IrLAP to get the discovery info it needs when answering</span>
<span class="cm"> *    discovery requests by other devices.</span>
<span class="cm"> */</span>
<span class="n">discovery_t</span> <span class="o">*</span><span class="nf">irlmp_get_discovery_response</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span><span class="p">,</span> <span class="p">(</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_rsp</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">hints</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set character set for device name (we use ASCII), and</span>
<span class="cm">	 *  copy device name. Remember to make room for a \0 at the</span>
<span class="cm">	 *  end</span>
<span class="cm">	 */</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_rsp</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">charset</span> <span class="o">=</span> <span class="n">CS_ASCII</span><span class="p">;</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_rsp</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">info</span><span class="p">,</span> <span class="n">sysctl_devname</span><span class="p">,</span>
		<span class="n">NICKNAME_MAX_LEN</span><span class="p">);</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_rsp</span><span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_rsp</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_rsp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_data_request (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send some data to peer device</span>
<span class="cm"> *</span>
<span class="cm"> * Note on skb management :</span>
<span class="cm"> * After calling the lower layers of the IrDA stack, we always</span>
<span class="cm"> * kfree() the skb, which drop the reference count (and potentially</span>
<span class="cm"> * destroy it).</span>
<span class="cm"> * IrLMP and IrLAP may queue the packet, and in those cases will need</span>
<span class="cm"> * to use skb_get() to keep it around.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_data_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Make room for MUX header */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LMP_HEADER</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">LMP_HEADER</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_DATA_REQUEST</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>

	<span class="cm">/* Drop reference count - see irlap_data_request(). */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_data_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_data_indication (handle, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Got data from LAP layer so pass it up to upper layer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_data_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Hide LMP header from layer above */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LMP_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">data_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t forget to refcount it - see irlap_driver_rcv(). */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">data_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_udata_request (self, skb)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_udata_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">userdata</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Make room for MUX header */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LMP_HEADER</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">LMP_HEADER</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_UDATA_REQUEST</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>

	<span class="cm">/* Drop reference count - see irlap_data_request(). */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_udata_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send unreliable data (but still within the connection)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_udata_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Hide LMP header from layer above */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LMP_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t forget to refcount it - see irlap_driver_rcv(). */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
					      <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_connless_data_request (self, skb)</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="kt">int</span> <span class="nf">irlmp_connless_data_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span>
				<span class="n">__u8</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">clone_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">userdata</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Make room for MUX and PID header */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LMP_HEADER</span><span class="o">+</span><span class="n">LMP_PID_HEADER</span><span class="p">,</span>
		    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Insert protocol identifier */</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">LMP_PID_HEADER</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	  <span class="n">userdata</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">else</span>
	  <span class="n">userdata</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

	<span class="cm">/* Connectionless sockets must use 0x70 */</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">LMP_HEADER</span><span class="p">);</span>
	<span class="n">userdata</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">userdata</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSAP_CONNLESS</span><span class="p">;</span>

	<span class="cm">/* Try to send Connectionless  packets out on all links */</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">clone_skb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">userdata</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clone_skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">irlap_unitdata_request</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">clone_skb</span><span class="p">);</span>
		<span class="cm">/* irlap_unitdata_request() don&#39;t increase refcount,</span>
<span class="cm">		 * so no dev_kfree_skb() - Jean II */</span>

		<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_connless_data_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Receive unreliable data outside any connection. Mostly used by Ultra</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
<span class="kt">void</span> <span class="nf">irlmp_connless_data_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Hide LMP and PID header from layer above */</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LMP_HEADER</span><span class="o">+</span><span class="n">LMP_PID_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t forget to refcount it - see irlap_driver_rcv(). */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
					      <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Propagate status indication from LAP to LSAPs (via LMP)</span>
<span class="cm"> * This don&#39;t trigger any change of state in lap_cb, lmp_cb or lsap_cb,</span>
<span class="cm"> * and the event is stateless, therefore we can bypass both state machines</span>
<span class="cm"> * and send the event direct to the LSAP user.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_status_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			     <span class="n">LINK_STATUS</span> <span class="n">link</span><span class="p">,</span> <span class="n">LOCK_STATUS</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>

	<span class="cm">/* Send status_indication to all LSAPs using this link */</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">hashbin_find_next</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">curr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Inform service user if he has requested it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">status_indication</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">curr</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">status_indication</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						       <span class="n">link</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), no handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Receive flow control indication from LAP.</span>
<span class="cm"> * LAP want us to send it one more frame. We implement a simple round</span>
<span class="cm"> * robin scheduler between the active sockets so that we get a bit of</span>
<span class="cm"> * fairness. Note that the round robin is far from perfect, but it&#39;s</span>
<span class="cm"> * better than nothing.</span>
<span class="cm"> * We then poll the selected socket so that we can do synchronous</span>
<span class="cm"> * refilling of IrLAP (which allow to minimise the number of buffers).</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_flow_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">LOCAL_FLOW</span> <span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lsap_todo</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">flow</span> <span class="o">==</span> <span class="n">FLOW_START</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Get the number of lsap. That&#39;s the only safe way to know</span>
<span class="cm">	 * that we have looped around... - Jean II */</span>
	<span class="n">lsap_todo</span> <span class="o">=</span> <span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() : %d lsaps to scan</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">lsap_todo</span><span class="p">);</span>

	<span class="cm">/* Poll lsap in order until the queue is full or until we</span>
<span class="cm">	 * tried them all.</span>
<span class="cm">	 * Most often, the current LSAP will have something to send,</span>
<span class="cm">	 * so we will go through this loop only once. - Jean II */</span>
	<span class="k">while</span><span class="p">((</span><span class="n">lsap_todo</span><span class="o">--</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="p">(</span><span class="n">IRLAP_GET_TX_QUEUE_LEN</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">LAP_HIGH_THRESHOLD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Try to find the next lsap we should poll. */</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">flow_next</span><span class="p">;</span>
		<span class="cm">/* If we have no lsap, restart from first one */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
		<span class="cm">/* Verify current one and find the next one */</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">hashbin_find_next</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">next</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flow_next</span><span class="p">);</span>
		<span class="cm">/* Uh-oh... Paranoia */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() : curr is %p, next was %p and is now %p, still %d to go - queue len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">flow_next</span><span class="p">,</span> <span class="n">lsap_todo</span><span class="p">,</span> <span class="n">IRLAP_GET_TX_QUEUE_LEN</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">));</span>

		<span class="cm">/* Inform lsap user that it can send one more packet. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">curr</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						     <span class="n">curr</span><span class="p">,</span> <span class="n">flow</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), no handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Function irlmp_hint_to_service (hint)</span>
<span class="c"> *</span>
<span class="c"> *    Returns a list of all servics contained in the given hint bits. This</span>
<span class="c"> *    function assumes that the hint bits have the size of two bytes only</span>
<span class="c"> */</span>
<span class="c">__u8 *irlmp_hint_to_service(__u8 *hint)</span>
<span class="c">{</span>
<span class="c">	__u8 *service;</span>
<span class="c">	int i = 0;</span>

<span class="c">	/*</span>
<span class="c">	 * Allocate array to store services in. 16 entries should be safe</span>
<span class="c">	 * since we currently only support 2 hint bytes</span>
<span class="c">	 */</span>
<span class="c">	service = kmalloc(16, GFP_ATOMIC);</span>
<span class="c">	if (!service) {</span>
<span class="c">		IRDA_DEBUG(1, &quot;%s(), Unable to kmalloc!\n&quot;, __func__);</span>
<span class="c">		return NULL;</span>
<span class="c">	}</span>

<span class="c">	if (!hint[0]) {</span>
<span class="c">		IRDA_DEBUG(1, &quot;&lt;None&gt;\n&quot;);</span>
<span class="c">		kfree(service);</span>
<span class="c">		return NULL;</span>
<span class="c">	}</span>
<span class="c">	if (hint[0] &amp; HINT_PNP)</span>
<span class="c">		IRDA_DEBUG(1, &quot;PnP Compatible &quot;);</span>
<span class="c">	if (hint[0] &amp; HINT_PDA)</span>
<span class="c">		IRDA_DEBUG(1, &quot;PDA/Palmtop &quot;);</span>
<span class="c">	if (hint[0] &amp; HINT_COMPUTER)</span>
<span class="c">		IRDA_DEBUG(1, &quot;Computer &quot;);</span>
<span class="c">	if (hint[0] &amp; HINT_PRINTER) {</span>
<span class="c">		IRDA_DEBUG(1, &quot;Printer &quot;);</span>
<span class="c">		service[i++] = S_PRINTER;</span>
<span class="c">	}</span>
<span class="c">	if (hint[0] &amp; HINT_MODEM)</span>
<span class="c">		IRDA_DEBUG(1, &quot;Modem &quot;);</span>
<span class="c">	if (hint[0] &amp; HINT_FAX)</span>
<span class="c">		IRDA_DEBUG(1, &quot;Fax &quot;);</span>
<span class="c">	if (hint[0] &amp; HINT_LAN) {</span>
<span class="c">		IRDA_DEBUG(1, &quot;LAN Access &quot;);</span>
<span class="c">		service[i++] = S_LAN;</span>
<span class="c">	}</span>
<span class="c">	/*</span>
<span class="c">	 *  Test if extension byte exists. This byte will usually be</span>
<span class="c">	 *  there, but this is not really required by the standard.</span>
<span class="c">	 *  (IrLMP p. 29)</span>
<span class="c">	 */</span>
<span class="c">	if (hint[0] &amp; HINT_EXTENSION) {</span>
<span class="c">		if (hint[1] &amp; HINT_TELEPHONY) {</span>
<span class="c">			IRDA_DEBUG(1, &quot;Telephony &quot;);</span>
<span class="c">			service[i++] = S_TELEPHONY;</span>
<span class="c">		} if (hint[1] &amp; HINT_FILE_SERVER)</span>
<span class="c">			IRDA_DEBUG(1, &quot;File Server &quot;);</span>

<span class="c">		if (hint[1] &amp; HINT_COMM) {</span>
<span class="c">			IRDA_DEBUG(1, &quot;IrCOMM &quot;);</span>
<span class="c">			service[i++] = S_COMM;</span>
<span class="c">		}</span>
<span class="c">		if (hint[1] &amp; HINT_OBEX) {</span>
<span class="c">			IRDA_DEBUG(1, &quot;IrOBEX &quot;);</span>
<span class="c">			service[i++] = S_OBEX;</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">	IRDA_DEBUG(1, &quot;\n&quot;);</span>

<span class="c">	/* So that client can be notified about any discovery */</span>
<span class="c">	service[i++] = S_ANY;</span>

<span class="c">	service[i] = S_END;</span>

<span class="c">	return service;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">__u16</span> <span class="n">service_hint_mapping</span><span class="p">[</span><span class="n">S_END</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">HINT_PNP</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_PNP */</span>
	<span class="p">{</span> <span class="n">HINT_PDA</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_PDA */</span>
	<span class="p">{</span> <span class="n">HINT_COMPUTER</span><span class="p">,</span>	<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_COMPUTER */</span>
	<span class="p">{</span> <span class="n">HINT_PRINTER</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_PRINTER */</span>
	<span class="p">{</span> <span class="n">HINT_MODEM</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_MODEM */</span>
	<span class="p">{</span> <span class="n">HINT_FAX</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_FAX */</span>
	<span class="p">{</span> <span class="n">HINT_LAN</span><span class="p">,</span>		<span class="mi">0</span> <span class="p">},</span>			<span class="cm">/* S_LAN */</span>
	<span class="p">{</span> <span class="n">HINT_EXTENSION</span><span class="p">,</span>	<span class="n">HINT_TELEPHONY</span> <span class="p">},</span>	<span class="cm">/* S_TELEPHONY */</span>
	<span class="p">{</span> <span class="n">HINT_EXTENSION</span><span class="p">,</span>	<span class="n">HINT_COMM</span> <span class="p">},</span>		<span class="cm">/* S_COMM */</span>
	<span class="p">{</span> <span class="n">HINT_EXTENSION</span><span class="p">,</span>	<span class="n">HINT_OBEX</span> <span class="p">},</span>		<span class="cm">/* S_OBEX */</span>
	<span class="p">{</span> <span class="mh">0xFF</span><span class="p">,</span>			<span class="mh">0xFF</span> <span class="p">},</span>			<span class="cm">/* S_ANY */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_service_to_hint (service)</span>
<span class="cm"> *</span>
<span class="cm"> *    Converts a service type, to a hint bit</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns: a 16 bit hint value, with the service bit set</span>
<span class="cm"> */</span>
<span class="n">__u16</span> <span class="nf">irlmp_service_to_hint</span><span class="p">(</span><span class="kt">int</span> <span class="n">service</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16_host_order</span> <span class="n">hint</span><span class="p">;</span>

	<span class="n">hint</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">service_hint_mapping</span><span class="p">[</span><span class="n">service</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">hint</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">service_hint_mapping</span><span class="p">[</span><span class="n">service</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">hint</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_service_to_hint</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_register_service (service)</span>
<span class="cm"> *</span>
<span class="cm"> *    Register local service with IrLMP</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">irlmp_register_service</span><span class="p">(</span><span class="n">__u16</span> <span class="n">hints</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_service_t</span> <span class="o">*</span><span class="n">service</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), hints = %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hints</span><span class="p">);</span>

	<span class="cm">/* Make a new registration */</span>
	<span class="n">service</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">irlmp_service_t</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">service</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to kmalloc!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">service</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">hints</span><span class="p">;</span>
	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">service</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">service</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span> <span class="o">|=</span> <span class="n">hints</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">service</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_register_service</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_unregister_service (handle)</span>
<span class="cm"> *</span>
<span class="cm"> *    Unregister service with IrLMP.</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns: 0 on success, -1 on error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_unregister_service</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_service_t</span> <span class="o">*</span><span class="n">service</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Caller may call with invalid handle (it&#39;s legal) - Jean II */</span>
	<span class="n">service</span> <span class="o">=</span> <span class="n">hashbin_lock_find</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">service</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown service!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hashbin_remove_this</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">service</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>

	<span class="cm">/* Remove old hint bits */</span>
	<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Refresh current hint bits */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">service</span> <span class="o">=</span> <span class="p">(</span><span class="n">irlmp_service_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">service</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span> <span class="o">|=</span> <span class="n">service</span><span class="o">-&gt;</span><span class="n">hints</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>

		<span class="n">service</span> <span class="o">=</span> <span class="p">(</span><span class="n">irlmp_service_t</span> <span class="o">*</span><span class="p">)</span><span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">services</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_unregister_service</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_register_client (hint_mask, callback1, callback2)</span>
<span class="cm"> *</span>
<span class="cm"> *    Register a local client with IrLMP</span>
<span class="cm"> *	First callback is selective discovery (based on hints)</span>
<span class="cm"> *	Second callback is for selective discovery expiries</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns: handle &gt; 0 on success, 0 on error</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">irlmp_register_client</span><span class="p">(</span><span class="n">__u16</span> <span class="n">hint_mask</span><span class="p">,</span> <span class="n">DISCOVERY_CALLBACK1</span> <span class="n">disco_clb</span><span class="p">,</span>
			    <span class="n">DISCOVERY_CALLBACK2</span> <span class="n">expir_clb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="cm">/* Make a new registration */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">irlmp_client_t</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unable to kmalloc!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register the details */</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">hint_mask</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">hint_mask</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">disco_callback</span> <span class="o">=</span> <span class="n">disco_clb</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">expir_callback</span> <span class="o">=</span> <span class="n">expir_clb</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_register_client</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_update_client (handle, hint_mask, callback1, callback2)</span>
<span class="cm"> *</span>
<span class="cm"> *    Updates specified client (handle) with possibly new hint_mask and</span>
<span class="cm"> *    callback</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns: 0 on success, -1 on error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_update_client</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">hint_mask</span><span class="p">,</span>
			<span class="n">DISCOVERY_CALLBACK1</span> <span class="n">disco_clb</span><span class="p">,</span>
			<span class="n">DISCOVERY_CALLBACK2</span> <span class="n">expir_clb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_client_t</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">client</span> <span class="o">=</span> <span class="n">hashbin_lock_find</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown client!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">client</span><span class="o">-&gt;</span><span class="n">hint_mask</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">hint_mask</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">disco_callback</span> <span class="o">=</span> <span class="n">disco_clb</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">expir_callback</span> <span class="o">=</span> <span class="n">expir_clb</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_update_client</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_unregister_client (handle)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns: 0 on success, -1 on error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irlmp_unregister_client</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlmp_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Caller may call with invalid handle (it&#39;s legal) - Jean II */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="n">hashbin_lock_find</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown client!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), removing client!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">hashbin_remove_this</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irlmp_unregister_client</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_slsap_inuse (slsap)</span>
<span class="cm"> *</span>
<span class="cm"> *    Check if the given source LSAP selector is in use</span>
<span class="cm"> *</span>
<span class="cm"> * This function is clearly not very efficient. On the mitigating side, the</span>
<span class="cm"> * stack make sure that in 99% of the cases, we are called only once</span>
<span class="cm"> * for each socket allocation. We could probably keep a bitmap</span>
<span class="cm"> * of the allocated LSAP, but I&#39;m not sure the complexity is worth it.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_slsap_inuse</span><span class="p">(</span><span class="n">__u8</span> <span class="n">slsap_sel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">slsap_sel</span> <span class="o">!=</span> <span class="n">LSAP_ANY</span><span class="p">,</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
	<span class="cm">/* Accept all bindings to the connectionless LSAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">LSAP_CONNLESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>

	<span class="cm">/* Valid values are between 0 and 127 (0x0-0x6F) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slsap_sel</span> <span class="o">&gt;</span> <span class="n">LSAP_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if slsap is already in use. To do this we have to loop over</span>
<span class="cm">	 *  every IrLAP connection and check every LSAP associated with each</span>
<span class="cm">	 *  the connection.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
			<span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">goto</span> <span class="n">errlap</span><span class="p">;);</span>

		<span class="cm">/* Careful for priority inversions here !</span>
<span class="cm">		 * irlmp-&gt;links is never taken while another IrDA</span>
<span class="cm">		 * spinlock is held, so we are safe. Jean II */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>

		<span class="cm">/* For this IrLAP, check all the LSAPs */</span>
		<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span>
				    <span class="k">goto</span> <span class="n">errlsap</span><span class="p">;);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">slsap_sel</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Source LSAP selector=%02x in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">errlsap</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span><span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>

		<span class="cm">/* Next LAP */</span>
		<span class="n">lap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Server sockets are typically waiting for connections and</span>
<span class="cm">	 * therefore reside in the unconnected list. We don&#39;t want</span>
<span class="cm">	 * to give out their LSAPs for obvious reasons...</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">goto</span> <span class="n">erruncon</span><span class="p">;);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">==</span> <span class="n">slsap_sel</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Source LSAP selector=%02x in use (unconnected)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">erruncon</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span><span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="cm">/* Error exit from within one of the two nested loops.</span>
<span class="cm">	 * Make sure we release the right spinlock in the righ order.</span>
<span class="cm">	 * Jean II */</span>
<span class="nl">errlsap:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
<span class="n">IRDA_ASSERT_LABEL</span><span class="p">(</span><span class="n">errlap</span><span class="o">:</span><span class="p">)</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="cm">/* Error exit from within the unconnected loop.</span>
<span class="cm">	 * Just one spinlock to release... Jean II */</span>
<span class="nl">erruncon:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_find_free_slsap ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Find a free source LSAP to use. This function is called if the service</span>
<span class="cm"> *    user has requested a source LSAP equal to LM_ANY</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__u8</span> <span class="nf">irlmp_find_free_slsap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">lsap_sel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wrapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Most users don&#39;t really care which LSAPs they are given,</span>
<span class="cm">	 * and therefore we automatically give them a free LSAP.</span>
<span class="cm">	 * This function try to find a suitable LSAP, i.e. which is</span>
<span class="cm">	 * not in use and is within the acceptable range. Jean II */</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Always increment to LSAP number before using it.</span>
<span class="cm">		 * In theory, we could reuse the last LSAP number, as long</span>
<span class="cm">		 * as it is no longer in use. Some IrDA stack do that.</span>
<span class="cm">		 * However, the previous socket may be half closed, i.e.</span>
<span class="cm">		 * we closed it, we think it&#39;s no longer in use, but the</span>
<span class="cm">		 * other side did not receive our close and think it&#39;s</span>
<span class="cm">		 * active and still send data on it.</span>
<span class="cm">		 * This is similar to what is done with PIDs and TCP ports.</span>
<span class="cm">		 * Also, this reduce the number of calls to irlmp_slsap_inuse()</span>
<span class="cm">		 * which is an expensive function to call.</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">last_lsap_sel</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Check if we need to wraparound (0x70-0x7f are reserved) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">last_lsap_sel</span> <span class="o">&gt;</span> <span class="n">LSAP_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* 0x00-0x10 are also reserved for well know ports */</span>
			<span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">last_lsap_sel</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>

			<span class="cm">/* Make sure we terminate the loop */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wrapped</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: no more free LSAPs !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* If the LSAP is in use, try the next one.</span>
<span class="cm">		 * Despite the autoincrement, we need to check if the lsap</span>
<span class="cm">		 * is really in use or not, first because LSAP may be</span>
<span class="cm">		 * directly allocated in irlmp_open_lsap(), and also because</span>
<span class="cm">		 * we may wraparound on old sockets. Jean II */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">irlmp_slsap_inuse</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">last_lsap_sel</span><span class="p">));</span>

	<span class="cm">/* Got it ! */</span>
	<span class="n">lsap_sel</span> <span class="o">=</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">last_lsap_sel</span><span class="p">;</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), found free lsap_sel=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">lsap_sel</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">lsap_sel</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_convert_lap_reason (lap_reason)</span>
<span class="cm"> *</span>
<span class="cm"> *    Converts IrLAP disconnect reason codes to IrLMP disconnect reason</span>
<span class="cm"> *    codes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">LM_REASON</span> <span class="nf">irlmp_convert_lap_reason</span><span class="p">(</span> <span class="n">LAP_REASON</span> <span class="n">lap_reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reason</span> <span class="o">=</span> <span class="n">LM_LAP_DISCONNECT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lap_reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LAP_DISC_INDICATION</span>: <span class="cm">/* Received a disconnect request from peer */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), LAP_DISC_INDICATION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">LM_USER_REQUEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAP_NO_RESPONSE</span>:    <span class="cm">/* To many retransmits without response */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), LAP_NO_RESPONSE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">LM_LAP_DISCONNECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAP_RESET_INDICATION</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), LAP_RESET_INDICATION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">LM_LAP_RESET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAP_FOUND_NONE</span>:
	<span class="k">case</span> <span class="n">LAP_MEDIA_BUSY</span>:
	<span class="k">case</span> <span class="n">LAP_PRIMARY_CONFLICT</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), LAP_FOUND_NONE, LAP_MEDIA_BUSY or LAP_PRIMARY_CONFLICT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">LM_CONNECT_FAILURE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown IrLAP disconnect reason %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">lap_reason</span><span class="p">);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">LM_LAP_DISCONNECT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">reason</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="k">struct</span> <span class="n">irlmp_iter_state</span> <span class="p">{</span>
	<span class="n">hashbin_t</span> <span class="o">*</span><span class="n">hashbin</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LSAP_START_TOKEN	((void *)1)</span>
<span class="cp">#define LINK_START_TOKEN	((void *)2)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlmp_seq_hb_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlmp_iter_state</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="p">);</span>
	     <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">element</span> <span class="o">=</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">off</span> <span class="o">||</span> <span class="o">*</span><span class="n">off</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* NB: hashbin left locked */</span>
			<span class="k">return</span> <span class="n">element</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlmp_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlmp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">off</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LSAP_START_TOKEN</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">irlmp_seq_hb_idx</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LINK_START_TOKEN</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">irlmp_seq_hb_idx</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irlmp_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlmp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">LSAP_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* start of list of lsaps */</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">irlmp_seq_hb_idx</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">v</span> <span class="o">?</span> <span class="n">v</span> <span class="o">:</span> <span class="n">LINK_START_TOKEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">LINK_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* start of list of links */</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">irlmp_seq_hb_idx</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* no more in this hash bin */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">==</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span>  <span class="n">LINK_START_TOKEN</span><span class="p">;</span>

		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlmp_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irlmp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="p">)</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">irlmp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">LSAP_START_TOKEN</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Unconnected LSAPs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">LINK_START_TOKEN</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Registered Link Layers:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">==</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span> <span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;lsap state: %s, &quot;</span><span class="p">,</span>
			   <span class="n">irlsap_state</span><span class="p">[</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
			   <span class="s">&quot;slsap_sel: %#02x, dlsap_sel: %#02x, &quot;</span><span class="p">,</span>
			   <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;(%s)&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hashbin</span> <span class="o">==</span> <span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">lap</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;lap state: %s, &quot;</span><span class="p">,</span>
			   <span class="n">irlmp_state</span><span class="p">[</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lap_state</span><span class="p">]);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;saddr: %#08x, daddr: %#08x, &quot;</span><span class="p">,</span>
			   <span class="n">lap</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">lap</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;num lsaps: %d&quot;</span><span class="p">,</span>
			   <span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">));</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Careful for priority inversions here !</span>
<span class="cm">		 * All other uses of attrib spinlock are independent of</span>
<span class="cm">		 * the object spinlock, so we are safe. Jean II */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">  Connected LSAPs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">);</span>
		     <span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
		     <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span><span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span>
				    <span class="k">goto</span> <span class="n">outloop</span><span class="p">;);</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  lsap state: %s, &quot;</span><span class="p">,</span>
				   <span class="n">irlsap_state</span><span class="p">[</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span><span class="p">]);</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
				   <span class="s">&quot;slsap_sel: %#02x, dlsap_sel: %#02x, &quot;</span><span class="p">,</span>
				   <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">);</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;(%s)&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="n">IRDA_ASSERT_LABEL</span><span class="p">(</span><span class="n">outloop</span><span class="o">:</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">irlmp_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">irlmp_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">irlmp_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">irlmp_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">irlmp_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;);</span>

	<span class="k">return</span> <span class="n">seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlmp_seq_ops</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irlmp_iter_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">irlmp_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">irlmp_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
