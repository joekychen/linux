<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › ircomm › ircomm_tty.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ircomm_tty.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      ircomm_tty.c</span>
<span class="cm"> * Version:       1.0</span>
<span class="cm"> * Description:   IrCOMM serial TTY driver</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sun Jun  6 21:00:56 1999</span>
<span class="cm"> * Modified at:   Wed Feb 23 00:09:02 2000</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Sources:       serial.c and previous IrCOMM work by Takahide Higuchi</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1999-2000 Dag Brattli, All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> *     GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public License</span>
<span class="cm"> *     along with this program; if not, write to the Free Software</span>
<span class="cm"> *     Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<span class="cm"> *     MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;		</span><span class="cm">/* for MODULE_ALIAS_CHARDEV_MAJOR */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irmod.h&gt;</span>

<span class="cp">#include &lt;net/irda/ircomm_core.h&gt;</span>
<span class="cp">#include &lt;net/irda/ircomm_param.h&gt;</span>
<span class="cp">#include &lt;net/irda/ircomm_tty_attach.h&gt;</span>
<span class="cp">#include &lt;net/irda/ircomm_tty.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span>  <span class="n">ircomm_tty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">ircomm_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">ircomm_tty_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">ircomm_tty_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_send_xchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_do_softint</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ircomm_tty_data_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ircomm_tty_control_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ircomm_tty_flow_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				       <span class="n">LOCAL_FLOW</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ircomm_tty_proc_fops</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

<span class="k">static</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">ircomm_tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>            <span class="o">=</span> <span class="n">ircomm_tty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>           <span class="o">=</span> <span class="n">ircomm_tty_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>           <span class="o">=</span> <span class="n">ircomm_tty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span>      <span class="o">=</span> <span class="n">ircomm_tty_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="n">ircomm_tty_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_buffer</span>    <span class="o">=</span> <span class="n">ircomm_tty_flush_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>           <span class="o">=</span> <span class="n">ircomm_tty_ioctl</span><span class="p">,</span>	<span class="cm">/* ircomm_tty_ioctl.c */</span>
	<span class="p">.</span><span class="n">tiocmget</span>        <span class="o">=</span> <span class="n">ircomm_tty_tiocmget</span><span class="p">,</span>	<span class="cm">/* ircomm_tty_ioctl.c */</span>
	<span class="p">.</span><span class="n">tiocmset</span>        <span class="o">=</span> <span class="n">ircomm_tty_tiocmset</span><span class="p">,</span>	<span class="cm">/* ircomm_tty_ioctl.c */</span>
	<span class="p">.</span><span class="n">throttle</span>        <span class="o">=</span> <span class="n">ircomm_tty_throttle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span>      <span class="o">=</span> <span class="n">ircomm_tty_unthrottle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_xchar</span>      <span class="o">=</span> <span class="n">ircomm_tty_send_xchar</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span>     <span class="o">=</span> <span class="n">ircomm_tty_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>            <span class="o">=</span> <span class="n">ircomm_tty_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>           <span class="o">=</span> <span class="n">ircomm_tty_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span>          <span class="o">=</span> <span class="n">ircomm_tty_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_until_sent</span> <span class="o">=</span> <span class="n">ircomm_tty_wait_until_sent</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="p">.</span><span class="n">proc_fops</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">ircomm_tty_proc_fops</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_init()</span>
<span class="cm"> *</span>
<span class="cm"> *    Init IrCOMM TTY layer/driver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ircomm_tty_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="n">IRCOMM_TTY_PORTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ircomm_tty</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ircomm_tty</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), can&#39;t allocate hashbin!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_name</span>     <span class="o">=</span> <span class="s">&quot;ircomm&quot;</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;ircomm&quot;</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span>           <span class="o">=</span> <span class="n">IRCOMM_TTY_MAJOR</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span>     <span class="o">=</span> <span class="n">IRCOMM_TTY_MINOR</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span>            <span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SERIAL</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span>         <span class="o">=</span> <span class="n">SERIAL_TYPE_NORMAL</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">init_termios</span>    <span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">B9600</span> <span class="o">|</span> <span class="n">CS8</span> <span class="o">|</span> <span class="n">CREAD</span> <span class="o">|</span> <span class="n">HUPCL</span> <span class="o">|</span> <span class="n">CLOCAL</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span>           <span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span><span class="p">;</span>
	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_register_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(): Couldn&#39;t register serial driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">__ircomm_tty_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">ircomm_tty_shutdown</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_cleanup ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove IrCOMM TTY layer/driver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ircomm_tty_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), failed to unregister driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">ircomm_tty</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">__ircomm_tty_cleanup</span><span class="p">);</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_startup (self)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">notify_t</span> <span class="n">notify</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Check if already open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">ASYNC_B_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), already open so break out!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register with IrCOMM */</span>
	<span class="n">irda_notify_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="p">);</span>
	<span class="cm">/* These callbacks we must handle ourselves */</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">data_indication</span>       <span class="o">=</span> <span class="n">ircomm_tty_data_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span>      <span class="o">=</span> <span class="n">ircomm_tty_control_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span>       <span class="o">=</span> <span class="n">ircomm_tty_flow_indication</span><span class="p">;</span>

	<span class="cm">/* Use the ircomm_tty interface for these ones */</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span> <span class="o">=</span> <span class="n">ircomm_tty_disconnect_indication</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span>       <span class="o">=</span> <span class="n">ircomm_tty_connect_confirm</span><span class="p">;</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span>    <span class="o">=</span> <span class="n">ircomm_tty_connect_indication</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;ircomm_tty&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>
	<span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span> <span class="o">=</span> <span class="n">ircomm_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">service_type</span><span class="p">,</span>
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">;</span>

	<span class="cm">/* Connect IrCOMM link with remote device */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ircomm_tty_attach_cable</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), error attaching cable!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNC_B_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_block_til_ready (self, filp)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_block_til_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">do_clocal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">extra_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If non-blocking mode is set, or the port is not enabled,</span>
<span class="cm">	 * then make the check up front and then exit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span> <span class="o">||</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">)){</span>
		<span class="cm">/* nonblock mode is set or port is not enabled */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), O_NONBLOCK requested!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CLOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), doing CLOCAL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="n">do_clocal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for carrier detect and the line to become</span>
<span class="cm">	 * free (i.e., not in use by the callout).  While we are in</span>
<span class="cm">	 * this loop, self-&gt;open_count is dropped by one, so that</span>
<span class="cm">	 * mgsl_close() knows when to free things.  We restore it upon</span>
<span class="cm">	 * exit, either normal or abnormal.</span>
<span class="cm">	 */</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(%d):block_til_ready before block on %s open_count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="p">);</span>

	<span class="cm">/* As far as I can see, we protect open_count - Jean II */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">extra_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="o">++</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Here, we use to lock those two guys, but</span>
<span class="cm">			 * as ircomm_param_request() does it itself,</span>
<span class="cm">			 * I don&#39;t see the point (and I see the deadlock).</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dte</span> <span class="o">|=</span> <span class="n">IRCOMM_RTS</span> <span class="o">+</span> <span class="n">IRCOMM_DTR</span><span class="p">;</span>

			<span class="n">ircomm_param_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRCOMM_DTE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ASYNC_B_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_HUP_NOTIFY</span><span class="p">)</span> <span class="o">?</span>
					<span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if link is ready now. Even if CLOCAL is</span>
<span class="cm">		 * specified, we cannot return before the IrCOMM link is</span>
<span class="cm">		 * ready</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ASYNC_B_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">do_clocal</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CD</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_READY</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(%d):block_til_ready blocking on %s open_count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="p">);</span>

		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extra_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ++ is not atomic, so this should be protected - Jean II */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="o">--</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(%d):block_til_ready after blocking on %s open_count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_open (tty, filp)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine is called when a particular tty device is opened. This</span>
<span class="cm"> *    routine is mandatory; if this routine is not filled in, the attempted</span>
<span class="cm"> *    open will fail with ENODEV.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="cm">/* Check if instance already exists */</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">hashbin_lock_find</span><span class="p">(</span><span class="n">ircomm_tty</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No, so make new instance */</span>
		<span class="n">self</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">=</span> <span class="n">FLOW_STOP</span><span class="p">;</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tqueue</span><span class="p">,</span> <span class="n">ircomm_tty_do_softint</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">IRCOMM_TTY_HDR_UNINITIALISED</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span> <span class="o">=</span> <span class="n">IRCOMM_TTY_DATA_UNINITIALISED</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">close_delay</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">closing_wait</span> <span class="o">=</span> <span class="mi">30</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>

		<span class="cm">/* Init some important stuff */</span>
		<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_wait</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Force TTY into raw mode by default which is usually what</span>
<span class="cm">		 * we want for IrCOMM and IrLPT. This way applications will</span>
<span class="cm">		 * not have to twiddle with printcap etc.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note this is completely usafe and doesn&#39;t work properly</span>
<span class="cm">		 */</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_oflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Insert into hash */</span>
		<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">ircomm_tty</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* ++ is not atomic, so this should be protected - Jean II */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), %s%d, count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>

	<span class="cm">/* Not really used by us, but lets do it anyway */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">low_latency</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_LOW_LATENCY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the port is the middle of closing, bail out now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">ASYNC_B_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Hm, why are we blocking on ASYNC_CLOSING if we</span>
<span class="cm">		 * do return -EAGAIN/-ERESTARTSYS below anyway?</span>
<span class="cm">		 * IMHO it&#39;s either not needed in the first place</span>
<span class="cm">		 * or for some reason we need to make sure the async</span>
<span class="cm">		 * closing has been finished - if so, wouldn&#39;t we</span>
<span class="cm">		 * probably better sleep uninterruptible?</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ASYNC_B_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s - got signal while blocking on ASYNC_CLOSING!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="p">}</span>

<span class="cp">#ifdef SERIAL_DO_RESTART</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_HUP_NOTIFY</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Check if this is a &quot;normal&quot; ircomm device, or an irlpt device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">service_type</span> <span class="o">=</span> <span class="n">IRCOMM_3_WIRE</span> <span class="o">|</span> <span class="n">IRCOMM_9_WIRE</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">service_type</span> <span class="o">=</span> <span class="n">IRCOMM_9_WIRE</span><span class="p">;</span> <span class="cm">/* 9 wire as default */</span>
		<span class="cm">/* Jan Kiszka -&gt; add DSR/RI -&gt; Conform to IrCOMM spec */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span> <span class="o">=</span> <span class="n">IRCOMM_CTS</span> <span class="o">|</span> <span class="n">IRCOMM_CD</span> <span class="o">|</span> <span class="n">IRCOMM_DSR</span> <span class="o">|</span> <span class="n">IRCOMM_RI</span><span class="p">;</span> <span class="cm">/* Default line settings */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), IrCOMM device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), IrLPT device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">service_type</span> <span class="o">=</span> <span class="n">IRCOMM_3_WIRE_RAW</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">service_type</span> <span class="o">=</span> <span class="n">IRCOMM_3_WIRE_RAW</span><span class="p">;</span> <span class="cm">/* Default */</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ircomm_tty_startup</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ircomm_tty_block_til_ready</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
		      <span class="s">&quot;%s(), returning after block_til_ready with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span>
		      <span class="n">ret</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_close (tty, filp)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine is called when a particular tty device is closed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), returning 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Uh, oh.  tty-&gt;count is 1, which means that the tty</span>
<span class="cm">		 * structure will be freed.  state-&gt;count should always</span>
<span class="cm">		 * be one in these conditions.  If it&#39;s greater than</span>
<span class="cm">		 * one, we&#39;ve got real problems, since it means the</span>
<span class="cm">		 * serial port won&#39;t be shutdown.</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), bad serial port count; &quot;</span>
			   <span class="s">&quot;tty-&gt;count is 1, state-&gt;count is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span>
			   <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), bad serial port count for ttys%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), open count &gt; 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Hum... Should be test_and_set_bit ??? - Jean II */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNC_B_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* We need to unlock here (we were unlocking at the end of this</span>
<span class="cm">	 * function), because tty_wait_until_sent() may schedule.</span>
<span class="cm">	 * I don&#39;t know if the rest should be protected somehow,</span>
<span class="cm">	 * so someone should check. - Jean II */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we wait for the transmit buffer to clear; and we notify</span>
<span class="cm">	 * the line discipline to only process XON/XOFF characters.</span>
<span class="cm">	 */</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">closing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">closing_wait</span> <span class="o">!=</span> <span class="n">ASYNC_CLOSING_WAIT_NONE</span><span class="p">)</span>
		<span class="n">tty_wait_until_sent_from_close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">closing_wait</span><span class="p">);</span>

	<span class="n">ircomm_tty_shutdown</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">tty_driver_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">tty_ldisc_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">closing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_delay</span><span class="p">)</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_delay</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ASYNC_NORMAL_ACTIVE</span><span class="o">|</span><span class="n">ASYNC_CLOSING</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_flush_buffer (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let do_softint() do this to avoid race condition with</span>
<span class="cm">	 * do_softint() ;-)</span>
<span class="cm">	 */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tqueue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_do_softint (work)</span>
<span class="cm"> *</span>
<span class="cm"> *    We use this routine to give the write wakeup to the user at at a</span>
<span class="cm"> *    safe time (as fast as possible after write have completed). This</span>
<span class="cm"> *    can be compared to the Tx interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_do_softint</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ircomm_tty_cb</span><span class="p">,</span> <span class="n">tqueue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">ctrl_skb</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span> <span class="o">||</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Unlink control buffer */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ctrl_skb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ctrl_skb</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">ctrl_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Flush control buffer if any */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ctrl_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">==</span> <span class="n">FLOW_START</span><span class="p">)</span>
			<span class="n">ircomm_control_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">,</span> <span class="n">ctrl_skb</span><span class="p">);</span>
		<span class="cm">/* Drop reference count - see ircomm_ttp_data_request(). */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">ctrl_skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Unlink transmit buffer */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Flush transmit buffer if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ircomm_tty_do_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRCOMM_TTY_DATA_REQUEST</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Drop reference count - see ircomm_ttp_data_request(). */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check if user (still) wants to be waken up */</span>
	<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_write (tty, buf, count)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine is called by the kernel to write a series of characters</span>
<span class="cm"> *    to the tty device. The characters may come from user space or kernel</span>
<span class="cm"> *    space. This routine will return the number of characters actually</span>
<span class="cm"> *    accepted for writing. This routine is mandatory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tailroom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), count=%d, hw_stopped=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span> <span class="n">count</span><span class="p">,</span>
		   <span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* We may receive packets from the TTY even before we have finished</span>
<span class="cm">	 * our setup. Not cool.</span>
<span class="cm">	 * The problem is that we don&#39;t know the final header and data size</span>
<span class="cm">	 * to create the proper skb, so any skb we would create would have</span>
<span class="cm">	 * bogus header and data size, so need care.</span>
<span class="cm">	 * We use a bogus header size to safely detect this condition.</span>
<span class="cm">	 * Another problem is that hw_stopped was set to 0 way before it</span>
<span class="cm">	 * should be, so we would drop this skb. It should now be fixed.</span>
<span class="cm">	 * One option is to not accept data until we are properly setup.</span>
<span class="cm">	 * But, I suspect that when it happens, the ppp line discipline</span>
<span class="cm">	 * just &quot;drops&quot; the data, which might screw up connect scripts.</span>
<span class="cm">	 * The second option is to create a &quot;safe skb&quot;, with large header</span>
<span class="cm">	 * and small size (see ircomm_tty_open() for values).</span>
<span class="cm">	 * We just need to make sure that when the real values get filled,</span>
<span class="cm">	 * we don&#39;t mess up the original &quot;safe skb&quot; (see tx_data_size).</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_HDR_UNINITIALISED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s() : not initialised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="cp">#ifdef IRCOMM_NO_TX_BEFORE_INIT</span>
		<span class="cm">/* We didn&#39;t consume anything, TTY will retry */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Protect our manipulation of self-&gt;tx_skb and related */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Fetch current transmit buffer */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send out all the data we get, possibly as multiple fragmented</span>
<span class="cm">	 * frames, but this will only happen if the data is larger than the</span>
<span class="cm">	 * max data size. The normal case however is just the opposite, and</span>
<span class="cm">	 * this function may be called multiple times, and will then actually</span>
<span class="cm">	 * defragment the data and send it out as one packet as soon as</span>
<span class="cm">	 * possible, but at a safer point in time</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* Adjust data size to the max data size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do we already have a buffer ready for transmit, or do</span>
<span class="cm">		 * we need to allocate a new frame</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Any room for more data at the end of the current</span>
<span class="cm">			 * transmit buffer? Cannot use skb_tailroom, since</span>
<span class="cm">			 * dev_alloc_skb gives us a larger skb than we</span>
<span class="cm">			 * requested</span>
<span class="cm">			 * Note : use tx_data_size, because max_data_size</span>
<span class="cm">			 * may have changed and we don&#39;t want to overwrite</span>
<span class="cm">			 * the skb. - Jean II</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tailroom</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_data_size</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Adjust data to tailroom */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">tailroom</span><span class="p">)</span>
					<span class="n">size</span> <span class="o">=</span> <span class="n">tailroom</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Current transmit frame is full, so break</span>
<span class="cm">				 * out, so we can send it as soon as possible</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Prepare a full sized frame */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="o">+</span>
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="cm">/* Remember skb size because max_data_size may</span>
<span class="cm">			 * change later on - Jean II */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_data_size</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy data */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="n">size</span><span class="p">),</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Schedule a new thread which will transmit the frame as soon</span>
<span class="cm">	 * as possible, but at a safe point in time. We do this so the</span>
<span class="cm">	 * &quot;user&quot; can give us data multiple times, as PPP does (because of</span>
<span class="cm">	 * its 256 byte tx buffer). We will then defragment and send out</span>
<span class="cm">	 * all this data as one single packet.</span>
<span class="cm">	 */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tqueue</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_write_room (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine returns the numbers of characters the tty driver will</span>
<span class="cm"> *    accept for queuing to be written. This number is subject to change as</span>
<span class="cm"> *    output buffers get emptied, or if the output flow control is acted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

<span class="cp">#ifdef IRCOMM_NO_TX_BEFORE_INIT</span>
	<span class="cm">/* max_header_size tells us if the channel is initialised or not. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_HDR_UNINITIALISED</span><span class="p">)</span>
		<span class="cm">/* Don&#39;t bother us yet */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Check if we are allowed to transmit any data.</span>
<span class="cm">	 * hw_stopped is the regular flow control.</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_data_size</span> <span class="o">-</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_wait_until_sent (tty, timeout)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine waits until the device has written out all of the</span>
<span class="cm"> *    characters in its transmitter FIFO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_jiffies</span><span class="p">,</span> <span class="n">poll_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">orig_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* Set poll time to 200 ms */</span>
	<span class="n">poll_time</span> <span class="o">=</span> <span class="n">IRDA_MIN</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">&amp;&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">poll_time</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">orig_jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_throttle (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine notifies the tty driver that input buffers for the line</span>
<span class="cm"> *    discipline are close to full, and it should somehow signal that no</span>
<span class="cm"> *    more characters should be sent to the tty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Software flow control? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">I_IXOFF</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span>
		<span class="n">ircomm_tty_send_xchar</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">STOP_CHAR</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>

	<span class="cm">/* Hardware flow control? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRCOMM_RTS</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dte</span> <span class="o">|=</span> <span class="n">IRCOMM_DELTA_RTS</span><span class="p">;</span>

		<span class="n">ircomm_param_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRCOMM_DTE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ircomm_flow_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">,</span> <span class="n">FLOW_STOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_unthrottle (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine notifies the tty drivers that it should signals that</span>
<span class="cm"> *    characters can now be sent to the tty without fear of overrunning the</span>
<span class="cm"> *    input buffers of the line disciplines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Using software flow control? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">I_IXOFF</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ircomm_tty_send_xchar</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">START_CHAR</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Using hardware flow control? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dte</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IRCOMM_RTS</span><span class="o">|</span><span class="n">IRCOMM_DELTA_RTS</span><span class="p">);</span>

		<span class="n">ircomm_param_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRCOMM_DTE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), FLOW_START</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ircomm_flow_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">,</span> <span class="n">FLOW_START</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_chars_in_buffer (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *    Indicates if there are any data in the buffer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ASYNC_B_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ircomm_tty_detach_cable</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

	<span class="cm">/* Free parameter buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ctrl_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ctrl_skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ctrl_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free transmit buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ircomm_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_hangup (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine notifies the tty driver that it should hangup the tty</span>
<span class="cm"> *    device.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* ircomm_tty_flush_buffer(tty); */</span>
	<span class="n">ircomm_tty_shutdown</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* I guess we need to lock here - Jean II */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_send_xchar (tty, ch)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine is used to send a high-priority XON/XOFF character to</span>
<span class="cm"> *    the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_send_xchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), not impl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_start (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *    This routine notifies the tty driver that it resume sending</span>
<span class="cm"> *    characters to the tty device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ircomm_tty_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">ircomm_flow_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">,</span> <span class="n">FLOW_START</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_stop (tty)</span>
<span class="cm"> *</span>
<span class="cm"> *     This routine notifies the tty driver that it should stop outputting</span>
<span class="cm"> *     characters to the tty device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">ircomm_flow_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ircomm</span><span class="p">,</span> <span class="n">FLOW_STOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_check_modem_status (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Check for any changes in the DCE&#39;s line settings. This function should</span>
<span class="cm"> *    be called whenever the dce parameter settings changes, to update the</span>
<span class="cm"> *    flow control settings and other things</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ircomm_tty_check_modem_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRCOMM_DCE_DELTA_ANY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*wake_up_interruptible(&amp;self-&gt;delta_msr_wait);*/</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CHECK_CD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRCOMM_DELTA_CD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
			   <span class="s">&quot;%s(), ircomm%d CD now %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CD</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
				   <span class="s">&quot;%s(), Doing serial hangup..</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
				<span class="n">tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

			<span class="cm">/* Hangup will remote the tty, so better break out */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CTS_FLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CTS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
					   <span class="s">&quot;%s(), CTS tx start...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
				<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="cm">/* Wake up processes blocked on open */</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>

				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tqueue</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CTS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
					   <span class="s">&quot;%s(), CTS tx stop...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
				<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_data_indication (instance, sap, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Handle incoming data, and deliver it to the line discipline</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_data_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), no tty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we receive data when hardware is stopped then something is wrong.</span>
<span class="cm">	 * We try to poll the peers line settings to check if we are up todate.</span>
<span class="cm">	 * Devices like WinCE can do this, and since they don&#39;t send any</span>
<span class="cm">	 * params, we can just as well declare the hardware for running.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">==</span> <span class="n">FLOW_START</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), polling for line settings!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="n">ircomm_param_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">IRCOMM_POLL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>

		<span class="cm">/* We can just as well declare the hardware for running */</span>
		<span class="n">ircomm_tty_send_initial_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">ircomm_tty_link_established</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use flip buffer functions since the code may be called from interrupt</span>
<span class="cm">	 * context</span>
<span class="cm">	 */</span>
	<span class="n">tty_insert_flip_string</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>

	<span class="cm">/* No need to kfree_skb - see ircomm_ttp_data_indication() */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_control_indication (instance, sap, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Parse all incoming parameters (easy!)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_control_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clen</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">clen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">irda_param_extract_all</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">IRDA_MIN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">clen</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">ircomm_param_info</span><span class="p">);</span>

	<span class="cm">/* No need to kfree_skb - see ircomm_control_indication() */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function ircomm_tty_flow_indication (instance, sap, cmd)</span>
<span class="cm"> *</span>
<span class="cm"> *    This function is called by IrTTP when it wants us to slow down the</span>
<span class="cm"> *    transmission of data. We just mark the hardware as stopped, and wait</span>
<span class="cm"> *    for IrTTP to notify us that things are OK again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_flow_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				       <span class="n">LOCAL_FLOW</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FLOW_START</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), hw start!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* ircomm_tty_do_softint will take care of the rest */</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tqueue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>  <span class="cm">/* If we get here, something is very wrong, better stop */</span>
	<span class="k">case</span> <span class="n">FLOW_STOP</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), hw stopped!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span> <span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">flow</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ircomm_tty_line_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">sep</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;State: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ircomm_tty_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">]);</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Service type: &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">service_type</span> <span class="o">&amp;</span> <span class="n">IRCOMM_9_WIRE</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;9_WIRE&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">service_type</span> <span class="o">&amp;</span> <span class="n">IRCOMM_3_WIRE</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;3_WIRE&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">service_type</span> <span class="o">&amp;</span> <span class="n">IRCOMM_3_WIRE_RAW</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;3_WIRE_RAW&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;No common service type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Port name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">port_name</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DTE status:&quot;</span><span class="p">);</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dte</span> <span class="o">&amp;</span> <span class="n">IRCOMM_RTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cRTS&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dte</span> <span class="o">&amp;</span> <span class="n">IRCOMM_DTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cDTR&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DCE status:&quot;</span><span class="p">);</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cCTS&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span> <span class="o">&amp;</span> <span class="n">IRCOMM_DSR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cDSR&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span> <span class="o">&amp;</span> <span class="n">IRCOMM_CD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cCD&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">dce</span> <span class="o">&amp;</span> <span class="n">IRCOMM_RI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cRI&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Configuration: &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">null_modem</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DTE &lt;-&gt; DCE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DTE &lt;-&gt; DTE (null modem emulation)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Data rate: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">data_rate</span><span class="p">);</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Flow control:&quot;</span><span class="p">);</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_XON_XOFF_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cXON_XOFF_IN&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_XON_XOFF_OUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cXON_XOFF_OUT&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_RTS_CTS_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cRTS_CTS_IN&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_RTS_CTS_OUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cRTS_CTS_OUT&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_DSR_DTR_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cDSR_DTR_IN&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_DSR_DTR_OUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cDSR_DTR_OUT&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_ENQ_ACK_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cENQ_ACK_IN&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">settings</span><span class="p">.</span><span class="n">flow_control</span> <span class="o">&amp;</span> <span class="n">IRCOMM_ENQ_ACK_OUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cENQ_ACK_OUT&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Flags:&quot;</span><span class="p">);</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CTS_FLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cASYNC_CTS_FLOW&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CHECK_CD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cASYNC_CHECK_CD&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cASYNC_INITIALIZED&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_LOW_LATENCY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cASYNC_LOW_LATENCY&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CLOSING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cASYNC_CLOSING&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%cASYNC_NORMAL_ACTIVE&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;|&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Role: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">client</span> <span class="o">?</span> <span class="s">&quot;client&quot;</span> <span class="o">:</span> <span class="s">&quot;server&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Open count: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Max data size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_data_size</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Max header size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Hardware: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">self</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">?</span> <span class="s">&quot;Stopped&quot;</span> <span class="o">:</span> <span class="s">&quot;Running&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ircomm_tty</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">ircomm_tty</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">IRCOMM_TTY_MAGIC</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ircomm_tty_line_info</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ircomm_tty_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">ircomm_tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ircomm_tty</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ircomm_tty_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ircomm_tty_proc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ircomm_tty_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ircomm_tty_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IrCOMM serial TTY driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_CHARDEV_MAJOR</span><span class="p">(</span><span class="n">IRCOMM_TTY_MAJOR</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ircomm_tty_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ircomm_tty_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
