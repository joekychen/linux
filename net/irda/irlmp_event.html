<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irlmp_event.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irlmp_event.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irlmp_event.c</span>
<span class="cm"> * Version:       0.8</span>
<span class="cm"> * Description:   An IrDA LMP event driver for Linux</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Mon Aug  4 20:40:53 1997</span>
<span class="cm"> * Modified at:   Tue Dec 14 23:04:16 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-1999 Dag Brattli &lt;dagb@cs.uit.no&gt;,</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/timer.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp_frame.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp_event.h&gt;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlmp_state</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;LAP_STANDBY&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_U_CONNECT&quot;</span><span class="p">,</span>
	<span class="s">&quot;LAP_ACTIVE&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlsap_state</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;LSAP_DISCONNECTED&quot;</span><span class="p">,</span>
	<span class="s">&quot;LSAP_CONNECT&quot;</span><span class="p">,</span>
	<span class="s">&quot;LSAP_CONNECT_PEND&quot;</span><span class="p">,</span>
	<span class="s">&quot;LSAP_DATA_TRANSFER_READY&quot;</span><span class="p">,</span>
	<span class="s">&quot;LSAP_SETUP&quot;</span><span class="p">,</span>
	<span class="s">&quot;LSAP_SETUP_PEND&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_IRDA_DEBUG</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">irlmp_event</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;LM_CONNECT_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_CONNECT_CONFIRM&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_CONNECT_RESPONSE&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_CONNECT_INDICATION&quot;</span><span class="p">,</span>

	<span class="s">&quot;LM_DISCONNECT_INDICATION&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_DISCONNECT_REQUEST&quot;</span><span class="p">,</span>

	<span class="s">&quot;LM_DATA_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_UDATA_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_DATA_INDICATION&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_UDATA_INDICATION&quot;</span><span class="p">,</span>

	<span class="s">&quot;LM_WATCHDOG_TIMEOUT&quot;</span><span class="p">,</span>

	<span class="cm">/* IrLAP events */</span>
	<span class="s">&quot;LM_LAP_CONNECT_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_CONNECT_INDICATION&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_CONNECT_CONFIRM&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_DISCONNECT_INDICATION&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_DISCONNECT_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_DISCOVERY_REQUEST&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_DISCOVERY_CONFIRM&quot;</span><span class="p">,</span>
	<span class="s">&quot;LM_LAP_IDLE_TIMEOUT&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_IRDA_DEBUG */</span><span class="cp"></span>

<span class="cm">/* LAP Connection control proto declarations */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irlmp_state_standby</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irlmp_state_u_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irlmp_state_active</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* LSAP Connection control proto declarations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_state_disconnected</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_state_connect</span>     <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_state_connect_pend</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_state_dtr</span>         <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_state_setup</span>       <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irlmp_state_setup_pend</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lap_state</span><span class="p">[])</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="n">irlmp_state_standby</span><span class="p">,</span>
	<span class="n">irlmp_state_u_connect</span><span class="p">,</span>
	<span class="n">irlmp_state_active</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lsap_state</span><span class="p">[])(</span> <span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="n">irlmp_state_disconnected</span><span class="p">,</span>
	<span class="n">irlmp_state_connect</span><span class="p">,</span>
	<span class="n">irlmp_state_connect_pend</span><span class="p">,</span>
	<span class="n">irlmp_state_dtr</span><span class="p">,</span>
	<span class="n">irlmp_state_setup</span><span class="p">,</span>
	<span class="n">irlmp_state_setup_pend</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irlmp_next_lap_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					<span class="n">IRLMP_STATE</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	IRDA_DEBUG(4, &quot;%s(), LMP LAP = %s\n&quot;, __func__, irlmp_state[state]);</span>
<span class="cm">	*/</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irlmp_next_lsap_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					 <span class="n">LSAP_STATE</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	IRDA_ASSERT(self != NULL, return;);</span>
<span class="cm">	IRDA_DEBUG(4, &quot;%s(), LMP LSAP = %s\n&quot;, __func__, irlsap_state[state]);</span>
<span class="cm">	*/</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do connection control events */</span>
<span class="kt">int</span> <span class="nf">irlmp_do_lsap_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), EVENT = %s, STATE = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">irlsap_state</span><span class="p">[</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span><span class="p">]);</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">lsap_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap_state</span><span class="p">])</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function do_lap_event (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    Do IrLAP control events</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irlmp_do_lap_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), EVENT = %s, STATE = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span>
		   <span class="n">irlmp_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap_state</span><span class="p">]);</span>

	<span class="p">(</span><span class="o">*</span><span class="n">lap_state</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap_state</span><span class="p">])</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlmp_discovery_timer_expired</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* We always cleanup the log (active &amp; passive discovery) */</span>
	<span class="n">irlmp_do_expiry</span><span class="p">();</span>

	<span class="n">irlmp_do_discovery</span><span class="p">(</span><span class="n">sysctl_discovery_slots</span><span class="p">);</span>

	<span class="cm">/* Restart timer */</span>
	<span class="n">irlmp_start_discovery_timer</span><span class="p">(</span><span class="n">irlmp</span><span class="p">,</span> <span class="n">sysctl_discovery_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlmp_watchdog_timer_expired</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_WATCHDOG_TIMEOUT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irlmp_idle_timer_expired</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_LAP_IDLE_TIMEOUT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send an event on all LSAPs attached to this LAP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">hashbin_t</span> <span class="o">*</span>	<span class="n">lsap_hashbin</span><span class="p">,</span>
			<span class="n">IRLMP_EVENT</span>	<span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap_next</span><span class="p">;</span>

	<span class="cm">/* Note : this function use the new hashbin_find_next()</span>
<span class="cm">	 * function, instead of the old hashbin_get_next().</span>
<span class="cm">	 * This make sure that we are always pointing one lsap</span>
<span class="cm">	 * ahead, so that if the current lsap is removed as the</span>
<span class="cm">	 * result of sending the event, we don&#39;t care.</span>
<span class="cm">	 * Also, as we store the context ourselves, if an enumeration</span>
<span class="cm">	 * of the same lsap hashbin happens as the result of sending the</span>
<span class="cm">	 * event, we don&#39;t care.</span>
<span class="cm">	 * The only problem is if the next lsap is removed. In that case,</span>
<span class="cm">	 * hashbin_find_next() will return NULL and we will abort the</span>
<span class="cm">	 * enumeration. - Jean II */</span>

	<span class="cm">/* Also : we don&#39;t accept any skb in input. We can *NOT* pass</span>
<span class="cm">	 * the same skb to multiple clients safely, we would need to</span>
<span class="cm">	 * skb_clone() it. - Jean II */</span>

	<span class="n">lsap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">lsap_hashbin</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">hashbin_find_next</span><span class="p">(</span><span class="n">lsap_hashbin</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">lsap</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lsap_next</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">irlmp_do_lsap_event</span><span class="p">(</span><span class="n">lsap</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="n">lsap_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *    LAP connection control states</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_standby (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    STANDBY, The IrLAP connection does not exist.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlmp_state_standby</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCOVERY_REQUEST</span>:
		<span class="cm">/* irlmp_next_station_state( LMP_DISCOVER); */</span>

		<span class="n">irlap_discovery_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">discovery_cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_INDICATION</span>:
		<span class="cm">/*  It&#39;s important to switch state first, to avoid IrLMP to</span>
<span class="cm">		 *  think that the link is free since IrLMP may then start</span>
<span class="cm">		 *  discovery before the connection is properly set up. DB.</span>
<span class="cm">		 */</span>
		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_ACTIVE</span><span class="p">);</span>

		<span class="cm">/* Just accept connection TODO, this should be fixed */</span>
		<span class="n">irlap_connect_response</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() LS_CONNECT_REQUEST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_U_CONNECT</span><span class="p">);</span>

		<span class="cm">/* FIXME: need to set users requested QoS */</span>
		<span class="n">irlap_connect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), Error LM_LAP_DISCONNECT_INDICATION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>

		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_STANDBY</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_u_connect (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    U_CONNECT, The layer above has tried to open an LSAP connection but</span>
<span class="cm"> *    since the IrLAP connection does not exist, we must first start an</span>
<span class="cm"> *    IrLAP connection. We are now waiting response from IrLAP.</span>
<span class="cm"> * */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlmp_state_u_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), event=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_INDICATION</span>:
		<span class="cm">/*  It&#39;s important to switch state first, to avoid IrLMP to</span>
<span class="cm">		 *  think that the link is free since IrLMP may then start</span>
<span class="cm">		 *  discovery before the connection is properly set up. DB.</span>
<span class="cm">		 */</span>
		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_ACTIVE</span><span class="p">);</span>

		<span class="cm">/* Just accept connection TODO, this should be fixed */</span>
		<span class="n">irlap_connect_response</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* Tell LSAPs that they can start sending data */</span>
		<span class="n">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span><span class="p">);</span>

		<span class="cm">/* Note : by the time we get there (LAP retries and co),</span>
<span class="cm">		 * the lsaps may already have gone. This avoid getting stuck</span>
<span class="cm">		 * forever in LAP_ACTIVE state - Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() NO LSAPs !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlmp_start_idle_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_IDLE_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_REQUEST</span>:
		<span class="cm">/* Already trying to connect */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span>:
		<span class="cm">/* For all lsap_ce E Associated do LS_Connect_confirm */</span>
		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_ACTIVE</span><span class="p">);</span>

		<span class="cm">/* Tell LSAPs that they can start sending data */</span>
		<span class="n">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span><span class="p">);</span>

		<span class="cm">/* Note : by the time we get there (LAP retries and co),</span>
<span class="cm">		 * the lsaps may already have gone. This avoid getting stuck</span>
<span class="cm">		 * forever in LAP_ACTIVE state - Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() NO LSAPs !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlmp_start_idle_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_IDLE_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), LM_LAP_DISCONNECT_INDICATION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_STANDBY</span><span class="p">);</span>

		<span class="cm">/* Send disconnect event to all LSAPs using this link */</span>
		<span class="n">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span>
					<span class="n">LM_LAP_DISCONNECT_INDICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), LM_LAP_DISCONNECT_REQUEST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* One of the LSAP did timeout or was closed, if it was</span>
<span class="cm">		 * the last one, try to get out of here - Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irlap_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_active (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    ACTIVE, IrLAP connection is active</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irlmp_state_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">lap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), LS_CONNECT_REQUEST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * IrLAP may have a pending disconnect. We tried to close</span>
<span class="cm">		 * IrLAP, but it was postponed because the link was</span>
<span class="cm">		 * busy or we were still sending packets. As we now</span>
<span class="cm">		 * need it, make sure it stays on. Jean II</span>
<span class="cm">		 */</span>
		<span class="n">irlap_clear_disconnect</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  LAP connection already active, just bounce back! Since we</span>
<span class="cm">		 *  don&#39;t know which LSAP that tried to do this, we have to</span>
<span class="cm">		 *  notify all LSAPs using this LAP, but that should be safe to</span>
<span class="cm">		 *  do anyway.</span>
<span class="cm">		 */</span>
		<span class="n">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span><span class="p">);</span>

		<span class="cm">/* Needed by connect indication */</span>
		<span class="n">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span>
					<span class="n">LM_LAP_CONNECT_CONFIRM</span><span class="p">);</span>
		<span class="cm">/* Keep state */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_REQUEST</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Need to find out if we should close IrLAP or not. If there</span>
<span class="cm">		 *  is only one LSAP connection left on this link, that LSAP</span>
<span class="cm">		 *  must be the one that tries to close IrLAP. It will be</span>
<span class="cm">		 *  removed later and moved to the list of unconnected LSAPs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Timer value is checked in irsysctl - Jean II */</span>
			<span class="n">irlmp_start_idle_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">sysctl_lap_keepalive_time</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* No more connections, so close IrLAP */</span>

			<span class="cm">/* We don&#39;t want to change state just yet, because</span>
<span class="cm">			 * we want to reflect accurately the real state of</span>
<span class="cm">			 * the LAP, not the state we wish it was in,</span>
<span class="cm">			 * so that we don&#39;t lose LM_LAP_CONNECT_REQUEST.</span>
<span class="cm">			 * In some cases, IrLAP won&#39;t close the LAP</span>
<span class="cm">			 * immediately. For example, it might still be</span>
<span class="cm">			 * retrying packets or waiting for the pf bit.</span>
<span class="cm">			 * As the LAP always send a DISCONNECT_INDICATION</span>
<span class="cm">			 * in PCLOSE or SCLOSE, just change state on that.</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">irlap_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_IDLE_TIMEOUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">HASHBIN_GET_SIZE</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Same reasoning as above - keep state */</span>
			<span class="n">irlap_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span>:
		<span class="n">irlmp_next_lap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LAP_STANDBY</span><span class="p">);</span>

		<span class="cm">/* In some case, at this point our side has already closed</span>
<span class="cm">		 * all lsaps, and we are waiting for the idle_timer to</span>
<span class="cm">		 * expire. If another device reconnect immediately, the</span>
<span class="cm">		 * idle timer will expire in the midle of the connection</span>
<span class="cm">		 * initialisation, screwing up things a lot...</span>
<span class="cm">		 * Therefore, we must stop the timer... */</span>
		<span class="n">irlmp_stop_idle_timer</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Inform all connected LSAP&#39;s using this link</span>
<span class="cm">		 */</span>
		<span class="n">irlmp_do_all_lsap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span>
					<span class="n">LM_LAP_DISCONNECT_INDICATION</span><span class="p">);</span>

		<span class="cm">/* Force an expiry of the discovery log.</span>
<span class="cm">		 * Now that the LAP is free, the system may attempt to</span>
<span class="cm">		 * connect to another device. Unfortunately, our entries</span>
<span class="cm">		 * are stale. There is a small window (&lt;3s) before the</span>
<span class="cm">		 * normal discovery will run and where irlmp_connect_request()</span>
<span class="cm">		 * can get the wrong info, so make sure things get</span>
<span class="cm">		 * cleaned *NOW* ;-) - Jean II */</span>
		<span class="n">irlmp_do_expiry</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *    LSAP connection control states</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_disconnected (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    DISCONNECTED</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_state_disconnected</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IRDA_ULTRA</span>
	<span class="k">case</span> <span class="n">LM_UDATA_INDICATION</span>:
		<span class="cm">/* This is most bizarre. Those packets are  aka unreliable</span>
<span class="cm">		 * connected, aka IrLPT or SOCK_DGRAM/IRDAPROTO_UNITDATA.</span>
<span class="cm">		 * Why do we pass them as Ultra ??? Jean II */</span>
		<span class="n">irlmp_connless_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRDA_ULTRA */</span><span class="cp"></span>
	<span class="k">case</span> <span class="n">LM_CONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), LM_CONNECT_REQUEST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: busy with another request!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Don&#39;t forget to refcount it (see irlmp_connect_request()) */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_SETUP_PEND</span><span class="p">);</span>

		<span class="cm">/* Start watchdog timer (5 secs for now) */</span>
		<span class="n">irlmp_start_watchdog_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_INDICATION</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: busy with another request!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Don&#39;t forget to refcount it (see irlap_driver_rcv()) */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_CONNECT_PEND</span><span class="p">);</span>

		<span class="cm">/* Start watchdog timer</span>
<span class="cm">		 * This is not mentionned in the spec, but there is a rare</span>
<span class="cm">		 * race condition that can get the socket stuck.</span>
<span class="cm">		 * If we receive this event while our LAP is closing down,</span>
<span class="cm">		 * the LM_LAP_CONNECT_REQUEST get lost and we get stuck in</span>
<span class="cm">		 * CONNECT_PEND state forever.</span>
<span class="cm">		 * The other cause of getting stuck down there is if the</span>
<span class="cm">		 * higher layer never reply to the CONNECT_INDICATION.</span>
<span class="cm">		 * Anyway, it make sense to make sure that we always have</span>
<span class="cm">		 * a backup plan. 1 second is plenty (should be immediate).</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">irlmp_start_watchdog_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_CONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s on LSAP %#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_connect (self, event, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    CONNECT</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_state_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_RESPONSE</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Bind this LSAP to the IrLAP link where the connect was</span>
<span class="cm">		 *  received</span>
<span class="cm">		 */</span>
		<span class="n">lsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">irlmp</span><span class="o">-&gt;</span><span class="n">unconnected_lsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span>
				      <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">self</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">lsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">);</span>	<span class="cm">/* TRUE */</span>

		<span class="n">irlmp_send_lcf_pdu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">,</span>
				   <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">CONNECT_CNF</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DATA_TRANSFER_READY</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_WATCHDOG_TIMEOUT</span>:
		<span class="cm">/* May happen, who knows...</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() WATCHDOG_TIMEOUT!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Disconnect, get out... - Jean II */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">LSAP_ANY</span><span class="p">;</span>
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* LM_LAP_DISCONNECT_INDICATION : Should never happen, we</span>
<span class="cm">		 * are *not* yet bound to the IrLAP link. Jean II */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s on LSAP %#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_connect_pend (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    CONNECT_PEND</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_state_connect_pend</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_REQUEST</span>:
		<span class="cm">/* Keep state */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_RESPONSE</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), LM_CONNECT_RESPONSE, &quot;</span>
			   <span class="s">&quot;no indication issued yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Keep state */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_DISCONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), LM_DISCONNECT_REQUEST, &quot;</span>
			   <span class="s">&quot;not yet bound to IrLAP connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Keep state */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), LS_CONNECT_CONFIRM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_CONNECT</span><span class="p">);</span>

		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">irlmp_connect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">tx_skb</span><span class="p">);</span>
		<span class="cm">/* Drop reference count - see irlmp_connect_indication(). */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_WATCHDOG_TIMEOUT</span>:
		<span class="cm">/* Will happen in some rare cases because of a race condition.</span>
<span class="cm">		 * Just make sure we don&#39;t stay there forever...</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() WATCHDOG_TIMEOUT!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Go back to disconnected mode, keep the socket waiting */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span> <span class="o">=</span> <span class="n">LSAP_ANY</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* LM_LAP_DISCONNECT_INDICATION : Should never happen, we</span>
<span class="cm">		 * are *not* yet bound to the IrLAP link. Jean II */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s on LSAP %#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_dtr (self, event, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    DATA_TRANSFER_READY</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_state_dtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_DATA_REQUEST</span>: <span class="cm">/* Optimize for the common case */</span>
		<span class="n">irlmp_send_data_pdu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">,</span>
				    <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_DATA_INDICATION</span>: <span class="cm">/* Optimize for the common case */</span>
		<span class="n">irlmp_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_UDATA_REQUEST</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">irlmp_send_data_pdu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">,</span>
				    <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_UDATA_INDICATION</span>:
		<span class="n">irlmp_udata_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_REQUEST</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), LM_CONNECT_REQUEST, &quot;</span>
			   <span class="s">&quot;error, LSAP already connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Keep state */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_RESPONSE</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), LM_CONNECT_RESPONSE, &quot;</span>
			   <span class="s">&quot;error, LSAP already connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Keep state */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_DISCONNECT_REQUEST</span>:
		<span class="n">irlmp_send_lcf_pdu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span>
				   <span class="n">DISCONNECT</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>
		<span class="cm">/* Called only from irlmp_disconnect_request(), will</span>
<span class="cm">		 * unbind from LAP over there. Jean II */</span>

		<span class="cm">/* Try to close the LAP connection if its still there */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), trying to close IrLAP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span>
					   <span class="n">LM_LAP_DISCONNECT_REQUEST</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span>:
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">reason</span> <span class="o">=</span> <span class="n">irlmp_convert_lap_reason</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_DISCONNECT_INDICATION</span>:
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		 <span class="cm">/* Try to close the LAP connection */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), trying to close IrLAP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_DISCONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s on LSAP %#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_setup (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    SETUP, Station Control has set up the underlying IrLAP connection.</span>
<span class="cm"> *    An LSAP connection request has been transmitted to the peer</span>
<span class="cm"> *    LSAP-Connection Control FSM and we are awaiting reply.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_state_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_CONNECT_CONFIRM</span>:
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DATA_TRANSFER_READY</span><span class="p">);</span>

		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

		<span class="n">irlmp_connect_confirm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_DISCONNECT_INDICATION</span>:
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		 <span class="cm">/* Try to close the LAP connection */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), trying to close IrLAP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_DISCONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span>:
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">LMP_LAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">reason</span> <span class="o">=</span> <span class="n">irlmp_convert_lap_reason</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_WATCHDOG_TIMEOUT</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() WATCHDOG_TIMEOUT!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_DISCONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_CONNECT_FAILURE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s on LSAP %#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irlmp_state_setup_pend (event, skb, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    SETUP_PEND, An LM_CONNECT_REQUEST has been received from the service</span>
<span class="cm"> *    user to set up an LSAP connection. A request has been sent to the</span>
<span class="cm"> *    LAP FSM to set up the underlying IrLAP connection, and we</span>
<span class="cm"> *    are awaiting confirm.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irlmp_state_setup_pend</span><span class="p">(</span><span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">IRLMP_EVENT</span> <span class="n">event</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irlmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_LAP_CONNECT_CONFIRM</span>:
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">conn_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">irlmp_send_lcf_pdu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">,</span>
				   <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">,</span> <span class="n">CONNECT_CMD</span><span class="p">,</span> <span class="n">tx_skb</span><span class="p">);</span>
		<span class="cm">/* Drop reference count - see irlap_data_request(). */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">);</span>

		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_SETUP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_WATCHDOG_TIMEOUT</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() : WATCHDOG_TIMEOUT !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>

		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">irlmp_do_lap_event</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="p">,</span> <span class="n">LM_LAP_DISCONNECT_REQUEST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LM_CONNECT_FAILURE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_LAP_DISCONNECT_INDICATION</span>: <span class="cm">/* LS_Disconnect.indication */</span>
		<span class="n">del_timer</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>

		<span class="n">irlmp_next_lsap_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">LSAP_DISCONNECTED</span><span class="p">);</span>

		<span class="n">reason</span> <span class="o">=</span> <span class="n">irlmp_convert_lap_reason</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">);</span>

		<span class="n">irlmp_disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown event %s on LSAP %#02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">irlmp_event</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
