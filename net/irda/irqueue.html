<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irqueue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irqueue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irqueue.c</span>
<span class="cm"> * Version:       0.3</span>
<span class="cm"> * Description:   General queue implementation</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Tue Jun  9 13:29:31 1998</span>
<span class="cm"> * Modified at:   Sun Dec 12 13:48:22 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Modified at:   Thu Jan  4 14:29:10 CET 2001</span>
<span class="cm"> * Modified by:   Marc Zyngier &lt;mzyngier@freesurf.fr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (C) 1998-1999, Aage Kvalnes &lt;aage@cs.uit.no&gt;</span>
<span class="cm"> *     Copyright (C) 1998, Dag Brattli,</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *     This code is taken from the Vortex Operating System written by Aage</span>
<span class="cm"> *     Kvalnes. Aage has agreed that this code can use the GPL licence,</span>
<span class="cm"> *     although he does not use that licence in his own code.</span>
<span class="cm"> *</span>
<span class="cm"> *     This copyright does however _not_ include the ELF hash() function</span>
<span class="cm"> *     which I currently don&#39;t know which licence or copyright it</span>
<span class="cm"> *     has. Please inform me if you know.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE :</span>
<span class="cm"> * There are various problems with this package :</span>
<span class="cm"> *	o the hash function for ints is pathetic (but could be changed)</span>
<span class="cm"> *	o locking is sometime suspicious (especially during enumeration)</span>
<span class="cm"> *	o most users have only a few elements (== overhead)</span>
<span class="cm"> *	o most users never use search, so don&#39;t benefit from hashing</span>
<span class="cm"> * Problem already fixed :</span>
<span class="cm"> *	o not 64 bit compliant (most users do hashv = (int) self)</span>
<span class="cm"> *	o hashbin_remove() is broken =&gt; use hashbin_remove_this()</span>
<span class="cm"> * I think most users would be better served by a simple linked list</span>
<span class="cm"> * (like include/linux/list.h) with a global spinlock per list.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Notes on the concurrent access to hashbin and other SMP issues</span>
<span class="cm"> * -------------------------------------------------------------</span>
<span class="cm"> *	Hashbins are very often in the IrDA stack a global repository of</span>
<span class="cm"> * information, and therefore used in a very asynchronous manner following</span>
<span class="cm"> * various events (driver calls, timers, user calls...).</span>
<span class="cm"> *	Therefore, very often it is highly important to consider the</span>
<span class="cm"> * management of concurrent access to the hashbin and how to guarantee the</span>
<span class="cm"> * consistency of the operations on it.</span>
<span class="cm"> *</span>
<span class="cm"> *	First, we need to define the objective of locking :</span>
<span class="cm"> *		1) Protect user data (content pointed by the hashbin)</span>
<span class="cm"> *		2) Protect hashbin structure itself (linked list in each bin)</span>
<span class="cm"> *</span>
<span class="cm"> *			     OLD LOCKING</span>
<span class="cm"> *			     -----------</span>
<span class="cm"> *</span>
<span class="cm"> *	The previous locking strategy, either HB_LOCAL or HB_GLOBAL were</span>
<span class="cm"> * both inadequate in *both* aspect.</span>
<span class="cm"> *		o HB_GLOBAL was using a spinlock for each bin (local locking).</span>
<span class="cm"> *		o HB_LOCAL was disabling irq on *all* CPUs, so use a single</span>
<span class="cm"> *		  global semaphore.</span>
<span class="cm"> *	The problems were :</span>
<span class="cm"> *		A) Global irq disabling is no longer supported by the kernel</span>
<span class="cm"> *		B) No protection for the hashbin struct global data</span>
<span class="cm"> *			o hashbin_delete()</span>
<span class="cm"> *			o hb_current</span>
<span class="cm"> *		C) No protection for user data in some cases</span>
<span class="cm"> *</span>
<span class="cm"> *	A) HB_LOCAL use global irq disabling, so doesn&#39;t work on kernel</span>
<span class="cm"> * 2.5.X. Even when it is supported (kernel 2.4.X and earlier), its</span>
<span class="cm"> * performance is not satisfactory on SMP setups. Most hashbins were</span>
<span class="cm"> * HB_LOCAL, so (A) definitely need fixing.</span>
<span class="cm"> *	B) HB_LOCAL could be modified to fix (B). However, because HB_GLOBAL</span>
<span class="cm"> * lock only the individual bins, it will never be able to lock the</span>
<span class="cm"> * global data, so can&#39;t do (B).</span>
<span class="cm"> *	C) Some functions return pointer to data that is still in the</span>
<span class="cm"> * hashbin :</span>
<span class="cm"> *		o hashbin_find()</span>
<span class="cm"> *		o hashbin_get_first()</span>
<span class="cm"> *		o hashbin_get_next()</span>
<span class="cm"> *	As the data is still in the hashbin, it may be changed or free&#39;d</span>
<span class="cm"> * while the caller is examinimg the data. In those case, locking can&#39;t</span>
<span class="cm"> * be done within the hashbin, but must include use of the data within</span>
<span class="cm"> * the caller.</span>
<span class="cm"> *	The caller can easily do this with HB_LOCAL (just disable irqs).</span>
<span class="cm"> * However, this is impossible with HB_GLOBAL because the caller has no</span>
<span class="cm"> * way to know the proper bin, so don&#39;t know which spinlock to use.</span>
<span class="cm"> *</span>
<span class="cm"> *	Quick summary : can no longer use HB_LOCAL, and HB_GLOBAL is</span>
<span class="cm"> * fundamentally broken and will never work.</span>
<span class="cm"> *</span>
<span class="cm"> *			     NEW LOCKING</span>
<span class="cm"> *			     -----------</span>
<span class="cm"> *</span>
<span class="cm"> *	To fix those problems, I&#39;ve introduce a few changes in the</span>
<span class="cm"> * hashbin locking :</span>
<span class="cm"> *		1) New HB_LOCK scheme</span>
<span class="cm"> *		2) hashbin-&gt;hb_spinlock</span>
<span class="cm"> *		3) New hashbin usage policy</span>
<span class="cm"> *</span>
<span class="cm"> * HB_LOCK :</span>
<span class="cm"> * -------</span>
<span class="cm"> *	HB_LOCK is a locking scheme intermediate between the old HB_LOCAL</span>
<span class="cm"> * and HB_GLOBAL. It uses a single spinlock to protect the whole content</span>
<span class="cm"> * of the hashbin. As it is a single spinlock, it can protect the global</span>
<span class="cm"> * data of the hashbin and not only the bins themselves.</span>
<span class="cm"> *	HB_LOCK can only protect some of the hashbin calls, so it only lock</span>
<span class="cm"> * call that can be made 100% safe and leave other call unprotected.</span>
<span class="cm"> *	HB_LOCK in theory is slower than HB_GLOBAL, but as the hashbin</span>
<span class="cm"> * content is always small contention is not high, so it doesn&#39;t matter</span>
<span class="cm"> * much. HB_LOCK is probably faster than HB_LOCAL.</span>
<span class="cm"> *</span>
<span class="cm"> * hashbin-&gt;hb_spinlock :</span>
<span class="cm"> * --------------------</span>
<span class="cm"> *	The spinlock that HB_LOCK uses is available for caller, so that</span>
<span class="cm"> * the caller can protect unprotected calls (see below).</span>
<span class="cm"> *	If the caller want to do entirely its own locking (HB_NOLOCK), he</span>
<span class="cm"> * can do so and may use safely this spinlock.</span>
<span class="cm"> *	Locking is done like this :</span>
<span class="cm"> *		spin_lock_irqsave(&amp;hashbin-&gt;hb_spinlock, flags);</span>
<span class="cm"> *	Releasing the lock :</span>
<span class="cm"> *		spin_unlock_irqrestore(&amp;hashbin-&gt;hb_spinlock, flags);</span>
<span class="cm"> *</span>
<span class="cm"> * Safe &amp; Protected calls :</span>
<span class="cm"> * ----------------------</span>
<span class="cm"> *	The following calls are safe or protected via HB_LOCK :</span>
<span class="cm"> *		o hashbin_new()		-&gt; safe</span>
<span class="cm"> *		o hashbin_delete()</span>
<span class="cm"> *		o hashbin_insert()</span>
<span class="cm"> *		o hashbin_remove_first()</span>
<span class="cm"> *		o hashbin_remove()</span>
<span class="cm"> *		o hashbin_remove_this()</span>
<span class="cm"> *		o HASHBIN_GET_SIZE()	-&gt; atomic</span>
<span class="cm"> *</span>
<span class="cm"> *	The following calls only protect the hashbin itself :</span>
<span class="cm"> *		o hashbin_lock_find()</span>
<span class="cm"> *		o hashbin_find_next()</span>
<span class="cm"> *</span>
<span class="cm"> * Unprotected calls :</span>
<span class="cm"> * -----------------</span>
<span class="cm"> *	The following calls need to be protected by the caller :</span>
<span class="cm"> *		o hashbin_find()</span>
<span class="cm"> *		o hashbin_get_first()</span>
<span class="cm"> *		o hashbin_get_next()</span>
<span class="cm"> *</span>
<span class="cm"> * Locking Policy :</span>
<span class="cm"> * --------------</span>
<span class="cm"> *	If the hashbin is used only in a single thread of execution</span>
<span class="cm"> * (explicitly or implicitely), you can use HB_NOLOCK</span>
<span class="cm"> *	If the calling module already provide concurrent access protection,</span>
<span class="cm"> * you may use HB_NOLOCK.</span>
<span class="cm"> *</span>
<span class="cm"> *	In all other cases, you need to use HB_LOCK and lock the hashbin</span>
<span class="cm"> * every time before calling one of the unprotected calls. You also must</span>
<span class="cm"> * use the pointer returned by the unprotected call within the locked</span>
<span class="cm"> * region.</span>
<span class="cm"> *</span>
<span class="cm"> * Extra care for enumeration :</span>
<span class="cm"> * --------------------------</span>
<span class="cm"> *	hashbin_get_first() and hashbin_get_next() use the hashbin to</span>
<span class="cm"> * store the current position, in hb_current.</span>
<span class="cm"> *	As long as the hashbin remains locked, this is safe. If you unlock</span>
<span class="cm"> * the hashbin, the current position may change if anybody else modify</span>
<span class="cm"> * or enumerate the hashbin.</span>
<span class="cm"> *	Summary : do the full enumeration while locked.</span>
<span class="cm"> *</span>
<span class="cm"> *	Alternatively, you may use hashbin_find_next(). But, this will</span>
<span class="cm"> * be slower, is more complex to use and doesn&#39;t protect the hashbin</span>
<span class="cm"> * content. So, care is needed here as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Other issues :</span>
<span class="cm"> * ------------</span>
<span class="cm"> *	I believe that we are overdoing it by using spin_lock_irqsave()</span>
<span class="cm"> * and we should use only spin_lock_bh() or similar. But, I don&#39;t have</span>
<span class="cm"> * the balls to try it out.</span>
<span class="cm"> *	Don&#39;t believe that because hashbin are now (somewhat) SMP safe</span>
<span class="cm"> * that the rest of the code is. Higher layers tend to be safest,</span>
<span class="cm"> * but LAP and LMP would need some serious dedicated love.</span>
<span class="cm"> *</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irqueue.h&gt;</span>

<span class="cm">/************************ QUEUE SUBROUTINES ************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Hashbin</span>
<span class="cm"> */</span>
<span class="cp">#define GET_HASHBIN(x) ( x &amp; HASHBIN_MASK )</span>

<span class="cm">/*</span>
<span class="cm"> * Function hash (name)</span>
<span class="cm"> *</span>
<span class="cm"> *    This function hash the input string &#39;name&#39; using the ELF hash</span>
<span class="cm"> *    function for strings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="nf">hash</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">g</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">name</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&amp;</span> <span class="mh">0xf0000000</span><span class="p">)))</span>
			<span class="n">h</span> <span class="o">^=</span><span class="n">g</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">;</span>
		<span class="n">h</span> <span class="o">&amp;=~</span><span class="n">g</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function enqueue_first (queue, proc)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert item first in queue.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_first</span><span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">**</span><span class="n">queue</span><span class="p">,</span> <span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">element</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if queue is empty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue is empty.  Insert one element into the queue.</span>
<span class="cm">		 */</span>
		<span class="n">element</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">q_prev</span> <span class="o">=</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue is not empty.  Insert element into front of queue.</span>
<span class="cm">		 */</span>
		<span class="n">element</span><span class="o">-&gt;</span><span class="n">q_next</span>          <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_prev</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
		<span class="n">element</span><span class="o">-&gt;</span><span class="n">q_prev</span>          <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_prev</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_prev</span>         <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span>                 <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function dequeue (queue)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove first entry in queue</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irda_queue_t</span> <span class="o">*</span><span class="nf">dequeue_first</span><span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">**</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irda_queue_t</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;dequeue_first()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set return value</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span>  <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue was empty.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">==</span> <span class="o">*</span><span class="n">queue</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Queue only contained a single element. It will now be</span>
<span class="cm">		 *  empty.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue contained several element.  Remove the first one.</span>
<span class="cm">		 */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_prev</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="o">-&gt;</span><span class="n">q_prev</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_prev</span><span class="p">;</span>
		<span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the removed entry (or NULL of queue was empty).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function dequeue_general (queue, element)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irda_queue_t</span> <span class="o">*</span><span class="nf">dequeue_general</span><span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">**</span><span class="n">queue</span><span class="p">,</span> <span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">element</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irda_queue_t</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;dequeue_general()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set return value</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span>  <span class="o">*</span><span class="n">queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue was empty.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">==</span> <span class="o">*</span><span class="n">queue</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Queue only contained a single element. It will now be</span>
<span class="cm">		 *  empty.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Remove specific element.</span>
<span class="cm">		 */</span>
		<span class="n">element</span><span class="o">-&gt;</span><span class="n">q_prev</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
		<span class="n">element</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="o">-&gt;</span><span class="n">q_prev</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">q_prev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="n">element</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the removed entry (or NULL of queue was empty).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************ HASHBIN MANAGEMENT ************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_create ( type, name )</span>
<span class="cm"> *</span>
<span class="cm"> *    Create hashbin!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">hashbin_t</span> <span class="o">*</span><span class="nf">hashbin_new</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate new hashbin</span>
<span class="cm">	 */</span>
	<span class="n">hashbin</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hashbin</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashbin</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize structure</span>
<span class="cm">	 */</span>
	<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">HB_MAGIC</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>hashbin->hb_current = NULL;</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* Make sure all spinlock&#39;s are unlocked */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">hashbin</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_new</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Function hashbin_delete (hashbin, free_func)</span>
<span class="cm"> *</span>
<span class="cm"> *    Destroy hashbin, the free_func can be a user supplied special routine</span>
<span class="cm"> *    for deallocating this structure if it&#39;s complex. If not the user can</span>
<span class="cm"> *    just supply kfree, which should take care of the job.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hashbin_lock_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="kt">int</span> <span class="nf">hashbin_delete</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="n">FREE_FUNC</span> <span class="n">free_func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Synchronize */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="n">hashbin_lock_depth</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Free the entries in the hashbin, TODO: use hashbin_clear when</span>
<span class="cm">	 *  it has been shown to work</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHBIN_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">dequeue_first</span><span class="p">((</span><span class="n">irda_queue_t</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">queue</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">free_func</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="n">free_func</span><span class="p">)(</span><span class="n">queue</span><span class="p">);</span>
			<span class="n">queue</span> <span class="o">=</span> <span class="n">dequeue_first</span><span class="p">(</span>
				<span class="p">(</span><span class="n">irda_queue_t</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Cleanup local data */</span>
	<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="o">~</span><span class="n">HB_MAGIC</span><span class="p">;</span>

	<span class="cm">/* Release lock */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
		<span class="n">hashbin_lock_depth</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Free the hashbin structure</span>
<span class="cm">	 */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hashbin</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_delete</span><span class="p">);</span>

<span class="cm">/********************* HASHBIN LIST OPERATIONS *********************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_insert (hashbin, entry, name)</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert an entry into the hashbin</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hashbin_insert</span><span class="p">(</span><span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">long</span> <span class="n">hashv</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bin</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locate hashbin</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
		<span class="n">hashv</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>
	<span class="n">bin</span> <span class="o">=</span> <span class="n">GET_HASHBIN</span><span class="p">(</span> <span class="n">hashv</span> <span class="p">);</span>

	<span class="cm">/* Synchronize */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store name and key</span>
<span class="cm">	 */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_hash</span> <span class="o">=</span> <span class="n">hashv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">(</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_name</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Insert new entry first</span>
<span class="cm">	 */</span>
	<span class="n">enqueue_first</span><span class="p">(</span> <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">],</span>
		       <span class="n">entry</span><span class="p">);</span>
	<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_size</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Release lock */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_insert</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Function hashbin_remove_first (hashbin)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove first entry of the hashbin</span>
<span class="cm"> *</span>
<span class="cm"> * Note : this function no longer use hashbin_remove(), but does things</span>
<span class="cm"> * similar to hashbin_remove_this(), so can be considered safe.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">hashbin_remove_first</span><span class="p">(</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">hashbin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">irda_queue_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Synchronize */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin_get_first</span><span class="p">(</span> <span class="n">hashbin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">bin</span><span class="p">;</span>
		<span class="kt">long</span>	<span class="n">hashv</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Locate hashbin</span>
<span class="cm">		 */</span>
		<span class="n">hashv</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_hash</span><span class="p">;</span>
		<span class="n">bin</span> <span class="o">=</span> <span class="n">GET_HASHBIN</span><span class="p">(</span> <span class="n">hashv</span> <span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Dequeue the entry...</span>
<span class="cm">		 */</span>
		<span class="n">dequeue_general</span><span class="p">(</span> <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">],</span>
				 <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">*</span><span class="p">)</span> <span class="n">entry</span> <span class="p">);</span>
		<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_size</span><span class="o">--</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Check if this item is the currently selected item, and in</span>
<span class="cm">		 *  that case we must reset hb_current</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">==</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span><span class="p">)</span>
			<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Release lock */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  Function hashbin_remove (hashbin, hashv, name)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove entry with the given name</span>
<span class="cm"> *</span>
<span class="cm"> *  The use of this function is highly discouraged, because the whole</span>
<span class="cm"> *  concept behind hashbin_remove() is broken. In many cases, it&#39;s not</span>
<span class="cm"> *  possible to guarantee the unicity of the index (either hashv or name),</span>
<span class="cm"> *  leading to removing the WRONG entry.</span>
<span class="cm"> *  The only simple safe use is :</span>
<span class="cm"> *		hashbin_remove(hasbin, (int) self, NULL);</span>
<span class="cm"> *  In other case, you must think hard to guarantee unicity of the index.</span>
<span class="cm"> *  Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">hashbin_remove</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="kt">long</span> <span class="n">hashv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bin</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locate hashbin</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
		<span class="n">hashv</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>
	<span class="n">bin</span> <span class="o">=</span> <span class="n">GET_HASHBIN</span><span class="p">(</span> <span class="n">hashv</span> <span class="p">);</span>

	<span class="cm">/* Synchronize */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search for entry</span>
<span class="cm">	 */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check for key</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_hash</span> <span class="o">==</span> <span class="n">hashv</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Name compare too?</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">name</span> <span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">!=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">]</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If entry was found, dequeue it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">found</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">dequeue_general</span><span class="p">(</span> <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">],</span>
				 <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">*</span><span class="p">)</span> <span class="n">entry</span> <span class="p">);</span>
		<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_size</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Check if this item is the currently selected item, and in</span>
<span class="cm">		 *  that case we must reset hb_current</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">==</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span><span class="p">)</span>
			<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Release lock */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>


	<span class="cm">/* Return */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">found</span> <span class="p">)</span>
		<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_remove</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Function hashbin_remove_this (hashbin, entry)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove entry with the given name</span>
<span class="cm"> *</span>
<span class="cm"> * In some cases, the user of hashbin can&#39;t guarantee the unicity</span>
<span class="cm"> * of either the hashv or name.</span>
<span class="cm"> * In those cases, using the above function is guaranteed to cause troubles,</span>
<span class="cm"> * so we use this one instead...</span>
<span class="cm"> * And by the way, it&#39;s also faster, because we skip the search phase ;-)</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">hashbin_remove_this</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">bin</span><span class="p">;</span>
	<span class="kt">long</span>	<span class="n">hashv</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="cm">/* Synchronize */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>

	<span class="cm">/* Check if valid and not already removed... */</span>
	<span class="k">if</span><span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locate hashbin</span>
<span class="cm">	 */</span>
	<span class="n">hashv</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_hash</span><span class="p">;</span>
	<span class="n">bin</span> <span class="o">=</span> <span class="n">GET_HASHBIN</span><span class="p">(</span> <span class="n">hashv</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dequeue the entry...</span>
<span class="cm">	 */</span>
	<span class="n">dequeue_general</span><span class="p">(</span> <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">],</span>
			 <span class="p">(</span><span class="n">irda_queue_t</span><span class="o">*</span><span class="p">)</span> <span class="n">entry</span> <span class="p">);</span>
	<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_size</span><span class="o">--</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if this item is the currently selected item, and in</span>
<span class="cm">	 *  that case we must reset hb_current</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">==</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span><span class="p">)</span>
		<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/* Release lock */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_type</span> <span class="o">&amp;</span> <span class="n">HB_LOCK</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* Default is no-lock  */</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_remove_this</span><span class="p">);</span>

<span class="cm">/*********************** HASHBIN ENUMERATION ***********************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_common_find (hashbin, hashv, name)</span>
<span class="cm"> *</span>
<span class="cm"> *    Find item with the given hashv or name</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">hashbin_find</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="kt">long</span> <span class="n">hashv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bin</span><span class="p">;</span>
	<span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;hashbin_find()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locate hashbin</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
		<span class="n">hashv</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>
	<span class="n">bin</span> <span class="o">=</span> <span class="n">GET_HASHBIN</span><span class="p">(</span> <span class="n">hashv</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search for entry</span>
<span class="cm">	 */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check for key</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_hash</span> <span class="o">==</span> <span class="n">hashv</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Name compare too?</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">name</span> <span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_name</span><span class="p">,</span> <span class="n">name</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">!=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">]</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_find</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_lock_find (hashbin, hashv, name)</span>
<span class="cm"> *</span>
<span class="cm"> *    Find item with the given hashv or name</span>
<span class="cm"> *</span>
<span class="cm"> * Same, but with spinlock protection...</span>
<span class="cm"> * I call it safe, but it&#39;s only safe with respect to the hashbin, not its</span>
<span class="cm"> * content. - Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">hashbin_lock_find</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="kt">long</span> <span class="n">hashv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* Synchronize */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search for entry</span>
<span class="cm">	 */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin_find</span><span class="p">(</span><span class="n">hashbin</span><span class="p">,</span> <span class="n">hashv</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Release lock */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_lock_find</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_find (hashbin, hashv, name, pnext)</span>
<span class="cm"> *</span>
<span class="cm"> *    Find an item with the given hashv or name, and its successor</span>
<span class="cm"> *</span>
<span class="cm"> * This function allow to do concurrent enumerations without the</span>
<span class="cm"> * need to lock over the whole session, because the caller keep the</span>
<span class="cm"> * context of the search. On the other hand, it might fail and return</span>
<span class="cm"> * NULL if the entry is removed. - Jean II</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">hashbin_find_next</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">,</span> <span class="kt">long</span> <span class="n">hashv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">**</span> <span class="n">pnext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* Synchronize */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search for current entry</span>
<span class="cm">	 * This allow to check if the current item is still in the</span>
<span class="cm">	 * hashbin or has been removed.</span>
<span class="cm">	 */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin_find</span><span class="p">(</span><span class="n">hashbin</span><span class="p">,</span> <span class="n">hashv</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Trick hashbin_get_next() to return what we want</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pnext</span> <span class="o">=</span> <span class="n">hashbin_get_next</span><span class="p">(</span> <span class="n">hashbin</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">pnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Release lock */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_get_first (hashbin)</span>
<span class="cm"> *</span>
<span class="cm"> *    Get a pointer to first element in hashbin, this function must be</span>
<span class="cm"> *    called before any calls to hashbin_get_next()!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">irda_queue_t</span> <span class="o">*</span><span class="nf">hashbin_get_first</span><span class="p">(</span> <span class="n">hashbin_t</span><span class="o">*</span> <span class="n">hashbin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irda_queue_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHBIN_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Did not find any item in hashbin</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_get_first</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function hashbin_get_next (hashbin)</span>
<span class="cm"> *</span>
<span class="cm"> *    Get next item in hashbin. A series of hashbin_get_next() calls must</span>
<span class="cm"> *    be started by a call to hashbin_get_first(). The function returns</span>
<span class="cm"> *    NULL when all items have been traversed</span>
<span class="cm"> *</span>
<span class="cm"> * The context of the search is stored within the hashbin, so you must</span>
<span class="cm"> * protect yourself from concurrent enumerations. - Jean II</span>
<span class="cm"> */</span>
<span class="n">irda_queue_t</span> <span class="o">*</span><span class="nf">hashbin_get_next</span><span class="p">(</span> <span class="n">hashbin_t</span> <span class="o">*</span><span class="n">hashbin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irda_queue_t</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HB_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span><span class="o">-&gt;</span><span class="n">q_next</span><span class="p">;</span>
	<span class="n">bin</span> <span class="o">=</span> <span class="n">GET_HASHBIN</span><span class="p">(</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">q_hash</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Make sure that we are not back at the beginning of the queue</span>
<span class="cm">	 *  again</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span> <span class="o">!=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">bin</span> <span class="p">])</span> <span class="p">{</span>
		<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check that this is not the last queue in hashbin</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">bin</span> <span class="o">&gt;=</span> <span class="n">HASHBIN_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Move to next queue in hashbin</span>
<span class="cm">	 */</span>
	<span class="n">bin</span><span class="o">++</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHBIN_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_queue</span><span class="p">[</span> <span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hashbin</span><span class="o">-&gt;</span><span class="n">hb_current</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hashbin_get_next</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
