<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irnet › irnet.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>irnet.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	IrNET protocol module : Synchronous PPP over an IrDA socket.</span>
<span class="cm"> *</span>
<span class="cm"> *		Jean II - HPL `00 - &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains definitions and declarations global to the IrNET module,</span>
<span class="cm"> * all grouped in one place...</span>
<span class="cm"> * This file is a *private* header, so other modules don&#39;t want to know</span>
<span class="cm"> * what&#39;s in there...</span>
<span class="cm"> *</span>
<span class="cm"> * Note : as most part of the Linux kernel, this module is available</span>
<span class="cm"> * under the GNU General Public License (GPL).</span>
<span class="cm"> */</span>

<span class="cp">#ifndef IRNET_H</span>
<span class="cp">#define IRNET_H</span>

<span class="cm">/************************** DOCUMENTATION ***************************/</span>
<span class="cm">/*</span>
<span class="cm"> * What is IrNET</span>
<span class="cm"> * -------------</span>
<span class="cm"> * IrNET is a protocol allowing to carry TCP/IP traffic between two</span>
<span class="cm"> * IrDA peers in an efficient fashion. It is a thin layer, passing PPP</span>
<span class="cm"> * packets to IrTTP and vice versa. It uses PPP in synchronous mode,</span>
<span class="cm"> * because IrTTP offer a reliable sequenced packet service (as opposed</span>
<span class="cm"> * to a byte stream). In fact, you could see IrNET as carrying TCP/IP</span>
<span class="cm"> * in a IrDA socket, using PPP to provide the glue.</span>
<span class="cm"> *</span>
<span class="cm"> * The main difference with traditional PPP over IrCOMM is that we</span>
<span class="cm"> * avoid the framing and serial emulation which are a performance</span>
<span class="cm"> * bottleneck. It also allows multipoint communications in a sensible</span>
<span class="cm"> * fashion.</span>
<span class="cm"> *</span>
<span class="cm"> * The main difference with IrLAN is that we use PPP for the link</span>
<span class="cm"> * management, which is more standard, interoperable and flexible than</span>
<span class="cm"> * the IrLAN protocol. For example, PPP adds authentication,</span>
<span class="cm"> * encryption, compression, header compression and automated routing</span>
<span class="cm"> * setup. And, as IrNET let PPP do the hard work, the implementation</span>
<span class="cm"> * is much simpler than IrLAN.</span>
<span class="cm"> *</span>
<span class="cm"> * The Linux implementation</span>
<span class="cm"> * ------------------------</span>
<span class="cm"> * IrNET is written on top of the Linux-IrDA stack, and interface with</span>
<span class="cm"> * the generic Linux PPP driver. Because IrNET depend on recent</span>
<span class="cm"> * changes of the PPP driver interface, IrNET will work only with very</span>
<span class="cm"> * recent kernel (2.3.99-pre6 and up).</span>
<span class="cm"> *</span>
<span class="cm"> * The present implementation offer the following features :</span>
<span class="cm"> *	o simple user interface using pppd</span>
<span class="cm"> *	o efficient implementation (interface directly to PPP and IrTTP)</span>
<span class="cm"> *	o addressing (you can specify the name of the IrNET recipient)</span>
<span class="cm"> *	o multipoint operation (limited by IrLAP specification)</span>
<span class="cm"> *	o information in /proc/net/irda/irnet</span>
<span class="cm"> *	o IrNET events on /dev/irnet (for user space daemon)</span>
<span class="cm"> *	o IrNET daemon (irnetd) to automatically handle incoming requests</span>
<span class="cm"> *	o Windows 2000 compatibility (tested, but need more work)</span>
<span class="cm"> * Currently missing :</span>
<span class="cm"> *	o Lot&#39;s of testing (that&#39;s your job)</span>
<span class="cm"> *	o Connection retries (may be too hard to do)</span>
<span class="cm"> *	o Check pppd persist mode</span>
<span class="cm"> *	o User space daemon (to automatically handle incoming requests)</span>
<span class="cm"> *</span>
<span class="cm"> * The setup is not currently the most easy, but this should get much</span>
<span class="cm"> * better when everything will get integrated...</span>
<span class="cm"> *</span>
<span class="cm"> * Acknowledgements</span>
<span class="cm"> * ----------------</span>
<span class="cm"> * This module is based on :</span>
<span class="cm"> *	o The PPP driver (ppp_synctty/ppp_generic) by Paul Mackerras</span>
<span class="cm"> *	o The IrLAN protocol (irlan_common/XXX) by Dag Brattli</span>
<span class="cm"> *	o The IrSock interface (af_irda) by Dag Brattli</span>
<span class="cm"> *	o Some other bits from the kernel and my drivers...</span>
<span class="cm"> * Infinite thanks to those brave souls for providing the infrastructure</span>
<span class="cm"> * upon which IrNET is built.</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks to all my colleagues in HP for helping me. In particular,</span>
<span class="cm"> * thanks to Salil Pradhan and Bill Serra for W2k testing...</span>
<span class="cm"> * Thanks to Luiz Magalhaes for irnetd and much testing...</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks to Alan Cox for answering lot&#39;s of my stupid questions, and</span>
<span class="cm"> * to Paul Mackerras answering my questions on how to best integrate</span>
<span class="cm"> * IrNET and pppd.</span>
<span class="cm"> *</span>
<span class="cm"> * Jean II</span>
<span class="cm"> *</span>
<span class="cm"> * Note on some implementations choices...</span>
<span class="cm"> * ------------------------------------</span>
<span class="cm"> *	1) Direct interface vs tty/socket</span>
<span class="cm"> * I could have used a tty interface to hook to ppp and use the full</span>
<span class="cm"> * socket API to connect to IrDA. The code would have been easier to</span>
<span class="cm"> * maintain, and maybe the code would have been smaller...</span>
<span class="cm"> * Instead, we hook directly to ppp_generic and to IrTTP, which make</span>
<span class="cm"> * things more complicated...</span>
<span class="cm"> *</span>
<span class="cm"> * The first reason is flexibility : this allow us to create IrNET</span>
<span class="cm"> * instances on demand (no /dev/ircommX crap) and to allow linkname</span>
<span class="cm"> * specification on pppd command line...</span>
<span class="cm"> *</span>
<span class="cm"> * Second reason is speed optimisation. If you look closely at the</span>
<span class="cm"> * transmit and receive paths, you will notice that they are &quot;super lean&quot;</span>
<span class="cm"> * (that&#39;s why they look ugly), with no function calls and as little data</span>
<span class="cm"> * copy and modification as I could...</span>
<span class="cm"> *</span>
<span class="cm"> *	2) irnetd in user space</span>
<span class="cm"> * irnetd is implemented in user space, which is necessary to call pppd.</span>
<span class="cm"> * This also give maximum benefits in term of flexibility and customability,</span>
<span class="cm"> * and allow to offer the event channel, useful for other stuff like debug.</span>
<span class="cm"> *</span>
<span class="cm"> * On the other hand, this require a loose coordination between the</span>
<span class="cm"> * present module and irnetd. One critical area is how incoming request</span>
<span class="cm"> * are handled.</span>
<span class="cm"> * When irnet receive an incoming request, it send an event to irnetd and</span>
<span class="cm"> * drop the incoming IrNET socket.</span>
<span class="cm"> * irnetd start a pppd instance, which create a new IrNET socket. This new</span>
<span class="cm"> * socket is then connected in the originating node to the pppd instance.</span>
<span class="cm"> * At this point, in the originating node, the first socket is closed.</span>
<span class="cm"> *</span>
<span class="cm"> * I admit, this is a bit messy and waste some resources. The alternative</span>
<span class="cm"> * is caching incoming socket, and that&#39;s also quite messy and waste</span>
<span class="cm"> * resources.</span>
<span class="cm"> * We also make connection time slower. For example, on a 115 kb/s link it</span>
<span class="cm"> * adds 60ms to the connection time (770 ms). However, this is slower than</span>
<span class="cm"> * the time it takes to fire up pppd on my P133...</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * History :</span>
<span class="cm"> * -------</span>
<span class="cm"> *</span>
<span class="cm"> * v1 - 15.5.00 - Jean II</span>
<span class="cm"> *	o Basic IrNET (hook to ppp_generic &amp; IrTTP - incl. multipoint)</span>
<span class="cm"> *	o control channel on /dev/irnet (set name/address)</span>
<span class="cm"> *	o event channel on /dev/irnet (for user space daemon)</span>
<span class="cm"> *</span>
<span class="cm"> * v2 - 5.6.00 - Jean II</span>
<span class="cm"> *	o Enable DROP_NOT_READY to avoid PPP timeouts &amp; other weirdness...</span>
<span class="cm"> *	o Add DISCONNECT_TO event and rename DISCONNECT_FROM.</span>
<span class="cm"> *	o Set official device number alloaction on /dev/irnet</span>
<span class="cm"> *</span>
<span class="cm"> * v3 - 30.8.00 - Jean II</span>
<span class="cm"> *	o Update to latest Linux-IrDA changes :</span>
<span class="cm"> *		- queue_t =&gt; irda_queue_t</span>
<span class="cm"> *	o Update to ppp-2.4.0 :</span>
<span class="cm"> *		- move irda_irnet_connect from PPPIOCATTACH to TIOCSETD</span>
<span class="cm"> *	o Add EXPIRE event (depend on new IrDA-Linux patch)</span>
<span class="cm"> *	o Switch from `hashbin_remove&#39; to `hashbin_remove_this&#39; to fix</span>
<span class="cm"> *	  a multilink bug... (depend on new IrDA-Linux patch)</span>
<span class="cm"> *	o fix a self-&gt;daddr to self-&gt;raddr in irda_irnet_connect to fix</span>
<span class="cm"> *	  another multilink bug (darn !)</span>
<span class="cm"> *	o Remove LINKNAME_IOCTL cruft</span>
<span class="cm"> *</span>
<span class="cm"> * v3b - 31.8.00 - Jean II</span>
<span class="cm"> *	o Dump discovery log at event channel startup</span>
<span class="cm"> *</span>
<span class="cm"> * v4 - 28.9.00 - Jean II</span>
<span class="cm"> *	o Fix interaction between poll/select and dump discovery log</span>
<span class="cm"> *	o Add IRNET_BLOCKED_LINK event (depend on new IrDA-Linux patch)</span>
<span class="cm"> *	o Add IRNET_NOANSWER_FROM event (mostly to help support)</span>
<span class="cm"> *	o Release flow control in disconnect_indication</span>
<span class="cm"> *	o Block packets while connecting (speed up connections)</span>
<span class="cm"> *</span>
<span class="cm"> * v5 - 11.01.01 - Jean II</span>
<span class="cm"> *	o Init self-&gt;max_header_size, just in case...</span>
<span class="cm"> *	o Set up ap-&gt;chan.hdrlen, to get zero copy on tx side working.</span>
<span class="cm"> *	o avoid tx-&gt;ttp-&gt;flow-&gt;ppp-&gt;tx-&gt;... loop, by checking flow state</span>
<span class="cm"> *		Thanks to Christian Gennerat for finding this bug !</span>
<span class="cm"> *	---</span>
<span class="cm"> *	o Declare the proper MTU/MRU that we can support</span>
<span class="cm"> *		(but PPP doesn&#39;t read the MTU value :-()</span>
<span class="cm"> *	o Declare hashbin HB_NOLOCK instead of HB_LOCAL to avoid</span>
<span class="cm"> *		disabling and enabling irq twice</span>
<span class="cm"> *</span>
<span class="cm"> * v6 - 31.05.01 - Jean II</span>
<span class="cm"> *	o Print source address in Found, Discovery, Expiry &amp; Request events</span>
<span class="cm"> *	o Print requested source address in /proc/net/irnet</span>
<span class="cm"> *	o Change control channel input. Allow multiple commands in one line.</span>
<span class="cm"> *	o Add saddr command to change ap-&gt;rsaddr (and use that in IrDA)</span>
<span class="cm"> *	---</span>
<span class="cm"> *	o Make the IrDA connection procedure totally asynchronous.</span>
<span class="cm"> *	  Heavy rewrite of the IAS query code and the whole connection</span>
<span class="cm"> *	  procedure. Now, irnet_connect() no longer need to be called from</span>
<span class="cm"> *	  a process context...</span>
<span class="cm"> *	o Enable IrDA connect retries in ppp_irnet_send(). The good thing</span>
<span class="cm"> *	  is that IrDA connect retries are directly driven by PPP LCP</span>
<span class="cm"> *	  retries (we retry for each LCP packet), so that everything</span>
<span class="cm"> *	  is transparently controlled from pppd lcp-max-configure.</span>
<span class="cm"> *	o Add ttp_connect flag to prevent rentry on the connect procedure</span>
<span class="cm"> *	o Test and fixups to eliminate side effects of retries</span>
<span class="cm"> *</span>
<span class="cm"> * v7 - 22.08.01 - Jean II</span>
<span class="cm"> *	o Cleanup : Change &quot;saddr = 0x0&quot; to &quot;saddr = DEV_ADDR_ANY&quot;</span>
<span class="cm"> *	o Fix bug in BLOCK_WHEN_CONNECT introduced in v6 : due to the</span>
<span class="cm"> *	  asynchronous IAS query, self-&gt;tsap is NULL when PPP send the</span>
<span class="cm"> *	  first packet.  This was preventing &quot;connect-delay 0&quot; to work.</span>
<span class="cm"> *	  Change the test in ppp_irnet_send() to self-&gt;ttp_connect.</span>
<span class="cm"> *</span>
<span class="cm"> * v8 - 1.11.01 - Jean II</span>
<span class="cm"> *	o Tighten the use of self-&gt;ttp_connect and self-&gt;ttp_open to</span>
<span class="cm"> *	  prevent various race conditions.</span>
<span class="cm"> *	o Avoid leaking discovery log and skb</span>
<span class="cm"> *	o Replace &quot;self&quot; with &quot;server&quot; in irnet_connect_indication() to</span>
<span class="cm"> *	  better detect cut&#39;n&#39;paste error ;-)</span>
<span class="cm"> *</span>
<span class="cm"> * v9 - 29.11.01 - Jean II</span>
<span class="cm"> *	o Fix event generation in disconnect indication that I broke in v8</span>
<span class="cm"> *	  It was always generation &quot;No-Answer&quot; because I was testing ttp_open</span>
<span class="cm"> *	  just after clearing it. *blush*.</span>
<span class="cm"> *	o Use newly created irttp_listen() to fix potential crash when LAP</span>
<span class="cm"> *	  destroyed before irnet module removed.</span>
<span class="cm"> *</span>
<span class="cm"> * v10 - 4.3.2 - Jean II</span>
<span class="cm"> *	o When receiving a disconnect indication, don&#39;t reenable the</span>
<span class="cm"> *	  PPP Tx queue, this will trigger a reconnect. Instead, close</span>
<span class="cm"> *	  the channel, which will kill pppd...</span>
<span class="cm"> *</span>
<span class="cm"> * v11 - 20.3.02 - Jean II</span>
<span class="cm"> *	o Oops ! v10 fix disabled IrNET retries and passive behaviour.</span>
<span class="cm"> *	  Better fix in irnet_disconnect_indication() :</span>
<span class="cm"> *	  - if connected, kill pppd via hangup.</span>
<span class="cm"> *	  - if not connected, reenable ppp Tx, which trigger IrNET retry.</span>
<span class="cm"> *</span>
<span class="cm"> * v12 - 10.4.02 - Jean II</span>
<span class="cm"> *	o Fix race condition in irnet_connect_indication().</span>
<span class="cm"> *	  If the socket was already trying to connect, drop old connection</span>
<span class="cm"> *	  and use new one only if acting as primary. See comments.</span>
<span class="cm"> *</span>
<span class="cm"> * v13 - 30.5.02 - Jean II</span>
<span class="cm"> *	o Update module init code</span>
<span class="cm"> *</span>
<span class="cm"> * v14 - 20.2.03 - Jean II</span>
<span class="cm"> *	o Add discovery hint bits in the control channel.</span>
<span class="cm"> *	o Remove obsolete MOD_INC/DEC_USE_COUNT in favor of .owner</span>
<span class="cm"> *</span>
<span class="cm"> * v15 - 7.4.03 - Jean II</span>
<span class="cm"> *	o Replace spin_lock_irqsave() with spin_lock_bh() so that we can</span>
<span class="cm"> *	  use ppp_unit_number(). It&#39;s probably also better overall...</span>
<span class="cm"> *	o Disable call to ppp_unregister_channel(), because we can&#39;t do it.</span>
<span class="cm"> */</span>

<span class="cm">/***************************** INCLUDES *****************************/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;	</span><span class="cm">/* isspace() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/string.h&gt;	</span><span class="cm">/* skip_spaces() */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/ppp_defs.h&gt;</span>
<span class="cp">#include &lt;linux/ppp-ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_channel.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/iriap.h&gt;</span>
<span class="cp">#include &lt;net/irda/irias_object.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/irttp.h&gt;</span>
<span class="cp">#include &lt;net/irda/discovery.h&gt;</span>

<span class="cm">/***************************** OPTIONS *****************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Define or undefine to compile or not some optional part of the</span>
<span class="cm"> * IrNET driver...</span>
<span class="cm"> * Note : the present defaults make sense, play with that at your</span>
<span class="cm"> * own risk...</span>
<span class="cm"> */</span>
<span class="cm">/* IrDA side of the business... */</span>
<span class="cp">#define DISCOVERY_NOMASK	</span><span class="cm">/* To enable W2k compatibility... */</span><span class="cp"></span>
<span class="cp">#define ADVERTISE_HINT		</span><span class="cm">/* Advertise IrLAN hint bit */</span><span class="cp"></span>
<span class="cp">#define ALLOW_SIMULT_CONNECT	</span><span class="cm">/* This seem to work, cross fingers... */</span><span class="cp"></span>
<span class="cp">#define DISCOVERY_EVENTS	</span><span class="cm">/* Query the discovery log to post events */</span><span class="cp"></span>
<span class="cp">#define INITIAL_DISCOVERY	</span><span class="cm">/* Dump current discovery log as events */</span><span class="cp"></span>
<span class="cp">#undef STREAM_COMPAT		</span><span class="cm">/* Not needed - potentially messy */</span><span class="cp"></span>
<span class="cp">#undef CONNECT_INDIC_KICK	</span><span class="cm">/* Might mess IrDA, not needed */</span><span class="cp"></span>
<span class="cp">#undef FAIL_SEND_DISCONNECT	</span><span class="cm">/* Might mess IrDA, not needed */</span><span class="cp"></span>
<span class="cp">#undef PASS_CONNECT_PACKETS	</span><span class="cm">/* Not needed ? Safe */</span><span class="cp"></span>
<span class="cp">#undef MISSING_PPP_API		</span><span class="cm">/* Stuff I wish I could do */</span><span class="cp"></span>

<span class="cm">/* PPP side of the business */</span>
<span class="cp">#define BLOCK_WHEN_CONNECT	</span><span class="cm">/* Block packets when connecting */</span><span class="cp"></span>
<span class="cp">#define CONNECT_IN_SEND		</span><span class="cm">/* Retry IrDA connection procedure */</span><span class="cp"></span>
<span class="cp">#undef FLUSH_TO_PPP		</span><span class="cm">/* Not sure about this one, let&#39;s play safe */</span><span class="cp"></span>
<span class="cp">#undef SECURE_DEVIRNET		</span><span class="cm">/* Bah... */</span><span class="cp"></span>

<span class="cm">/****************************** DEBUG ******************************/</span>

<span class="cm">/*</span>
<span class="cm"> * This set of flags enable and disable all the various warning,</span>
<span class="cm"> * error and debug message of this driver.</span>
<span class="cm"> * Each section can be enabled and disabled independently</span>
<span class="cm"> */</span>
<span class="cm">/* In the PPP part */</span>
<span class="cp">#define DEBUG_CTRL_TRACE	0	</span><span class="cm">/* Control channel */</span><span class="cp"></span>
<span class="cp">#define DEBUG_CTRL_INFO		0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_CTRL_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_FS_TRACE		0	</span><span class="cm">/* filesystem callbacks */</span><span class="cp"></span>
<span class="cp">#define DEBUG_FS_INFO		0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_FS_ERROR		1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_PPP_TRACE		0	</span><span class="cm">/* PPP related functions */</span><span class="cp"></span>
<span class="cp">#define DEBUG_PPP_INFO		0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_PPP_ERROR		1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_MODULE_TRACE	0	</span><span class="cm">/* module insertion/removal */</span><span class="cp"></span>
<span class="cp">#define DEBUG_MODULE_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>

<span class="cm">/* In the IrDA part */</span>
<span class="cp">#define DEBUG_IRDA_SR_TRACE	0	</span><span class="cm">/* IRDA subroutines */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SR_INFO	0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SR_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SOCK_TRACE	0	</span><span class="cm">/* IRDA main socket functions */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SOCK_INFO	0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SOCK_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SERV_TRACE	0	</span><span class="cm">/* The IrNET server */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SERV_INFO	0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_SERV_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_TCB_TRACE	0	</span><span class="cm">/* IRDA IrTTP callbacks */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_CB_INFO	0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_CB_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_OCB_TRACE	0	</span><span class="cm">/* IRDA other callbacks */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_OCB_INFO	0	</span><span class="cm">/* various info */</span><span class="cp"></span>
<span class="cp">#define DEBUG_IRDA_OCB_ERROR	1	</span><span class="cm">/* problems */</span><span class="cp"></span>

<span class="cp">#define DEBUG_ASSERT		0	</span><span class="cm">/* Verify all assertions */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * These are the macros we are using to actually print the debug</span>
<span class="cm"> * statements. Don&#39;t look at it, it&#39;s ugly...</span>
<span class="cm"> *</span>
<span class="cm"> * One of the trick is that, as the DEBUG_XXX are constant, the</span>
<span class="cm"> * compiler will optimise away the if() in all cases.</span>
<span class="cm"> */</span>
<span class="cm">/* All error messages (will show up in the normal logs) */</span>
<span class="cp">#define DERROR(dbg, format, args...) \</span>
<span class="cp">	{if(DEBUG_##dbg) \</span>
<span class="cp">		printk(KERN_INFO &quot;irnet: %s(): &quot; format, __func__ , ##args);}</span>

<span class="cm">/* Normal debug message (will show up in /var/log/debug) */</span>
<span class="cp">#define DEBUG(dbg, format, args...) \</span>
<span class="cp">	{if(DEBUG_##dbg) \</span>
<span class="cp">		printk(KERN_DEBUG &quot;irnet: %s(): &quot; format, __func__ , ##args);}</span>

<span class="cm">/* Entering a function (trace) */</span>
<span class="cp">#define DENTER(dbg, format, args...) \</span>
<span class="cp">	{if(DEBUG_##dbg) \</span>
<span class="cp">		printk(KERN_DEBUG &quot;irnet: -&gt; %s&quot; format, __func__ , ##args);}</span>

<span class="cm">/* Entering and exiting a function in one go (trace) */</span>
<span class="cp">#define DPASS(dbg, format, args...) \</span>
<span class="cp">	{if(DEBUG_##dbg) \</span>
<span class="cp">		printk(KERN_DEBUG &quot;irnet: &lt;&gt;%s&quot; format, __func__ , ##args);}</span>

<span class="cm">/* Exiting a function (trace) */</span>
<span class="cp">#define DEXIT(dbg, format, args...) \</span>
<span class="cp">	{if(DEBUG_##dbg) \</span>
<span class="cp">		printk(KERN_DEBUG &quot;irnet: &lt;-%s()&quot; format, __func__ , ##args);}</span>

<span class="cm">/* Exit a function with debug */</span>
<span class="cp">#define DRETURN(ret, dbg, args...) \</span>
<span class="cp">	{DEXIT(dbg, &quot;: &quot; args);\</span>
<span class="cp">	return ret; }</span>

<span class="cm">/* Exit a function on failed condition */</span>
<span class="cp">#define DABORT(cond, ret, dbg, args...) \</span>
<span class="cp">	{if(cond) {\</span>
<span class="cp">		DERROR(dbg, args);\</span>
<span class="cp">		return ret; }}</span>

<span class="cm">/* Invalid assertion, print out an error and exit... */</span>
<span class="cp">#define DASSERT(cond, ret, dbg, args...) \</span>
<span class="cp">	{if((DEBUG_ASSERT) &amp;&amp; !(cond)) {\</span>
<span class="cp">		DERROR(dbg, &quot;Invalid assertion: &quot; args);\</span>
<span class="cp">		return ret; }}</span>

<span class="cm">/************************ CONSTANTS &amp; MACROS ************************/</span>

<span class="cm">/* Paranoia */</span>
<span class="cp">#define IRNET_MAGIC	0xB00754</span>

<span class="cm">/* Number of control events in the control channel buffer... */</span>
<span class="cp">#define IRNET_MAX_EVENTS	8	</span><span class="cm">/* Should be more than enough... */</span><span class="cp"></span>

<span class="cm">/****************************** TYPES ******************************/</span>

<span class="cm">/*</span>
<span class="cm"> * This is the main structure where we store all the data pertaining to</span>
<span class="cm"> * one instance of irnet.</span>
<span class="cm"> * Note : in irnet functions, a pointer this structure is usually called</span>
<span class="cm"> * &quot;ap&quot; or &quot;self&quot;. If the code is borrowed from the IrDA stack, it tend</span>
<span class="cm"> * to be called &quot;self&quot;, and if it is borrowed from the PPP driver it is</span>
<span class="cm"> * &quot;ap&quot;. Apart from that, it&#39;s exactly the same structure ;-)</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">irnet_socket</span>
<span class="p">{</span>
  <span class="cm">/* ------------------- Instance management ------------------- */</span>
  <span class="cm">/* We manage a linked list of IrNET socket instances */</span>
  <span class="n">irda_queue_t</span>		<span class="n">q</span><span class="p">;</span>		<span class="cm">/* Must be first - for hasbin */</span>
  <span class="kt">int</span>			<span class="n">magic</span><span class="p">;</span>		<span class="cm">/* Paranoia */</span>

  <span class="cm">/* --------------------- FileSystem part --------------------- */</span>
  <span class="cm">/* &quot;pppd&quot; interact directly with us on a /dev/ file */</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span>		<span class="n">file</span><span class="p">;</span>		<span class="cm">/* File descriptor of this instance */</span>
  <span class="cm">/* TTY stuff - to keep &quot;pppd&quot; happy */</span>
  <span class="k">struct</span> <span class="n">ktermios</span>	<span class="n">termios</span><span class="p">;</span>	<span class="cm">/* Various tty flags */</span>
  <span class="cm">/* Stuff for the control channel */</span>
  <span class="kt">int</span>			<span class="n">event_index</span><span class="p">;</span>	<span class="cm">/* Last read in the event log */</span>

  <span class="cm">/* ------------------------- PPP part ------------------------- */</span>
  <span class="cm">/* We interface directly to the ppp_generic driver in the kernel */</span>
  <span class="kt">int</span>			<span class="n">ppp_open</span><span class="p">;</span>	<span class="cm">/* registered with ppp_generic */</span>
  <span class="k">struct</span> <span class="n">ppp_channel</span>	<span class="n">chan</span><span class="p">;</span>		<span class="cm">/* Interface to generic ppp layer */</span>

  <span class="kt">int</span>			<span class="n">mru</span><span class="p">;</span>		<span class="cm">/* Max size of PPP payload */</span>
  <span class="n">u32</span>			<span class="n">xaccm</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* Asynchronous character map (just */</span>
  <span class="n">u32</span>			<span class="n">raccm</span><span class="p">;</span>		<span class="cm">/* to please pppd - dummy) */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* PPP flags (compression, ...) */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rbits</span><span class="p">;</span>		<span class="cm">/* Unused receive flags ??? */</span>
  <span class="k">struct</span> <span class="n">work_struct</span> <span class="n">disconnect_work</span><span class="p">;</span>   <span class="cm">/* Process context disconnection */</span>
  <span class="cm">/* ------------------------ IrTTP part ------------------------ */</span>
  <span class="cm">/* We create a pseudo &quot;socket&quot; over the IrDA tranport */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ttp_open</span><span class="p">;</span>	<span class="cm">/* Set when IrTTP is ready */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ttp_connect</span><span class="p">;</span>	<span class="cm">/* Set when IrTTP is connecting */</span>
  <span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span>	<span class="n">tsap</span><span class="p">;</span>		<span class="cm">/* IrTTP instance (the connection) */</span>

  <span class="kt">char</span>			<span class="n">rname</span><span class="p">[</span><span class="n">NICKNAME_MAX_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
					<span class="cm">/* IrDA nickname of destination */</span>
  <span class="n">__u32</span>			<span class="n">rdaddr</span><span class="p">;</span>		<span class="cm">/* Requested peer IrDA address */</span>
  <span class="n">__u32</span>			<span class="n">rsaddr</span><span class="p">;</span>		<span class="cm">/* Requested local IrDA address */</span>
  <span class="n">__u32</span>			<span class="n">daddr</span><span class="p">;</span>		<span class="cm">/* actual peer IrDA address */</span>
  <span class="n">__u32</span>			<span class="n">saddr</span><span class="p">;</span>		<span class="cm">/* my local IrDA address */</span>
  <span class="n">__u8</span>			<span class="n">dtsap_sel</span><span class="p">;</span>	<span class="cm">/* Remote TSAP selector */</span>
  <span class="n">__u8</span>			<span class="n">stsap_sel</span><span class="p">;</span>	<span class="cm">/* Local TSAP selector */</span>

  <span class="n">__u32</span>			<span class="n">max_sdu_size_rx</span><span class="p">;</span><span class="cm">/* Socket parameters used for IrTTP */</span>
  <span class="n">__u32</span>			<span class="n">max_sdu_size_tx</span><span class="p">;</span>
  <span class="n">__u32</span>			<span class="n">max_data_size</span><span class="p">;</span>
  <span class="n">__u8</span>			<span class="n">max_header_size</span><span class="p">;</span>
  <span class="n">LOCAL_FLOW</span>		<span class="n">tx_flow</span><span class="p">;</span>	<span class="cm">/* State of the Tx path in IrTTP */</span>

  <span class="cm">/* ------------------- IrLMP and IrIAS part ------------------- */</span>
  <span class="cm">/* Used for IrDA Discovery and socket name resolution */</span>
  <span class="kt">void</span> <span class="o">*</span>		<span class="n">ckey</span><span class="p">;</span>		<span class="cm">/* IrLMP client handle */</span>
  <span class="n">__u16</span>			<span class="n">mask</span><span class="p">;</span>		<span class="cm">/* Hint bits mask (filter discov.)*/</span>
  <span class="kt">int</span>			<span class="n">nslots</span><span class="p">;</span>		<span class="cm">/* Number of slots for discovery */</span>

  <span class="k">struct</span> <span class="n">iriap_cb</span> <span class="o">*</span>	<span class="n">iriap</span><span class="p">;</span>		<span class="cm">/* Used to query remote IAS */</span>
  <span class="kt">int</span>			<span class="n">errno</span><span class="p">;</span>		<span class="cm">/* status of the IAS query */</span>

  <span class="cm">/* -------------------- Discovery log part -------------------- */</span>
  <span class="cm">/* Used by initial discovery on the control channel</span>
<span class="cm">   * and by irnet_discover_daddr_and_lsap_sel() */</span>
  <span class="k">struct</span> <span class="n">irda_device_info</span> <span class="o">*</span><span class="n">discoveries</span><span class="p">;</span>	<span class="cm">/* Copy of the discovery log */</span>
  <span class="kt">int</span>			<span class="n">disco_index</span><span class="p">;</span>	<span class="cm">/* Last read in the discovery log */</span>
  <span class="kt">int</span>			<span class="n">disco_number</span><span class="p">;</span>	<span class="cm">/* Size of the discovery log */</span>

  <span class="k">struct</span> <span class="n">mutex</span>		<span class="n">lock</span><span class="p">;</span>

<span class="p">}</span> <span class="n">irnet_socket</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the various event that we will generate on the control channel</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">irnet_event</span>
<span class="p">{</span>
  <span class="n">IRNET_DISCOVER</span><span class="p">,</span>		<span class="cm">/* New IrNET node discovered */</span>
  <span class="n">IRNET_EXPIRE</span><span class="p">,</span>			<span class="cm">/* IrNET node expired */</span>
  <span class="n">IRNET_CONNECT_TO</span><span class="p">,</span>		<span class="cm">/* IrNET socket has connected to other node */</span>
  <span class="n">IRNET_CONNECT_FROM</span><span class="p">,</span>		<span class="cm">/* Other node has connected to IrNET socket */</span>
  <span class="n">IRNET_REQUEST_FROM</span><span class="p">,</span>		<span class="cm">/* Non satisfied connection request */</span>
  <span class="n">IRNET_NOANSWER_FROM</span><span class="p">,</span>		<span class="cm">/* Failed connection request */</span>
  <span class="n">IRNET_BLOCKED_LINK</span><span class="p">,</span>		<span class="cm">/* Link (IrLAP) is blocked for &gt; 3s */</span>
  <span class="n">IRNET_DISCONNECT_FROM</span><span class="p">,</span>	<span class="cm">/* IrNET socket has disconnected */</span>
  <span class="n">IRNET_DISCONNECT_TO</span>		<span class="cm">/* Closing IrNET socket */</span>
<span class="p">}</span> <span class="n">irnet_event</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the storage for an event and its arguments</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">irnet_log</span>
<span class="p">{</span>
  <span class="n">irnet_event</span>	<span class="n">event</span><span class="p">;</span>
  <span class="kt">int</span>		<span class="n">unit</span><span class="p">;</span>
  <span class="n">__u32</span>		<span class="n">saddr</span><span class="p">;</span>
  <span class="n">__u32</span>		<span class="n">daddr</span><span class="p">;</span>
  <span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="n">NICKNAME_MAX_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* 21 + 1 */</span>
  <span class="n">__u16_host_order</span> <span class="n">hints</span><span class="p">;</span>			<span class="cm">/* Discovery hint bits */</span>
<span class="p">}</span> <span class="n">irnet_log</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the storage for all events and related stuff...</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">irnet_ctrl_channel</span>
<span class="p">{</span>
  <span class="n">irnet_log</span>	<span class="n">log</span><span class="p">[</span><span class="n">IRNET_MAX_EVENTS</span><span class="p">];</span>	<span class="cm">/* Event log */</span>
  <span class="kt">int</span>		<span class="n">index</span><span class="p">;</span>		<span class="cm">/* Current index in log */</span>
  <span class="n">spinlock_t</span>	<span class="n">spinlock</span><span class="p">;</span>	<span class="cm">/* Serialize access to the event log */</span>
  <span class="n">wait_queue_head_t</span>	<span class="n">rwait</span><span class="p">;</span>	<span class="cm">/* processes blocked on read (or poll) */</span>
<span class="p">}</span> <span class="n">irnet_ctrl_channel</span><span class="p">;</span>

<span class="cm">/**************************** PROTOTYPES ****************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Global functions of the IrNET module</span>
<span class="cm"> * Note : we list here also functions called from one file to the other.</span>
<span class="cm"> */</span>

<span class="cm">/* -------------------------- IRDA PART -------------------------- */</span>
<span class="k">extern</span> <span class="kt">int</span>
	<span class="n">irda_irnet_create</span><span class="p">(</span><span class="n">irnet_socket</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Initialise a IrNET socket */</span>
<span class="k">extern</span> <span class="kt">int</span>
	<span class="n">irda_irnet_connect</span><span class="p">(</span><span class="n">irnet_socket</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Try to connect over IrDA */</span>
<span class="k">extern</span> <span class="kt">void</span>
	<span class="n">irda_irnet_destroy</span><span class="p">(</span><span class="n">irnet_socket</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* Teardown  a IrNET socket */</span>
<span class="k">extern</span> <span class="kt">int</span>
	<span class="n">irda_irnet_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>		<span class="cm">/* Initialise IrDA part of IrNET */</span>
<span class="k">extern</span> <span class="kt">void</span>
	<span class="n">irda_irnet_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>	<span class="cm">/* Teardown IrDA part of IrNET */</span>

<span class="cm">/**************************** VARIABLES ****************************/</span>

<span class="cm">/* Control channel stuff - allocated in irnet_irda.h */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">irnet_ctrl_channel</span>	<span class="n">irnet_events</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* IRNET_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
