<!DOCTYPE html>
<html><head><title>joekychen/linux » net › irda › irttp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irttp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irttp.c</span>
<span class="cm"> * Version:       1.2</span>
<span class="cm"> * Description:   Tiny Transport Protocol (TTP) implementation</span>
<span class="cm"> * Status:        Stable</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sun Aug 31 20:14:31 1997</span>
<span class="cm"> * Modified at:   Wed Jan  5 11:31:27 2000</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;,</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2003 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is</span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlap.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;</span>
<span class="cp">#include &lt;net/irda/parameters.h&gt;</span>
<span class="cp">#include &lt;net/irda/irttp.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irttp_cb</span> <span class="o">*</span><span class="n">irttp</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__irttp_close_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irttp_data_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irttp_udata_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_disconnect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					<span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_connect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
				     <span class="n">__u8</span> <span class="n">header_size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_connect_confirm</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
				  <span class="n">__u8</span> <span class="n">header_size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_run_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_flush_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_fragment_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">irttp_reassemble_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_todo_expired</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irttp_param_max_sdu_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">get</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_flow_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="n">LOCAL_FLOW</span> <span class="n">flow</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irttp_status_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				    <span class="n">LINK_STATUS</span> <span class="n">link</span><span class="p">,</span> <span class="n">LOCK_STATUS</span> <span class="n">lock</span><span class="p">);</span>

<span class="cm">/* Information for parsing parameters in IrTTP */</span>
<span class="k">static</span> <span class="n">pi_minor_info_t</span> <span class="n">pi_minor_call_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>                                             <span class="cm">/* 0x00 */</span>
	<span class="p">{</span> <span class="n">irttp_param_max_sdu_size</span><span class="p">,</span> <span class="n">PV_INTEGER</span> <span class="o">|</span> <span class="n">PV_BIG_ENDIAN</span> <span class="p">}</span> <span class="cm">/* 0x01 */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">pi_major_info_t</span> <span class="n">pi_major_call_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span> <span class="n">pi_minor_call_table</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}};</span>
<span class="k">static</span> <span class="n">pi_param_info_t</span> <span class="n">param_info</span> <span class="o">=</span> <span class="p">{</span> <span class="n">pi_major_call_table</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>

<span class="cm">/************************ GLOBAL PROCEDURES ************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_init (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize the IrTTP layer. Called by module initialization code</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">irttp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irttp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irttp_cb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irttp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">irttp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">TTP_MAGIC</span><span class="p">;</span>

	<span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span> <span class="o">=</span> <span class="n">hashbin_new</span><span class="p">(</span><span class="n">HB_LOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t allocate IrTTP hashbin!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">irttp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_cleanup (void)</span>
<span class="cm"> *</span>
<span class="cm"> *    Called by module destruction/cleanup code</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irttp_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check for main structure */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Delete hashbin and close all TSAP instances in it</span>
<span class="cm">	 */</span>
	<span class="n">hashbin_delete</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">FREE_FUNC</span><span class="p">)</span> <span class="n">__irttp_close_tsap</span><span class="p">);</span>

	<span class="n">irttp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* De-allocate main structure */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">irttp</span><span class="p">);</span>

	<span class="n">irttp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*************************** SUBROUTINES ***************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_start_todo_timer (self, timeout)</span>
<span class="cm"> *</span>
<span class="cm"> *    Start todo timer.</span>
<span class="cm"> *</span>
<span class="cm"> * Made it more effient and unsensitive to race conditions - Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irttp_start_todo_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set new value for timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">todo_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_todo_expired (data)</span>
<span class="cm"> *</span>
<span class="cm"> *    Todo timer has expired!</span>
<span class="cm"> *</span>
<span class="cm"> * One of the restriction of the timer is that it is run only on the timer</span>
<span class="cm"> * interrupt which run every 10ms. This mean that even if you set the timer</span>
<span class="cm"> * with a delay of 0, it may take up to 10ms before it&#39;s run.</span>
<span class="cm"> * So, to minimise latency and keep cache fresh, we try to avoid using</span>
<span class="cm"> * it as much as possible.</span>
<span class="cm"> * Note : we can&#39;t use tasklets, because they can&#39;t be asynchronously</span>
<span class="cm"> * killed (need user context), and we can&#39;t guarantee that here...</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_todo_expired</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Check that we still exist */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span> <span class="o">||</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(instance=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Try to make some progress, especially on Tx side - Jean II */</span>
	<span class="n">irttp_run_rx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Check if time for disconnect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pend</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Check if it&#39;s possible to disconnect yet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Make sure disconnect is not pending anymore */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pend</span><span class="p">);</span>	<span class="cm">/* FALSE */</span>

			<span class="cm">/* Note : self-&gt;disconnect_skb may be NULL */</span>
			<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_skb</span><span class="p">,</span>
						 <span class="n">P_NORMAL</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Try again later */</span>
			<span class="n">irttp_start_todo_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

			<span class="cm">/* No reason to try and close now */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check if it&#39;s closing time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_pend</span><span class="p">)</span>
		<span class="cm">/* Finish cleanup */</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_flush_queues (self)</span>
<span class="cm"> *</span>
<span class="cm"> *     Flushes (removes all frames) in transitt-buffer (tx_list)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_flush_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Deallocate frames waiting to be sent */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Deallocate received frames */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Deallocate received fragments */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_reassemble (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Makes a new (continuous) skb of all the fragments in the fragment</span>
<span class="cm"> *    queue</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">irttp_reassemble_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Fragment index */</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), self-&gt;rx_sdu_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">TTP_HEADER</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to reserve space for TTP header in case this skb needs to</span>
<span class="cm">	 * be requeued in case delivery failes</span>
<span class="cm">	 */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Copy all fragments to a new buffer</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">frag</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
		   <span class="s">&quot;%s(), frame len=%d, rx_sdu_size=%d, rx_max_sdu_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span><span class="p">);</span>
	<span class="cm">/* Note : irttp_run_rx_queue() calculate self-&gt;rx_sdu_size</span>
<span class="cm">	 * by summing the size of all fragments, so we should always</span>
<span class="cm">	 * have n == self-&gt;rx_sdu_size, except in cases where we</span>
<span class="cm">	 * droped the last fragment (when self-&gt;rx_sdu_size exceed</span>
<span class="cm">	 * self-&gt;rx_max_sdu_size), where n &lt; self-&gt;rx_sdu_size.</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span><span class="p">;);</span>

	<span class="cm">/* Set the new length */</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_fragment_skb (skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Fragments a frame and queues all the fragments for transmission</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irttp_fragment_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Split frame into a number of segments</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), fragmenting ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Make new segment */</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="o">+</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">,</span>
				 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">);</span>

		<span class="cm">/* Copy data from the original skb into this fragment. */</span>
		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">),</span>
			      <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">);</span>

		<span class="cm">/* Insert TTP header, with the more bit set */</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TTP_MORE</span><span class="p">;</span>

		<span class="cm">/* Hide the copied data from the original skb */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">);</span>

		<span class="cm">/* Queue fragment */</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">frag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Queue what is left of the original skb */</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), queuing last segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* Clear more bit */</span>

	<span class="cm">/* Queue fragment */</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_param_max_sdu_size (self, param)</span>
<span class="cm"> *</span>
<span class="cm"> *    Handle the MaxSduSize parameter in the connect frames, this function</span>
<span class="cm"> *    will be called both when this parameter needs to be inserted into, and</span>
<span class="cm"> *    extracted from the connect frames</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irttp_param_max_sdu_size</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">irda_param_t</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">get</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">)</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), MaxSduSize=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">pv</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*************************** CLIENT CALLS ***************************/</span>
<span class="cm">/************************** LMP CALLBACKS **************************/</span>
<span class="cm">/* Everything is happily mixed up. Waiting for next clean up - Jean II */</span>

<span class="cm">/*</span>
<span class="cm"> * Initialization, that has to be done on new tsap</span>
<span class="cm"> * instance allocation and on duplication</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_init_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">tsap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">todo_timer</span><span class="p">);</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsap</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_open_tsap (stsap, notify)</span>
<span class="cm"> *</span>
<span class="cm"> *    Create TSAP connection endpoint,</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="nf">irttp_open_tsap</span><span class="p">(</span><span class="n">__u8</span> <span class="n">stsap_sel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">credit</span><span class="p">,</span> <span class="n">notify_t</span> <span class="o">*</span><span class="n">notify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="n">notify_t</span> <span class="n">ttp_notify</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;);</span>

	<span class="cm">/* The IrLMP spec (IrLMP 1.1 p10) says that we have the right to</span>
<span class="cm">	 * use only 0x01-0x6F. Of course, we can use LSAP_ANY as well.</span>
<span class="cm">	 * JeanII */</span>
	<span class="k">if</span><span class="p">((</span><span class="n">stsap_sel</span> <span class="o">!=</span> <span class="n">LSAP_ANY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">((</span><span class="n">stsap_sel</span> <span class="o">&lt;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">stsap_sel</span> <span class="o">&gt;=</span> <span class="mh">0x70</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), invalid tsap!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unable to kmalloc!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize internal objects */</span>
	<span class="n">irttp_init_tsap</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Initialise todo timer */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">todo_timer</span><span class="p">.</span><span class="n">data</span>     <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">todo_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irttp_todo_expired</span><span class="p">;</span>

	<span class="cm">/* Initialize callbacks for IrLMP to use */</span>
	<span class="n">irda_notify_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ttp_notify</span><span class="p">);</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">connect_confirm</span> <span class="o">=</span> <span class="n">irttp_connect_confirm</span><span class="p">;</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">connect_indication</span> <span class="o">=</span> <span class="n">irttp_connect_indication</span><span class="p">;</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">disconnect_indication</span> <span class="o">=</span> <span class="n">irttp_disconnect_indication</span><span class="p">;</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">data_indication</span> <span class="o">=</span> <span class="n">irttp_data_indication</span><span class="p">;</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">udata_indication</span> <span class="o">=</span> <span class="n">irttp_udata_indication</span><span class="p">;</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">flow_indication</span> <span class="o">=</span> <span class="n">irttp_flow_indication</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">status_indication</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ttp_notify</span><span class="p">.</span><span class="n">status_indication</span> <span class="o">=</span> <span class="n">irttp_status_indication</span><span class="p">;</span>
	<span class="n">ttp_notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">ttp_notify</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">notify</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">NOTIFY_MAX_NAME</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Create LSAP at IrLMP layer</span>
<span class="cm">	 */</span>
	<span class="n">lsap</span> <span class="o">=</span> <span class="n">irlmp_open_lsap</span><span class="p">(</span><span class="n">stsap_sel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ttp_notify</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lsap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: unable to allocate LSAP!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If user specified LSAP_ANY as source TSAP selector, then IrLMP</span>
<span class="cm">	 *  will replace it with whatever source selector which is free, so</span>
<span class="cm">	 *  the stsap_sel we have might not be valid anymore</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span> <span class="o">=</span> <span class="n">lsap</span><span class="o">-&gt;</span><span class="n">slsap_sel</span><span class="p">;</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), stsap_sel=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span> <span class="o">=</span> <span class="o">*</span><span class="n">notify</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">lsap</span><span class="p">;</span>

	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">credit</span> <span class="o">&gt;</span> <span class="n">TTP_RX_MAX_CREDIT</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">initial_credit</span> <span class="o">=</span> <span class="n">TTP_RX_MAX_CREDIT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">initial_credit</span> <span class="o">=</span> <span class="n">credit</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_open_tsap</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_close (handle)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove an instance of a TSAP. This function should only deal with the</span>
<span class="cm"> *    deallocation of the TSAP, and resetting of the TSAPs values;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__irttp_close_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* First make sure we&#39;re connected. */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">irttp_flush_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">todo_timer</span><span class="p">);</span>

	<span class="cm">/* This one won&#39;t be cleaned up if we are disconnect_pend + close_pend</span>
<span class="cm">	 * and we receive a disconnect_indication */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_skb</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="o">~</span><span class="n">TTP_TSAP_MAGIC</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Remove TSAP from list of all TSAPs and then deallocate all resources</span>
<span class="cm"> *    associated with this TSAP</span>
<span class="cm"> *</span>
<span class="cm"> * Note : because we *free* the tsap structure, it is the responsibility</span>
<span class="cm"> * of the caller to make sure we are called only once and to deal with</span>
<span class="cm"> * possible race conditions. - Jean II</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irttp_close_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">tsap</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Make sure tsap has been disconnected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if disconnect is not pending */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pend</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: TSAP still connected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">P_NORMAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">close_pend</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">irttp_start_todo_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Will be back! */</span>
	<span class="p">}</span>

	<span class="n">tsap</span> <span class="o">=</span> <span class="n">hashbin_remove</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">self</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">tsap</span> <span class="o">==</span> <span class="n">self</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Close corresponding LSAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irlmp_close_lsap</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_close_tsap</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_udata_request (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send unreliable data on this TSAP</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irttp_udata_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Take shortcut on zero byte packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that nothing bad happens */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), Not connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), UData is too large for IrLAP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irlmp_udata_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_udata_request</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Function irttp_data_request (handle, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Queue frame for transmission. If SAR is enabled, fragement the frame</span>
<span class="cm"> *    and queue the fragments for transmission</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irttp_data_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() : queue len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">));</span>

	<span class="cm">/* Take shortcut on zero byte packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check that nothing bad happens */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: Not connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if SAR is disabled, and the frame is larger than what fits</span>
<span class="cm">	 *  inside an IrLAP frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: SAR disabled, and data is too large for IrLAP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if SAR is enabled, and the frame is larger than the</span>
<span class="cm">	 *  TxMaxSduSize</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">!=</span> <span class="n">TTP_SAR_UNBOUND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s: SAR enabled, but data is larger than TxMaxSduSize!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check if transmit queue is full</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TTP_TX_MAX_QUEUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Give it a chance to empty itself</span>
<span class="cm">		 */</span>
		<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/* Drop packet. This error code should trigger the caller</span>
<span class="cm">		 * to resend the data in the client code - Jean II */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Queue frame, or queue frame segments */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Queue frame */</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TTP_HEADER</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* Clear more bit */</span>

		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Fragment the frame, this function will also queue the</span>
<span class="cm">		 *  fragments, we don&#39;t care about the fact the transmit</span>
<span class="cm">		 *  queue may be overfilled by all the segments for a little</span>
<span class="cm">		 *  while</span>
<span class="cm">		 */</span>
		<span class="n">irttp_fragment_skb</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we can accept more data from client */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_sdu_busy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TTP_TX_HIGH_THRESHOLD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Tx queue filling up, so stop client. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						     <span class="n">self</span><span class="p">,</span> <span class="n">FLOW_STOP</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* self-&gt;tx_sdu_busy is the state of the client.</span>
<span class="cm">		 * Update state after notifying client to avoid</span>
<span class="cm">		 * race condition with irttp_flow_indication().</span>
<span class="cm">		 * If the queue empty itself after our test but before</span>
<span class="cm">		 * we set the flag, we will fix ourselves below in</span>
<span class="cm">		 * irttp_run_tx_queue().</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_sdu_busy</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Try to make some progress */</span>
	<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_data_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_run_tx_queue (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmit packets queued for transmission (if possible)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_run_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() : send_credit = %d, queue_len = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span><span class="p">,</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">));</span>

	<span class="cm">/* Get exclusive access to the tx queue, otherwise don&#39;t touch it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irda_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue_lock</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Try to send out frames as long as we have credits</span>
<span class="cm">	 * and as long as LAP is not full. If LAP is full, it will</span>
<span class="cm">	 * poll us through irttp_flow_indication() - Jean II */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="o">!</span><span class="n">irlmp_lap_tx_queue_full</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Since we can transmit and receive frames concurrently,</span>
<span class="cm">		 *  the code below is a critical region and we must assure that</span>
<span class="cm">		 *  nobody messes with the credits while we update them.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Only room for 127 credits in frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">127</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span><span class="o">--</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  More bit must be set by the data_request() or fragment()</span>
<span class="cm">		 *  functions</span>
<span class="cm">		 */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>

		<span class="cm">/* Detach from socket.</span>
<span class="cm">		 * The current skb has a reference to the socket that sent</span>
<span class="cm">		 * it (skb-&gt;sk). When we pass it to IrLMP, the skb will be</span>
<span class="cm">		 * stored in in IrLAP (self-&gt;wx_list). When we are within</span>
<span class="cm">		 * IrLAP, we lose the notion of socket, so we should not</span>
<span class="cm">		 * have a reference to a socket. So, we drop it here.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Why does it matter ?</span>
<span class="cm">		 * When the skb is freed (kfree_skb), if it is associated</span>
<span class="cm">		 * with a socket, it release buffer space on the socket</span>
<span class="cm">		 * (through sock_wfree() and sock_def_write_space()).</span>
<span class="cm">		 * If the socket no longer exist, we may crash. Hard.</span>
<span class="cm">		 * When we close a socket, we make sure that associated packets</span>
<span class="cm">		 * in IrTTP are freed. However, we have no way to cancel</span>
<span class="cm">		 * the packet that we have passed to IrLAP. So, if a packet</span>
<span class="cm">		 * remains in IrLAP (retry on the link or else) after we</span>
<span class="cm">		 * close the socket, we are dead !</span>
<span class="cm">		 * Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* IrSOCK application, IrOBEX, ... */</span>
			<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
			<span class="cm">/* IrCOMM over IrTTP, IrLAN, ... */</span>

		<span class="cm">/* Pass the skb to IrLMP - done */</span>
		<span class="n">irlmp_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we can accept more frames from client.</span>
<span class="cm">	 * We don&#39;t want to wait until the todo timer to do that, and we</span>
<span class="cm">	 * can&#39;t use tasklets (grr...), so we are obliged to give control</span>
<span class="cm">	 * to client. That&#39;s ok, this test will be true not too often</span>
<span class="cm">	 * (max once per LAP window) and we are called from places</span>
<span class="cm">	 * where we can spend a bit of time doing stuff. - Jean II */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_sdu_busy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TTP_TX_LOW_THRESHOLD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_pend</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">flow_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						     <span class="n">self</span><span class="p">,</span> <span class="n">FLOW_START</span><span class="p">);</span>

		<span class="cm">/* self-&gt;tx_sdu_busy is the state of the client.</span>
<span class="cm">		 * We don&#39;t really have a race here, but it&#39;s always safer</span>
<span class="cm">		 * to update our state after the client - Jean II */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_sdu_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reset lock */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_give_credit (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Send a dataless flowdata TTP-PDU and give available credit to peer</span>
<span class="cm"> *    TSAP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irttp_give_credit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() send=%d,avail=%d,remote=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span><span class="p">);</span>

	<span class="cm">/* Give credit to peer */</span>
	<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">TTP_MAX_HEADER</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for LMP, and LAP header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">LMP_MAX_HEADER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Since we can transmit and receive frames concurrently,</span>
<span class="cm">	 *  the code below is a critical region and we must assure that</span>
<span class="cm">	 *  nobody messes with the credits while we update them.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Only space for 127 credits in frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">127</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">skb_put</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>

	<span class="n">irlmp_data_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">tx_skb</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_udata_indication (instance, sap, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Received some unit-data (unreliable)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irttp_udata_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Just pass data to layer above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">udata_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
						    <span class="n">self</span><span class="p">,</span><span class="n">skb</span><span class="p">);</span>
		<span class="cm">/* Same comment as in irttp_do_data_indication() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Either no handler, or handler returns an error */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_data_indication (instance, sap, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Receive segment from IrLMP.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irttp_data_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>     <span class="cm">/* Extract the credits */</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*  Deal with inbound credit</span>
<span class="cm">	 *  Since we can transmit and receive frames concurrently,</span>
<span class="cm">	 *  the code below is a critical region and we must assure that</span>
<span class="cm">	 *  nobody messes with the credits while we update them.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Data or dataless packet? Dataless frames contains only the</span>
<span class="cm">	 *  TTP_HEADER.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  We don&#39;t remove the TTP header, since we must preserve the</span>
<span class="cm">		 *  more bit, so the defragment routing knows what to do</span>
<span class="cm">		 */</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Dataless flowdata TTP-PDU */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/* Push data to the higher layer.</span>
<span class="cm">	 * We do it synchronously because running the todo timer for each</span>
<span class="cm">	 * receive packet would be too much overhead and latency.</span>
<span class="cm">	 * By passing control to the higher layer, we run the risk that</span>
<span class="cm">	 * it may take time or grab a lock. Most often, the higher layer</span>
<span class="cm">	 * will only put packet in a queue.</span>
<span class="cm">	 * Anyway, packets are only dripping through the IrDA, so we can</span>
<span class="cm">	 * have time before the next packet.</span>
<span class="cm">	 * Further, we are run from NET_BH, so the worse that can happen is</span>
<span class="cm">	 * us missing the optimal time to send back the PF bit in LAP.</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">irttp_run_rx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* We now give credits to peer in irttp_run_rx_queue().</span>
<span class="cm">	 * We need to send credit *NOW*, otherwise we are going</span>
<span class="cm">	 * to miss the next Tx window. The todo timer may take</span>
<span class="cm">	 * a while before it&#39;s run... - Jean II */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the peer device has given us some credits and we didn&#39;t have</span>
<span class="cm">	 * anyone from before, then we need to shedule the tx queue.</span>
<span class="cm">	 * We need to do that because our Tx have stopped (so we may not</span>
<span class="cm">	 * get any LAP flow indication) and the user may be stopped as</span>
<span class="cm">	 * well. - Jean II</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Restart pushing stuff to LAP */</span>
		<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="cm">/* Note : we don&#39;t want to schedule the todo timer</span>
<span class="cm">		 * because it has horrible latency. No tasklets</span>
<span class="cm">		 * because the tasklet API is broken. - Jean II */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_status_indication (self, reason)</span>
<span class="cm"> *</span>
<span class="cm"> *    Status_indication, just pass to the higher layer...</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_status_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				    <span class="n">LINK_STATUS</span> <span class="n">link</span><span class="p">,</span> <span class="n">LOCK_STATUS</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Check if client has already closed the TSAP and gone away */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_pend</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Inform service user if he has requested it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">status_indication</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">status_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span>
					       <span class="n">link</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), no handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_flow_indication (self, reason)</span>
<span class="cm"> *</span>
<span class="cm"> *    Flow_indication : IrLAP tells us to send more data.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_flow_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="n">LOCAL_FLOW</span> <span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(instance=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="cm">/* We are &quot;polled&quot; directly from LAP, and the LAP want to fill</span>
<span class="cm">	 * its Tx window. We want to do our best to send it data, so that</span>
<span class="cm">	 * we maximise the window. On the other hand, we want to limit the</span>
<span class="cm">	 * amount of work here so that LAP doesn&#39;t hang forever waiting</span>
<span class="cm">	 * for packets. - Jean II */</span>

	<span class="cm">/* Try to send some packets. Currently, LAP calls us every time</span>
<span class="cm">	 * there is one free slot, so we will send only one packet.</span>
<span class="cm">	 * This allow the scheduler to do its round robin - Jean II */</span>
	<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Note regarding the interraction with higher layer.</span>
<span class="cm">	 * irttp_run_tx_queue() may call the client when its queue</span>
<span class="cm">	 * start to empty, via notify.flow_indication(). Initially.</span>
<span class="cm">	 * I wanted this to happen in a tasklet, to avoid client</span>
<span class="cm">	 * grabbing the CPU, but we can&#39;t use tasklets safely. And timer</span>
<span class="cm">	 * is definitely too slow.</span>
<span class="cm">	 * This will happen only once per LAP window, and usually at</span>
<span class="cm">	 * the third packet (unless window is smaller). LAP is still</span>
<span class="cm">	 * doing mtt and sending first packet so it&#39;s sort of OK</span>
<span class="cm">	 * to do that. Jean II */</span>

	<span class="cm">/* If we need to send disconnect. try to do it now */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pend</span><span class="p">)</span>
		<span class="n">irttp_start_todo_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_flow_request (self, command)</span>
<span class="cm"> *</span>
<span class="cm"> *    This function could be used by the upper layers to tell IrTTP to stop</span>
<span class="cm"> *    delivering frames if the receive queues are starting to get full, or</span>
<span class="cm"> *    to tell IrTTP to start delivering frames again.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irttp_flow_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">LOCAL_FLOW</span> <span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flow</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FLOW_STOP</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), flow stop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FLOW_START</span>:
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), flow start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="cm">/* Client say he can accept more data, try to free our</span>
<span class="cm">		 * queues ASAP - Jean II */</span>
		<span class="n">irttp_run_rx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown flow command!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_flow_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_connect_request (self, dtsap_sel, daddr, qos)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to connect to remote destination TSAP selector</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irttp_connect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dtsap_sel</span><span class="p">,</span>
			  <span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">daddr</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), max_sdu_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">max_sdu_size</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Any userdata supplied? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">,</span>
				   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* Reserve space for MUX_CONTROL and LAP header */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Check that the client has reserved enough space for</span>
<span class="cm">		 *  headers</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TTP_MAX_HEADER</span><span class="p">,</span>
			<span class="p">{</span> <span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize connection parameters */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">dtsap_sel</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">initial_credit</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Give away max 127 credits for now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">127</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* SAR enabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_sdu_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">),</span>
			<span class="p">{</span> <span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">);</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>

		<span class="cm">/* Insert SAR parameters */</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="o">+</span><span class="n">TTP_SAR_HEADER</span><span class="p">);</span>

		<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TTP_PARAMETERS</span> <span class="o">|</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span> <span class="cm">/* Length */</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* MaxSduSize */</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span> <span class="cm">/* Value length */</span>

		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_be16</span><span class="p">((</span><span class="n">__u16</span><span class="p">)</span> <span class="n">max_sdu_size</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)(</span><span class="n">frame</span><span class="o">+</span><span class="mi">4</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Insert plain TTP header */</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>

		<span class="cm">/* Insert initial credit in frame */</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Connect with IrLMP. No QoS parameters for now */</span>
	<span class="k">return</span> <span class="n">irlmp_connect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">dtsap_sel</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">qos</span><span class="p">,</span>
				     <span class="n">tx_skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_connect_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_connect_confirm (handle, qos, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Service user confirms TSAP connection with peer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_connect_confirm</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_seg_size</span><span class="p">,</span>
				  <span class="n">__u8</span> <span class="n">max_header_size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parameters</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">plen</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span> <span class="o">=</span> <span class="n">max_seg_size</span> <span class="o">-</span> <span class="n">TTP_HEADER</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">max_header_size</span> <span class="o">+</span> <span class="n">TTP_HEADER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if we have got some QoS parameters back! This should be the</span>
<span class="cm">	 *  negotiated QoS for the link.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;IrTTP, Negotiated BAUD_RATE: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;IrTTP, Negotiated BAUD_RATE: %d bps.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">qos</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), Initial send_credit=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="n">parameters</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">TTP_HEADER</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">plen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_extract_all</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
					     <span class="n">IRDA_MIN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plen</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">param_info</span><span class="p">);</span>

		<span class="cm">/* Any errors in the parameter list? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: error extracting parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="cm">/* Do not accept this connection attempt */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Remove parameters */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IRDA_MIN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">plen</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() send=%d,avail=%d,remote=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
	      <span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), MaxSduSize=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_confirm</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">qos</span><span class="p">,</span>
					     <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span><span class="p">,</span>
					     <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_connect_indication (handle, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Some other device is connecting to this TSAP</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_connect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_seg_size</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">max_header_size</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parameters</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">plen</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">lsap</span> <span class="o">=</span> <span class="n">sap</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span> <span class="o">=</span> <span class="n">max_seg_size</span> <span class="o">-</span> <span class="n">TTP_HEADER</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">max_header_size</span><span class="o">+</span><span class="n">TTP_HEADER</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), TSAP sel=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">);</span>

	<span class="cm">/* Need to update dtsap_sel if its equal to LSAP_ANY */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">lsap</span><span class="o">-&gt;</span><span class="n">dlsap_sel</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parameters</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">TTP_HEADER</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">plen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_param_extract_all</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
					     <span class="n">IRDA_MIN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">plen</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">param_info</span><span class="p">);</span>

		<span class="cm">/* Any errors in the parameter list? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: error extracting parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="cm">/* Do not accept this connection attempt */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Remove parameters */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IRDA_MIN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">plen</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">connect_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
						<span class="n">qos</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span><span class="p">,</span>
						<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_header_size</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_connect_response (handle, userdata)</span>
<span class="cm"> *</span>
<span class="cm"> *    Service user is accepting the connection, just pass it down to</span>
<span class="cm"> *    IrLMP!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irttp_connect_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), Source TSAP selector=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">);</span>

	<span class="cm">/* Any userdata supplied? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">,</span>
				   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* Reserve space for MUX_CONTROL and LAP header */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Check that the client has reserved enough space for</span>
<span class="cm">		 *  headers</span>
<span class="cm">		 */</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">userdata</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TTP_MAX_HEADER</span><span class="p">,</span>
			<span class="p">{</span> <span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span> <span class="o">=</span> <span class="n">max_sdu_size</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">initial_credit</span><span class="p">;</span>

	<span class="cm">/* Frame has only space for max 127 credits (7 bits) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">127</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="cm">/* SAR enabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_sdu_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">TTP_MAX_HEADER</span> <span class="o">+</span> <span class="n">TTP_SAR_HEADER</span><span class="p">),</span>
			<span class="p">{</span> <span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">);</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>

		<span class="cm">/* Insert TTP header with SAR parameters */</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="o">+</span><span class="n">TTP_SAR_HEADER</span><span class="p">);</span>

		<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TTP_PARAMETERS</span> <span class="o">|</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span> <span class="cm">/* Length */</span>

		<span class="cm">/* irda_param_insert(self, IRTTP_MAX_SDU_SIZE, frame+1,  */</span>
<span class="cm">/*				  TTP_SAR_HEADER, &amp;param_info) */</span>

		<span class="n">frame</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* MaxSduSize */</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span> <span class="cm">/* Value length */</span>

		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_be16</span><span class="p">((</span><span class="n">__u16</span><span class="p">)</span> <span class="n">max_sdu_size</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)(</span><span class="n">frame</span><span class="o">+</span><span class="mi">4</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Insert TTP header */</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>

		<span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">irlmp_connect_response</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">tx_skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_connect_response</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_dup (self, instance)</span>
<span class="cm"> *</span>
<span class="cm"> *    Duplicate TSAP, can be used by servers to confirm a connection on a</span>
<span class="cm"> *    new TSAP so it can keep listening on the old one.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="nf">irttp_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Protect our access to the old tsap instance */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Find the old instance */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashbin_find</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">orig</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unable to find TSAP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a new instance */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unable to kmalloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t need the old instance any more */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Try to dup the LSAP (may fail if we were too slow) */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">irlmp_dup</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), dup failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Not everything should be copied */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="cm">/* Initialize internal objects */</span>
	<span class="n">irttp_init_tsap</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="cm">/* This is locked */</span>
	<span class="n">hashbin_insert</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">,</span> <span class="p">(</span><span class="n">irda_queue_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">new</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">new</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_dup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_disconnect_request (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Close this connection please! If priority is high, the queued data</span>
<span class="cm"> *    segments, if any, will be deallocated first</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irttp_disconnect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Already disconnected? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), already disconnected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disconnect already pending ?</span>
<span class="cm">	 * We need to use an atomic operation to prevent reentry. This</span>
<span class="cm">	 * function may be called from various context, like user, timer</span>
<span class="cm">	 * for following a disconnect_indication() (i.e. net_bh).</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pend</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), disconnect already pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">userdata</span><span class="p">);</span>

		<span class="cm">/* Try to make some progress */</span>
		<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check if there is still data segments in the transmit queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priority</span> <span class="o">==</span> <span class="n">P_HIGH</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  No need to send the queued data, if we are</span>
<span class="cm">			 *  disconnecting right now since the data will</span>
<span class="cm">			 *  not have any usable connection to be sent on</span>
<span class="cm">			 */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): High priority!!()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irttp_flush_queues</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priority</span> <span class="o">==</span> <span class="n">P_NORMAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Must delay disconnect until after all data segments</span>
<span class="cm">			 *  have been sent and the tx_queue is empty</span>
<span class="cm">			 */</span>
			<span class="cm">/* We&#39;ll reuse this one later for the disconnect */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_skb</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>  <span class="cm">/* May be NULL */</span>

			<span class="n">irttp_run_tx_queue</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="n">irttp_start_todo_timer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Note : we don&#39;t need to check if self-&gt;rx_queue is full and the</span>
<span class="cm">	 * state of self-&gt;rx_sdu_busy because the disconnect response will</span>
<span class="cm">	 * be sent at the LMP level (so even if the peer has its Tx queue</span>
<span class="cm">	 * full of data). - Jean II */</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Disconnecting ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">userdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
		<span class="n">tx_skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">LMP_MAX_HEADER</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_skb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Reserve space for MUX and LAP header</span>
<span class="cm">		 */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">LMP_MAX_HEADER</span><span class="p">);</span>

		<span class="n">userdata</span> <span class="o">=</span> <span class="n">tx_skb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">irlmp_disconnect_request</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>

	<span class="cm">/* The disconnect is no longer pending */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">disconnect_pend</span><span class="p">);</span>	<span class="cm">/* FALSE */</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irttp_disconnect_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_disconnect_indication (self, reason)</span>
<span class="cm"> *</span>
<span class="cm"> *    Disconnect indication, TSAP disconnected by peer?</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_disconnect_indication</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
		<span class="n">LM_REASON</span> <span class="n">reason</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">TTP_TSAP_MAGIC</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Prevent higher layer to send more data */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="cm">/* Check if client has already tried to close the TSAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_pend</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In this case, the higher layer is probably gone. Don&#39;t</span>
<span class="cm">		 * bother it and clean up the remains - Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">irttp_close_tsap</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we are here, we assume that is the higher layer is still</span>
<span class="cm">	 * waiting for the disconnect notification and able to process it,</span>
<span class="cm">	 * even if he tried to disconnect. Otherwise, it would have already</span>
<span class="cm">	 * attempted to close the tsap and self-&gt;close_pend would be TRUE.</span>
<span class="cm">	 * Jean II */</span>

	<span class="cm">/* No need to notify the client if has already tried to disconnect */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">disconnect_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span>
						   <span class="n">reason</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_do_data_indication (self, skb)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to deliver reassembled skb to layer above, and requeue it if that</span>
<span class="cm"> *    for some reason should fail. We mark rx sdu as busy to apply back</span>
<span class="cm"> *    pressure is necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_do_data_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Check if client has already closed the TSAP and gone away */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">close_pend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">data_indication</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Usually the layer above will notify that it&#39;s input queue is</span>
<span class="cm">	 * starting to get filled by using the flow request, but this may</span>
<span class="cm">	 * be difficult, so it can instead just refuse to eat it and just</span>
<span class="cm">	 * give an error back</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() requeueing skb!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* Make sure we take a break */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

		<span class="cm">/* Need to push the header in again */</span>
		<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* Make sure MORE bit is cleared */</span>

		<span class="cm">/* Put skb back on queue */</span>
		<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irttp_run_rx_queue (self)</span>
<span class="cm"> *</span>
<span class="cm"> *     Check if we have any frames to be transmitted, or if we have any</span>
<span class="cm"> *     available credit to give away.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_run_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() send=%d,avail=%d,remote=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span><span class="p">);</span>

	<span class="cm">/* Get exclusive access to the rx queue, otherwise don&#39;t touch it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irda_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue_lock</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Reassemble all frames in receive queue and deliver them</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* This bit will tell us if it&#39;s the last fragment or not */</span>
		<span class="n">more</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">;</span>

		<span class="cm">/* Remove TTP header */</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TTP_HEADER</span><span class="p">);</span>

		<span class="cm">/* Add the length of the remaining data */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If SAR is disabled, or user has requested no reassembly</span>
<span class="cm">		 * of received fragments then we just deliver them</span>
<span class="cm">		 * immediately. This can be requested by clients that</span>
<span class="cm">		 * implements byte streams without any message boundaries</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span> <span class="o">==</span> <span class="n">TTP_SAR_DISABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irttp_do_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check if this is a fragment, and not the last fragment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">more</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Queue the fragment if we still are within the</span>
<span class="cm">			 *  limits of the maximum size of the rx_sdu</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), queueing frag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">__func__</span><span class="p">);</span>
				<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Free the part of the SDU that is too big */</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  This is the last fragment, so time to reassemble!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span> <span class="o">==</span> <span class="n">TTP_SAR_UNBOUND</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * A little optimizing. Only queue the fragment if</span>
<span class="cm">			 * there are other fragments. Since if this is the</span>
<span class="cm">			 * last and only fragment, there is no need to</span>
<span class="cm">			 * reassemble :-)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">,</span>
					       <span class="n">skb</span><span class="p">);</span>

				<span class="n">skb</span> <span class="o">=</span> <span class="n">irttp_reassemble_skb</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Now we can deliver the reassembled skb */</span>
			<span class="n">irttp_do_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Truncated frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="cm">/* Free the part of the SDU that is too big */</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="cm">/* Deliver only the valid but truncated part of SDU */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">irttp_reassemble_skb</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

			<span class="n">irttp_do_data_indication</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s not trivial to keep track of how many credits are available</span>
<span class="cm">	 * by incrementing at each packet, because delivery may fail</span>
<span class="cm">	 * (irttp_do_data_indication() may requeue the frame) and because</span>
<span class="cm">	 * we need to take care of fragmentation.</span>
<span class="cm">	 * We want the other side to send up to initial_credit packets.</span>
<span class="cm">	 * We have some frames in our queues, and we have already allowed it</span>
<span class="cm">	 * to send remote_credit.</span>
<span class="cm">	 * No need to spinlock, write is atomic and self correcting...</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">initial_credit</span> <span class="o">-</span>
			      <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">+</span>
			       <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">)</span> <span class="o">+</span>
			       <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_fragments</span><span class="p">)));</span>

	<span class="cm">/* Do we have too much credits to send to peer ? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span> <span class="o">&lt;=</span> <span class="n">TTP_RX_MIN_CREDIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Send explicit credit frame */</span>
		<span class="n">irttp_give_credit</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="cm">/* Note : do *NOT* check if tx_queue is non-empty, that</span>
<span class="cm">		 * will produce deadlocks. I repeat : send a credit frame</span>
<span class="cm">		 * even if we have something to send in our Tx queue.</span>
<span class="cm">		 * If we have credits, it means that our Tx queue is blocked.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Let&#39;s suppose the peer can&#39;t keep up with our Tx. He will</span>
<span class="cm">		 * flow control us by not sending us any credits, and we</span>
<span class="cm">		 * will stop Tx and start accumulating credits here.</span>
<span class="cm">		 * Up to the point where the peer will stop its Tx queue,</span>
<span class="cm">		 * for lack of credits.</span>
<span class="cm">		 * Let&#39;s assume the peer application is single threaded.</span>
<span class="cm">		 * It will block on Tx and never consume any Rx buffer.</span>
<span class="cm">		 * Deadlock. Guaranteed. - Jean II</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/* Reset lock */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">struct</span> <span class="n">irttp_iter_state</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irttp_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irttp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="cm">/* Protect our access to the tsap list */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_first</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">);</span>
	     <span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irttp_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irttp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashbin_get_next</span><span class="p">(</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irttp_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irttp</span><span class="o">-&gt;</span><span class="n">tsaps</span><span class="o">-&gt;</span><span class="n">hb_spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irttp_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">irttp_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;TSAP %d, &quot;</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;stsap_sel: %02x, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">stsap_sel</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;dtsap_sel: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  connected: %s, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">connected</span><span class="o">?</span> <span class="s">&quot;TRUE&quot;</span><span class="o">:</span><span class="s">&quot;FALSE&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;avail credit: %d, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">avail_credit</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;remote credit: %d, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">remote_credit</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;send credit: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">send_credit</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  tx packets: %lu, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;rx packets: %lu, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;tx_queue len: %u &quot;</span><span class="p">,</span>
		   <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;rx_queue len: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  tx_sdu_busy: %s, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_sdu_busy</span><span class="o">?</span> <span class="s">&quot;TRUE&quot;</span><span class="o">:</span><span class="s">&quot;FALSE&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;rx_sdu_busy: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_sdu_busy</span><span class="o">?</span> <span class="s">&quot;TRUE&quot;</span><span class="o">:</span><span class="s">&quot;FALSE&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  max_seg_size: %u, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;tx_max_sdu_size: %u, &quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_max_sdu_size</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;rx_max_sdu_size: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_max_sdu_size</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  Used by (%s)</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">irttp_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">irttp_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">irttp_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">irttp_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">irttp_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irttp_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irttp_seq_ops</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irttp_iter_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">irttp_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">irttp_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
