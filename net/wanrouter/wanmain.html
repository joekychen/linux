<!DOCTYPE html>
<html><head><title>joekychen/linux » net › wanrouter › wanmain.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>wanmain.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm">* wanmain.c	WAN Multiprotocol Router Module. Main code.</span>
<span class="cm">*</span>
<span class="cm">*		This module is completely hardware-independent and provides</span>
<span class="cm">*		the following common services for the WAN Link Drivers:</span>
<span class="cm">*		 o WAN device management (registering, unregistering)</span>
<span class="cm">*		 o Network interface management</span>
<span class="cm">*		 o Physical connection management (dial-up, incoming calls)</span>
<span class="cm">*		 o Logical connection management (switched virtual circuits)</span>
<span class="cm">*		 o Protocol encapsulation/decapsulation</span>
<span class="cm">*</span>
<span class="cm">* Author:	Gideon Hack</span>
<span class="cm">*</span>
<span class="cm">* Copyright:	(c) 1995-1999 Sangoma Technologies Inc.</span>
<span class="cm">*</span>
<span class="cm">*		This program is free software; you can redistribute it and/or</span>
<span class="cm">*		modify it under the terms of the GNU General Public License</span>
<span class="cm">*		as published by the Free Software Foundation; either version</span>
<span class="cm">*		2 of the License, or (at your option) any later version.</span>
<span class="cm">* ============================================================================</span>
<span class="cm">* Nov 24, 2000  Nenad Corbic	Updated for 2.4.X kernels</span>
<span class="cm">* Nov 07, 2000  Nenad Corbic	Fixed the Mulit-Port PPP for kernels 2.2.16 and</span>
<span class="cm">*  				greater.</span>
<span class="cm">* Aug 2,  2000  Nenad Corbic	Block the Multi-Port PPP from running on</span>
<span class="cm">*  			        kernels 2.2.16 or greater.  The SyncPPP</span>
<span class="cm">*  			        has changed.</span>
<span class="cm">* Jul 13, 2000  Nenad Corbic	Added SyncPPP support</span>
<span class="cm">* 				Added extra debugging in device_setup().</span>
<span class="cm">* Oct 01, 1999  Gideon Hack     Update for s514 PCI card</span>
<span class="cm">* Dec 27, 1996	Gene Kozin	Initial version (based on Sangoma&#39;s WANPIPE)</span>
<span class="cm">* Jan 16, 1997	Gene Kozin	router_devlist made public</span>
<span class="cm">* Jan 31, 1997  Alan Cox	Hacked it about a bit for 2.1</span>
<span class="cm">* Jun 27, 1997  Alan Cox	realigned with vendor code</span>
<span class="cm">* Oct 15, 1997  Farhan Thawar   changed wan_encapsulate to add a pad byte of 0</span>
<span class="cm">* Apr 20, 1998	Alan Cox	Fixed 2.1 symbols</span>
<span class="cm">* May 17, 1998  K. Baranowski	Fixed SNAP encapsulation in wan_encapsulate</span>
<span class="cm">* Dec 15, 1998  Arnaldo Melo    support for firmwares of up to 128000 bytes</span>
<span class="cm">*                               check wandev-&gt;setup return value</span>
<span class="cm">* Dec 22, 1998  Arnaldo Melo    vmalloc/vfree used in device_setup to allocate</span>
<span class="cm">*                               kernel memory and copy configuration data to</span>
<span class="cm">*                               kernel space (for big firmwares)</span>
<span class="cm">* Jun 02, 1999  Gideon Hack	Updates for Linux 2.0.X and 2.2.X kernels.</span>
<span class="cm">*****************************************************************************/</span>

<span class="cp">#include &lt;linux/stddef.h&gt;	</span><span class="cm">/* offsetof(), etc. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;	</span><span class="cm">/* return codes */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;	</span><span class="cm">/* support for loadable modules */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;		</span><span class="cm">/* kmalloc(), kfree() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;	</span><span class="cm">/* inline mem*, str* functions */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/byteorder.h&gt;	</span><span class="cm">/* htons(), etc. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/wanrouter.h&gt;	</span><span class="cm">/* WAN router API definitions */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/vmalloc.h&gt;	</span><span class="cm">/* vmalloc, vfree */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/uaccess.h&gt;        </span><span class="cm">/* copy_to/from_user */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/init.h&gt;         </span><span class="cm">/* __initfunc et al. */</span><span class="cp"></span>

<span class="cp">#define DEV_TO_SLAVE(dev)	(*((struct net_device **)netdev_priv(dev)))</span>

<span class="cm">/*</span>
<span class="cm"> * 	Function Prototypes</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	WAN device IOCTL handlers</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">wanrouter_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wanrouter_device_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				  <span class="n">wandev_conf_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wanrouter_device_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				 <span class="n">wandev_stat_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_stat</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wanrouter_device_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wanrouter_device_new_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				   <span class="n">wanif_conf_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wanrouter_device_del_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_name</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Miscellaneous</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wanrouter_find_device</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wanrouter_delete_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lock_adapter_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">smp_flags</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">unlock_adapter_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">smp_flags</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>



<span class="cm">/*</span>
<span class="cm"> *	Global Data</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">wanrouter_fullname</span><span class="p">[]</span>  <span class="o">=</span> <span class="s">&quot;Sangoma WANPIPE Router&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">wanrouter_copyright</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;(c) 1995-2000 Sangoma Technologies Inc.&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">wanrouter_modname</span><span class="p">[]</span> <span class="o">=</span> <span class="n">ROUTER_NAME</span><span class="p">;</span> <span class="cm">/* short module name */</span>
<span class="k">struct</span> <span class="n">wan_device</span><span class="o">*</span> <span class="n">wanrouter_router_devlist</span><span class="p">;</span> <span class="cm">/* list of registered devices */</span>

<span class="cm">/*</span>
<span class="cm"> *	Organize Unique Identifiers for encapsulation/decapsulation</span>
<span class="cm"> */</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static unsigned char wanrouter_oui_ether[] = { 0x00, 0x00, 0x00 };</span>
<span class="c">static unsigned char wanrouter_oui_802_2[] = { 0x00, 0x80, 0xC2 };</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">wanrouter_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s v%u.%u %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">wanrouter_fullname</span><span class="p">,</span> <span class="n">ROUTER_VERSION</span><span class="p">,</span> <span class="n">ROUTER_RELEASE</span><span class="p">,</span>
	       <span class="n">wanrouter_copyright</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_proc_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: can&#39;t create entry in proc filesystem!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">wanrouter_modname</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">wanrouter_cleanup</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wanrouter_proc_cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is just plain dumb.  We should move the bugger to drivers/net/wan,</span>
<span class="cm"> * slap it first in directory and make it module_init().  The only reason</span>
<span class="cm"> * for subsys_initcall() here is that net goes after drivers (why, BTW?)</span>
<span class="cm"> */</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">wanrouter_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">wanrouter_cleanup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * 	Kernel APIs</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 	Register WAN device.</span>
<span class="cm"> * 	o verify device credentials</span>
<span class="cm"> * 	o create an entry for the device in the /proc/net/router directory</span>
<span class="cm"> * 	o initialize internally maintained fields of the wan_device structure</span>
<span class="cm"> * 	o link device data space to a singly-linked list</span>
<span class="cm"> * 	o if it&#39;s the first device, then start kernel &#39;thread&#39;</span>
<span class="cm"> * 	o increment module use count</span>
<span class="cm"> *</span>
<span class="cm"> * 	Return:</span>
<span class="cm"> *	0	Ok</span>
<span class="cm"> *	&lt; 0	error.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Context:	process</span>
<span class="cm"> */</span>


<span class="kt">int</span> <span class="nf">register_wan_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">wandev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ROUTER_MAGIC</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">namelen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">namelen</span> <span class="o">||</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">WAN_DRVNAME_SZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wanrouter_find_device</span><span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

<span class="cp">#ifdef WANDEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: registering WAN device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">wanrouter_modname</span><span class="p">,</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Register /proc directory entry</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_proc_add</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;%s: can&#39;t create /proc/net/router/%s entry!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">wanrouter_modname</span><span class="p">,</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Initialize fields of the wan_device structure maintained by the</span>
<span class="cm">	 *	router and update local data.</span>
<span class="cm">	 */</span>

	<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">wanrouter_router_devlist</span><span class="p">;</span>
	<span class="n">wanrouter_router_devlist</span> <span class="o">=</span> <span class="n">wandev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Unregister WAN device.</span>
<span class="cm"> *	o shut down device</span>
<span class="cm"> *	o unlink device data space from the linked list</span>
<span class="cm"> *	o delete device entry in the /proc/net/router directory</span>
<span class="cm"> *	o decrement module use count</span>
<span class="cm"> *</span>
<span class="cm"> *	Return:		0	Ok</span>
<span class="cm"> *			&lt;0	error.</span>
<span class="cm"> *	Context:	process</span>
<span class="cm"> */</span>


<span class="kt">int</span> <span class="nf">unregister_wan_device</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">wandev</span> <span class="o">=</span> <span class="n">wanrouter_router_devlist</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">wandev</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">wandev</span><span class="p">,</span> <span class="n">wandev</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="cp">#ifdef WANDEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: unregistering WAN device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">wanrouter_modname</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">WAN_UNCONFIGURED</span><span class="p">)</span>
		<span class="n">wanrouter_device_shutdown</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wanrouter_router_devlist</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="n">wanrouter_proc_delete</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>

<span class="c">/*</span>
<span class="c"> *	Encapsulate packet.</span>
<span class="c"> *</span>
<span class="c"> *	Return:	encapsulation header size</span>
<span class="c"> *		&lt; 0	- unsupported Ethertype</span>
<span class="c"> *</span>
<span class="c"> *	Notes:</span>
<span class="c"> *	1. This function may be called on interrupt context.</span>
<span class="c"> */</span>


<span class="c">int wanrouter_encapsulate(struct sk_buff *skb, struct net_device *dev,</span>
<span class="c">			  unsigned short type)</span>
<span class="c">{</span>
<span class="c">	int hdr_len = 0;</span>

<span class="c">	switch (type) {</span>
<span class="c">	case ETH_P_IP:		/* IP datagram encapsulation */</span>
<span class="c">		hdr_len += 1;</span>
<span class="c">		skb_push(skb, 1);</span>
<span class="c">		skb-&gt;data[0] = NLPID_IP;</span>
<span class="c">		break;</span>

<span class="c">	case ETH_P_IPX:		/* SNAP encapsulation */</span>
<span class="c">	case ETH_P_ARP:</span>
<span class="c">		hdr_len += 7;</span>
<span class="c">		skb_push(skb, 7);</span>
<span class="c">		skb-&gt;data[0] = 0;</span>
<span class="c">		skb-&gt;data[1] = NLPID_SNAP;</span>
<span class="c">		skb_copy_to_linear_data_offset(skb, 2, wanrouter_oui_ether,</span>
<span class="c">					       sizeof(wanrouter_oui_ether));</span>
<span class="c">		*((unsigned short*)&amp;skb-&gt;data[5]) = htons(type);</span>
<span class="c">		break;</span>

<span class="c">	default:		/* Unknown packet type */</span>
<span class="c">		printk(KERN_INFO</span>
<span class="c">			&quot;%s: unsupported Ethertype 0x%04X on interface %s!\n&quot;,</span>
<span class="c">			wanrouter_modname, type, dev-&gt;name);</span>
<span class="c">		hdr_len = -EINVAL;</span>
<span class="c">	}</span>
<span class="c">	return hdr_len;</span>
<span class="c">}</span>


<span class="c">/*</span>
<span class="c"> *	Decapsulate packet.</span>
<span class="c"> *</span>
<span class="c"> *	Return:	Ethertype (in network order)</span>
<span class="c"> *			0	unknown encapsulation</span>
<span class="c"> *</span>
<span class="c"> *	Notes:</span>
<span class="c"> *	1. This function may be called on interrupt context.</span>
<span class="c"> */</span>


<span class="c">__be16 wanrouter_type_trans(struct sk_buff *skb, struct net_device *dev)</span>
<span class="c">{</span>
<span class="c">	int cnt = skb-&gt;data[0] ? 0 : 1;	/* there may be a pad present */</span>
<span class="c">	__be16 ethertype;</span>

<span class="c">	switch (skb-&gt;data[cnt]) {</span>
<span class="c">	case NLPID_IP:		/* IP datagramm */</span>
<span class="c">		ethertype = htons(ETH_P_IP);</span>
<span class="c">		cnt += 1;</span>
<span class="c">		break;</span>

<span class="c">	case NLPID_SNAP:	/* SNAP encapsulation */</span>
<span class="c">		if (memcmp(&amp;skb-&gt;data[cnt + 1], wanrouter_oui_ether,</span>
<span class="c">			   sizeof(wanrouter_oui_ether))){</span>
<span class="c">			printk(KERN_INFO</span>
<span class="c">				&quot;%s: unsupported SNAP OUI %02X-%02X-%02X &quot;</span>
<span class="c">				&quot;on interface %s!\n&quot;, wanrouter_modname,</span>
<span class="c">				skb-&gt;data[cnt+1], skb-&gt;data[cnt+2],</span>
<span class="c">				skb-&gt;data[cnt+3], dev-&gt;name);</span>
<span class="c">			return 0;</span>
<span class="c">		}</span>
<span class="c">		ethertype = *((__be16*)&amp;skb-&gt;data[cnt+4]);</span>
<span class="c">		cnt += 6;</span>
<span class="c">		break;</span>

<span class="c">	/* add other protocols, e.g. CLNP, ESIS, ISIS, if needed */</span>

<span class="c">	default:</span>
<span class="c">		printk(KERN_INFO</span>
<span class="c">			&quot;%s: unsupported NLPID 0x%02X on interface %s!\n&quot;,</span>
<span class="c">			wanrouter_modname, skb-&gt;data[cnt], dev-&gt;name);</span>
<span class="c">		return 0;</span>
<span class="c">	}</span>
<span class="c">	skb-&gt;protocol = ethertype;</span>
<span class="c">	skb-&gt;pkt_type = PACKET_HOST;	/*	Physically point to point */</span>
<span class="c">	skb_pull(skb, cnt);</span>
<span class="c">	skb_reset_mac_header(skb);</span>
<span class="c">	return ethertype;</span>
<span class="c">}</span>

<span class="cp">#endif  /*  0  */</span>

<span class="cm">/*</span>
<span class="cm"> *	WAN device IOCTL.</span>
<span class="cm"> *	o find WAN device associated with this node</span>
<span class="cm"> *	o execute requested action or pass command to the device driver</span>
<span class="cm"> */</span>

<span class="kt">long</span> <span class="nf">wanrouter_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ROUTER_IOCTL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">wandev</span> <span class="o">=</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ROUTER_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wanrouter_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ROUTER_SETUP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_device_setup</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ROUTER_DOWN</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_device_shutdown</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ROUTER_STAT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_device_stat</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ROUTER_IFNEW</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_device_new_if</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ROUTER_IFDEL</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_device_del_if</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ROUTER_IFSTAT</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">ROUTER_USER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cmd</span> <span class="o">&lt;=</span> <span class="n">ROUTER_USER_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">else</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wanrouter_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	WAN Driver IOCTL Handlers</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Setup WAN link device.</span>
<span class="cm"> *	o verify user address space</span>
<span class="cm"> *	o allocate kernel memory and copy configuration data to kernel space</span>
<span class="cm"> *	o if configuration data includes extension, copy it to kernel space too</span>
<span class="cm"> *	o call driver&#39;s setup() entry point</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wanrouter_device_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				  <span class="n">wandev_conf_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wandev_conf_t</span> <span class="o">*</span><span class="n">conf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Nothing to do ? */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: ERROR, No setup script: wandev-&gt;setup()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">conf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">wandev_conf_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: ERROR, Failed to allocate kernel memory !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">u_conf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wandev_conf_t</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Failed to copy user config data to kernel space!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ROUTER_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: ERROR, Invalid MAGIC Number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">&amp;&amp;</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">&gt;</span> <span class="mi">128000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			    <span class="s">&quot;%s: ERROR, Invalid firmware data size %i !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;%s: ERROR, Failed allocate kernel memory !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">conf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			     <span class="s">&quot;%s: ERROR, Failed to copy from user data !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		    <span class="s">&quot;%s: ERROR, No firmware found ! Firmware size = %i !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Shutdown WAN device.</span>
<span class="cm"> *	o delete all not opened logical channels for this device</span>
<span class="cm"> *	o call driver&#39;s shutdown() entry point</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wanrouter_device_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">WAN_UNCONFIGURED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%s: Shutting Down!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span> <span class="n">dev</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_delete_interface</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="cm">/* The above function deallocates the current dev</span>
<span class="cm">		 * structure. Therefore, we cannot use netdev_priv(dev)</span>
<span class="cm">		 * as the next element: wandev-&gt;dev points to the</span>
<span class="cm">		 * next element */</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>	<span class="cm">/* there are opened interfaces  */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">err</span><span class="o">=</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get WAN device status &amp; statistics.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wanrouter_device_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				 <span class="n">wandev_stat_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wandev_stat_t</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stat</span><span class="p">));</span>

	<span class="cm">/* Ask device driver to update device statistics */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">WAN_UNCONFIGURED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span>
		<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>

	<span class="cm">/* Fill out structure */</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">ndev</span>  <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">u_stat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stat</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Create new WAN interface.</span>
<span class="cm"> *	o verify user address space</span>
<span class="cm"> *	o copy configuration data to kernel address space</span>
<span class="cm"> *	o allocate network interface data space</span>
<span class="cm"> *	o call driver&#39;s new_if() entry point</span>
<span class="cm"> *	o make sure there is no interface name conflict</span>
<span class="cm"> *	o register network interface</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wanrouter_device_new_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span>
				   <span class="n">wanif_conf_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wanif_conf_t</span> <span class="o">*</span><span class="n">cnf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">WAN_UNCONFIGURED</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">new_if</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">cnf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">wanif_conf_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">cnf</span><span class="p">,</span> <span class="n">u_conf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wanif_conf_t</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ROUTER_MAGIC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnf</span><span class="o">-&gt;</span><span class="n">config_id</span> <span class="o">==</span> <span class="n">WANCONFIG_MPPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Wanpipe Mulit-Port PPP support has not been compiled in!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">new_if</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">cnf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Register network interface. This will invoke init()</span>
<span class="cm">		 * function supplied by the driver.  If device registered</span>
<span class="cm">		 * successfully, add it to the interface list.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="cp">#ifdef WANDEBUG</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: registering interface %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wanrouter_modname</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="cp">#endif</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smp_flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

				<span class="n">lock_adapter_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_flags</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">slave</span><span class="o">=</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
					     <span class="n">DEV_TO_SLAVE</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
					     <span class="n">slave</span> <span class="o">=</span> <span class="n">DEV_TO_SLAVE</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span>
						<span class="n">DEV_TO_SLAVE</span><span class="p">(</span><span class="n">slave</span><span class="p">)</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="o">++</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>

				<span class="n">unlock_adapter_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_flags</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* done !!! */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">del_if</span><span class="p">)</span>
			<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">del_if</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cnf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	Delete WAN logical channel.</span>
<span class="cm"> *	 o verify user address space</span>
<span class="cm"> *	 o copy configuration data to kernel address space</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wanrouter_device_del_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">WAN_IFNAME_SZ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">WAN_UNCONFIGURED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">u_name</span><span class="p">,</span> <span class="n">WAN_IFNAME_SZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">wanrouter_delete_interface</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If last interface being deleted, shutdown card</span>
<span class="cm">	 * This helps with administration at leaf nodes</span>
<span class="cm">	 * (You can tell if the person at the other end of the phone</span>
<span class="cm">	 * has an interface configured) and avoids DoS vulnerabilities</span>
<span class="cm">	 * in binary driver files - this fixes a problem with the current</span>
<span class="cm">	 * Sangoma driver going into strange states when all the network</span>
<span class="cm">	 * interfaces are deleted and the link irrecoverably disconnected.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">&amp;&amp;</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">wandev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Miscellaneous Functions</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Find WAN device by name.</span>
<span class="cm"> *	Return pointer to the WAN device data space or NULL if device not found.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="nf">wanrouter_find_device</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">wandev</span> <span class="o">=</span> <span class="n">wanrouter_router_devlist</span><span class="p">;</span>
	     <span class="n">wandev</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">wandev</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wandev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Delete WAN logical channel identified by its name.</span>
<span class="cm"> *	o find logical channel by its name</span>
<span class="cm"> *	o call driver&#39;s del_if() entry point</span>
<span class="cm"> *	o unregister network interface</span>
<span class="cm"> *	o unlink channel data space from linked list of channels</span>
<span class="cm"> *	o release channel data space</span>
<span class="cm"> *</span>
<span class="cm"> *	Return:	0		success</span>
<span class="cm"> *		-ENODEV		channel not found.</span>
<span class="cm"> *		-EBUSY		interface is open</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: If (force != 0), then device will be destroyed even if interface</span>
<span class="cm"> *	associated with it is open. It&#39;s caller&#39;s responsibility to make</span>
<span class="cm"> *	sure that opened interfaces are not removed!</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wanrouter_delete_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">wan_device</span> <span class="o">*</span><span class="n">wandev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smp_flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_adapter_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_flags</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">slave</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_adapter_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>	<span class="cm">/* interface not found */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>	<span class="cm">/* interface in use */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">del_if</span><span class="p">)</span>
		<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">del_if</span><span class="p">(</span><span class="n">wandev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">lock_adapter_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">prev_slave</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">slave</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="o">*</span><span class="n">prev_slave</span> <span class="o">=</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">slave</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">wandev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">--</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">;</span>
	<span class="n">unlock_adapter_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wandev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_flags</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: unregistering &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wandev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_adapter_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">smp_flags</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">smp_flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlock_adapter_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">smp_flags</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">smp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_wan_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_wan_device</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	End</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
