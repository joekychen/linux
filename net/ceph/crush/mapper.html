<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ceph › crush › mapper.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mapper.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifdef __KERNEL__</span>
<span class="cp"># include &lt;linux/string.h&gt;</span>
<span class="cp"># include &lt;linux/slab.h&gt;</span>
<span class="cp"># include &lt;linux/bug.h&gt;</span>
<span class="cp"># include &lt;linux/kernel.h&gt;</span>
<span class="cp"># ifndef dprintk</span>
<span class="cp">#  define dprintk(args...)</span>
<span class="cp"># endif</span>
<span class="cp">#else</span>
<span class="cp"># include &lt;string.h&gt;</span>
<span class="cp"># include &lt;stdio.h&gt;</span>
<span class="cp"># include &lt;stdlib.h&gt;</span>
<span class="cp"># include &lt;assert.h&gt;</span>
<span class="cp"># define BUG_ON(x) assert(!(x))</span>
<span class="cp"># define dprintk(args...) </span><span class="cm">/* printf(args) */</span><span class="cp"></span>
<span class="cp"># define kmalloc(x, f) malloc(x)</span>
<span class="cp"># define kfree(x) free(x)</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/crush/crush.h&gt;</span>
<span class="cp">#include &lt;linux/crush/hash.h&gt;</span>
<span class="cp">#include &lt;linux/crush/mapper.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Implement the core CRUSH mapping algorithm.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * crush_find_rule - find a crush_rule id for a given ruleset, type, and size.</span>
<span class="cm"> * @map: the crush_map</span>
<span class="cm"> * @ruleset: the storage ruleset id (user defined)</span>
<span class="cm"> * @type: storage ruleset type (user defined)</span>
<span class="cm"> * @size: output set size</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">crush_find_rule</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">crush_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ruleset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">max_rules</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">map</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">ruleset</span> <span class="o">==</span> <span class="n">ruleset</span> <span class="o">&amp;&amp;</span>
		    <span class="n">map</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
		    <span class="n">map</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">min_size</span> <span class="o">&lt;=</span> <span class="n">size</span> <span class="o">&amp;&amp;</span>
		    <span class="n">map</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">max_size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * bucket choose methods</span>
<span class="cm"> *</span>
<span class="cm"> * For each bucket algorithm, we have a &quot;choose&quot; method that, given a</span>
<span class="cm"> * crush input @x and replica position (usually, position in output set) @r,</span>
<span class="cm"> * will produce an item in the bucket.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Choose based on a random permutation of the bucket.</span>
<span class="cm"> *</span>
<span class="cm"> * We used to use some prime number arithmetic to do this, but it</span>
<span class="cm"> * wasn&#39;t very random, and had some other bad behaviors.  Instead, we</span>
<span class="cm"> * calculate an actual random permutation of the bucket members.</span>
<span class="cm"> * Since this is expensive, we optimize for the r=0 case, which</span>
<span class="cm"> * captures the vast majority of calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bucket_perm_choose</span><span class="p">(</span><span class="k">struct</span> <span class="n">crush_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>

	<span class="cm">/* start a new permutation if @x has changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_x</span> <span class="o">!=</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)</span><span class="n">x</span> <span class="o">||</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;bucket %d new x=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

		<span class="cm">/* optimize common r=0 case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">crush_hash32_3</span><span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">%</span>
				<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>   <span class="cm">/* magic value, see below */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* clean up after the r=0 case above */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* calculate permutation up to pr */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; perm_choose have %d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span> <span class="o">&lt;=</span> <span class="n">pr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span><span class="p">;</span>
		<span class="cm">/* no point in swapping the final entry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">crush_hash32_3</span><span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span>
				<span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
				<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
				<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; perm_choose swap %d with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm_n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; perm_choose  %d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">[</span><span class="n">pr</span><span class="p">];</span>
<span class="nl">out:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; perm_choose %d sz=%d x=%d r=%d (%d) s=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* uniform */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bucket_uniform_choose</span><span class="p">(</span><span class="k">struct</span> <span class="n">crush_bucket_uniform</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bucket_perm_choose</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bucket_list_choose</span><span class="p">(</span><span class="k">struct</span> <span class="n">crush_bucket_list</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u64</span> <span class="n">w</span> <span class="o">=</span> <span class="n">crush_hash32_4</span><span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span><span class="n">x</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					 <span class="n">r</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
		<span class="n">w</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;list_choose i=%d x=%d r=%d item %d weight %x &quot;</span>
			<span class="s">&quot;sw %x rand %llx&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">item_weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">sum_weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="p">);</span>
		<span class="n">w</span> <span class="o">*=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">sum_weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/*dprintk(&quot; scaled %llx\n&quot;, w);*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">item_weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;bad list sums for bucket %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>


<span class="cm">/* (binary) tree */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">height</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">++</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">left</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">right</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">terminal</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bucket_tree_choose</span><span class="p">(</span><span class="k">struct</span> <span class="n">crush_bucket_tree</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">w</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* start at root */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">num_nodes</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">terminal</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* pick point in [0, w) */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">node_weights</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">crush_hash32_4</span><span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span>
					  <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">w</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>

		<span class="cm">/* descend to the left or right? */</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">left</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">node_weights</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">right</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>


<span class="cm">/* straw */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bucket_straw_choose</span><span class="p">(</span><span class="k">struct</span> <span class="n">crush_bucket_straw</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">high_draw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">draw</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">draw</span> <span class="o">=</span> <span class="n">crush_hash32_3</span><span class="p">(</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">draw</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="n">draw</span> <span class="o">*=</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">straws</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">draw</span> <span class="o">&gt;</span> <span class="n">high_draw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">high_draw</span> <span class="o">=</span> <span class="n">draw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bucket</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">high</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">crush_bucket_choose</span><span class="p">(</span><span class="k">struct</span> <span class="n">crush_bucket</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; crush_bucket_choose %d x=%d r=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CRUSH_BUCKET_UNIFORM</span>:
		<span class="k">return</span> <span class="n">bucket_uniform_choose</span><span class="p">((</span><span class="k">struct</span> <span class="n">crush_bucket_uniform</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">,</span>
					  <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CRUSH_BUCKET_LIST</span>:
		<span class="k">return</span> <span class="n">bucket_list_choose</span><span class="p">((</span><span class="k">struct</span> <span class="n">crush_bucket_list</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">,</span>
					  <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CRUSH_BUCKET_TREE</span>:
		<span class="k">return</span> <span class="n">bucket_tree_choose</span><span class="p">((</span><span class="k">struct</span> <span class="n">crush_bucket_tree</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">,</span>
					  <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CRUSH_BUCKET_STRAW</span>:
		<span class="k">return</span> <span class="n">bucket_straw_choose</span><span class="p">((</span><span class="k">struct</span> <span class="n">crush_bucket_straw</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">,</span>
					   <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;unknown bucket %d alg %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">alg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * true if device is marked &quot;out&quot; (failed, fully offloaded)</span>
<span class="cm"> * of the cluster</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_out</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">crush_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x10000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">crush_hash32_2</span><span class="p">(</span><span class="n">CRUSH_HASH_RJENKINS1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span>
	    <span class="o">&lt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * crush_choose - choose numrep distinct items of given type</span>
<span class="cm"> * @map: the crush_map</span>
<span class="cm"> * @bucket: the bucket we are choose an item from</span>
<span class="cm"> * @x: crush input value</span>
<span class="cm"> * @numrep: the number of items to choose</span>
<span class="cm"> * @type: the type of item to choose</span>
<span class="cm"> * @out: pointer to output vector</span>
<span class="cm"> * @outpos: our position in that vector</span>
<span class="cm"> * @firstn: true if choosing &quot;first n&quot; items, false if choosing &quot;indep&quot;</span>
<span class="cm"> * @recurse_to_leaf: true if we want one device under each item of given type</span>
<span class="cm"> * @out2: second output vector for leaf items (if @recurse_to_leaf)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">crush_choose</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">crush_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">crush_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			<span class="k">const</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">weight</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numrep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outpos</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">firstn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">recurse_to_leaf</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">out2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ftotal</span><span class="p">,</span> <span class="n">flocal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry_descent</span><span class="p">,</span> <span class="n">retry_bucket</span><span class="p">,</span> <span class="n">skip_rep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crush_bucket</span> <span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">itemtype</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">collide</span><span class="p">,</span> <span class="n">reject</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig_tries</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="cm">/* attempts before we fall back to search */</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;CHOOSE%s bucket %d x %d outpos %d numrep %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recurse_to_leaf</span> <span class="o">?</span> <span class="s">&quot;_LEAF&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">bucket</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">outpos</span><span class="p">,</span> <span class="n">numrep</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rep</span> <span class="o">=</span> <span class="n">outpos</span><span class="p">;</span> <span class="n">rep</span> <span class="o">&lt;</span> <span class="n">numrep</span><span class="p">;</span> <span class="n">rep</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* keep trying until we get a non-out, non-colliding item */</span>
		<span class="n">ftotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skip_rep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">retry_descent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">in</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">;</span>               <span class="cm">/* initial bucket */</span>

			<span class="cm">/* choose through intervening buckets */</span>
			<span class="n">flocal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">collide</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">retry_bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">alg</span> <span class="o">==</span> <span class="n">CRUSH_BUCKET_UNIFORM</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* be careful */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">firstn</span> <span class="o">||</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)</span><span class="n">numrep</span> <span class="o">&gt;=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
						<span class="cm">/* r&#39; = r + f_total */</span>
						<span class="n">r</span> <span class="o">+=</span> <span class="n">ftotal</span><span class="p">;</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="n">numrep</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="cm">/* r&#39;=r+(n+1)*f_local */</span>
						<span class="n">r</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numrep</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
							<span class="p">(</span><span class="n">flocal</span><span class="o">+</span><span class="n">ftotal</span><span class="p">);</span>
					<span class="k">else</span>
						<span class="cm">/* r&#39; = r + n*f_local */</span>
						<span class="n">r</span> <span class="o">+=</span> <span class="n">numrep</span> <span class="o">*</span> <span class="p">(</span><span class="n">flocal</span><span class="o">+</span><span class="n">ftotal</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">firstn</span><span class="p">)</span>
						<span class="cm">/* r&#39; = r + f_total */</span>
						<span class="n">r</span> <span class="o">+=</span> <span class="n">ftotal</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="cm">/* r&#39; = r + n*f_local */</span>
						<span class="n">r</span> <span class="o">+=</span> <span class="n">numrep</span> <span class="o">*</span> <span class="p">(</span><span class="n">flocal</span><span class="o">+</span><span class="n">ftotal</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/* bucket choose */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reject</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flocal</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">flocal</span> <span class="o">&gt;</span> <span class="n">orig_tries</span><span class="p">)</span>
					<span class="n">item</span> <span class="o">=</span> <span class="n">bucket_perm_choose</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">item</span> <span class="o">=</span> <span class="n">crush_bucket_choose</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">max_devices</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;   bad item %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
					<span class="n">skip_rep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* desired type? */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">itemtype</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">item</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">itemtype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;  item %d type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">itemtype</span><span class="p">);</span>

				<span class="cm">/* keep going? */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">itemtype</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span>
					    <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">max_buckets</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;   bad item type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
						<span class="n">skip_rep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">in</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">item</span><span class="p">];</span>
					<span class="n">retry_bucket</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* collision? */</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">outpos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">collide</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="n">reject</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">recurse_to_leaf</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">crush_choose</span><span class="p">(</span><span class="n">map</span><span class="p">,</span>
							 <span class="n">map</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">item</span><span class="p">],</span>
							 <span class="n">weight</span><span class="p">,</span>
							 <span class="n">x</span><span class="p">,</span> <span class="n">outpos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							 <span class="n">out2</span><span class="p">,</span> <span class="n">outpos</span><span class="p">,</span>
							 <span class="n">firstn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							 <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">outpos</span><span class="p">)</span>
							<span class="cm">/* didn&#39;t get leaf */</span>
							<span class="n">reject</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* we already have a leaf! */</span>
						<span class="n">out2</span><span class="p">[</span><span class="n">outpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reject</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* out? */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">itemtype</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">reject</span> <span class="o">=</span> <span class="n">is_out</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span>
								<span class="n">item</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
					<span class="k">else</span>
						<span class="n">reject</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>

<span class="nl">reject:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reject</span> <span class="o">||</span> <span class="n">collide</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ftotal</span><span class="o">++</span><span class="p">;</span>
					<span class="n">flocal</span><span class="o">++</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">collide</span> <span class="o">&amp;&amp;</span> <span class="n">flocal</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
						<span class="cm">/* retry locally a few times */</span>
						<span class="n">retry_bucket</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flocal</span> <span class="o">&lt;=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">orig_tries</span><span class="p">)</span>
						<span class="cm">/* exhaustive bucket search */</span>
						<span class="n">retry_bucket</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ftotal</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span>
						<span class="cm">/* then retry descent */</span>
						<span class="n">retry_descent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="cm">/* else give up */</span>
						<span class="n">skip_rep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;  reject %d  collide %d  &quot;</span>
						<span class="s">&quot;ftotal %u  flocal %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">reject</span><span class="p">,</span> <span class="n">collide</span><span class="p">,</span> <span class="n">ftotal</span><span class="p">,</span>
						<span class="n">flocal</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retry_bucket</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retry_descent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skip_rep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;skip rep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;CHOOSE got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">out</span><span class="p">[</span><span class="n">outpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
		<span class="n">outpos</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;CHOOSE returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">outpos</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">outpos</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * crush_do_rule - calculate a mapping with the given input and rule</span>
<span class="cm"> * @map: the crush_map</span>
<span class="cm"> * @ruleno: the rule id</span>
<span class="cm"> * @x: hash input</span>
<span class="cm"> * @result: pointer to result vector</span>
<span class="cm"> * @result_max: maximum result size</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">crush_do_rule</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">crush_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">ruleno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result_max</span><span class="p">,</span>
		  <span class="k">const</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">weight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">CRUSH_MAX_SET</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">CRUSH_MAX_SET</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">CRUSH_MAX_SET</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">recurse_to_leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">osize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crush_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">step</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numrep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">firstn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">__u32</span><span class="p">)</span><span class="n">ruleno</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">max_rules</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; bad ruleno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ruleno</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rule</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">[</span><span class="n">ruleno</span><span class="p">];</span>
	<span class="n">result_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">o</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">step</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">crush_rule_step</span> <span class="o">*</span><span class="n">curstep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">steps</span><span class="p">[</span><span class="n">step</span><span class="p">];</span>

		<span class="n">firstn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">curstep</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CRUSH_RULE_TAKE</span>:
			<span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">curstep</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">;</span>
			<span class="n">wsize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">CRUSH_RULE_CHOOSE_LEAF_FIRSTN</span>:
		<span class="k">case</span> <span class="n">CRUSH_RULE_CHOOSE_FIRSTN</span>:
			<span class="n">firstn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">CRUSH_RULE_CHOOSE_LEAF_INDEP</span>:
		<span class="k">case</span> <span class="n">CRUSH_RULE_CHOOSE_INDEP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">wsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">recurse_to_leaf</span> <span class="o">=</span>
				<span class="n">curstep</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span>
				 <span class="n">CRUSH_RULE_CHOOSE_LEAF_FIRSTN</span> <span class="o">||</span>
				<span class="n">curstep</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span>
				<span class="n">CRUSH_RULE_CHOOSE_LEAF_INDEP</span><span class="p">;</span>

			<span class="cm">/* reset output */</span>
			<span class="n">osize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * see CRUSH_N, CRUSH_N_MINUS macros.</span>
<span class="cm">				 * basically, numrep &lt;= 0 means relative to</span>
<span class="cm">				 * the provided result_max</span>
<span class="cm">				 */</span>
				<span class="n">numrep</span> <span class="o">=</span> <span class="n">curstep</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">numrep</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">numrep</span> <span class="o">+=</span> <span class="n">result_max</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">numrep</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">osize</span> <span class="o">+=</span> <span class="n">crush_choose</span><span class="p">(</span><span class="n">map</span><span class="p">,</span>
						      <span class="n">map</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
						      <span class="n">weight</span><span class="p">,</span>
						      <span class="n">x</span><span class="p">,</span> <span class="n">numrep</span><span class="p">,</span>
						      <span class="n">curstep</span><span class="o">-&gt;</span><span class="n">arg2</span><span class="p">,</span>
						      <span class="n">o</span><span class="o">+</span><span class="n">osize</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
						      <span class="n">firstn</span><span class="p">,</span>
						      <span class="n">recurse_to_leaf</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">osize</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">recurse_to_leaf</span><span class="p">)</span>
				<span class="cm">/* copy final _leaf_ values to output set */</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">osize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">));</span>

			<span class="cm">/* swap t and w arrays */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
			<span class="n">o</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">wsize</span> <span class="o">=</span> <span class="n">osize</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>


		<span class="k">case</span> <span class="n">CRUSH_RULE_EMIT</span>:
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wsize</span> <span class="o">&amp;&amp;</span> <span class="n">result_len</span> <span class="o">&lt;</span> <span class="n">result_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span><span class="p">[</span><span class="n">result_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">result_len</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">wsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; unknown op %d at step %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">curstep</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result_len</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
