<!DOCTYPE html>
<html><head><title>joekychen/linux » net › mac80211 › ieee80211_i.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ieee80211_i.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2002-2005, Instant802 Networks, Inc.</span>
<span class="cm"> * Copyright 2005, Devicescape Software, Inc.</span>
<span class="cm"> * Copyright 2006-2007	Jiri Benc &lt;jbenc@suse.cz&gt;</span>
<span class="cm"> * Copyright 2007-2010	Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef IEEE80211_I_H</span>
<span class="cp">#define IEEE80211_I_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;net/ieee80211_radiotap.h&gt;</span>
<span class="cp">#include &lt;net/cfg80211.h&gt;</span>
<span class="cp">#include &lt;net/mac80211.h&gt;</span>
<span class="cp">#include &quot;key.h&quot;</span>
<span class="cp">#include &quot;sta_info.h&quot;</span>

<span class="k">struct</span> <span class="n">ieee80211_local</span><span class="p">;</span>

<span class="cm">/* Maximum number of broadcast/multicast frames to buffer when some of the</span>
<span class="cm"> * associated stations are using power saving. */</span>
<span class="cp">#define AP_MAX_BC_BUFFER 128</span>

<span class="cm">/* Maximum number of frames buffered to all STAs, including multicast frames.</span>
<span class="cm"> * Note: increasing this limit increases the potential memory requirement. Each</span>
<span class="cm"> * frame can be up to about 2 kB long. */</span>
<span class="cp">#define TOTAL_MAX_TX_BUFFER 512</span>

<span class="cm">/* Required encryption head and tailroom */</span>
<span class="cp">#define IEEE80211_ENCRYPT_HEADROOM 8</span>
<span class="cp">#define IEEE80211_ENCRYPT_TAILROOM 18</span>

<span class="cm">/* IEEE 802.11 (Ch. 9.5 Defragmentation) requires support for concurrent</span>
<span class="cm"> * reception of at least three fragmented frames. This limit can be increased</span>
<span class="cm"> * by changing this define, at the cost of slower frame reassembly and</span>
<span class="cm"> * increased memory use (about 2 kB of RAM per entry). */</span>
<span class="cp">#define IEEE80211_FRAGMENT_MAX 4</span>

<span class="cp">#define TU_TO_JIFFIES(x)	(usecs_to_jiffies((x) * 1024))</span>
<span class="cp">#define TU_TO_EXP_TIME(x)	(jiffies + TU_TO_JIFFIES(x))</span>

<span class="cp">#define IEEE80211_DEFAULT_UAPSD_QUEUES \</span>
<span class="cp">	(IEEE80211_WMM_IE_STA_QOSINFO_AC_BK |	\</span>
<span class="cp">	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BE |	\</span>
<span class="cp">	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VI |	\</span>
<span class="cp">	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)</span>

<span class="cp">#define IEEE80211_DEFAULT_MAX_SP_LEN		\</span>
<span class="cp">	IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL</span>

<span class="k">struct</span> <span class="n">ieee80211_fragment_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_frag_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_frag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skb_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ccmp</span><span class="p">;</span> <span class="cm">/* Whether fragments were encrypted with CCMP */</span>
	<span class="n">u8</span> <span class="n">last_pn</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="cm">/* PN of the last fragment if CCMP was used */</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="p">{</span>
	<span class="cm">/* don&#39;t want to look up all the time */</span>
	<span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">dtim_period</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">wmm_used</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">uapsd_supported</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_probe_resp</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mesh_id</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">mesh_id_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mesh_cfg</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#define IEEE80211_MAX_SUPP_RATES 32</span>
	<span class="n">u8</span> <span class="n">supp_rates</span><span class="p">[</span><span class="n">IEEE80211_MAX_SUPP_RATES</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">supp_rates_len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * During association, we save an ERP value from a probe response so</span>
<span class="cm">	 * that we can feed ERP info to the driver when handling the</span>
<span class="cm">	 * association completes. these fields probably won&#39;t be up-to-date</span>
<span class="cm">	 * otherwise, you probably don&#39;t want to use them.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">has_erp_value</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">erp_value</span><span class="p">;</span>

	<span class="cm">/* Keep track of the corruption of the last beacon/probe response. */</span>
	<span class="n">u8</span> <span class="n">corrupt_data</span><span class="p">;</span>

	<span class="cm">/* Keep track of what bits of information we have valid info for. */</span>
	<span class="n">u8</span> <span class="n">valid_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_corrupt_data_flags - BSS data corruption flags</span>
<span class="cm"> * @IEEE80211_BSS_CORRUPT_BEACON: last beacon frame received was corrupted</span>
<span class="cm"> * @IEEE80211_BSS_CORRUPT_PROBE_RESP: last probe response received was corrupted</span>
<span class="cm"> *</span>
<span class="cm"> * These are bss flags that are attached to a bss in the</span>
<span class="cm"> * @corrupt_data field of &amp;struct ieee80211_bss.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_bss_corrupt_data_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_BSS_CORRUPT_BEACON</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_BSS_CORRUPT_PROBE_RESP</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_valid_data_flags - BSS valid data flags</span>
<span class="cm"> * @IEEE80211_BSS_VALID_DTIM: DTIM data was gathered from non-corrupt IE</span>
<span class="cm"> * @IEEE80211_BSS_VALID_WMM: WMM/UAPSD data was gathered from non-corrupt IE</span>
<span class="cm"> * @IEEE80211_BSS_VALID_RATES: Supported rates were gathered from non-corrupt IE</span>
<span class="cm"> * @IEEE80211_BSS_VALID_ERP: ERP flag was gathered from non-corrupt IE</span>
<span class="cm"> *</span>
<span class="cm"> * These are bss flags that are attached to a bss in the</span>
<span class="cm"> * @valid_data field of &amp;struct ieee80211_bss.  They show which parts</span>
<span class="cm"> * of the data structure were recieved as a result of an un-corrupted</span>
<span class="cm"> * beacon/probe response.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_bss_valid_data_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_BSS_VALID_DTIM</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_BSS_VALID_WMM</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_BSS_VALID_RATES</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_BSS_VALID_ERP</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">bss_mesh_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="k">return</span> <span class="n">bss</span><span class="o">-&gt;</span><span class="n">mesh_cfg</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">bss_mesh_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="k">return</span> <span class="n">bss</span><span class="o">-&gt;</span><span class="n">mesh_id</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">bss_mesh_id_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="k">return</span> <span class="n">bss</span><span class="o">-&gt;</span><span class="n">mesh_id_len</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">__bitwise__</span> <span class="n">ieee80211_tx_result</span><span class="p">;</span>
<span class="cp">#define TX_CONTINUE	((__force ieee80211_tx_result) 0u)</span>
<span class="cp">#define TX_DROP		((__force ieee80211_tx_result) 1u)</span>
<span class="cp">#define TX_QUEUED	((__force ieee80211_tx_result) 2u)</span>

<span class="cp">#define IEEE80211_TX_UNICAST		BIT(1)</span>
<span class="cp">#define IEEE80211_TX_PS_BUFFERED	BIT(2)</span>

<span class="k">struct</span> <span class="n">ieee80211_tx_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">__bitwise__</span> <span class="n">ieee80211_rx_result</span><span class="p">;</span>
<span class="cp">#define RX_CONTINUE		((__force ieee80211_rx_result) 0u)</span>
<span class="cp">#define RX_DROP_UNUSABLE	((__force ieee80211_rx_result) 1u)</span>
<span class="cp">#define RX_DROP_MONITOR		((__force ieee80211_rx_result) 2u)</span>
<span class="cp">#define RX_QUEUED		((__force ieee80211_rx_result) 3u)</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_packet_rx_flags - packet RX flags</span>
<span class="cm"> * @IEEE80211_RX_RA_MATCH: frame is destined to interface currently processed</span>
<span class="cm"> *	(incl. multicast frames)</span>
<span class="cm"> * @IEEE80211_RX_IN_SCAN: received while scanning</span>
<span class="cm"> * @IEEE80211_RX_FRAGMENTED: fragmented frame</span>
<span class="cm"> * @IEEE80211_RX_AMSDU: a-MSDU packet</span>
<span class="cm"> * @IEEE80211_RX_MALFORMED_ACTION_FRM: action frame is malformed</span>
<span class="cm"> * @IEEE80211_RX_DEFERRED_RELEASE: frame was subjected to receive reordering</span>
<span class="cm"> *</span>
<span class="cm"> * These are per-frame flags that are attached to a frame in the</span>
<span class="cm"> * @rx_flags field of &amp;struct ieee80211_rx_status.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_packet_rx_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_RX_IN_SCAN</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_RX_RA_MATCH</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_RX_FRAGMENTED</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_RX_AMSDU</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IEEE80211_RX_MALFORMED_ACTION_FRM</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IEEE80211_RX_DEFERRED_RELEASE</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_rx_flags - RX data flags</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_RX_CMNTR: received on cooked monitor already</span>
<span class="cm"> * @IEEE80211_RX_BEACON_REPORTED: This frame was already reported</span>
<span class="cm"> *	to cfg80211_report_obss_beacon().</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used across handling multiple interfaces</span>
<span class="cm"> * for a single frame.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_rx_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_RX_CMNTR</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_RX_BEACON_REPORTED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_rx_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Index into sequence numbers array, 0..16</span>
<span class="cm">	 * since the last (16) is used for non-QoS,</span>
<span class="cm">	 * will be 16 on non-QoS frames.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">seqno_idx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Index into the security IV/PN arrays, 0..16</span>
<span class="cm">	 * since the last (16) is used for CCMP-encrypted</span>
<span class="cm">	 * management frames, will be set to 16 on mgmt</span>
<span class="cm">	 * frames and 0 on non-QoS frames.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">security_idx</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">tkip_iv32</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tkip_iv16</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">beacon_data</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">head_len</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_if_ap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">beacon_data</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">beacon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">probe_resp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vlans</span><span class="p">;</span>

	<span class="cm">/* yes, this looks ugly, but guarantees that we can later use</span>
<span class="cm">	 * bitmap_empty :)</span>
<span class="cm">	 * NB: don&#39;t touch this bitmap, use sta_info_{set,clear}_tim_bit */</span>
	<span class="n">u8</span> <span class="n">tim</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">IEEE80211_MAX_AID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">ps_bc_buf</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_sta_ps</span><span class="p">;</span> <span class="cm">/* number of stations in PS mode */</span>
	<span class="n">atomic_t</span> <span class="n">num_mcast_sta</span><span class="p">;</span> <span class="cm">/* number of stations receiving multicast */</span>
	<span class="kt">int</span> <span class="n">dtim_count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dtim_bc_mc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_if_wds</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">remote_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_if_vlan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* used for all tx if the VLAN is configured to 4-addr mode */</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mesh_stats</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">fwded_mcast</span><span class="p">;</span>		<span class="cm">/* Mesh forwarded multicast frames */</span>
	<span class="n">__u32</span> <span class="n">fwded_unicast</span><span class="p">;</span>		<span class="cm">/* Mesh forwarded unicast frames */</span>
	<span class="n">__u32</span> <span class="n">fwded_frames</span><span class="p">;</span>		<span class="cm">/* Mesh total forwarded frames */</span>
	<span class="n">__u32</span> <span class="n">dropped_frames_ttl</span><span class="p">;</span>	<span class="cm">/* Not transmitted since mesh_ttl == 0*/</span>
	<span class="n">__u32</span> <span class="n">dropped_frames_no_route</span><span class="p">;</span>	<span class="cm">/* Not transmitted, no route found */</span>
	<span class="n">__u32</span> <span class="n">dropped_frames_congestion</span><span class="p">;</span><span class="cm">/* Not forwarded due to congestion */</span>
	<span class="n">atomic_t</span> <span class="n">estab_plinks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PREQ_Q_F_START		0x1</span>
<span class="cp">#define PREQ_Q_F_REFRESH	0x2</span>
<span class="k">struct</span> <span class="n">mesh_preq_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dst</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ieee80211_work_type</span> <span class="p">{</span>
	<span class="n">IEEE80211_WORK_ABORT</span><span class="p">,</span>
	<span class="n">IEEE80211_WORK_REMAIN_ON_CHANNEL</span><span class="p">,</span>
	<span class="n">IEEE80211_WORK_OFFCHANNEL_TX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum work_done_result - indicates what to do after work was done</span>
<span class="cm"> *</span>
<span class="cm"> * @WORK_DONE_DESTROY: This work item is no longer needed, destroy.</span>
<span class="cm"> * @WORK_DONE_REQUEUE: This work item was reset to be reused, and</span>
<span class="cm"> *	should be requeued.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">work_done_result</span> <span class="p">{</span>
	<span class="n">WORK_DONE_DESTROY</span><span class="p">,</span>
	<span class="n">WORK_DONE_REQUEUE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">work_done_result</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_work</span> <span class="o">*</span><span class="n">wk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">chan_type</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_work_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">started</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">duration</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">remain</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">wait</span><span class="p">;</span>
			<span class="n">bool</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">offchan_tx</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="kt">size_t</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/* flags used in struct ieee80211_if_managed.flags */</span>
<span class="k">enum</span> <span class="n">ieee80211_sta_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_STA_BEACON_POLL</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_CONNECTION_POLL</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_CONTROL_PORT</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_DISABLE_11N</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_CSA_RECEIVED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_MFP_ENABLED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_UAPSD_ENABLED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_NULLFUNC_ACKED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_RESET_SIGNAL_AVE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
	<span class="n">IEEE80211_STA_DISABLE_40MHZ</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_mgd_auth_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">expected_transaction</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="n">WLAN_KEY_LEN_WEP104</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">key_len</span><span class="p">,</span> <span class="n">key_idx</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">done</span><span class="p">;</span>

	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ie</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_mgd_assoc_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">supp_rates</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ht_operation_ie</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">capability</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prev_bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">supp_rates_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wmm</span><span class="p">,</span> <span class="n">uapsd</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">have_beacon</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sent_assoc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">synced</span><span class="p">;</span>

	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ie</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_if_managed</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">conn_mon_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">bcn_mon_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">chswitch_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">monitor_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">chswitch_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">beacon_connection_loss_work</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">beacon_timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">probe_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe_send_count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nullfunc_failed</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">associated</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_mgd_auth_data</span> <span class="o">*</span><span class="n">auth_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_mgd_assoc_data</span> <span class="o">*</span><span class="n">assoc_data</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="n">u16</span> <span class="n">aid</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timers_running</span><span class="p">;</span> <span class="cm">/* used for quiesce/restart */</span>
	<span class="n">bool</span> <span class="n">powersave</span><span class="p">;</span> <span class="cm">/* powersave requested for this iface */</span>
	<span class="n">bool</span> <span class="n">broken_ap</span><span class="p">;</span> <span class="cm">/* AP is broken -- turn off powersave */</span>
	<span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">req_smps</span><span class="p">,</span> <span class="cm">/* requested smps mode */</span>
				 <span class="n">ap_smps</span><span class="p">,</span> <span class="cm">/* smps mode AP thinks we&#39;re in */</span>
				 <span class="n">driver_smps_mode</span><span class="p">;</span> <span class="cm">/* smps mode request */</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">request_smps_work</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">beacon_crc_valid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">beacon_crc</span><span class="p">;</span>

	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">IEEE80211_MFP_DISABLED</span><span class="p">,</span>
		<span class="n">IEEE80211_MFP_OPTIONAL</span><span class="p">,</span>
		<span class="n">IEEE80211_MFP_REQUIRED</span>
	<span class="p">}</span> <span class="n">mfp</span><span class="p">;</span> <span class="cm">/* management frame protection */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bitmask of enabled u-apsd queues,</span>
<span class="cm">	 * IEEE80211_WMM_IE_STA_QOSINFO_AC_BE &amp; co. Needs a new association</span>
<span class="cm">	 * to take effect.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uapsd_queues</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum number of buffered frames AP can deliver during a</span>
<span class="cm">	 * service period, IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL or similar.</span>
<span class="cm">	 * Needs a new association to take effect.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uapsd_max_sp_len</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">wmm_last_param_set</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">use_4addr</span><span class="p">;</span>

	<span class="cm">/* Signal strength from the last Beacon frame in the current BSS. */</span>
	<span class="kt">int</span> <span class="n">last_beacon_signal</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Weighted average of the signal strength from Beacon frames in the</span>
<span class="cm">	 * current BSS. This is in units of 1/16 of the signal unit to maintain</span>
<span class="cm">	 * accuracy and to speed up calculations, i.e., the value need to be</span>
<span class="cm">	 * divided by 16 to get the actual value.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">ave_beacon_signal</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of Beacon frames used in ave_beacon_signal. This can be used</span>
<span class="cm">	 * to avoid generating less reliable cqm events that would be based</span>
<span class="cm">	 * only on couple of received frames.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count_beacon_signal</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Last Beacon frame signal strength average (ave_beacon_signal / 16)</span>
<span class="cm">	 * that triggered a cqm event. 0 indicates that no event has been</span>
<span class="cm">	 * generated for the current association.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">last_cqm_event_signal</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * State variables for keeping track of RSSI of the AP currently</span>
<span class="cm">	 * connected to and informing driver when RSSI has gone</span>
<span class="cm">	 * below/above a certain threshold.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rssi_min_thold</span><span class="p">,</span> <span class="n">rssi_max_thold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_ave_beacon_signal</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="n">ht_capa</span><span class="p">;</span> <span class="cm">/* configured ht-cap over-rides */</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="n">ht_capa_mask</span><span class="p">;</span> <span class="cm">/* Valid parts of ht_capa */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_if_ibss</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_scan_completed</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">basic_rates</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">timer_running</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">fixed_bssid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fixed_channel</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">privacy</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">control_port</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">,</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibss_join_req</span><span class="p">;</span>
	<span class="cm">/* probe response/beacon for IBSS */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">presp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">incomplete_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">incomplete_stations</span><span class="p">;</span>

	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">IEEE80211_IBSS_MLME_SEARCH</span><span class="p">,</span>
		<span class="n">IEEE80211_IBSS_MLME_JOINED</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_mesh_sync_ops - Extensible synchronization framework interface</span>
<span class="cm"> *</span>
<span class="cm"> * these declarations define the interface, which enables</span>
<span class="cm"> * vendor-specific mesh synchronization</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee802_11_elems</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ieee80211_mesh_sync_ops</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rx_bcn_presp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">stype</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee802_11_elems</span> <span class="o">*</span><span class="n">elems</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="n">rx_status</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adjust_tbtt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
	<span class="cm">/* add other framework functions here */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_if_mesh</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">housekeeping_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">mesh_path_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">mesh_path_root_timer</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timers_running</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wrkq_flags</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">mesh_id</span><span class="p">[</span><span class="n">IEEE80211_MAX_MESH_ID_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">mesh_id_len</span><span class="p">;</span>
	<span class="cm">/* Active Path Selection Protocol Identifier */</span>
	<span class="n">u8</span> <span class="n">mesh_pp_id</span><span class="p">;</span>
	<span class="cm">/* Active Path Selection Metric Identifier */</span>
	<span class="n">u8</span> <span class="n">mesh_pm_id</span><span class="p">;</span>
	<span class="cm">/* Congestion Control Mode Identifier */</span>
	<span class="n">u8</span> <span class="n">mesh_cc_id</span><span class="p">;</span>
	<span class="cm">/* Synchronization Protocol Identifier */</span>
	<span class="n">u8</span> <span class="n">mesh_sp_id</span><span class="p">;</span>
	<span class="cm">/* Authentication Protocol Identifier */</span>
	<span class="n">u8</span> <span class="n">mesh_auth_id</span><span class="p">;</span>
	<span class="cm">/* Local mesh Sequence Number */</span>
	<span class="n">u32</span> <span class="n">sn</span><span class="p">;</span>
	<span class="cm">/* Last used PREQ ID */</span>
	<span class="n">u32</span> <span class="n">preq_id</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">mpaths</span><span class="p">;</span>
	<span class="cm">/* Timestamp of last SN update */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_sn_update</span><span class="p">;</span>
	<span class="cm">/* Time when it&#39;s ok to send next PERR */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_perr</span><span class="p">;</span>
	<span class="cm">/* Timestamp of last PREQ sent */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_preq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mesh_rmc</span> <span class="o">*</span><span class="n">rmc</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">mesh_preq_queue_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mesh_preq_queue</span> <span class="n">preq_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">preq_queue_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mesh_stats</span> <span class="n">mshstats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mesh_config</span> <span class="n">mshcfg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mesh_seqnum</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">accepting_plinks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_gates</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">IEEE80211_MESH_SEC_NONE</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
		<span class="n">IEEE80211_MESH_SEC_AUTHED</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
		<span class="n">IEEE80211_MESH_SEC_SECURED</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">security</span><span class="p">;</span>
	<span class="cm">/* Extensible Synchronization Framework */</span>
	<span class="k">struct</span> <span class="n">ieee80211_mesh_sync_ops</span> <span class="o">*</span><span class="n">sync_ops</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">sync_offset_clockdrift_max</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">sync_offset_lock</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">adjusting_tbtt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
<span class="cp">#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name)	\</span>
<span class="cp">	do { (msh)-&gt;mshstats.name++; } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name) \</span>
<span class="cp">	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_sub_if_data_flags - virtual interface flags</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_SDATA_ALLMULTI: interface wants all multicast packets</span>
<span class="cm"> * @IEEE80211_SDATA_PROMISC: interface is promisc</span>
<span class="cm"> * @IEEE80211_SDATA_OPERATING_GMODE: operating in G-only mode</span>
<span class="cm"> * @IEEE80211_SDATA_DONT_BRIDGE_PACKETS: bridge packets between</span>
<span class="cm"> *	associated stations and deliver multicast frames both</span>
<span class="cm"> *	back to wireless media and to the local net stack.</span>
<span class="cm"> * @IEEE80211_SDATA_DISCONNECT_RESUME: Disconnect after resume.</span>
<span class="cm"> * @IEEE80211_SDATA_IN_DRIVER: indicates interface was added to driver</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_sub_if_data_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_SDATA_ALLMULTI</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_SDATA_PROMISC</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_SDATA_OPERATING_GMODE</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_SDATA_DONT_BRIDGE_PACKETS</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IEEE80211_SDATA_DISCONNECT_RESUME</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IEEE80211_SDATA_IN_DRIVER</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_sdata_state_bits - virtual interface state bits</span>
<span class="cm"> * @SDATA_STATE_RUNNING: virtual interface is up &amp; running; this</span>
<span class="cm"> *	mirrors netif_running() but is separate for interface type</span>
<span class="cm"> *	change handling while the interface is up</span>
<span class="cm"> * @SDATA_STATE_OFFCHANNEL: This interface is currently in offchannel</span>
<span class="cm"> *	mode, so queues are stopped</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_sdata_state_bits</span> <span class="p">{</span>
	<span class="n">SDATA_STATE_RUNNING</span><span class="p">,</span>
	<span class="n">SDATA_STATE_OFFCHANNEL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">wireless_dev</span> <span class="n">wdev</span><span class="p">;</span>

	<span class="cm">/* keys */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">key_list</span><span class="p">;</span>

	<span class="cm">/* count for keys needing tailroom space allocation */</span>
	<span class="kt">int</span> <span class="n">crypto_tx_tailroom_needed_cnt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">drop_unencrypted</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>

	<span class="cm">/* to detect idle changes */</span>
	<span class="n">bool</span> <span class="n">old_idle</span><span class="p">;</span>

	<span class="cm">/* Fragment table for host-based reassembly */</span>
	<span class="k">struct</span> <span class="n">ieee80211_fragment_entry</span>	<span class="n">fragments</span><span class="p">[</span><span class="n">IEEE80211_FRAGMENT_MAX</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fragment_next</span><span class="p">;</span>

	<span class="cm">/* TID bitmap for NoAck policy */</span>
	<span class="n">u16</span> <span class="n">noack_map</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_key</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">keys</span><span class="p">[</span><span class="n">NUM_DEFAULT_KEYS</span> <span class="o">+</span> <span class="n">NUM_DEFAULT_MGMT_KEYS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ieee80211_key</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">default_unicast_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_key</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">default_multicast_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_key</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">default_mgmt_key</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">sequence_number</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">control_port_protocol</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">control_port_no_encrypt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_tx_queue_params</span> <span class="n">tx_conf</span><span class="p">[</span><span class="n">IEEE80211_NUM_ACS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skb_queue</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">arp_filter_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * AP this belongs to: self in AP mode and</span>
<span class="cm">	 * corresponding AP in VLAN mode, NULL for</span>
<span class="cm">	 * all others (might be needed later in IBSS)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ieee80211_if_ap</span> <span class="o">*</span><span class="n">bss</span><span class="p">;</span>

	<span class="cm">/* bitmap of allowed (non-MCS) rate indexes for rate control */</span>
	<span class="n">u32</span> <span class="n">rc_rateidx_mask</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">rc_rateidx_mcs_mask</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">][</span><span class="n">IEEE80211_HT_MCS_MASK_LEN</span><span class="p">];</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ieee80211_if_ap</span> <span class="n">ap</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ieee80211_if_wds</span> <span class="n">wds</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ieee80211_if_vlan</span> <span class="n">vlan</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ieee80211_if_managed</span> <span class="n">mgd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ieee80211_if_ibss</span> <span class="n">ibss</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ieee80211_if_mesh</span> <span class="n">mesh</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">mntr_flags</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MAC80211_DEBUGFS</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">subdir_stations</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">default_unicast_key</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">default_multicast_key</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">default_mgmt_key</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">debugfs</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* must be last, dynamically sized area in this! */</span>
	<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="n">vif</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="nf">vif_to_sdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span><span class="p">,</span> <span class="n">vif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sdata_queue_type</span> <span class="p">{</span>
	<span class="n">IEEE80211_SDATA_QUEUE_TYPE_FRAME</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IEEE80211_SDATA_QUEUE_AGG_START</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_SDATA_QUEUE_AGG_STOP</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IEEE80211_RX_MSG</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_TX_STATUS_MSG</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IEEE80211_EOSP_MSG</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">skb_eosp_msg_data</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">sta</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">],</span> <span class="n">iface</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">queue_stop_reason</span> <span class="p">{</span>
	<span class="n">IEEE80211_QUEUE_STOP_REASON_DRIVER</span><span class="p">,</span>
	<span class="n">IEEE80211_QUEUE_STOP_REASON_PS</span><span class="p">,</span>
	<span class="n">IEEE80211_QUEUE_STOP_REASON_CSA</span><span class="p">,</span>
	<span class="n">IEEE80211_QUEUE_STOP_REASON_AGGREGATION</span><span class="p">,</span>
	<span class="n">IEEE80211_QUEUE_STOP_REASON_SUSPEND</span><span class="p">,</span>
	<span class="n">IEEE80211_QUEUE_STOP_REASON_SKB_ADD</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
<span class="k">struct</span> <span class="n">tpt_led_trigger</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">led_trigger</span> <span class="n">trig</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tpt_blink</span> <span class="o">*</span><span class="n">blink_table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blink_table_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prev_traffic</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_bytes</span><span class="p">,</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">active</span><span class="p">,</span> <span class="n">want</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">running</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * mac80211 scan flags - currently active scan mode</span>
<span class="cm"> *</span>
<span class="cm"> * @SCAN_SW_SCANNING: We&#39;re currently in the process of scanning but may as</span>
<span class="cm"> *	well be on the operating channel</span>
<span class="cm"> * @SCAN_HW_SCANNING: The hardware is scanning for us, we have no way to</span>
<span class="cm"> *	determine if we are on the operating channel or not</span>
<span class="cm"> * @SCAN_ONCHANNEL_SCANNING:  Do a software scan on only the current operating</span>
<span class="cm"> *	channel. This should not interrupt normal traffic.</span>
<span class="cm"> * @SCAN_COMPLETED: Set for our scan work function when the driver reported</span>
<span class="cm"> *	that the scan completed.</span>
<span class="cm"> * @SCAN_ABORTED: Set for our scan work function when the driver reported</span>
<span class="cm"> *	a scan complete for an aborted scan.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCAN_SW_SCANNING</span><span class="p">,</span>
	<span class="n">SCAN_HW_SCANNING</span><span class="p">,</span>
	<span class="n">SCAN_ONCHANNEL_SCANNING</span><span class="p">,</span>
	<span class="n">SCAN_COMPLETED</span><span class="p">,</span>
	<span class="n">SCAN_ABORTED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum mac80211_scan_state - scan state machine states</span>
<span class="cm"> *</span>
<span class="cm"> * @SCAN_DECISION: Main entry point to the scan state machine, this state</span>
<span class="cm"> *	determines if we should keep on scanning or switch back to the</span>
<span class="cm"> *	operating channel</span>
<span class="cm"> * @SCAN_SET_CHANNEL: Set the next channel to be scanned</span>
<span class="cm"> * @SCAN_SEND_PROBE: Send probe requests and wait for probe responses</span>
<span class="cm"> * @SCAN_SUSPEND: Suspend the scan and go back to operating channel to</span>
<span class="cm"> *	send out data</span>
<span class="cm"> * @SCAN_RESUME: Resume the scan and scan the next channel</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mac80211_scan_state</span> <span class="p">{</span>
	<span class="n">SCAN_DECISION</span><span class="p">,</span>
	<span class="n">SCAN_SET_CHANNEL</span><span class="p">,</span>
	<span class="n">SCAN_SEND_PROBE</span><span class="p">,</span>
	<span class="n">SCAN_SUSPEND</span><span class="p">,</span>
	<span class="n">SCAN_RESUME</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="p">{</span>
	<span class="cm">/* embed the driver visible part.</span>
<span class="cm">	 * don&#39;t cast (use the static inlines below), but we keep</span>
<span class="cm">	 * it first anyway so they become a no-op */</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="n">hw</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * work stuff, potentially off-channel (in the future)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">work_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">work_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work_work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * private workqueue to mac80211. mac80211 makes this accessible</span>
<span class="cm">	 * via ieee80211_queue_work()</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_stop_reasons</span><span class="p">[</span><span class="n">IEEE80211_MAX_QUEUES</span><span class="p">];</span>
	<span class="cm">/* also used to protect ampdu_ac_queue and amdpu_ac_stop_refcnt */</span>
	<span class="n">spinlock_t</span> <span class="n">queue_stop_reason_lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">open_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">monitors</span><span class="p">,</span> <span class="n">cooked_mntrs</span><span class="p">;</span>
	<span class="cm">/* number of interfaces with corresponding FIF_ flags */</span>
	<span class="kt">int</span> <span class="n">fif_fcsfail</span><span class="p">,</span> <span class="n">fif_plcpfail</span><span class="p">,</span> <span class="n">fif_control</span><span class="p">,</span> <span class="n">fif_other_bss</span><span class="p">,</span> <span class="n">fif_pspoll</span><span class="p">,</span>
	    <span class="n">fif_probe_req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe_req_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter_flags</span><span class="p">;</span> <span class="cm">/* FIF_* */</span>

	<span class="n">bool</span> <span class="n">wiphy_ciphers_allocated</span><span class="p">;</span>

	<span class="cm">/* protects the aggregated multicast list and filter calls */</span>
	<span class="n">spinlock_t</span> <span class="n">filter_lock</span><span class="p">;</span>

	<span class="cm">/* used for uploading changed mc list */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reconfig_filter</span><span class="p">;</span>

	<span class="cm">/* used to reconfigure hardware SM PS */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">recalc_smps</span><span class="p">;</span>

	<span class="cm">/* aggregated multicast list */</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="n">mc_list</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">tim_in_locked_section</span><span class="p">;</span> <span class="cm">/* see ieee80211_beacon_get() */</span>

	<span class="cm">/*</span>
<span class="cm">	 * suspended is true if we finished all the suspend _and_ we have</span>
<span class="cm">	 * not yet come up from resume. This is to be used by mac80211</span>
<span class="cm">	 * to ensure driver sanity during suspend and mac80211&#39;s own</span>
<span class="cm">	 * sanity. It can eventually be used for WoW as well.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">suspended</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Resuming is true while suspended, but when we&#39;re reprogramming the</span>
<span class="cm">	 * hardware -- at that time it&#39;s allowed to use ieee80211_queue_work()</span>
<span class="cm">	 * again even though some other parts of the stack are still suspended</span>
<span class="cm">	 * and we still drop received frames to avoid waking the stack.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">resuming</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * quiescing is true during the suspend process _only_ to</span>
<span class="cm">	 * ease timer cancelling etc.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">quiescing</span><span class="p">;</span>

	<span class="cm">/* device is started */</span>
	<span class="n">bool</span> <span class="n">started</span><span class="p">;</span>

	<span class="cm">/* wowlan is enabled -- don&#39;t reconfig on resume */</span>
	<span class="n">bool</span> <span class="n">wowlan</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">tx_headroom</span><span class="p">;</span> <span class="cm">/* required headroom for hardware/radiotap */</span>

	<span class="cm">/* Tasklet and skb queue to process calls from IRQ mode. All frames</span>
<span class="cm">	 * added to skb_queue will be processed, but frames in</span>
<span class="cm">	 * skb_queue_unreliable may be dropped if the total length of these</span>
<span class="cm">	 * queues increases over the limit. */</span>
<span class="cp">#define IEEE80211_IRQSAFE_QUEUE_LIMIT 128</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skb_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skb_queue_unreliable</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Internal FIFO queue which is shared between multiple rx path</span>
<span class="cm">	 * stages. Its main task is to provide a serialization mechanism,</span>
<span class="cm">	 * so all rx handlers can enjoy having exclusive access to their</span>
<span class="cm">	 * private data structures.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">rx_skb_queue</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">running_rx_handler</span><span class="p">;</span>	<span class="cm">/* protected by rx_skb_queue.lock */</span>

	<span class="cm">/* Station data */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The mutex only protects the list, hash table and</span>
<span class="cm">	 * counter, reads are done with RCU.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">sta_mtx</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">tim_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sta_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">sta_cleanup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta_generation</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">pending</span><span class="p">[</span><span class="n">IEEE80211_MAX_QUEUES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tx_pending_tasklet</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">agg_queue_stop</span><span class="p">[</span><span class="n">IEEE80211_MAX_QUEUES</span><span class="p">];</span>

	<span class="cm">/* number of interfaces with corresponding IFF_ flags */</span>
	<span class="n">atomic_t</span> <span class="n">iff_allmultis</span><span class="p">,</span> <span class="n">iff_promiscs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rate_control_ref</span> <span class="o">*</span><span class="n">rate_ctrl</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">wep_tx_tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_cipher</span> <span class="o">*</span><span class="n">wep_rx_tfm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wep_iv</span><span class="p">;</span>

	<span class="cm">/* see iface.c */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">interfaces</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">iflist_mtx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Key mutex, protects sdata&#39;s key_list and sta_info&#39;s</span>
<span class="cm">	 * key pointers (write access, they&#39;re RCU.)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">key_mtx</span><span class="p">;</span>

	<span class="cm">/* mutex for scan and work locking */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

	<span class="cm">/* Scanning and BSS list */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scanning</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_ssid</span> <span class="n">scan_ssid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">int_scan_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">scan_req</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_scan_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">scan_channel</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">hw_scan_band</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scan_channel_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scan_ies_len</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">sched_scanning</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sched_scan_ies</span> <span class="n">sched_scan_ies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">sched_scan_stopped_work</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leave_oper_channel_time</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mac80211_scan_state</span> <span class="n">next_scan_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">scan_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">scan_sdata</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">_oper_channel_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">oper_channel</span><span class="p">,</span> <span class="o">*</span><span class="n">csa_channel</span><span class="p">;</span>

	<span class="cm">/* Temporary remain-on-channel for off-channel operations */</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">tmp_channel</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">tmp_channel_type</span><span class="p">;</span>

	<span class="cm">/* SNMP counters */</span>
	<span class="cm">/* dot11CountersTable */</span>
	<span class="n">u32</span> <span class="n">dot11TransmittedFragmentCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11MulticastTransmittedFrameCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11FailedCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11RetryCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11MultipleRetryCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11FrameDuplicateCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11ReceivedFragmentCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11MulticastReceivedFrameCount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11TransmittedFrameCount</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
	<span class="kt">int</span> <span class="n">tx_led_counter</span><span class="p">,</span> <span class="n">rx_led_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">led_trigger</span> <span class="o">*</span><span class="n">tx_led</span><span class="p">,</span> <span class="o">*</span><span class="n">rx_led</span><span class="p">,</span> <span class="o">*</span><span class="n">assoc_led</span><span class="p">,</span> <span class="o">*</span><span class="n">radio_led</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tpt_led_trigger</span> <span class="o">*</span><span class="n">tpt_led_trigger</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tx_led_name</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">rx_led_name</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
	     <span class="n">assoc_led_name</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">radio_led_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MAC80211_DEBUG_COUNTERS</span>
	<span class="cm">/* TX/RX handler statistics */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_drop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_queued</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_drop_unencrypted</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_drop_fragment</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_drop_wep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_drop_not_assoc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_handlers_drop_unauth_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_drop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_queued</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_drop_nullfunc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_drop_defrag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_drop_short</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_drop_passive_scan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_expand_skb_head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_expand_skb_head_cloned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_expand_skb_head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_expand_skb_head2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_handlers_fragments</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_status_drop</span><span class="p">;</span>
<span class="cp">#define I802_DEBUG_INC(c) (c)++</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_MAC80211_DEBUG_COUNTERS */</span><span class="cp"></span>
<span class="cp">#define I802_DEBUG_INC(c) do { } while (0)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAC80211_DEBUG_COUNTERS */</span><span class="cp"></span>


	<span class="kt">int</span> <span class="n">total_ps_buffered</span><span class="p">;</span> <span class="cm">/* total number of all buffered unicast and</span>
<span class="cm">				* multicast packets for power saving stations</span>
<span class="cm">				*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wmm_acm</span><span class="p">;</span> <span class="cm">/* bit field of ACM bits (BIT(802.1D tag)) */</span>

	<span class="n">bool</span> <span class="n">pspolling</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">offchannel_ps_enabled</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * PS can only be enabled when we have exactly one managed</span>
<span class="cm">	 * interface (and monitors) in PS, this then points there.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">ps_sdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">dynamic_ps_enable_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">dynamic_ps_disable_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">dynamic_ps_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">network_latency_notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">ifa_notifier</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The dynamic ps timeout configured from user space via WEXT -</span>
<span class="cm">	 * this will override whatever chosen by mac80211 internally.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">dynamic_ps_forced_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dynamic_ps_user_timeout</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disable_dynamic_ps</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">user_power_level</span><span class="p">;</span> <span class="cm">/* in dBm */</span>
	<span class="kt">int</span> <span class="n">power_constr_level</span><span class="p">;</span> <span class="cm">/* in dBm */</span>

	<span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps_mode</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">restart_work</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MAC80211_DEBUGFS</span>
	<span class="k">struct</span> <span class="n">local_debugfsdentries</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rcdir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">keys</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">debugfs</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">hw_roc_channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">hw_roc_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">hw_roc_skb</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_roc_skb_for_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">hw_roc_start</span><span class="p">,</span> <span class="n">hw_roc_done</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">hw_roc_channel_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hw_roc_duration</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw_roc_cookie</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">hw_roc_for_tx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">idr</span> <span class="n">ack_status_frames</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ack_status_lock</span><span class="p">;</span>

	<span class="cm">/* dummy netdev for use w/ NAPI */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="n">napi_dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>

	<span class="cm">/* virtual monitor interface */</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">monitor_sdata</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span>
<span class="nf">IEEE80211_DEV_TO_SUB_IF</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this struct represents 802.11n&#39;s RA/TID combination */</span>
<span class="k">struct</span> <span class="n">ieee80211_ra_tid</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ra</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">tid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Parsed Information Elements */</span>
<span class="k">struct</span> <span class="n">ieee802_11_elems</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ie_start</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">total_len</span><span class="p">;</span>

	<span class="cm">/* pointers to IEs */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">supp_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">fh_params</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ds_params</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cf_params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_tim_ie</span> <span class="o">*</span><span class="n">tim</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ibss_params</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">challenge</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">wpa</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">rsn</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">erp_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ext_supp_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">wmm_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">wmm_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="o">*</span><span class="n">ht_cap_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_operation</span> <span class="o">*</span><span class="n">ht_operation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_meshconf_ie</span> <span class="o">*</span><span class="n">mesh_config</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mesh_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">peering</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">preq</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">prep</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">perr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_rann_ie</span> <span class="o">*</span><span class="n">rann</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ch_switch_elem</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">country_elem</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pwr_constr_elem</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">quiet_elem</span><span class="p">;</span>	<span class="cm">/* first quite element */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">timeout_int</span><span class="p">;</span>

	<span class="cm">/* length of them, respectively */</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">supp_rates_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fh_params_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ds_params_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cf_params_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tim_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ibss_params_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">challenge_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wpa_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rsn_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">erp_info_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ext_supp_rates_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wmm_info_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wmm_param_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mesh_id_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">peering_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">preq_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prep_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">perr_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ch_switch_elem_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">country_elem_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pwr_constr_elem_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">quiet_elem_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_of_quiet_elem</span><span class="p">;</span>	<span class="cm">/* can be more the one */</span>
	<span class="n">u8</span> <span class="n">timeout_int_len</span><span class="p">;</span>

	<span class="cm">/* whether a parse error occurred while retrieving these elements */</span>
	<span class="n">bool</span> <span class="n">parse_error</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="nf">hw_to_local</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_local</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ieee80211_bssid_match</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">raddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">raddr</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">raddr</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">ieee80211_hw_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_tx_set_protected</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_data</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_bss_info_change_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_configure_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ieee80211_reset_erp_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>

<span class="cm">/* STA code */</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_setup_sdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_mgd_auth</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">cfg80211_auth_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_mgd_assoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfg80211_assoc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_mgd_deauth</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">cfg80211_deauth_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_mgd_disassoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cfg80211_disassoc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_send_pspoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_recalc_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="n">s32</span> <span class="n">latency</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_max_network_latency</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_set_arp_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_process_chanswitch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_channel_sw_ie</span> <span class="o">*</span><span class="n">sw_elem</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">timestamp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_rx_queued_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_reset_beacon_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_reset_conn_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_mgd_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>

<span class="cm">/* IBSS code */</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_notify_scan_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_setup_sdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_rx_no_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">supp_rates</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_ibss_join</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfg80211_ibss_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_ibss_leave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ibss_rx_queued_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* mesh code */</span>
<span class="kt">void</span> <span class="n">ieee80211_mesh_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_mesh_rx_queued_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* scan/BSS handling */</span>
<span class="kt">void</span> <span class="n">ieee80211_scan_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_request_internal_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ssid_len</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_request_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_scan_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_run_deferred_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="n">ieee80211_rx_result</span>
<span class="n">ieee80211_scan_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ieee80211_mlme_notify_scan_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="o">*</span>
<span class="n">ieee80211_bss_info_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="n">rx_status</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee802_11_elems</span> <span class="o">*</span><span class="n">elems</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">beacon</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_rx_bss_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">);</span>

<span class="cm">/* scheduled scan handling */</span>
<span class="kt">int</span> <span class="n">ieee80211_request_sched_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">cfg80211_sched_scan_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_request_sched_scan_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sched_scan_stopped_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/* off-channel helpers */</span>
<span class="kt">void</span> <span class="n">ieee80211_offchannel_stop_vifs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">offchannel_ps_enable</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_offchannel_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">offchannel_ps_disable</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_hw_roc_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>

<span class="cm">/* interface handling */</span>
<span class="kt">int</span> <span class="n">ieee80211_iface_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_iface_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_if_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">new_dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">vif_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_if_change_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_if_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_remove_interfaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">__ieee80211_recalc_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_recalc_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_adjust_monitor_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ieee80211_sdata_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SDATA_STATE_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* tx handling */</span>
<span class="kt">void</span> <span class="n">ieee80211_clear_tx_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_tx_pending</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="n">netdev_tx_t</span> <span class="n">ieee80211_monitor_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">netdev_tx_t</span> <span class="n">ieee80211_subif_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* HT */</span>
<span class="kt">void</span> <span class="n">ieee80211_apply_htcap_overrides</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="o">*</span><span class="n">ht_cap</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ht_cap_ie_to_sta_ht_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="o">*</span><span class="n">ht_cap_ie</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="o">*</span><span class="n">ht_cap</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_send_delba</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">da</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">initiator</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reason_code</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_send_smps_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">da</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_request_smps_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">___ieee80211_stop_rx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">initiator</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reason</span><span class="p">,</span> <span class="n">bool</span> <span class="n">stop</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__ieee80211_stop_rx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span>
				    <span class="n">u16</span> <span class="n">initiator</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reason</span><span class="p">,</span> <span class="n">bool</span> <span class="n">stop</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_tear_down_BA_sessions</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">bool</span> <span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_process_delba</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_process_addba_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_process_addba_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ieee80211_stop_tx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">ieee80211_back_parties</span> <span class="n">initiator</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">tx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">___ieee80211_stop_tx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">ieee80211_back_parties</span> <span class="n">initiator</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_start_tx_ba_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_tx_ba_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_ba_session_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_tx_ba_session_handle_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_release_reorder_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">);</span>

<span class="cm">/* Spectrum management */</span>
<span class="kt">void</span> <span class="n">ieee80211_process_measurement_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Suspend/resume and hw reconfiguration */</span>
<span class="kt">int</span> <span class="n">ieee80211_reconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span> <span class="n">__ieee80211_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfg80211_wowlan</span> <span class="o">*</span><span class="n">wowlan</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ieee80211_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">hw_to_local</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">WARN</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SCAN_HW_SCANNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">scanning</span><span class="p">),</span>
		<span class="s">&quot;%s: resume with hardware scan still in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">wiphy_name</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ieee80211_reconfig</span><span class="p">(</span><span class="n">hw_to_local</span><span class="p">(</span><span class="n">hw</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ieee80211_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">cfg80211_wowlan</span> <span class="o">*</span><span class="n">wowlan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ieee80211_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* utility functions/constants */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mac80211_wiphy_privid</span><span class="p">;</span> <span class="cm">/* for wiphy privid */</span>
<span class="n">u8</span> <span class="o">*</span><span class="n">ieee80211_get_bssid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_frame_duration</span><span class="p">(</span><span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">rate</span><span class="p">,</span> <span class="kt">int</span> <span class="n">erp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">short_preamble</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac80211_ev_michael_mic_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyidx</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">tsc</span><span class="p">,</span>
				     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_set_wmm_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			       <span class="n">bool</span> <span class="n">bss_notify</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ieee80211_tx_skb_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="kr">inline</span> <span class="nf">ieee80211_tx_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Send all internal mgmt frames on VO. Accordingly set TID to 7. */</span>
	<span class="n">ieee80211_tx_skb_tid</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ieee802_11_parse_elems</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee802_11_elems</span> <span class="o">*</span><span class="n">elems</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ieee802_11_parse_elems_crc</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee802_11_elems</span> <span class="o">*</span><span class="n">elems</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">filter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">crc</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ieee80211_mandatory_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ieee80211_dynamic_ps_enable_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_dynamic_ps_disable_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_dynamic_ps_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_send_nullfunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">powersave</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_rx_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_tx_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ack</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_beacon_connection_loss_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ieee80211_wake_queues_by_reason</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">queue_stop_reason</span> <span class="n">reason</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_queues_by_reason</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">queue_stop_reason</span> <span class="n">reason</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_wake_queue_by_reason</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">queue_stop_reason</span> <span class="n">reason</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_queue_by_reason</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">queue_stop_reason</span> <span class="n">reason</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_propagate_queue_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_add_pending_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_add_pending_skbs_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ieee80211_add_pending_skbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ieee80211_add_pending_skbs_fn</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">skbs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ieee80211_send_auth</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			 <span class="n">u16</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">u16</span> <span class="n">auth_alg</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="o">*</span><span class="n">extra</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extra_len</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span>
			 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">da</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u8</span> <span class="n">key_len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">key_idx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_build_preq_ies</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rate_mask</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="n">channel</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_build_probe_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ratemask</span><span class="p">,</span>
					  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">,</span>
					  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">,</span>
					  <span class="n">bool</span> <span class="n">directed</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_send_probe_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">ratemask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">directed</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_cck</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ieee80211_sta_def_wmm_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">supp_rates_len</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">supp_rates</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">ieee80211_sta_get_rates</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee802_11_elems</span> <span class="o">*</span><span class="n">elems</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">basic_rates</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__ieee80211_request_smps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps_mode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_recalc_smps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>

<span class="kt">size_t</span> <span class="n">ieee80211_ie_split</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ies</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ielen</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_ids</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">ieee80211_ie_split_vendor</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ies</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ielen</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="n">u8</span> <span class="o">*</span><span class="n">ieee80211_ie_build_ht_cap</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="o">*</span><span class="n">ht_cap</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="n">cap</span><span class="p">);</span>
<span class="n">u8</span> <span class="o">*</span><span class="n">ieee80211_ie_build_ht_oper</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="o">*</span><span class="n">ht_cap</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="n">prot_mode</span><span class="p">);</span>

<span class="cm">/* internal work items */</span>
<span class="kt">void</span> <span class="n">ieee80211_work_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_add_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_work</span> <span class="o">*</span><span class="n">wk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_work</span> <span class="o">*</span><span class="n">wk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_work_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_wk_remain_on_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ieee80211_wk_cancel_remain_on_channel</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">);</span>

<span class="cm">/* channel management */</span>
<span class="k">enum</span> <span class="n">ieee80211_chan_mode</span> <span class="p">{</span>
	<span class="n">CHAN_MODE_UNDEFINED</span><span class="p">,</span>
	<span class="n">CHAN_MODE_HOPPING</span><span class="p">,</span>
	<span class="n">CHAN_MODE_FIXED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ieee80211_chan_mode</span>
<span class="n">ieee80211_get_channel_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">ignore</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">ieee80211_set_channel_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">chantype</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">nl80211_channel_type</span>
<span class="n">ieee80211_ht_oper_to_channel_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_ht_operation</span> <span class="o">*</span><span class="n">ht_oper</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MAC80211_NOINLINE</span>
<span class="cp">#define debug_noinline noinline</span>
<span class="cp">#else</span>
<span class="cp">#define debug_noinline</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* IEEE80211_I_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
