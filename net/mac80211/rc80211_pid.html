<!DOCTYPE html>
<html><head><title>joekychen/linux » net › mac80211 › rc80211_pid.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rc80211_pid.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2007, Mattias Nissler &lt;mattias.nissler@gmx.de&gt;</span>
<span class="cm"> * Copyright 2007, Stefano Brivio &lt;stefano.brivio@polimi.it&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef RC80211_PID_H</span>
<span class="cp">#define RC80211_PID_H</span>

<span class="cm">/* Sampling period for measuring percentage of failed frames in ms. */</span>
<span class="cp">#define RC_PID_INTERVAL			125</span>

<span class="cm">/* Exponential averaging smoothness (used for I part of PID controller) */</span>
<span class="cp">#define RC_PID_SMOOTHING_SHIFT		3</span>
<span class="cp">#define RC_PID_SMOOTHING		(1 &lt;&lt; RC_PID_SMOOTHING_SHIFT)</span>

<span class="cm">/* Sharpening factor (used for D part of PID controller) */</span>
<span class="cp">#define RC_PID_SHARPENING_FACTOR	0</span>
<span class="cp">#define RC_PID_SHARPENING_DURATION	0</span>

<span class="cm">/* Fixed point arithmetic shifting amount. */</span>
<span class="cp">#define RC_PID_ARITH_SHIFT		8</span>

<span class="cm">/* Proportional PID component coefficient. */</span>
<span class="cp">#define RC_PID_COEFF_P			15</span>
<span class="cm">/* Integral PID component coefficient. */</span>
<span class="cp">#define RC_PID_COEFF_I			9</span>
<span class="cm">/* Derivative PID component coefficient. */</span>
<span class="cp">#define RC_PID_COEFF_D			15</span>

<span class="cm">/* Target failed frames rate for the PID controller. NB: This effectively gives</span>
<span class="cm"> * maximum failed frames percentage we&#39;re willing to accept. If the wireless</span>
<span class="cm"> * link quality is good, the controller will fail to adjust failed frames</span>
<span class="cm"> * percentage to the target. This is intentional.</span>
<span class="cm"> */</span>
<span class="cp">#define RC_PID_TARGET_PF		14</span>

<span class="cm">/* Rate behaviour normalization quantity over time. */</span>
<span class="cp">#define RC_PID_NORM_OFFSET		3</span>

<span class="cm">/* Push high rates right after loading. */</span>
<span class="cp">#define RC_PID_FAST_START		0</span>

<span class="cm">/* Arithmetic right shift for positive and negative values for ISO C. */</span>
<span class="cp">#define RC_PID_DO_ARITH_RIGHT_SHIFT(x, y) \</span>
<span class="cp">	((x) &lt; 0 ? -((-(x)) &gt;&gt; (y)) : (x) &gt;&gt; (y))</span>

<span class="k">enum</span> <span class="n">rc_pid_event_type</span> <span class="p">{</span>
	<span class="n">RC_PID_EVENT_TYPE_TX_STATUS</span><span class="p">,</span>
	<span class="n">RC_PID_EVENT_TYPE_RATE_CHANGE</span><span class="p">,</span>
	<span class="n">RC_PID_EVENT_TYPE_TX_RATE</span><span class="p">,</span>
	<span class="n">RC_PID_EVENT_TYPE_PF_SAMPLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">rc_pid_event_data</span> <span class="p">{</span>
	<span class="cm">/* RC_PID_EVENT_TX_STATUS */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="n">tx_status</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="cm">/* RC_PID_EVENT_TYPE_RATE_CHANGE */</span>
	<span class="cm">/* RC_PID_EVENT_TYPE_TX_RATE */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rate</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="cm">/* RC_PID_EVENT_TYPE_PF_SAMPLE */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">pf_sample</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">prop_err</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">int_err</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">der_err</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rc_pid_event</span> <span class="p">{</span>
	<span class="cm">/* The time when the event occurred */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>

	<span class="cm">/* Event ID number */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="cm">/* Type of event */</span>
	<span class="k">enum</span> <span class="n">rc_pid_event_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* type specific data */</span>
	<span class="k">union</span> <span class="n">rc_pid_event_data</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Size of the event ring buffer. */</span>
<span class="cp">#define RC_PID_EVENT_RING_SIZE 32</span>

<span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="p">{</span>
	<span class="cm">/* Counter that generates event IDs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ev_count</span><span class="p">;</span>

	<span class="cm">/* Ring buffer of events */</span>
	<span class="k">struct</span> <span class="n">rc_pid_event</span> <span class="n">ring</span><span class="p">[</span><span class="n">RC_PID_EVENT_RING_SIZE</span><span class="p">];</span>

	<span class="cm">/* Index to the entry in events_buf to be reused */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_entry</span><span class="p">;</span>

	<span class="cm">/* Lock that guards against concurrent access to this buffer struct */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* Wait queue for poll/select and blocking I/O */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitqueue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rc_pid_events_file_info</span> <span class="p">{</span>
	<span class="cm">/* The event buffer we read */</span>
	<span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>

	<span class="cm">/* The entry we have should read next */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_entry</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rc_pid_debugfs_entries - tunable parameters</span>
<span class="cm"> *</span>
<span class="cm"> * Algorithm parameters, tunable via debugfs.</span>
<span class="cm"> * @target: target percentage for failed frames</span>
<span class="cm"> * @sampling_period: error sampling interval in milliseconds</span>
<span class="cm"> * @coeff_p: absolute value of the proportional coefficient</span>
<span class="cm"> * @coeff_i: absolute value of the integral coefficient</span>
<span class="cm"> * @coeff_d: absolute value of the derivative coefficient</span>
<span class="cm"> * @smoothing_shift: absolute value of the integral smoothing factor (i.e.</span>
<span class="cm"> *	amount of smoothing introduced by the exponential moving average)</span>
<span class="cm"> * @sharpen_factor: absolute value of the derivative sharpening factor (i.e.</span>
<span class="cm"> *	amount of emphasis given to the derivative term after low activity</span>
<span class="cm"> *	events)</span>
<span class="cm"> * @sharpen_duration: duration of the sharpening effect after the detected low</span>
<span class="cm"> *	activity event, relative to sampling_period</span>
<span class="cm"> * @norm_offset: amount of normalization periodically performed on the learnt</span>
<span class="cm"> *	rate behaviour values (lower means we should trust more what we learnt</span>
<span class="cm"> *	about behaviour of rates, higher means we should trust more the natural</span>
<span class="cm"> *	ordering of rates)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rc_pid_debugfs_entries</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">sampling_period</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">coeff_p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">coeff_i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">coeff_d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">smoothing_shift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">sharpen_factor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">sharpen_duration</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">norm_offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">rate_control_pid_event_tx_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">stat</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">rate_control_pid_event_rate_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">rate_control_pid_event_tx_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">rate_control_pid_event_pf_sample</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					     <span class="n">s32</span> <span class="n">pf_sample</span><span class="p">,</span> <span class="n">s32</span> <span class="n">prop_err</span><span class="p">,</span>
					     <span class="n">s32</span> <span class="n">int_err</span><span class="p">,</span> <span class="n">s32</span> <span class="n">der_err</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">rate_control_pid_add_sta_debugfs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">rate_control_pid_remove_sta_debugfs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">rc_pid_sta_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_change</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_sample</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">tx_num_failed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_num_xmit</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">txrate_idx</span><span class="p">;</span>

	<span class="cm">/* Average failed frames percentage error (i.e. actual vs. target</span>
<span class="cm">	 * percentage), scaled by RC_PID_SMOOTHING. This value is computed</span>
<span class="cm">	 * using using an exponential weighted average technique:</span>
<span class="cm">	 *</span>
<span class="cm">	 *           (RC_PID_SMOOTHING - 1) * err_avg_old + err</span>
<span class="cm">	 * err_avg = ------------------------------------------</span>
<span class="cm">	 *                       RC_PID_SMOOTHING</span>
<span class="cm">	 *</span>
<span class="cm">	 * where err_avg is the new approximation, err_avg_old the previous one</span>
<span class="cm">	 * and err is the error w.r.t. to the current failed frames percentage</span>
<span class="cm">	 * sample. Note that the bigger RC_PID_SMOOTHING the more weight is</span>
<span class="cm">	 * given to the previous estimate, resulting in smoother behavior (i.e.</span>
<span class="cm">	 * corresponding to a longer integration window).</span>
<span class="cm">	 *</span>
<span class="cm">	 * For computation, we actually don&#39;t use the above formula, but this</span>
<span class="cm">	 * one:</span>
<span class="cm">	 *</span>
<span class="cm">	 * err_avg_scaled = err_avg_old_scaled - err_avg_old + err</span>
<span class="cm">	 *</span>
<span class="cm">	 * where:</span>
<span class="cm">	 * 	err_avg_scaled = err * RC_PID_SMOOTHING</span>
<span class="cm">	 * 	err_avg_old_scaled = err_avg_old * RC_PID_SMOOTHING</span>
<span class="cm">	 *</span>
<span class="cm">	 * This avoids floating point numbers and the per_failed_old value can</span>
<span class="cm">	 * easily be obtained by shifting per_failed_old_scaled right by</span>
<span class="cm">	 * RC_PID_SMOOTHING_SHIFT.</span>
<span class="cm">	 */</span>
	<span class="n">s32</span> <span class="n">err_avg_sc</span><span class="p">;</span>

	<span class="cm">/* Last framed failes percentage sample. */</span>
	<span class="n">u32</span> <span class="n">last_pf</span><span class="p">;</span>

	<span class="cm">/* Sharpening needed. */</span>
	<span class="n">u8</span> <span class="n">sharp_cnt</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MAC80211_DEBUGFS</span>
	<span class="cm">/* Event buffer */</span>
	<span class="k">struct</span> <span class="n">rc_pid_event_buffer</span> <span class="n">events</span><span class="p">;</span>

	<span class="cm">/* Events debugfs file entry */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">events_entry</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Algorithm parameters. We keep them on a per-algorithm approach, so they can</span>
<span class="cm"> * be tuned individually for each interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rc_pid_rateinfo</span> <span class="p">{</span>

	<span class="cm">/* Map sorted rates to rates in ieee80211_hw_mode. */</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Map rates in ieee80211_hw_mode to sorted rates. */</span>
	<span class="kt">int</span> <span class="n">rev_index</span><span class="p">;</span>

	<span class="cm">/* Did we do any measurement on this rate? */</span>
	<span class="n">bool</span> <span class="n">valid</span><span class="p">;</span>

	<span class="cm">/* Comparison with the lowest rate. */</span>
	<span class="kt">int</span> <span class="n">diff</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rc_pid_info</span> <span class="p">{</span>

	<span class="cm">/* The failed frames percentage target. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

	<span class="cm">/* Rate at which failed frames percentage is sampled in 0.001s. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sampling_period</span><span class="p">;</span>

	<span class="cm">/* P, I and D coefficients. */</span>
	<span class="kt">int</span> <span class="n">coeff_p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coeff_i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coeff_d</span><span class="p">;</span>

	<span class="cm">/* Exponential averaging shift. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">smoothing_shift</span><span class="p">;</span>

	<span class="cm">/* Sharpening factor and duration. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sharpen_factor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sharpen_duration</span><span class="p">;</span>

	<span class="cm">/* Normalization offset. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">norm_offset</span><span class="p">;</span>

	<span class="cm">/* Rates information. */</span>
	<span class="k">struct</span> <span class="n">rc_pid_rateinfo</span> <span class="o">*</span><span class="n">rinfo</span><span class="p">;</span>

	<span class="cm">/* Index of the last used rate. */</span>
	<span class="kt">int</span> <span class="n">oldrate</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MAC80211_DEBUGFS</span>
	<span class="cm">/* Debugfs entries created for the parameters above. */</span>
	<span class="k">struct</span> <span class="n">rc_pid_debugfs_entries</span> <span class="n">dentries</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* RC80211_PID_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
