<!DOCTYPE html>
<html><head><title>joekychen/linux » net › mac80211 › sta_info.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sta_info.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2002-2005, Instant802 Networks, Inc.</span>
<span class="cm"> * Copyright 2006-2007	Jiri Benc &lt;jbenc@suse.cz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>

<span class="cp">#include &lt;net/mac80211.h&gt;</span>
<span class="cp">#include &quot;ieee80211_i.h&quot;</span>
<span class="cp">#include &quot;driver-ops.h&quot;</span>
<span class="cp">#include &quot;rate.h&quot;</span>
<span class="cp">#include &quot;sta_info.h&quot;</span>
<span class="cp">#include &quot;debugfs_sta.h&quot;</span>
<span class="cp">#include &quot;mesh.h&quot;</span>
<span class="cp">#include &quot;wme.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: STA information lifetime rules</span>
<span class="cm"> *</span>
<span class="cm"> * STA info structures (&amp;struct sta_info) are managed in a hash table</span>
<span class="cm"> * for faster lookup and a list for iteration. They are managed using</span>
<span class="cm"> * RCU, i.e. access to the list and hash table is protected by RCU.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon allocating a STA info structure with sta_info_alloc(), the caller</span>
<span class="cm"> * owns that structure. It must then insert it into the hash table using</span>
<span class="cm"> * either sta_info_insert() or sta_info_insert_rcu(); only in the latter</span>
<span class="cm"> * case (which acquires an rcu read section but must not be called from</span>
<span class="cm"> * within one) will the pointer still be valid after the call. Note that</span>
<span class="cm"> * the caller may not do much with the STA info before inserting it, in</span>
<span class="cm"> * particular, it may not start any mesh peer link management or add</span>
<span class="cm"> * encryption keys.</span>
<span class="cm"> *</span>
<span class="cm"> * When the insertion fails (sta_info_insert()) returns non-zero), the</span>
<span class="cm"> * structure will have been freed by sta_info_insert()!</span>
<span class="cm"> *</span>
<span class="cm"> * Station entries are added by mac80211 when you establish a link with a</span>
<span class="cm"> * peer. This means different things for the different type of interfaces</span>
<span class="cm"> * we support. For a regular station this mean we add the AP sta when we</span>
<span class="cm"> * receive an association response from the AP. For IBSS this occurs when</span>
<span class="cm"> * get to know about a peer on the same IBSS. For WDS we add the sta for</span>
<span class="cm"> * the peer immediately upon device open. When using AP mode we add stations</span>
<span class="cm"> * for each respective station upon request from userspace through nl80211.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to remove a STA info structure, various sta_info_destroy_*()</span>
<span class="cm"> * calls are available.</span>
<span class="cm"> *</span>
<span class="cm"> * There is no concept of ownership on a STA entry, each structure is</span>
<span class="cm"> * owned by the global hash table/list until it is removed. All users of</span>
<span class="cm"> * the structure need to be RCU protected so that the structure won&#39;t be</span>
<span class="cm"> * freed before they are done using it.</span>
<span class="cm"> */</span>

<span class="cm">/* Caller must hold local-&gt;sta_mtx */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sta_info_hash_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">)],</span>
				      <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">sta</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">)],</span>
				   <span class="n">s</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sta</span><span class="p">)</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">,</span>
					<span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* protected by RCU */</span>
<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="nf">sta_info_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>

	<span class="n">sta</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH</span><span class="p">(</span><span class="n">addr</span><span class="p">)],</span>
				    <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sta</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span> <span class="o">==</span> <span class="n">sdata</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sta</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">,</span>
					    <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get sta info either from the specified interface</span>
<span class="cm"> * or from one of its vlans</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="nf">sta_info_get_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>

	<span class="n">sta</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH</span><span class="p">(</span><span class="n">addr</span><span class="p">)],</span>
				    <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sta</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span> <span class="o">==</span> <span class="n">sdata</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span> <span class="o">&amp;&amp;</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span> <span class="o">==</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sta</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">,</span>
					    <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="nf">sta_info_get_by_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdata</span> <span class="o">!=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">sta</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sta_info_free - free STA</span>
<span class="cm"> *</span>
<span class="cm"> * @local: pointer to the global information</span>
<span class="cm"> * @sta: STA info to free</span>
<span class="cm"> *</span>
<span class="cm"> * This function must undo everything done by sta_info_alloc()</span>
<span class="cm"> * that may happen before sta_info_insert(). It may only be</span>
<span class="cm"> * called when sta_info_insert() has not been attempted (and</span>
<span class="cm"> * if that fails, the station is freed anyway.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sta_info_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">rate_ctrl</span><span class="p">)</span>
		<span class="n">rate_control_free_sta</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_DEBUG</span>
	<span class="n">wiphy_debug</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">wiphy</span><span class="p">,</span> <span class="s">&quot;Destroyed STA %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAC80211_VERBOSE_DEBUG */</span><span class="cp"></span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold local-&gt;sta_mtx */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sta_info_hash_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">hnext</span> <span class="o">=</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">)];</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_hash</span><span class="p">[</span><span class="n">STA_HASH</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">)],</span> <span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sta_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">wk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>

	<span class="n">sta</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">wk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sta_info</span><span class="p">,</span> <span class="n">drv_unblock_wk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_STA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">ieee80211_sta_ps_deliver_wakeup</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PSPOLL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_DRIVER</span><span class="p">);</span>

		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">ieee80211_sta_ps_deliver_poll_response</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_UAPSD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_DRIVER</span><span class="p">);</span>

		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">ieee80211_sta_ps_deliver_uapsd</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_DRIVER</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sta_prepare_rate_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_HW_HAS_RATE_CONTROL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">rate_ctrl</span> <span class="o">=</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">rate_ctrl</span><span class="p">;</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">rate_ctrl_priv</span> <span class="o">=</span> <span class="n">rate_control_alloc_sta</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">rate_ctrl</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">rate_ctrl_priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="nf">sta_info_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">uptime</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sta</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sta</span><span class="p">)</span> <span class="o">+</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sta_data_size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">drv_unblock_wk</span><span class="p">,</span> <span class="n">sta_unblock</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ampdu_mlme</span><span class="p">.</span><span class="n">work</span><span class="p">,</span> <span class="n">ieee80211_ba_session_work</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ampdu_mlme</span><span class="p">.</span><span class="n">mtx</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span> <span class="o">=</span> <span class="n">local</span><span class="p">;</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">;</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">=</span> <span class="n">IEEE80211_STA_NONE</span><span class="p">;</span>

	<span class="n">do_posix_clock_monotonic_gettime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uptime</span><span class="p">);</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">last_connected</span> <span class="o">=</span> <span class="n">uptime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">ewma_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">avg_signal</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sta_prepare_rate_control</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">gfp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STA_TID_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * timer_to_tid must be initialized with identity mapping</span>
<span class="cm">		 * to enable session_timer&#39;s data differentiation. See</span>
<span class="cm">		 * sta_rx_agg_session_timer_expired for usage.</span>
<span class="cm">		 */</span>
		<span class="n">sta</span><span class="o">-&gt;</span><span class="n">timer_to_tid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_ACS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RX_DATA_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sta</span><span class="o">-&gt;</span><span class="n">last_seq_ctrl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">USHRT_MAX</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_DEBUG</span>
	<span class="n">wiphy_debug</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">wiphy</span><span class="p">,</span> <span class="s">&quot;Allocated STA %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAC80211_VERBOSE_DEBUG */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">plink_state</span> <span class="o">=</span> <span class="n">NL80211_PLINK_LISTEN</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">plink_timer</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">sta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sta_info_insert_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t be a WARN_ON because it can be triggered through a race:</span>
<span class="cm">	 * something inserts a STA (on one CPU) without holding the RTNL</span>
<span class="cm">	 * and another CPU turns off the net device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ieee80211_sdata_running</span><span class="p">(</span><span class="n">sdata</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sta_info_insert_drv_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ieee80211_sta_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">state</span> <span class="o">=</span> <span class="n">IEEE80211_STA_NOTEXIST</span><span class="p">;</span> <span class="n">state</span> <span class="o">&lt;</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span><span class="p">;</span> <span class="n">state</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">drv_sta_state</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drivers using legacy sta_add/sta_remove callbacks only</span>
<span class="cm">		 * get uploaded set to true after sta_add is called.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sta_add</span><span class="p">)</span>
			<span class="n">sta</span><span class="o">-&gt;</span><span class="n">uploaded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_ADHOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;%s: failed to move IBSS STA %pM to state %d (%d) - keeping it anyway.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* unwind on error */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">state</span> <span class="o">&gt;</span> <span class="n">IEEE80211_STA_NOTEXIST</span><span class="p">;</span> <span class="n">state</span><span class="o">--</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">drv_sta_state</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * should be called with sta_mtx locked</span>
<span class="cm"> * this function replaces the mutex lock</span>
<span class="cm"> * with a RCU lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sta_info_insert_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">station_info</span> <span class="n">sinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="cm">/* check if STA exists already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sta_info_get_bss</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* notify driver */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sta_info_insert_drv_state</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">local</span><span class="o">-&gt;</span><span class="n">num_sta</span><span class="o">++</span><span class="p">;</span>
	<span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_generation</span><span class="o">++</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* make the station visible */</span>
	<span class="n">sta_info_hash_add</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>

	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_list</span><span class="p">);</span>

	<span class="n">set_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_INSERTED</span><span class="p">);</span>

	<span class="n">ieee80211_sta_debugfs_add</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="n">rate_control_add_sta_debugfs</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sinfo</span><span class="p">));</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sinfo</span><span class="p">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_generation</span><span class="p">;</span>
	<span class="n">cfg80211_new_sta</span><span class="p">(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sinfo</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_DEBUG</span>
	<span class="n">wiphy_debug</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">wiphy</span><span class="p">,</span> <span class="s">&quot;Inserted STA %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAC80211_VERBOSE_DEBUG */</span><span class="cp"></span>

	<span class="cm">/* move reference to rcu-protected */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_vif_is_mesh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">))</span>
		<span class="n">mesh_accept_plinks_update</span><span class="p">(</span><span class="n">sdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_err:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sta_info_insert_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sta_info_insert_check</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sta_info_insert_finish</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_free:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">);</span>
	<span class="n">sta_info_free</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sta_info_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sta_info_insert_rcu</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__bss_tim_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_if_ap</span> <span class="o">*</span><span class="n">bss</span><span class="p">,</span> <span class="n">u16</span> <span class="n">aid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This format has been mandated by the IEEE specifications,</span>
<span class="cm">	 * so this line may not be changed to use the __set_bit() format.</span>
<span class="cm">	 */</span>
	<span class="n">bss</span><span class="o">-&gt;</span><span class="n">tim</span><span class="p">[</span><span class="n">aid</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">aid</span> <span class="o">%</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__bss_tim_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_if_ap</span> <span class="o">*</span><span class="n">bss</span><span class="p">,</span> <span class="n">u16</span> <span class="n">aid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This format has been mandated by the IEEE specifications,</span>
<span class="cm">	 * so this line may not be changed to use the __clear_bit() format.</span>
<span class="cm">	 */</span>
	<span class="n">bss</span><span class="o">-&gt;</span><span class="n">tim</span><span class="p">[</span><span class="n">aid</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">aid</span> <span class="o">%</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ieee80211_tids_for_ac</span><span class="p">(</span><span class="kt">int</span> <span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we ever support TIDs &gt; 7, this obviously needs to be adjusted */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ac</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_AC_VO</span>:
		<span class="k">return</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IEEE80211_AC_VI</span>:
		<span class="k">return</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IEEE80211_AC_BE</span>:
		<span class="k">return</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IEEE80211_AC_BK</span>:
		<span class="k">return</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sta_info_recalc_tim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_if_ap</span> <span class="o">*</span><span class="n">bss</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">indicate_tim</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ignore_for_tim</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">uapsd_queues</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ac</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* No need to do anything if the driver does all */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_HW_AP_LINK_PS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If all ACs are delivery-enabled then we should build</span>
<span class="cm">	 * the TIM bit for all ACs anyway; if only some are then</span>
<span class="cm">	 * we ignore those and build the TIM bit using only the</span>
<span class="cm">	 * non-enabled ones.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_for_tim</span> <span class="o">==</span> <span class="n">BIT</span><span class="p">(</span><span class="n">IEEE80211_NUM_ACS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ignore_for_tim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ac</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_ACS</span><span class="p">;</span> <span class="n">ac</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tids</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ignore_for_tim</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">indicate_tim</span> <span class="o">|=</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">indicate_tim</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">tids</span> <span class="o">=</span> <span class="n">ieee80211_tids_for_ac</span><span class="p">(</span><span class="n">ac</span><span class="p">);</span>

		<span class="n">indicate_tim</span> <span class="o">|=</span>
			<span class="n">sta</span><span class="o">-&gt;</span><span class="n">driver_buffered_tids</span> <span class="o">&amp;</span> <span class="n">tids</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">done:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">tim_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">indicate_tim</span><span class="p">)</span>
		<span class="n">__bss_tim_set</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">aid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__bss_tim_clear</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">aid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_tim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">tim_in_locked_section</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">drv_set_tim</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">,</span> <span class="n">indicate_tim</span><span class="p">);</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">tim_in_locked_section</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">tim_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">sta_info_buffer_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Timeout: (2 * listen_interval * beacon_int * 1024 / 1000000) sec */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">listen_interval</span> <span class="o">*</span>
		   <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">bss_conf</span><span class="p">.</span><span class="n">beacon_int</span> <span class="o">*</span>
		   <span class="mi">32</span> <span class="o">/</span> <span class="mi">15625</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="n">STA_TX_BUFFER_EXPIRE</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">STA_TX_BUFFER_EXPIRE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">bool</span> <span class="nf">sta_info_cleanup_expire_buffered_ac</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First check for frames that should expire on the filtered</span>
<span class="cm">	 * queue. Frames here were rejected by the driver and are on</span>
<span class="cm">	 * a separate queue to avoid reordering with normal PS-buffered</span>
<span class="cm">	 * frames. They also aren&#39;t accounted for right now in the</span>
<span class="cm">	 * total_ps_buffered counter.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sta_info_buffer_expired</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Frames are queued in order, so if this one</span>
<span class="cm">		 * hasn&#39;t expired yet we can stop testing. If</span>
<span class="cm">		 * we actually reached the end of the queue we</span>
<span class="cm">		 * also need to stop, of course.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now also check the normal PS-buffered queue, this will</span>
<span class="cm">	 * only find something if the filtered queue was emptied</span>
<span class="cm">	 * since the filtered frames are all before the normal PS</span>
<span class="cm">	 * buffered frames.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sta_info_buffer_expired</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * frames are queued in order, so if this one</span>
<span class="cm">		 * hasn&#39;t expired yet (or we reached the end of</span>
<span class="cm">		 * the queue) we can stop testing</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">local</span><span class="o">-&gt;</span><span class="n">total_ps_buffered</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_PS_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Buffered frame expired (STA %pM)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, recalculate the TIM bit for this station -- it might</span>
<span class="cm">	 * now be clear because the station was too slow to retrieve its</span>
<span class="cm">	 * frames.</span>
<span class="cm">	 */</span>
	<span class="n">sta_info_recalc_tim</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return whether there are any frames still buffered, this is</span>
<span class="cm">	 * used to check whether the cleanup timer still needs to run,</span>
<span class="cm">	 * if there are no frames we don&#39;t need to rearm the timer.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		 <span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">]));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">sta_info_cleanup_expire_buffered</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">have_buffered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ac</span><span class="p">;</span>

	<span class="cm">/* This is only necessary for stations on BSS interfaces */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ac</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_ACS</span><span class="p">;</span> <span class="n">ac</span><span class="o">++</span><span class="p">)</span>
		<span class="n">have_buffered</span> <span class="o">|=</span>
			<span class="n">sta_info_cleanup_expire_buffered_ac</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">have_buffered</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">__sta_info_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tid_ampdu_tx</span> <span class="o">*</span><span class="n">tid_tx</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">local</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="n">sdata</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before removing the station from the driver and</span>
<span class="cm">	 * rate control, it might still start new aggregation</span>
<span class="cm">	 * sessions -- block that to make sure the tear-down</span>
<span class="cm">	 * will be sufficient.</span>
<span class="cm">	 */</span>
	<span class="n">set_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_BLOCK_BA</span><span class="p">);</span>
	<span class="n">ieee80211_sta_tear_down_BA_sessions</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sta_info_hash_del</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">key_mtx</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DEFAULT_KEYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__ieee80211_key_free</span><span class="p">(</span><span class="n">key_mtx_dereference</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">gtk</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ptk</span><span class="p">)</span>
		<span class="n">__ieee80211_key_free</span><span class="p">(</span><span class="n">key_mtx_dereference</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">ptk</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">key_mtx</span><span class="p">);</span>

	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">local</span><span class="o">-&gt;</span><span class="n">num_sta</span><span class="o">--</span><span class="p">;</span>
	<span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_generation</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_AP_VLAN</span><span class="p">)</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">vlan</span><span class="p">.</span><span class="n">sta</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">&gt;</span> <span class="n">IEEE80211_STA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sta_info_move_state</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">uploaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drv_sta_state</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">IEEE80211_STA_NONE</span><span class="p">,</span>
				    <span class="n">IEEE80211_STA_NOTEXIST</span><span class="p">);</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, after we wait for an RCU grace period,</span>
<span class="cm">	 * neither mac80211 nor the driver can reference this</span>
<span class="cm">	 * sta struct any more except by still existing timers</span>
<span class="cm">	 * associated with this station that we clean up below.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_STA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="p">);</span>

		<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_STA</span><span class="p">);</span>

		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="o">-&gt;</span><span class="n">num_sta_ps</span><span class="p">);</span>
		<span class="n">sta_info_recalc_tim</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ac</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_ACS</span><span class="p">;</span> <span class="n">ac</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">total_ps_buffered</span> <span class="o">-=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
		<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_vif_is_mesh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">))</span>
		<span class="n">mesh_accept_plinks_update</span><span class="p">(</span><span class="n">sdata</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_DEBUG</span>
	<span class="n">wiphy_debug</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">wiphy</span><span class="p">,</span> <span class="s">&quot;Removed STA %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAC80211_VERBOSE_DEBUG */</span><span class="cp"></span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">drv_unblock_wk</span><span class="p">);</span>

	<span class="n">cfg80211_del_sta</span><span class="p">(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">rate_control_remove_sta_debugfs</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="n">ieee80211_sta_debugfs_remove</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_vif_is_mesh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mesh_plink_deactivate</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">plink_timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Destroy aggregation state here. It would be nice to wait for the</span>
<span class="cm">	 * driver to finish aggregation stop and then clean up, but for now</span>
<span class="cm">	 * drivers have to handle aggregation stop being requested, followed</span>
<span class="cm">	 * directly by station destruction.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STA_TID_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tid_tx</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ampdu_mlme</span><span class="p">.</span><span class="n">tid_tx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tid_tx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_tx</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tid_tx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sta_info_free</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sta_info_destroy_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
	<span class="n">sta</span> <span class="o">=</span> <span class="n">sta_info_get</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sta_info_destroy</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sta_info_destroy_addr_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
	<span class="n">sta</span> <span class="o">=</span> <span class="n">sta_info_get_bss</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sta_info_destroy</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sta_info_cleanup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">timer_needed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sta_info_cleanup_expire_buffered</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">))</span>
			<span class="n">timer_needed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">quiescing</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_needed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_cleanup</span><span class="p">,</span>
		  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">STA_INFO_CLEANUP_INTERVAL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sta_info_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">tim_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_list</span><span class="p">);</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_cleanup</span><span class="p">,</span> <span class="n">sta_info_cleanup</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">local</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sta_info_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_cleanup</span><span class="p">);</span>
	<span class="n">sta_info_flush</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sta_info_flush - flush matching STA entries from the STA table</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of removed STA entries.</span>
<span class="cm"> *</span>
<span class="cm"> * @local: local interface data</span>
<span class="cm"> * @sdata: matching rule for the net device (sta-&gt;dev) or %NULL to match all STAs</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sta_info_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdata</span> <span class="o">||</span> <span class="n">sdata</span> <span class="o">==</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">__sta_info_destroy</span><span class="p">(</span><span class="n">sta</span><span class="p">));</span>
			<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ieee80211_sta_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdata</span> <span class="o">!=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">+</span> <span class="n">exp_time</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_IBSS_DEBUG</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: expiring inactive STA %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">__sta_info_destroy</span><span class="p">(</span><span class="n">sta</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sta_mtx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="nf">ieee80211_find_sta_by_ifaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">localaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="o">*</span><span class="n">nxt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just return a random station if localaddr is NULL</span>
<span class="cm">	 * ... first in list.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_sta_info</span><span class="p">(</span><span class="n">hw_to_local</span><span class="p">(</span><span class="n">hw</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">nxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">localaddr</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">localaddr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">uploaded</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ieee80211_find_sta_by_ifaddr</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="nf">ieee80211_find_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vif</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sta</span> <span class="o">=</span> <span class="n">sta_info_get_bss</span><span class="p">(</span><span class="n">vif_to_sdata</span><span class="p">(</span><span class="n">vif</span><span class="p">),</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">uploaded</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ieee80211_find_sta</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_sta_ps_flags</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span> <span class="o">=</span> <span class="n">_sta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">;</span>

	<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_DRIVER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_STA</span><span class="p">))</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="o">-&gt;</span><span class="n">num_sta_ps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* powersave support code */</span>
<span class="kt">void</span> <span class="nf">ieee80211_sta_ps_deliver_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">pending</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">filtered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ac</span><span class="p">;</span>

	<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_SP</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">STA_TID_NUM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">driver_buffered_tids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IEEE80211_HW_AP_LINK_PS</span><span class="p">))</span>
		<span class="n">drv_sta_notify</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">STA_NOTIFY_AWAKE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">);</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>

	<span class="cm">/* Send all buffered frames to the station */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ac</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_ACS</span><span class="p">;</span> <span class="n">ac</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">),</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">skb_queue_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="n">filtered</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">skb_queue_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="n">buffered</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ieee80211_add_pending_skbs_fn</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="n">clear_sta_ps_flags</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>

	<span class="n">local</span><span class="o">-&gt;</span><span class="n">total_ps_buffered</span> <span class="o">-=</span> <span class="n">buffered</span><span class="p">;</span>

	<span class="n">sta_info_recalc_tim</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_PS_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: STA %pM aid %d sending %d filtered/%d PS frames &quot;</span>
	       <span class="s">&quot;since STA not sleeping anymore</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">aid</span><span class="p">,</span> <span class="n">filtered</span><span class="p">,</span> <span class="n">buffered</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAC80211_VERBOSE_PS_DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ieee80211_send_null_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span>
					 <span class="k">enum</span> <span class="n">ieee80211_frame_release_type</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_qos_hdr</span> <span class="o">*</span><span class="n">nullfunc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nullfunc</span><span class="p">);</span>
	<span class="n">__le16</span> <span class="n">fc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">qos</span> <span class="o">=</span> <span class="n">test_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_WME</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">IEEE80211_FTYPE_DATA</span> <span class="o">|</span>
				 <span class="n">IEEE80211_STYPE_QOS_NULLFUNC</span> <span class="o">|</span>
				 <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">fc</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">IEEE80211_FTYPE_DATA</span> <span class="o">|</span>
				 <span class="n">IEEE80211_STYPE_NULLFUNC</span> <span class="o">|</span>
				 <span class="n">IEEE80211_FCTL_FROMDS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">extra_tx_headroom</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">extra_tx_headroom</span><span class="p">);</span>

	<span class="n">nullfunc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">frame_control</span> <span class="o">=</span> <span class="n">fc</span><span class="p">;</span>
	<span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">duration_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">addr1</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">addr2</span><span class="p">,</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">addr3</span><span class="p">,</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">skb_set_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ieee802_1d_to_ac</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">qos_ctrl</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">IEEE80211_FRAME_RELEASE_UAPSD</span><span class="p">)</span>
			<span class="n">nullfunc</span><span class="o">-&gt;</span><span class="n">qos_ctrl</span> <span class="o">|=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">IEEE80211_QOS_CTL_EOSP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell TX path to send this frame even though the</span>
<span class="cm">	 * STA may still remain is PS mode after this frame</span>
<span class="cm">	 * exchange. Also set EOSP to indicate this packet</span>
<span class="cm">	 * ends the poll/service period.</span>
<span class="cm">	 */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IEEE80211_TX_CTL_NO_PS_BUFFER</span> <span class="o">|</span>
		       <span class="n">IEEE80211_TX_STATUS_EOSP</span> <span class="o">|</span>
		       <span class="n">IEEE80211_TX_CTL_REQ_TX_STATUS</span><span class="p">;</span>

	<span class="n">drv_allow_buffered_frames</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">ieee80211_xmit</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ieee80211_sta_ps_deliver_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">n_frames</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ignored_acs</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">ieee80211_frame_release_type</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_sub_if_data</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">more_data</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ac</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">driver_release_tids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">frames</span><span class="p">;</span>

	<span class="cm">/* Service or PS-Poll period starts */</span>
	<span class="n">set_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_SP</span><span class="p">);</span>

	<span class="n">__skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frames</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get response frame(s) and more data bit for it.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ac</span> <span class="o">&lt;</span> <span class="n">IEEE80211_NUM_ACS</span><span class="p">;</span> <span class="n">ac</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tids</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ignored_acs</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">tids</span> <span class="o">=</span> <span class="n">ieee80211_tids_for_ac</span><span class="p">(</span><span class="n">ac</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">driver_release_tids</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">driver_buffered_tids</span> <span class="o">&amp;</span> <span class="n">tids</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">driver_release_tids</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

				<span class="k">while</span> <span class="p">(</span><span class="n">n_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
							<span class="n">local</span><span class="o">-&gt;</span><span class="n">total_ps_buffered</span><span class="o">--</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="n">n_frames</span><span class="o">--</span><span class="p">;</span>
					<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frames</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the driver has data on more than one TID then</span>
<span class="cm">			 * certainly there&#39;s more data if we release just a</span>
<span class="cm">			 * single frame now (from a single TID).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">IEEE80211_FRAME_RELEASE_PSPOLL</span> <span class="o">&amp;&amp;</span>
			    <span class="n">hweight16</span><span class="p">(</span><span class="n">driver_release_tids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">more_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">driver_release_tids</span> <span class="o">=</span>
					<span class="n">BIT</span><span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">driver_release_tids</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">tx_filtered</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">ps_tx_buf</span><span class="p">[</span><span class="n">ac</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">more_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tid</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For PS-Poll, this can only happen due to a race condition</span>
<span class="cm">		 * when we set the TIM bit and the station notices it, but</span>
<span class="cm">		 * before it can poll for the frame we expire it.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For uAPSD, this is said in the standard (11.2.1.5 h):</span>
<span class="cm">		 *	At each unscheduled SP for a non-AP STA, the AP shall</span>
<span class="cm">		 *	attempt to transmit at least one MSDU or MMPDU, but no</span>
<span class="cm">		 *	more than the value specified in the Max SP Length field</span>
<span class="cm">		 *	in the QoS Capability element from delivery-enabled ACs,</span>
<span class="cm">		 *	that are destined for the non-AP STA.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Since we have no other MSDU/MMPDU, transmit a QoS null frame.</span>
<span class="cm">		 */</span>

		<span class="cm">/* This will evaluate to 1, 3, 5 or 7. */</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">-</span> <span class="p">((</span><span class="n">ffs</span><span class="p">(</span><span class="o">~</span><span class="n">ignored_acs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">ieee80211_send_null_response</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver_release_tids</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">pending</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">tids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frames</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">IEEE80211_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">qoshdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">num</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Tell TX path to send this frame even though the</span>
<span class="cm">			 * STA may still remain is PS mode after this frame</span>
<span class="cm">			 * exchange.</span>
<span class="cm">			 */</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IEEE80211_TX_CTL_NO_PS_BUFFER</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Use MoreData flag to indicate whether there are</span>
<span class="cm">			 * more buffered frames for this STA</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">more_data</span> <span class="o">||</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frames</span><span class="p">))</span>
				<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span> <span class="o">|=</span>
					<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">IEEE80211_FCTL_MOREDATA</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span> <span class="o">&amp;=</span>
					<span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">~</span><span class="n">IEEE80211_FCTL_MOREDATA</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ieee80211_is_data_qos</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">ieee80211_is_qos_nullfunc</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">))</span>
				<span class="n">qoshdr</span> <span class="o">=</span> <span class="n">ieee80211_get_qos_ctl</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

			<span class="cm">/* end service period after last frame */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frames</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">IEEE80211_FRAME_RELEASE_UAPSD</span> <span class="o">&amp;&amp;</span>
				    <span class="n">qoshdr</span><span class="p">)</span>
					<span class="o">*</span><span class="n">qoshdr</span> <span class="o">|=</span> <span class="n">IEEE80211_QOS_CTL_EOSP</span><span class="p">;</span>

				<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IEEE80211_TX_STATUS_EOSP</span> <span class="o">|</span>
					       <span class="n">IEEE80211_TX_CTL_REQ_TX_STATUS</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">qoshdr</span><span class="p">)</span>
				<span class="n">tids</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="o">*</span><span class="n">qoshdr</span> <span class="o">&amp;</span> <span class="n">IEEE80211_QOS_CTL_TID_MASK</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">tids</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">drv_allow_buffered_frames</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">tids</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
					  <span class="n">reason</span><span class="p">,</span> <span class="n">more_data</span><span class="p">);</span>

		<span class="n">ieee80211_add_pending_skbs</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>

		<span class="n">sta_info_recalc_tim</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to release a frame that is buffered somewhere in the</span>
<span class="cm">		 * driver ... it&#39;ll have to handle that.</span>
<span class="cm">		 * Note that, as per the comment above, it&#39;ll also have to see</span>
<span class="cm">		 * if there is more than just one frame on the specific TID that</span>
<span class="cm">		 * we&#39;re releasing from, and it needs to set the more-data bit</span>
<span class="cm">		 * accordingly if we tell it that there&#39;s no more data. If we do</span>
<span class="cm">		 * tell it there&#39;s more data, then of course the more-data bit</span>
<span class="cm">		 * needs to be set anyway.</span>
<span class="cm">		 */</span>
		<span class="n">drv_release_buffered_frames</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">driver_release_tids</span><span class="p">,</span>
					    <span class="n">n_frames</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">more_data</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note that we don&#39;t recalculate the TIM bit here as it would</span>
<span class="cm">		 * most likely have no effect at all unless the driver told us</span>
<span class="cm">		 * that the TID became empty before returning here from the</span>
<span class="cm">		 * release function.</span>
<span class="cm">		 * Either way, however, when the driver tells us that the TID</span>
<span class="cm">		 * became empty we&#39;ll do the TIM recalculation.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ieee80211_sta_ps_deliver_poll_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ignore_for_response</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">uapsd_queues</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If all ACs are delivery-enabled then we should reply</span>
<span class="cm">	 * from any of them, if only some are enabled we reply</span>
<span class="cm">	 * only from the non-enabled ones.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_for_response</span> <span class="o">==</span> <span class="n">BIT</span><span class="p">(</span><span class="n">IEEE80211_NUM_ACS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ignore_for_response</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ieee80211_sta_ps_deliver_response</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ignore_for_response</span><span class="p">,</span>
					  <span class="n">IEEE80211_FRAME_RELEASE_PSPOLL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ieee80211_sta_ps_deliver_uapsd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_frames</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">max_sp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">delivery_enabled</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">uapsd_queues</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we ever grow support for TSPEC this might happen if</span>
<span class="cm">	 * the TSPEC update from hostapd comes in between a trigger</span>
<span class="cm">	 * frame setting WLAN_STA_UAPSD in the RX path and this</span>
<span class="cm">	 * actually getting called.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delivery_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">max_sp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">n_frames</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">n_frames</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">n_frames</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* XXX: what is a good value? */</span>
		<span class="n">n_frames</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ieee80211_sta_ps_deliver_response</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">,</span> <span class="o">~</span><span class="n">delivery_enabled</span><span class="p">,</span>
					  <span class="n">IEEE80211_FRAME_RELEASE_UAPSD</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ieee80211_sta_block_awake</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">pubsta</span><span class="p">,</span> <span class="n">bool</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pubsta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sta_info</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>

	<span class="n">trace_api_sta_block_awake</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">,</span> <span class="n">pubsta</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
		<span class="n">set_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_DRIVER</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_PS_DRIVER</span><span class="p">))</span>
		<span class="n">ieee80211_queue_work</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">drv_unblock_wk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ieee80211_sta_block_awake</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ieee80211_sta_eosp_irqsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">pubsta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pubsta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sta_info</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ieee80211_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_eosp_msg_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">trace_api_eosp</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">pubsta</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* too bad ... but race is better than loss */</span>
		<span class="n">clear_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_SP</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">,</span> <span class="n">pubsta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">iface</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">IEEE80211_EOSP_MSG</span><span class="p">;</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">skb_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ieee80211_sta_eosp_irqsafe</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ieee80211_sta_set_buffered</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">pubsta</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">tid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">buffered</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pubsta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sta_info</span><span class="p">,</span> <span class="n">sta</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">tid</span> <span class="o">&gt;=</span> <span class="n">STA_TID_NUM</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffered</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">driver_buffered_tids</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">driver_buffered_tids</span><span class="p">);</span>

	<span class="n">sta_info_recalc_tim</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ieee80211_sta_set_buffered</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sta_info_move_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sta_info</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">ieee80211_sta_state</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">new_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check allowed transitions first */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">new_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_NONE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">!=</span> <span class="n">IEEE80211_STA_AUTH</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_AUTH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">!=</span> <span class="n">IEEE80211_STA_NONE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">!=</span> <span class="n">IEEE80211_STA_ASSOC</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_ASSOC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">!=</span> <span class="n">IEEE80211_STA_AUTH</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">!=</span> <span class="n">IEEE80211_STA_AUTHORIZED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_AUTHORIZED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">!=</span> <span class="n">IEEE80211_STA_ASSOC</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;invalid state %d&quot;</span><span class="p">,</span> <span class="n">new_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MAC80211_VERBOSE_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: moving STA %pM to state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">new_state</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * notify the driver before the actual changes so it can</span>
<span class="cm">	 * fail the transition</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_sta_flag</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">WLAN_STA_INSERTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">drv_sta_state</span><span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">,</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span>
					<span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span><span class="p">,</span> <span class="n">new_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reflect the change in all state variables */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">new_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_NONE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">IEEE80211_STA_AUTH</span><span class="p">)</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">WLAN_STA_AUTH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_AUTH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">IEEE80211_STA_NONE</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">WLAN_STA_AUTH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">IEEE80211_STA_ASSOC</span><span class="p">)</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">WLAN_STA_ASSOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_ASSOC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">IEEE80211_STA_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">WLAN_STA_ASSOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">IEEE80211_STA_AUTHORIZED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_AP</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_AP_VLAN</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">vlan</span><span class="p">.</span><span class="n">sta</span><span class="p">))</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="o">-&gt;</span><span class="n">num_mcast_sta</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">WLAN_STA_AUTHORIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE80211_STA_AUTHORIZED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">==</span> <span class="n">IEEE80211_STA_ASSOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_AP</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">vif</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_AP_VLAN</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">vlan</span><span class="p">.</span><span class="n">sta</span><span class="p">))</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">bss</span><span class="o">-&gt;</span><span class="n">num_mcast_sta</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">WLAN_STA_AUTHORIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sta</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sta</span><span class="o">-&gt;</span><span class="n">sta_state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
