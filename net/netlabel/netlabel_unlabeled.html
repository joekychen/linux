<!DOCTYPE html>
<html><head><title>joekychen/linux » net › netlabel › netlabel_unlabeled.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netlabel_unlabeled.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NetLabel Unlabeled Support</span>
<span class="cm"> *</span>
<span class="cm"> * This file defines functions for dealing with unlabeled packets for the</span>
<span class="cm"> * NetLabel system.  The NetLabel system manages static and dynamic label</span>
<span class="cm"> * mappings for network protocols such as CIPSO and RIPSO.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Paul Moore &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * (c) Copyright Hewlett-Packard Development Company, L.P., 2006 - 2008</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program;  if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>
<span class="cp">#include &lt;net/genetlink.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/netlabel.h&gt;</span>
<span class="cp">#include &lt;asm/bug.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &quot;netlabel_user.h&quot;</span>
<span class="cp">#include &quot;netlabel_addrlist.h&quot;</span>
<span class="cp">#include &quot;netlabel_domainhash.h&quot;</span>
<span class="cp">#include &quot;netlabel_unlabeled.h&quot;</span>
<span class="cp">#include &quot;netlabel_mgmt.h&quot;</span>

<span class="cm">/* NOTE: at present we always use init&#39;s network namespace since we don&#39;t</span>
<span class="cm"> *       presently support different namespaces even though the majority of</span>
<span class="cm"> *       the functions in this file are &quot;namespace safe&quot; */</span>

<span class="cm">/* The unlabeled connection hash table which we use to map network interfaces</span>
<span class="cm"> * and addresses of unlabeled packets to a user specified secid value for the</span>
<span class="cm"> * LSM.  The hash table is used to lookup the network interface entry</span>
<span class="cm"> * (struct netlbl_unlhsh_iface) and then the interface entry is used to</span>
<span class="cm"> * lookup an IP address match from an ordered list.  If a network interface</span>
<span class="cm"> * match can not be found in the hash table then the default entry</span>
<span class="cm"> * (netlbl_unlhsh_def) is used.  The IP address entry list</span>
<span class="cm"> * (struct netlbl_unlhsh_addr) is ordered such that the entries with a</span>
<span class="cm"> * larger netmask come first.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netlbl_unlhsh_tbl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define netlbl_unlhsh_addr4_entry(iter) \</span>
<span class="cp">	container_of(iter, struct netlbl_unlhsh_addr4, list)</span>
<span class="k">struct</span> <span class="n">netlbl_unlhsh_addr4</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define netlbl_unlhsh_addr6_entry(iter) \</span>
<span class="cp">	container_of(iter, struct netlbl_unlhsh_addr6, list)</span>
<span class="k">struct</span> <span class="n">netlbl_unlhsh_addr6</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">addr4_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">addr6_list</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">valid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Argument struct for netlbl_unlhsh_walk() */</span>
<span class="k">struct</span> <span class="n">netlbl_unlhsh_walk_arg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">nl_cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Unlabeled connection hash table */</span>
<span class="cm">/* updates should be so rare that having one spinlock for the entire</span>
<span class="cm"> * hash table should be okay */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
<span class="cp">#define netlbl_unlhsh_rcu_deref(p) \</span>
<span class="cp">	rcu_dereference_check(p, lockdep_is_held(&amp;netlbl_unlhsh_lock))</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_tbl</span> <span class="o">*</span><span class="n">netlbl_unlhsh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">netlbl_unlhsh_def</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Accept unlabeled packets flag */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">netlabel_unlabel_acceptflg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* NetLabel Generic NETLINK unlabeled family */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">genl_family</span> <span class="n">netlbl_unlabel_gnl_family</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">GENL_ID_GENERATE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hdrsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">NETLBL_PROTO_VERSION</span><span class="p">,</span>
	<span class="p">.</span><span class="n">maxattr</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_A_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* NetLabel Netlink attribute policy */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_ACPTFLG</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U8</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span><span class="p">,</span>
				      <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span><span class="p">,</span>
				      <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span><span class="p">,</span>
				      <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span><span class="p">,</span>
				      <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_IFACE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_NUL_STRING</span><span class="p">,</span>
				   <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Unlabeled Connection Hash Table Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_free_iface - Frees an interface entry from the hash table</span>
<span class="cm"> * @entry: the entry&#39;s RCU field</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function is designed to be used as a callback to the call_rcu()</span>
<span class="cm"> * function so that memory allocated to a hash table interface entry can be</span>
<span class="cm"> * released safely.  It is important to note that this function does not free</span>
<span class="cm"> * the IPv4 and IPv6 address lists contained as part of an interface entry.  It</span>
<span class="cm"> * is up to the rest of the code to make sure an interface entry is only freed</span>
<span class="cm"> * once it&#39;s address lists are empty.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netlbl_unlhsh_free_iface</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">iter4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">tmp4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">iter6</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">tmp6</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

	<span class="n">iface</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="cm">/* no need for locks here since we are the only one with access to this</span>
<span class="cm">	 * structure */</span>

	<span class="n">netlbl_af4list_foreach_safe</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span> <span class="n">tmp4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netlbl_af4list_remove_entry</span><span class="p">(</span><span class="n">iter4</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">netlbl_unlhsh_addr4_entry</span><span class="p">(</span><span class="n">iter4</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="n">netlbl_af6list_foreach_safe</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span> <span class="n">tmp6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netlbl_af6list_remove_entry</span><span class="p">(</span><span class="n">iter6</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">netlbl_unlhsh_addr6_entry</span><span class="p">(</span><span class="n">iter6</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_hash - Hashing function for the hash table</span>
<span class="cm"> * @ifindex: the network interface/device to hash</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This is the hashing function for the unlabeled hash table, it returns the</span>
<span class="cm"> * bucket number for the given device/interface.  The caller is responsible for</span>
<span class="cm"> * ensuring that the hash table is protected with either a RCU read lock or</span>
<span class="cm"> * the hash table lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">netlbl_unlhsh_hash</span><span class="p">(</span><span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ifindex</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">netlbl_unlhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_unlhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_search_iface - Search for a matching interface entry</span>
<span class="cm"> * @ifindex: the network interface</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Searches the unlabeled connection hash table and returns a pointer to the</span>
<span class="cm"> * interface entry which matches @ifindex, otherwise NULL is returned.  The</span>
<span class="cm"> * caller is responsible for ensuring that the hash table is protected with</span>
<span class="cm"> * either a RCU read lock or the hash table lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="nf">netlbl_unlhsh_search_iface</span><span class="p">(</span><span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">bkt_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">bkt</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_hash</span><span class="p">(</span><span class="n">ifindex</span><span class="p">);</span>
	<span class="n">bkt_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netlbl_unlhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_unlhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">bkt</span><span class="p">];</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">bkt_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">ifindex</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_add_addr4 - Add a new IPv4 address entry to the hash table</span>
<span class="cm"> * @iface: the associated interface entry</span>
<span class="cm"> * @addr: IPv4 address in network byte order</span>
<span class="cm"> * @mask: IPv4 address mask in network byte order</span>
<span class="cm"> * @secid: LSM secid value for entry</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Add a new address entry into the unlabeled connection hash table using the</span>
<span class="cm"> * interface entry specified by @iface.  On success zero is returned, otherwise</span>
<span class="cm"> * a negative value is returned.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlhsh_add_addr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_addr4</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_addr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">secid</span> <span class="o">=</span> <span class="n">secid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af4list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_add_addr6 - Add a new IPv6 address entry to the hash table</span>
<span class="cm"> * @iface: the associated interface entry</span>
<span class="cm"> * @addr: IPv6 address in network byte order</span>
<span class="cm"> * @mask: IPv6 address mask in network byte order</span>
<span class="cm"> * @secid: LSM secid value for entry</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Add a new address entry into the unlabeled connection hash table using the</span>
<span class="cm"> * interface entry specified by @iface.  On success zero is returned, otherwise</span>
<span class="cm"> * a negative value is returned.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlhsh_add_addr6</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_addr6</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">secid</span> <span class="o">=</span> <span class="n">secid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af6list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_add_iface - Adds a new interface entry to the hash table</span>
<span class="cm"> * @ifindex: network interface</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Add a new, empty, interface entry into the unlabeled connection hash table.</span>
<span class="cm"> * On success a pointer to the new interface entry is returned, on failure NULL</span>
<span class="cm"> * is returned.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="nf">netlbl_unlhsh_add_iface</span><span class="p">(</span><span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>

	<span class="n">iface</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iface</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">);</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ifindex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bkt</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_hash</span><span class="p">(</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_unlhsh_search_iface</span><span class="p">(</span><span class="n">ifindex</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">add_iface_failure</span><span class="p">;</span>
		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">netlbl_unlhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_unlhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">bkt</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_unlhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">add_iface_failure</span><span class="p">;</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">,</span> <span class="n">iface</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iface</span><span class="p">;</span>

<span class="nl">add_iface_failure:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_add - Adds a new entry to the unlabeled connection hash table</span>
<span class="cm"> * @net: network namespace</span>
<span class="cm"> * @dev_name: interface name</span>
<span class="cm"> * @addr: IP address in network byte order</span>
<span class="cm"> * @mask: address mask in network byte order</span>
<span class="cm"> * @addr_len: length of address/mask (4 for IPv4, 16 for IPv6)</span>
<span class="cm"> * @secid: LSM secid value for the entry</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds a new entry to the unlabeled connection hash table.  Returns zero on</span>
<span class="cm"> * success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_unlhsh_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">addr_len</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">secid</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secctx_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlhsh_add_return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ifindex</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_search_iface</span><span class="p">(</span><span class="n">ifindex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ifindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_add_iface</span><span class="p">(</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlhsh_add_return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">AUDIT_MAC_UNLBL_STCADD</span><span class="p">,</span>
					      <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">addr_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span>: <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr4</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask4</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_add_addr4</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">addr4</span><span class="p">,</span> <span class="n">mask4</span><span class="p">,</span> <span class="n">secid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">netlbl_af4list_audit_addr</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						  <span class="n">dev_name</span><span class="p">,</span>
						  <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">,</span>
						  <span class="n">mask4</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">)</span>: <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr6</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">mask6</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_add_addr6</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">addr6</span><span class="p">,</span> <span class="n">mask6</span><span class="p">,</span> <span class="n">secid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">netlbl_af6list_audit_addr</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						  <span class="n">dev_name</span><span class="p">,</span>
						  <span class="n">addr6</span><span class="p">,</span> <span class="n">mask6</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlabel_mgmt_protocount</span><span class="p">);</span>

<span class="nl">unlhsh_add_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">secid</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">secctx</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">secctx_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; sec_obj=%s&quot;</span><span class="p">,</span> <span class="n">secctx</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">secctx</span><span class="p">,</span> <span class="n">secctx_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; res=%u&quot;</span><span class="p">,</span> <span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_remove_addr4 - Remove an IPv4 address entry</span>
<span class="cm"> * @net: network namespace</span>
<span class="cm"> * @iface: interface entry</span>
<span class="cm"> * @addr: IP address</span>
<span class="cm"> * @mask: IP address mask</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Remove an IP address entry from the unlabeled connection hash table.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlhsh_remove_addr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">list_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_addr4</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secctx_len</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">list_entry</span> <span class="o">=</span> <span class="n">netlbl_af4list_remove</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_addr4_entry</span><span class="p">(</span><span class="n">list_entry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">AUDIT_MAC_UNLBL_STCDEL</span><span class="p">,</span>
					      <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="n">netlbl_af4list_audit_addr</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">),</span>
					  <span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">secctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; sec_obj=%s&quot;</span><span class="p">,</span> <span class="n">secctx</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">secctx</span><span class="p">,</span> <span class="n">secctx_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; res=%u&quot;</span><span class="p">,</span> <span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_remove_addr6 - Remove an IPv6 address entry</span>
<span class="cm"> * @net: network namespace</span>
<span class="cm"> * @iface: interface entry</span>
<span class="cm"> * @addr: IP address</span>
<span class="cm"> * @mask: IP address mask</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Remove an IP address entry from the unlabeled connection hash table.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlhsh_remove_addr6</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">list_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_addr6</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secctx_len</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">list_entry</span> <span class="o">=</span> <span class="n">netlbl_af6list_remove</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_addr6_entry</span><span class="p">(</span><span class="n">list_entry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">AUDIT_MAC_UNLBL_STCDEL</span><span class="p">,</span>
					      <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="n">netlbl_af6list_audit_addr</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">),</span>
					  <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">secctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; sec_obj=%s&quot;</span><span class="p">,</span> <span class="n">secctx</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">secctx</span><span class="p">,</span> <span class="n">secctx_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; res=%u&quot;</span><span class="p">,</span> <span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_condremove_iface - Remove an interface entry</span>
<span class="cm"> * @iface: the interface entry</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Remove an interface entry from the unlabeled connection hash table if it is</span>
<span class="cm"> * empty.  An interface entry is considered to be empty if there are no</span>
<span class="cm"> * address entries assigned to it.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netlbl_unlhsh_condremove_iface</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">iter4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">iter6</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlhsh_condremove_failure</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="n">netlbl_af6list_foreach_rcu</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlhsh_condremove_failure</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>

	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">netlbl_unlhsh_free_iface</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">unlhsh_condremove_failure:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_remove - Remove an entry from the unlabeled hash table</span>
<span class="cm"> * @net: network namespace</span>
<span class="cm"> * @dev_name: interface name</span>
<span class="cm"> * @addr: IP address in network byte order</span>
<span class="cm"> * @mask: address mask in network byte order</span>
<span class="cm"> * @addr_len: length of address/mask (4 for IPv4, 16 for IPv6)</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes and existing entry from the unlabeled connection hash table.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_unlhsh_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">addr_len</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlhsh_remove_return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_search_iface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlhsh_remove_return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">addr_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_remove_addr4</span><span class="p">(</span><span class="n">net</span><span class="p">,</span>
						     <span class="n">iface</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
						     <span class="n">audit_info</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">)</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_remove_addr6</span><span class="p">(</span><span class="n">net</span><span class="p">,</span>
						     <span class="n">iface</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
						     <span class="n">audit_info</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netlbl_unlhsh_condremove_iface</span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlabel_mgmt_protocount</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">unlhsh_remove_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * General Helper Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlhsh_netdev_handler - Network device notification handler</span>
<span class="cm"> * @this: notifier block</span>
<span class="cm"> * @event: the event</span>
<span class="cm"> * @ptr: the network device (cast to void)</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Handle network device events, although at present all we care about is a</span>
<span class="cm"> * network device going away.  In the case of a device going away we clear any</span>
<span class="cm"> * related entries from the unlabeled connection hash table.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlhsh_netdev_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="cm">/* XXX - should this be a check for NETDEV_DOWN or _UNREGISTER? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_DOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_search_iface</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">iface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">netlbl_unlhsh_free_iface</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_acceptflg_set - Set the unlabeled accept flag</span>
<span class="cm"> * @value: desired value</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Set the value of the unlabeled accept flag to @value.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netlbl_unlabel_acceptflg_set</span><span class="p">(</span><span class="n">u8</span> <span class="n">value</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">old_val</span><span class="p">;</span>

	<span class="n">old_val</span> <span class="o">=</span> <span class="n">netlabel_unlabel_acceptflg</span><span class="p">;</span>
	<span class="n">netlabel_unlabel_acceptflg</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">AUDIT_MAC_UNLBL_ALLOW</span><span class="p">,</span>
					      <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span>
				 <span class="s">&quot; unlbl_accept=%u old=%u&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">old_val</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_addrinfo_get - Get the IPv4/6 address information</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> * @addr: the IP address</span>
<span class="cm"> * @mask: the IP address mask</span>
<span class="cm"> * @len: the address length</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Examine the Generic NETLINK message and extract the IP address information.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_addrinfo_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">**</span><span class="n">addr</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">**</span><span class="n">mask</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">addr_len</span> <span class="o">=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">addr_len</span> <span class="o">!=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">addr_len</span> <span class="o">=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">addr_len</span> <span class="o">!=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel Command Handlers</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_accept - Handle an ACCEPT message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated ACCEPT message and set the accept flag accordingly.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_ACPTFLG</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">nla_get_u8</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_ACPTFLG</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netlbl_netlink_auditinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
			<span class="n">netlbl_unlabel_acceptflg_set</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_list - Handle a LIST message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated LIST message and respond with the current status.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ans_skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">ans_skb</span> <span class="o">=</span> <span class="n">nlmsg_new</span><span class="p">(</span><span class="n">NLMSG_DEFAULT_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ans_skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">list_failure</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">genlmsg_put_reply</span><span class="p">(</span><span class="n">ans_skb</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netlbl_unlabel_gnl_family</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="n">NLBL_UNLABEL_C_LIST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">list_failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put_u8</span><span class="p">(</span><span class="n">ans_skb</span><span class="p">,</span>
			     <span class="n">NLBL_UNLABEL_A_ACPTFLG</span><span class="p">,</span>
			     <span class="n">netlabel_unlabel_acceptflg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">list_failure</span><span class="p">;</span>

	<span class="n">genlmsg_end</span><span class="p">(</span><span class="n">ans_skb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">genlmsg_reply</span><span class="p">(</span><span class="n">ans_skb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

<span class="nl">list_failure:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ans_skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticadd - Handle a STATICADD message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated STATICADD message and add a new unlabeled</span>
<span class="cm"> * connection entry to the hash table.  Returns zero on success, negative</span>
<span class="cm"> * values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow users to add both IPv4 and IPv6 addresses for a</span>
<span class="cm">	 * single entry.  However, allow users to create two entries, one each</span>
<span class="cm">	 * for IPv4 and IPv4, with the same LSM security context which should</span>
<span class="cm">	 * achieve the same result. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IFACE</span><span class="p">]</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">((</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">])</span> <span class="o">^</span>
	      <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">])))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">netlbl_netlink_auditinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlabel_addrinfo_get</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">dev_name</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IFACE</span><span class="p">]);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">security_secctx_to_secid</span><span class="p">(</span>
		                  <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]),</span>
				  <span class="n">nla_len</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]),</span>
				  <span class="o">&amp;</span><span class="n">secid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">netlbl_unlhsh_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span>
				 <span class="n">dev_name</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="n">secid</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticadddef - Handle a STATICADDDEF message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated STATICADDDEF message and add a new default</span>
<span class="cm"> * unlabeled connection entry.  Returns zero on success, negative values on</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticadddef</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow users to add both IPv4 and IPv6 addresses for a</span>
<span class="cm">	 * single entry.  However, allow users to create two entries, one each</span>
<span class="cm">	 * for IPv4 and IPv6, with the same LSM security context which should</span>
<span class="cm">	 * achieve the same result. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">((</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">])</span> <span class="o">^</span>
	      <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">])))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">netlbl_netlink_auditinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlabel_addrinfo_get</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">security_secctx_to_secid</span><span class="p">(</span>
		                  <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]),</span>
				  <span class="n">nla_len</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">]),</span>
				  <span class="o">&amp;</span><span class="n">secid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">netlbl_unlhsh_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="n">secid</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticremove - Handle a STATICREMOVE message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated STATICREMOVE message and remove the specified</span>
<span class="cm"> * unlabeled connection entry.  Returns zero on success, negative values on</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticremove</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>

	<span class="cm">/* See the note in netlbl_unlabel_staticadd() about not allowing both</span>
<span class="cm">	 * IPv4 and IPv6 in the same entry. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IFACE</span><span class="p">]</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">((</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">])</span> <span class="o">^</span>
	      <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">])))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">netlbl_netlink_auditinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlabel_addrinfo_get</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">dev_name</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IFACE</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">netlbl_unlhsh_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span>
				    <span class="n">dev_name</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticremovedef - Handle a STATICREMOVEDEF message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @info: the Generic NETLINK info block</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated STATICREMOVEDEF message and remove the default</span>
<span class="cm"> * unlabeled connection entry.  Returns zero on success, negative values on</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticremovedef</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>

	<span class="cm">/* See the note in netlbl_unlabel_staticadd() about not allowing both</span>
<span class="cm">	 * IPv4 and IPv6 in the same entry. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">])</span> <span class="o">^</span>
	      <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">]</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">])))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">netlbl_netlink_auditinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlabel_addrinfo_get</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">netlbl_unlhsh_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span>
				    <span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticlist_gen - Generate messages for STATICLIST[DEF]</span>
<span class="cm"> * @cmd: command/message</span>
<span class="cm"> * @iface: the interface entry</span>
<span class="cm"> * @addr4: the IPv4 address entry</span>
<span class="cm"> * @addr6: the IPv6 address entry</span>
<span class="cm"> * @arg: the netlbl_unlhsh_walk_arg structure</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function is designed to be used to generate a response for a</span>
<span class="cm"> * STATICLIST or STATICLISTDEF message.  When called either @addr4 or @addr6</span>
<span class="cm"> * can be specified, not both, the other unspecified entry should be set to</span>
<span class="cm"> * NULL by the caller.  Returns the size of the message on success, negative</span>
<span class="cm"> * values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticlist_gen</span><span class="p">(</span><span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_addr4</span> <span class="o">*</span><span class="n">addr4</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_unlhsh_addr6</span> <span class="o">*</span><span class="n">addr6</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_walk_arg</span> <span class="o">*</span><span class="n">cb_arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secctx_len</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">genlmsg_put</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">nl_cb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span>
			   <span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netlbl_unlabel_gnl_family</span><span class="p">,</span>
			   <span class="n">NLM_F_MULTI</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put_string</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
					 <span class="n">NLBL_UNLABEL_A_IFACE</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">addr_struct</span><span class="p">;</span>

		<span class="n">addr_struct</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
				  <span class="n">NLBL_UNLABEL_A_IPV4ADDR</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">),</span>
				  <span class="o">&amp;</span><span class="n">addr_struct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>

		<span class="n">addr_struct</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
				  <span class="n">NLBL_UNLABEL_A_IPV4MASK</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">),</span>
				  <span class="o">&amp;</span><span class="n">addr_struct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>

		<span class="n">secid</span> <span class="o">=</span> <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
				  <span class="n">NLBL_UNLABEL_A_IPV6ADDR</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">),</span>
				  <span class="o">&amp;</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
				  <span class="n">NLBL_UNLABEL_A_IPV6MASK</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">),</span>
				  <span class="o">&amp;</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>

		<span class="n">secid</span> <span class="o">=</span> <span class="n">addr6</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">secid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span>
			  <span class="n">NLBL_UNLABEL_A_SECCTX</span><span class="p">,</span>
			  <span class="n">secctx_len</span><span class="p">,</span>
			  <span class="n">secctx</span><span class="p">);</span>
	<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">secctx</span><span class="p">,</span> <span class="n">secctx_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">list_cb_failure</span><span class="p">;</span>

	<span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">seq</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">genlmsg_end</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

<span class="nl">list_cb_failure:</span>
	<span class="n">genlmsg_cancel</span><span class="p">(</span><span class="n">cb_arg</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticlist - Handle a STATICLIST message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @cb: the NETLINK callback</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated STATICLIST message and dump the unlabeled</span>
<span class="cm"> * connection hash table in a form suitable for use in a kernel generated</span>
<span class="cm"> * STATICLIST message.  Returns the length of @skb.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticlist</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_walk_arg</span> <span class="n">cb_arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">skip_bkt</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">skip_chain</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">skip_addr4</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">skip_addr6</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">iter_bkt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iter_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iter_addr4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iter_addr6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">iter_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">addr4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">addr6</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">cb_arg</span><span class="p">.</span><span class="n">nl_cb</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">cb_arg</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">cb_arg</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iter_bkt</span> <span class="o">=</span> <span class="n">skip_bkt</span><span class="p">;</span>
	     <span class="n">iter_bkt</span> <span class="o">&lt;</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_unlhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	     <span class="n">iter_bkt</span><span class="o">++</span><span class="p">,</span> <span class="n">iter_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iter_addr4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iter_addr6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_unlhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">iter_bkt</span><span class="p">];</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">iter_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">||</span>
			    <span class="n">iter_chain</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">skip_chain</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">addr4</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iter_addr4</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">skip_addr4</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_unlabel_staticlist_gen</span><span class="p">(</span>
					      <span class="n">NLBL_UNLABEL_C_STATICLIST</span><span class="p">,</span>
					      <span class="n">iface</span><span class="p">,</span>
					      <span class="n">netlbl_unlhsh_addr4_entry</span><span class="p">(</span><span class="n">addr4</span><span class="p">),</span>
					      <span class="nb">NULL</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">cb_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">iter_addr4</span><span class="o">--</span><span class="p">;</span>
					<span class="n">iter_chain</span><span class="o">--</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">unlabel_staticlist_return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
			<span class="n">netlbl_af6list_foreach_rcu</span><span class="p">(</span><span class="n">addr6</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iter_addr6</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">skip_addr6</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_unlabel_staticlist_gen</span><span class="p">(</span>
					      <span class="n">NLBL_UNLABEL_C_STATICLIST</span><span class="p">,</span>
					      <span class="n">iface</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">,</span>
					      <span class="n">netlbl_unlhsh_addr6_entry</span><span class="p">(</span><span class="n">addr6</span><span class="p">),</span>
					      <span class="o">&amp;</span><span class="n">cb_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">iter_addr6</span><span class="o">--</span><span class="p">;</span>
					<span class="n">iter_chain</span><span class="o">--</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">unlabel_staticlist_return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">unlabel_staticlist_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_bkt</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_chain</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_addr4</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_addr6</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_staticlistdef - Handle a STATICLISTDEF message</span>
<span class="cm"> * @skb: the NETLINK buffer</span>
<span class="cm"> * @cb: the NETLINK callback</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Process a user generated STATICLISTDEF message and dump the default</span>
<span class="cm"> * unlabeled connection entry in a form suitable for use in a kernel generated</span>
<span class="cm"> * STATICLISTDEF message.  Returns the length of @skb.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netlbl_unlabel_staticlistdef</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_walk_arg</span> <span class="n">cb_arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">skip_addr4</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">skip_addr6</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">iter_addr4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">addr4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="n">u32</span> <span class="n">iter_addr6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">addr6</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">cb_arg</span><span class="p">.</span><span class="n">nl_cb</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">cb_arg</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">cb_arg</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">iface</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlabel_staticlistdef_return</span><span class="p">;</span>

	<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">addr4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter_addr4</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">skip_addr4</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_unlabel_staticlist_gen</span><span class="p">(</span><span class="n">NLBL_UNLABEL_C_STATICLISTDEF</span><span class="p">,</span>
					      <span class="n">iface</span><span class="p">,</span>
					      <span class="n">netlbl_unlhsh_addr4_entry</span><span class="p">(</span><span class="n">addr4</span><span class="p">),</span>
					      <span class="nb">NULL</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">cb_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter_addr4</span><span class="o">--</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlabel_staticlistdef_return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="n">netlbl_af6list_foreach_rcu</span><span class="p">(</span><span class="n">addr6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter_addr6</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">skip_addr6</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_unlabel_staticlist_gen</span><span class="p">(</span><span class="n">NLBL_UNLABEL_C_STATICLISTDEF</span><span class="p">,</span>
					      <span class="n">iface</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">,</span>
					      <span class="n">netlbl_unlhsh_addr6_entry</span><span class="p">(</span><span class="n">addr6</span><span class="p">),</span>
					      <span class="o">&amp;</span><span class="n">cb_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter_addr6</span><span class="o">--</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlabel_staticlistdef_return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

<span class="nl">unlabel_staticlistdef_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_addr4</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">skip_addr6</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel Generic NETLINK Command Definitions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">genl_ops</span> <span class="n">netlbl_unlabel_genl_ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_STATICADD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GENL_ADMIN_PERM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_staticadd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_STATICREMOVE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GENL_ADMIN_PERM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_staticremove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_STATICLIST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_staticlist</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_STATICADDDEF</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GENL_ADMIN_PERM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_staticadddef</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_STATICREMOVEDEF</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GENL_ADMIN_PERM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_staticremovedef</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_STATICLISTDEF</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_staticlistdef</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_ACCEPT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">GENL_ADMIN_PERM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NLBL_UNLABEL_C_LIST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">netlbl_unlabel_genl_policy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">doit</span> <span class="o">=</span> <span class="n">netlbl_unlabel_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dumpit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel Generic NETLINK Protocol Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_genl_init - Register the Unlabeled NetLabel component</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Register the unlabeled packet NetLabel component with the Generic NETLINK</span>
<span class="cm"> * mechanism.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">netlbl_unlabel_genl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">genl_register_family_with_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlabel_gnl_family</span><span class="p">,</span>
		<span class="n">netlbl_unlabel_genl_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">netlbl_unlabel_genl_ops</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel KAPI Hooks</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">netlbl_unlhsh_netdev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_netdev_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_init - Initialize the unlabeled connection hash table</span>
<span class="cm"> * @size: the number of bits to use for the hash buckets</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Initializes the unlabeled connection hash table and registers a network</span>
<span class="cm"> * device notification handler.  This function should only be called by the</span>
<span class="cm"> * NetLabel subsystem itself during initialization.  Returns zero on success,</span>
<span class="cm"> * non-zero values on error.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">netlbl_unlabel_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_tbl</span> <span class="o">*</span><span class="n">hsh_tbl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hsh_tbl</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hsh_tbl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsh_tbl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">tbl</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">tbl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hsh_tbl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">iter</span><span class="p">]);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">netlbl_unlhsh</span><span class="p">,</span> <span class="n">hsh_tbl</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_lock</span><span class="p">);</span>

	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_unlhsh_netdev_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_getattr - Get the security attributes for an unlabled packet</span>
<span class="cm"> * @skb: the packet</span>
<span class="cm"> * @family: protocol family</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Determine the security attributes, if any, for an unlabled packet and return</span>
<span class="cm"> * them in @secattr.  Returns zero on success and negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_unlabel_getattr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_unlhsh_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">iface</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_search_iface</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_unlhsh_def</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iface</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlabel_getattr_nolabel</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_INET</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">hdr4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">addr4</span><span class="p">;</span>

		<span class="n">hdr4</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">addr4</span> <span class="o">=</span> <span class="n">netlbl_af4list_search</span><span class="p">(</span><span class="n">hdr4</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr4_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr4</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlabel_getattr_nolabel</span><span class="p">;</span>
		<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">secid</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_addr4_entry</span><span class="p">(</span><span class="n">addr4</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">PF_INET6</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">hdr6</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">addr6</span><span class="p">;</span>

		<span class="n">hdr6</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">addr6</span> <span class="o">=</span> <span class="n">netlbl_af6list_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr6</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">addr6_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr6</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlabel_getattr_nolabel</span><span class="p">;</span>
		<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">secid</span> <span class="o">=</span> <span class="n">netlbl_unlhsh_addr6_entry</span><span class="p">(</span><span class="n">addr6</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">unlabel_getattr_nolabel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NETLBL_SECATTR_SECID</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unlabel_getattr_nolabel:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netlabel_unlabel_acceptflg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
	<span class="n">secattr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_unlabel_defconf - Set the default config to allow unlabeled packets</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Set the default NetLabel configuration to allow incoming unlabeled packets</span>
<span class="cm"> * and to send unlabeled network traffic by default.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">netlbl_unlabel_defconf</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="n">audit_info</span><span class="p">;</span>

	<span class="cm">/* Only the kernel is allowed to call this function and the only time</span>
<span class="cm">	 * it is called is at bootup before the audit subsystem is reporting</span>
<span class="cm">	 * messages so don&#39;t worry to much about these values. */</span>
	<span class="n">security_task_getsecid</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">.</span><span class="n">secid</span><span class="p">);</span>
	<span class="n">audit_info</span><span class="p">.</span><span class="n">loginuid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">audit_info</span><span class="p">.</span><span class="n">sessionid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_domhsh_add_default</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">netlbl_unlabel_acceptflg_set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
