<!DOCTYPE html>
<html><head><title>joekychen/linux » net › netlabel › netlabel_domainhash.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netlabel_domainhash.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NetLabel Domain Hash Table</span>
<span class="cm"> *</span>
<span class="cm"> * This file manages the domain hash table that NetLabel uses to determine</span>
<span class="cm"> * which network labeling protocol to use for a given domain.  The NetLabel</span>
<span class="cm"> * system manages static and dynamic label mappings for network protocols such</span>
<span class="cm"> * as CIPSO and RIPSO.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Paul Moore &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * (c) Copyright Hewlett-Packard Development Company, L.P., 2006, 2008</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program;  if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/netlabel.h&gt;</span>
<span class="cp">#include &lt;net/cipso_ipv4.h&gt;</span>
<span class="cp">#include &lt;asm/bug.h&gt;</span>

<span class="cp">#include &quot;netlabel_mgmt.h&quot;</span>
<span class="cp">#include &quot;netlabel_addrlist.h&quot;</span>
<span class="cp">#include &quot;netlabel_domainhash.h&quot;</span>
<span class="cp">#include &quot;netlabel_user.h&quot;</span>

<span class="k">struct</span> <span class="n">netlbl_domhsh_tbl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Domain hash table */</span>
<span class="cm">/* updates should be so rare that having one spinlock for the entire hash table</span>
<span class="cm"> * should be okay */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>
<span class="cp">#define netlbl_domhsh_rcu_deref(p) \</span>
<span class="cp">	rcu_dereference_check(p, lockdep_is_held(&amp;netlbl_domhsh_lock))</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_domhsh_tbl</span> <span class="o">*</span><span class="n">netlbl_domhsh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">netlbl_domhsh_def</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Domain Hash Table Helper Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_free_entry - Frees a domain hash table entry</span>
<span class="cm"> * @entry: the entry&#39;s RCU field</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function is designed to be used as a callback to the call_rcu()</span>
<span class="cm"> * function so that the memory allocated to a hash table entry can be released</span>
<span class="cm"> * safely.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netlbl_domhsh_free_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">iter4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">tmp4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">iter6</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">tmp6</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlbl_dom_map</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netlbl_af4list_foreach_safe</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span> <span class="n">tmp4</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netlbl_af4list_remove_entry</span><span class="p">(</span><span class="n">iter4</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">netlbl_domhsh_addr4_entry</span><span class="p">(</span><span class="n">iter4</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="n">netlbl_af6list_foreach_safe</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span> <span class="n">tmp6</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netlbl_af6list_remove_entry</span><span class="p">(</span><span class="n">iter6</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">netlbl_domhsh_addr6_entry</span><span class="p">(</span><span class="n">iter6</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_hash - Hashing function for the domain hash table</span>
<span class="cm"> * @domain: the domain name to hash</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This is the hashing function for the domain hash table, it returns the</span>
<span class="cm"> * correct bucket number for the domain.  The caller is responsible for</span>
<span class="cm"> * ensuring that the hash table is protected with either a RCU read lock or the</span>
<span class="cm"> * hash table lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">netlbl_domhsh_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iter</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* This is taken (with slight modification) from</span>
<span class="cm">	 * security/selinux/ss/symtab.c:symhash() */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">);</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)))</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">netlbl_domhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_domhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_search - Search for a domain entry</span>
<span class="cm"> * @domain: the domain</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Searches the domain hash table and returns a pointer to the hash table</span>
<span class="cm"> * entry if found, otherwise NULL is returned.  The caller is responsible for</span>
<span class="cm"> * ensuring that the hash table is protected with either a RCU read lock or the</span>
<span class="cm"> * hash table lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="nf">netlbl_domhsh_search</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">bkt_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bkt</span> <span class="o">=</span> <span class="n">netlbl_domhsh_hash</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="n">bkt_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netlbl_domhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_domhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">bkt</span><span class="p">];</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">bkt_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_search_def - Search for a domain entry</span>
<span class="cm"> * @domain: the domain</span>
<span class="cm"> * @def: return default if no match is found</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Searches the domain hash table and returns a pointer to the hash table</span>
<span class="cm"> * entry if an exact match is found, if an exact match is not present in the</span>
<span class="cm"> * hash table then the default entry is returned if valid otherwise NULL is</span>
<span class="cm"> * returned.  The caller is responsible ensuring that the hash table is</span>
<span class="cm"> * protected with either a RCU read lock or the hash table lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="nf">netlbl_domhsh_search_def</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_rcu_deref</span><span class="p">(</span><span class="n">netlbl_domhsh_def</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_audit_add - Generate an audit entry for an add event</span>
<span class="cm"> * @entry: the entry being added</span>
<span class="cm"> * @addr4: the IPv4 address information</span>
<span class="cm"> * @addr6: the IPv6 address information</span>
<span class="cm"> * @result: the result code</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Generate an audit record for adding a new NetLabel/LSM mapping entry with</span>
<span class="cm"> * the given information.  Caller is responsible for holding the necessary</span>
<span class="cm"> * locks.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netlbl_domhsh_audit_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">addr4</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">addr6</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">cipsov4</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">AUDIT_MAC_MAP_ADD</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; nlbl_domain=%s&quot;</span><span class="p">,</span>
				 <span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">?</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">:</span> <span class="s">&quot;(default)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr4</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">map4</span><span class="p">;</span>
			<span class="n">map4</span> <span class="o">=</span> <span class="n">netlbl_domhsh_addr4_entry</span><span class="p">(</span><span class="n">addr4</span><span class="p">);</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">map4</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">cipsov4</span> <span class="o">=</span> <span class="n">map4</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">;</span>
			<span class="n">netlbl_af4list_audit_addr</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						  <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr6</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">netlbl_domaddr6_map</span> <span class="o">*</span><span class="n">map6</span><span class="p">;</span>
			<span class="n">map6</span> <span class="o">=</span> <span class="n">netlbl_domhsh_addr6_entry</span><span class="p">(</span><span class="n">addr6</span><span class="p">);</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">map6</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">netlbl_af6list_audit_addr</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr6</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">cipsov4</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span>:
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; nlbl_protocol=unlbl&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span>:
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cipsov4</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span>
					 <span class="s">&quot; nlbl_protocol=cipsov4 cipso_doi=%u&quot;</span><span class="p">,</span>
					 <span class="n">cipsov4</span><span class="o">-&gt;</span><span class="n">doi</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; res=%u&quot;</span><span class="p">,</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Domain Hash Table Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_init - Init for the domain hash</span>
<span class="cm"> * @size: the number of bits to use for the hash buckets</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Initializes the domain hash table, should be called only by</span>
<span class="cm"> * netlbl_user_init() during initialization.  Returns zero on success, non-zero</span>
<span class="cm"> * values on error.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">netlbl_domhsh_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domhsh_tbl</span> <span class="o">*</span><span class="n">hsh_tbl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hsh_tbl</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hsh_tbl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsh_tbl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">tbl</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">tbl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hsh_tbl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsh_tbl</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">iter</span><span class="p">]);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">netlbl_domhsh</span><span class="p">,</span> <span class="n">hsh_tbl</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_add - Adds a entry to the domain hash table</span>
<span class="cm"> * @entry: the entry to add</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds a new entry to the domain hash table and handles any updates to the</span>
<span class="cm"> * lower level protocol handler (i.e. CIPSO).  Returns zero on success,</span>
<span class="cm"> * negative on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry_old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">iter4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">tmp4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">iter6</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">tmp6</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

	<span class="cm">/* XXX - we can remove this RCU read lock as the spinlock protects the</span>
<span class="cm">	 *       entire function, but before we do we need to fixup the</span>
<span class="cm">	 *       netlbl_af[4,6]list RCU functions to do &quot;the right thing&quot; with</span>
<span class="cm">	 *       respect to rcu_dereference() when only a spinlock is held. */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">entry_old</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">entry_old</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search_def</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry_old</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">bkt</span> <span class="o">=</span> <span class="n">netlbl_domhsh_hash</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
			<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_domhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">bkt</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">netlbl_domhsh_def</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">)</span>
				<span class="n">netlbl_domhsh_audit_add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">iter4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
							<span class="n">ret_val</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
			<span class="n">netlbl_af6list_foreach_rcu</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">)</span>
				<span class="n">netlbl_domhsh_audit_add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">iter6</span><span class="p">,</span>
							<span class="n">ret_val</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">netlbl_domhsh_audit_add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">ret_val</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">entry_old</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span> <span class="o">&amp;&amp;</span>
		   <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">old_list4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">old_list6</span><span class="p">;</span>

		<span class="n">old_list4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry_old</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">;</span>
		<span class="n">old_list6</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry_old</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">;</span>

		<span class="cm">/* we only allow the addition of address selectors if all of</span>
<span class="cm">		 * the selectors do not exist in the existing domain map */</span>
		<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_af4list_search_exact</span><span class="p">(</span><span class="n">iter4</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
							<span class="n">iter4</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span>
							<span class="n">old_list4</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">add_return</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="n">netlbl_af6list_foreach_rcu</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netlbl_af6list_search_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter6</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">iter6</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span>
							<span class="n">old_list6</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">add_return</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

		<span class="n">netlbl_af4list_foreach_safe</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span> <span class="n">tmp4</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netlbl_af4list_remove_entry</span><span class="p">(</span><span class="n">iter4</span><span class="p">);</span>
			<span class="n">iter4</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af4list_add</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span> <span class="n">old_list4</span><span class="p">);</span>
			<span class="n">netlbl_domhsh_audit_add</span><span class="p">(</span><span class="n">entry_old</span><span class="p">,</span> <span class="n">iter4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">ret_val</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">add_return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="n">netlbl_af6list_foreach_safe</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span> <span class="n">tmp6</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netlbl_af6list_remove_entry</span><span class="p">(</span><span class="n">iter6</span><span class="p">);</span>
			<span class="n">iter6</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af6list_add</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span> <span class="n">old_list6</span><span class="p">);</span>
			<span class="n">netlbl_domhsh_audit_add</span><span class="p">(</span><span class="n">entry_old</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">iter6</span><span class="p">,</span>
						<span class="n">ret_val</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">add_return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">add_return:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_add_default - Adds the default entry to the domain hash table</span>
<span class="cm"> * @entry: the entry to add</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds a new default entry to the domain hash table and handles any updates</span>
<span class="cm"> * to the lower level protocol handler (i.e. CIPSO).  Returns zero on success,</span>
<span class="cm"> * negative on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_add_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netlbl_domhsh_add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_remove_entry - Removes a given entry from the domain table</span>
<span class="cm"> * @entry: the entry to remove</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes an entry from the domain hash table and handles any updates to the</span>
<span class="cm"> * lower level protocol handler (i.e. CIPSO).  Caller is responsible for</span>
<span class="cm"> * ensuring that the RCU read lock is held.  Returns zero on success, negative</span>
<span class="cm"> * on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_remove_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_domhsh_def</span><span class="p">))</span>
			<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">netlbl_domhsh_def</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>

	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">AUDIT_MAC_MAP_DEL</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span>
				 <span class="s">&quot; nlbl_domain=%s res=%u&quot;</span><span class="p">,</span>
				 <span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">?</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">:</span> <span class="s">&quot;(default)&quot;</span><span class="p">,</span>
				 <span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">iter4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">map4</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span>:
			<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">map4</span> <span class="o">=</span> <span class="n">netlbl_domhsh_addr4_entry</span><span class="p">(</span><span class="n">iter4</span><span class="p">);</span>
				<span class="n">cipso_v4_doi_putdef</span><span class="p">(</span><span class="n">map4</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* no need to check the IPv6 list since we currently</span>
<span class="cm">			 * support only unlabeled protocols for IPv6 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span>:
			<span class="n">cipso_v4_doi_putdef</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">netlbl_domhsh_free_entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_remove_af4 - Removes an address selector entry</span>
<span class="cm"> * @domain: the domain</span>
<span class="cm"> * @addr: IPv4 address</span>
<span class="cm"> * @mask: IPv4 address mask</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes an individual address selector from a domain mapping and potentially</span>
<span class="cm"> * the entire mapping if it is empty.  Returns zero on success, negative values</span>
<span class="cm"> * on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_remove_af4</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">entry_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">iter4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">iter6</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span><span class="p">)</span>
		<span class="n">entry_map</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">entry_map</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search_def</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry_map</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">entry_map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">remove_af4_failure</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>
	<span class="n">entry_addr</span> <span class="o">=</span> <span class="n">netlbl_af4list_remove</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">entry_map</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlbl_domhsh_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">remove_af4_failure</span><span class="p">;</span>
	<span class="n">netlbl_af4list_foreach_rcu</span><span class="p">(</span><span class="n">iter4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry_map</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">remove_af4_single_addr</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="n">netlbl_af6list_foreach_rcu</span><span class="p">(</span><span class="n">iter6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry_map</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">remove_af4_single_addr</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="cm">/* the domain mapping is empty so remove it from the mapping table */</span>
	<span class="n">netlbl_domhsh_remove_entry</span><span class="p">(</span><span class="n">entry_map</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>

<span class="nl">remove_af4_single_addr:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="cm">/* yick, we can&#39;t use call_rcu here because we don&#39;t have a rcu head</span>
<span class="cm">	 * pointer but hopefully this should be a rare case so the pause</span>
<span class="cm">	 * shouldn&#39;t be a problem */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_addr4_entry</span><span class="p">(</span><span class="n">entry_addr</span><span class="p">);</span>
	<span class="n">cipso_v4_doi_putdef</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">remove_af4_failure:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_remove - Removes an entry from the domain hash table</span>
<span class="cm"> * @domain: the domain to remove</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes an entry from the domain hash table and handles any updates to the</span>
<span class="cm"> * lower level protocol handler (i.e. CIPSO).  Returns zero on success,</span>
<span class="cm"> * negative on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_remove</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search_def</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_domhsh_remove_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_remove_default - Removes the default entry from the table</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes/resets the default entry for the domain hash table and handles any</span>
<span class="cm"> * updates to the lower level protocol handler (i.e. CIPSO).  Returns zero on</span>
<span class="cm"> * success, non-zero on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_remove_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netlbl_domhsh_remove</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_getentry - Get an entry from the domain hash table</span>
<span class="cm"> * @domain: the domain name to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Look through the domain hash table searching for an entry to match @domain,</span>
<span class="cm"> * return a pointer to a copy of the entry or NULL.  The caller is responsible</span>
<span class="cm"> * for ensuring that rcu_read_[un]lock() is called.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="nf">netlbl_domhsh_getentry</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netlbl_domhsh_search_def</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_getentry_af4 - Get an entry from the domain hash table</span>
<span class="cm"> * @domain: the domain name to search for</span>
<span class="cm"> * @addr: the IP address to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Look through the domain hash table searching for an entry to match @domain</span>
<span class="cm"> * and @addr, return a pointer to a copy of the entry or NULL.  The caller is</span>
<span class="cm"> * responsible for ensuring that rcu_read_[un]lock() is called.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="nf">netlbl_domhsh_getentry_af4</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
						       <span class="n">__be32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">dom_iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af4list</span> <span class="o">*</span><span class="n">addr_iter</span><span class="p">;</span>

	<span class="n">dom_iter</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search_def</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dom_iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dom_iter</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">addr_iter</span> <span class="o">=</span> <span class="n">netlbl_af4list_search</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">dom_iter</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">netlbl_domhsh_addr4_entry</span><span class="p">(</span><span class="n">addr_iter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_getentry_af6 - Get an entry from the domain hash table</span>
<span class="cm"> * @domain: the domain name to search for</span>
<span class="cm"> * @addr: the IP address to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Look through the domain hash table searching for an entry to match @domain</span>
<span class="cm"> * and @addr, return a pointer to a copy of the entry or NULL.  The caller is</span>
<span class="cm"> * responsible for ensuring that rcu_read_[un]lock() is called.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netlbl_domaddr6_map</span> <span class="o">*</span><span class="nf">netlbl_domhsh_getentry_af6</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">dom_iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_af6list</span> <span class="o">*</span><span class="n">addr_iter</span><span class="p">;</span>

	<span class="n">dom_iter</span> <span class="o">=</span> <span class="n">netlbl_domhsh_search_def</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dom_iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dom_iter</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">addr_iter</span> <span class="o">=</span> <span class="n">netlbl_af6list_search</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">dom_iter</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">netlbl_domhsh_addr6_entry</span><span class="p">(</span><span class="n">addr_iter</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_domhsh_walk - Iterate through the domain mapping hash table</span>
<span class="cm"> * @skip_bkt: the number of buckets to skip at the start</span>
<span class="cm"> * @skip_chain: the number of entries to skip in the first iterated bucket</span>
<span class="cm"> * @callback: callback for each entry</span>
<span class="cm"> * @cb_arg: argument for the callback function</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Interate over the domain mapping hash table, skipping the first @skip_bkt</span>
<span class="cm"> * buckets and @skip_chain entries.  For each entry in the table call</span>
<span class="cm"> * @callback, if @callback returns a negative value stop &#39;walking&#39; through the</span>
<span class="cm"> * table and return.  Updates the values in @skip_bkt and @skip_chain on</span>
<span class="cm"> * return.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_domhsh_walk</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">skip_bkt</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="o">*</span><span class="n">skip_chain</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">cb_arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iter_bkt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">iter_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">iter_entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chain_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iter_bkt</span> <span class="o">=</span> <span class="o">*</span><span class="n">skip_bkt</span><span class="p">;</span>
	     <span class="n">iter_bkt</span> <span class="o">&lt;</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_domhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	     <span class="n">iter_bkt</span><span class="o">++</span><span class="p">,</span> <span class="n">chain_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">netlbl_domhsh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="p">[</span><span class="n">iter_bkt</span><span class="p">];</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">iter_entry</span><span class="p">,</span> <span class="n">iter_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter_entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chain_cnt</span><span class="o">++</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">skip_chain</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">iter_entry</span><span class="p">,</span> <span class="n">cb_arg</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">chain_cnt</span><span class="o">--</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">walk_return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">walk_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="o">*</span><span class="n">skip_bkt</span> <span class="o">=</span> <span class="n">iter_bkt</span><span class="p">;</span>
	<span class="o">*</span><span class="n">skip_chain</span> <span class="o">=</span> <span class="n">chain_cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
