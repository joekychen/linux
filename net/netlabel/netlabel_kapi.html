<!DOCTYPE html>
<html><head><title>joekychen/linux » net › netlabel › netlabel_kapi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netlabel_kapi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NetLabel Kernel API</span>
<span class="cm"> *</span>
<span class="cm"> * This file defines the kernel API for the NetLabel system.  The NetLabel</span>
<span class="cm"> * system manages static and dynamic label mappings for network protocols such</span>
<span class="cm"> * as CIPSO and RIPSO.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Paul Moore &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * (c) Copyright Hewlett-Packard Development Company, L.P., 2006, 2008</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program;  if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/netlabel.h&gt;</span>
<span class="cp">#include &lt;net/cipso_ipv4.h&gt;</span>
<span class="cp">#include &lt;asm/bug.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &quot;netlabel_domainhash.h&quot;</span>
<span class="cp">#include &quot;netlabel_unlabeled.h&quot;</span>
<span class="cp">#include &quot;netlabel_cipso_v4.h&quot;</span>
<span class="cp">#include &quot;netlabel_user.h&quot;</span>
<span class="cp">#include &quot;netlabel_mgmt.h&quot;</span>
<span class="cp">#include &quot;netlabel_addrlist.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_map_del - Remove a NetLabel/LSM domain mapping</span>
<span class="cm"> * @domain: the domain mapping to remove</span>
<span class="cm"> * @family: address family</span>
<span class="cm"> * @addr: IP address</span>
<span class="cm"> * @mask: IP address mask</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes a NetLabel/LSM domain mapping.  A @domain value of NULL causes the</span>
<span class="cm"> * default domain mapping to be removed.  Returns zero on success, negative</span>
<span class="cm"> * values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cfg_map_del</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
		       <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">netlbl_domhsh_remove</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AF_INET</span>:
			<span class="k">return</span> <span class="n">netlbl_domhsh_remove_af4</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
							<span class="n">audit_info</span><span class="p">);</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_unlbl_map_add - Add a new unlabeled mapping</span>
<span class="cm"> * @domain: the domain mapping to add</span>
<span class="cm"> * @family: address family</span>
<span class="cm"> * @addr: IP address</span>
<span class="cm"> * @mask: IP address mask</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds a new unlabeled NetLabel/LSM domain mapping.  A @domain value of NULL</span>
<span class="cm"> * causes a new default domain mapping to be added.  Returns zero on success,</span>
<span class="cm"> * negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cfg_unlbl_map_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr_map</span> <span class="o">*</span><span class="n">addrmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">map4</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr6_map</span> <span class="o">*</span><span class="n">map6</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addrmap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addrmap</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AF_INET</span>: <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr4</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask4</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
			<span class="n">map4</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">map4</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map4</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
			<span class="n">map4</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">;</span>
			<span class="n">map4</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">s_addr</span> <span class="o">&amp;</span> <span class="n">mask4</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">;</span>
			<span class="n">map4</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask4</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">;</span>
			<span class="n">map4</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af4list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map4</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="k">case</span> <span class="n">AF_INET6</span>: <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr6</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">mask6</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
			<span class="n">map6</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">map6</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map6</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span><span class="p">;</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr6</span><span class="p">;</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask6</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask6</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask6</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask6</span><span class="o">-&gt;</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">mask6</span><span class="p">;</span>
			<span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af6list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map6</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span> <span class="o">=</span> <span class="n">addrmap</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_domhsh_add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cfg_unlbl_map_add_failure</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cfg_unlbl_map_add_failure:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrmap</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map4</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map6</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_unlbl_static_add - Adds a new static label</span>
<span class="cm"> * @net: network namespace</span>
<span class="cm"> * @dev_name: interface name</span>
<span class="cm"> * @addr: IP address in network byte order (struct in[6]_addr)</span>
<span class="cm"> * @mask: address mask in network byte order (struct in[6]_addr)</span>
<span class="cm"> * @family: address family</span>
<span class="cm"> * @secid: LSM secid value for the entry</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds a new NetLabel static label to be used when protocol provided labels</span>
<span class="cm"> * are not present on incoming traffic.  If @dev_name is NULL then the default</span>
<span class="cm"> * interface will be used.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cfg_unlbl_static_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">secid</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">netlbl_unlhsh_add</span><span class="p">(</span><span class="n">net</span><span class="p">,</span>
				 <span class="n">dev_name</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span>
				 <span class="n">secid</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_unlbl_static_del - Removes an existing static label</span>
<span class="cm"> * @net: network namespace</span>
<span class="cm"> * @dev_name: interface name</span>
<span class="cm"> * @addr: IP address in network byte order (struct in[6]_addr)</span>
<span class="cm"> * @mask: address mask in network byte order (struct in[6]_addr)</span>
<span class="cm"> * @family: address family</span>
<span class="cm"> * @secid: LSM secid value for the entry</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Removes an existing NetLabel static label used when protocol provided labels</span>
<span class="cm"> * are not present on incoming traffic.  If @dev_name is NULL then the default</span>
<span class="cm"> * interface will be used.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cfg_unlbl_static_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">addr_len</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">netlbl_unlhsh_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span>
				    <span class="n">dev_name</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span>
				    <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_cipsov4_add - Add a new CIPSOv4 DOI definition</span>
<span class="cm"> * @doi_def: CIPSO DOI definition</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Add a new CIPSO DOI definition as defined by @doi_def.  Returns zero on</span>
<span class="cm"> * success and negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cfg_cipsov4_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">doi_def</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cipso_v4_doi_add</span><span class="p">(</span><span class="n">doi_def</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_cipsov4_del - Remove an existing CIPSOv4 DOI definition</span>
<span class="cm"> * @doi: CIPSO DOI</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Remove an existing CIPSO DOI definition matching @doi.  Returns zero on</span>
<span class="cm"> * success and negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netlbl_cfg_cipsov4_del</span><span class="p">(</span><span class="n">u32</span> <span class="n">doi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cipso_v4_doi_remove</span><span class="p">(</span><span class="n">doi</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cfg_cipsov4_map_add - Add a new CIPSOv4 DOI mapping</span>
<span class="cm"> * @doi: the CIPSO DOI</span>
<span class="cm"> * @domain: the domain mapping to add</span>
<span class="cm"> * @addr: IP address</span>
<span class="cm"> * @mask: IP address mask</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Add a new NetLabel/LSM domain mapping for the given CIPSO DOI to the NetLabel</span>
<span class="cm"> * subsystem.  A @domain value of NULL adds a new default domain mapping.</span>
<span class="cm"> * Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cfg_cipsov4_map_add</span><span class="p">(</span><span class="n">u32</span> <span class="n">doi</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">doi_def</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr_map</span> <span class="o">*</span><span class="n">addrmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">addrinfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">doi_def</span> <span class="o">=</span> <span class="n">cipso_v4_doi_getdef</span><span class="p">(</span><span class="n">doi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doi_def</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_entry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">domain</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_domain</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span> <span class="o">=</span> <span class="n">doi_def</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addrmap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addrmap</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_addrmap</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list6</span><span class="p">);</span>

		<span class="n">addrinfo</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addrinfo</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addrinfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_addrinfo</span><span class="p">;</span>
		<span class="n">addrinfo</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span> <span class="o">=</span> <span class="n">doi_def</span><span class="p">;</span>
		<span class="n">addrinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span><span class="p">;</span>
		<span class="n">addrinfo</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_addr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">;</span>
		<span class="n">addrinfo</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">s_addr</span><span class="p">;</span>
		<span class="n">addrinfo</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_af4list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrinfo</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrmap</span><span class="o">-&gt;</span><span class="n">list4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cfg_cipsov4_map_add_failure</span><span class="p">;</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">addrsel</span> <span class="o">=</span> <span class="n">addrmap</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_addrmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_domhsh_add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cfg_cipsov4_map_add_failure</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cfg_cipsov4_map_add_failure:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrinfo</span><span class="p">);</span>
<span class="nl">out_addrinfo:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrmap</span><span class="p">);</span>
<span class="nl">out_addrmap:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
<span class="nl">out_domain:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="nl">out_entry:</span>
	<span class="n">cipso_v4_doi_putdef</span><span class="p">(</span><span class="n">doi_def</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Security Attribute Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_catmap_walk - Walk a LSM secattr catmap looking for a bit</span>
<span class="cm"> * @catmap: the category bitmap</span>
<span class="cm"> * @offset: the offset to start searching at, in bits</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function walks a LSM secattr category bitmap starting at @offset and</span>
<span class="cm"> * returns the spot of the first set bit or -ENOENT if no bits are set.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">catmap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_bit</span><span class="p">;</span>
	<span class="n">NETLBL_CATMAP_MAPTYPE</span> <span class="n">bitmap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span><span class="p">)</span> <span class="o">/</span> <span class="n">NETLBL_CATMAP_MAPSIZE</span><span class="p">;</span>
		<span class="n">node_bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">-</span>
			   <span class="p">(</span><span class="n">NETLBL_CATMAP_MAPSIZE</span> <span class="o">*</span> <span class="n">node_idx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">node_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">node_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">node_bit</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">bitmap</span> <span class="o">&amp;</span> <span class="n">NETLBL_CATMAP_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bitmap</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">node_bit</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">NETLBL_CATMAP_MAPSIZE</span> <span class="o">*</span> <span class="n">node_idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">node_bit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">node_idx</span> <span class="o">&gt;=</span> <span class="n">NETLBL_CATMAP_MAPCNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">node_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bitmap</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">[</span><span class="n">node_idx</span><span class="p">];</span>
		<span class="n">node_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_catmap_walk_rng - Find the end of a string of set bits</span>
<span class="cm"> * @catmap: the category bitmap</span>
<span class="cm"> * @offset: the offset to start searching at, in bits</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function walks a LSM secattr category bitmap starting at @offset and</span>
<span class="cm"> * returns the spot of the first cleared bit or -ENOENT if the offset is past</span>
<span class="cm"> * the end of the bitmap.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_walk_rng</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">catmap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_bit</span><span class="p">;</span>
	<span class="n">NETLBL_CATMAP_MAPTYPE</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="n">NETLBL_CATMAP_MAPTYPE</span> <span class="n">bitmap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span><span class="p">)</span> <span class="o">/</span> <span class="n">NETLBL_CATMAP_MAPSIZE</span><span class="p">;</span>
		<span class="n">node_bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">-</span>
			   <span class="p">(</span><span class="n">NETLBL_CATMAP_MAPSIZE</span> <span class="o">*</span> <span class="n">node_idx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">node_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">node_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bitmask</span> <span class="o">=</span> <span class="n">NETLBL_CATMAP_BIT</span> <span class="o">&lt;&lt;</span> <span class="n">node_bit</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">bitmap</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">[</span><span class="n">node_idx</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bitmask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bitmap</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bitmask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">node_bit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bitmask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">NETLBL_CATMAP_MAPSIZE</span> <span class="o">*</span> <span class="n">node_idx</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">node_bit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">node_idx</span> <span class="o">&gt;=</span> <span class="n">NETLBL_CATMAP_MAPCNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span>	<span class="n">NETLBL_CATMAP_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">node_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bitmask</span> <span class="o">=</span> <span class="n">NETLBL_CATMAP_BIT</span><span class="p">;</span>
		<span class="n">node_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_catmap_setbit - Set a bit in a LSM secattr catmap</span>
<span class="cm"> * @catmap: the category bitmap</span>
<span class="cm"> * @bit: the bit to set</span>
<span class="cm"> * @flags: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Set the bit specified by @bit in @catmap.  Returns zero on success,</span>
<span class="cm"> * negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_setbit</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">bit</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">catmap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_bit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_idx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	       <span class="n">bit</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">))</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">netlbl_secattr_catmap_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">NETLBL_CATMAP_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* gcc always rounds to zero when doing integer division */</span>
	<span class="n">node_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span><span class="p">)</span> <span class="o">/</span> <span class="n">NETLBL_CATMAP_MAPSIZE</span><span class="p">;</span>
	<span class="n">node_bit</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">-</span> <span class="p">(</span><span class="n">NETLBL_CATMAP_MAPSIZE</span> <span class="o">*</span> <span class="n">node_idx</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span> <span class="o">|=</span> <span class="n">NETLBL_CATMAP_BIT</span> <span class="o">&lt;&lt;</span> <span class="n">node_bit</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_catmap_setrng - Set a range of bits in a LSM secattr catmap</span>
<span class="cm"> * @catmap: the category bitmap</span>
<span class="cm"> * @start: the starting bit</span>
<span class="cm"> * @end: the last bit in the string</span>
<span class="cm"> * @flags: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Set a range of bits, starting at @start and ending with @end.  Returns zero</span>
<span class="cm"> * on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_setrng</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">start</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">end</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">catmap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iter_max_spot</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">spot</span><span class="p">;</span>

	<span class="cm">/* XXX - This could probably be made a bit faster by combining writes</span>
<span class="cm">	 * to the catmap instead of setting a single bit each time, but for</span>
<span class="cm">	 * right now skipping to the start of the range in the catmap should</span>
<span class="cm">	 * be a nice improvement over calling the individual setbit function</span>
<span class="cm">	 * repeatedly from a loop. */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	       <span class="n">start</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">))</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">iter_max_spot</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">spot</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">spot</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">ret_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">spot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spot</span> <span class="o">&gt;=</span> <span class="n">iter_max_spot</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">iter_max_spot</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">startbit</span> <span class="o">+</span> <span class="n">NETLBL_CATMAP_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_secattr_catmap_setbit</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">spot</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LSM Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_enabled - Determine if the NetLabel subsystem is enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * The LSM can use this function to determine if it should use NetLabel</span>
<span class="cm"> * security attributes in it&#39;s enforcement mechanism.  Currently, NetLabel is</span>
<span class="cm"> * considered to be enabled when it&#39;s configuration contains a valid setup for</span>
<span class="cm"> * at least one labeled protocol (i.e. NetLabel can understand incoming</span>
<span class="cm"> * labeled packets of at least one type); otherwise NetLabel is considered to</span>
<span class="cm"> * be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* At some point we probably want to expose this mechanism to the user</span>
<span class="cm">	 * as well so that admins can toggle NetLabel regardless of the</span>
<span class="cm">	 * configuration */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netlabel_mgmt_protocount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_sock_setattr - Label a socket using the correct protocol</span>
<span class="cm"> * @sk: the socket to label</span>
<span class="cm"> * @family: protocol family</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Attach the correct label to the given socket using the security attributes</span>
<span class="cm"> * specified in @secattr.  This function requires exclusive access to @sk,</span>
<span class="cm"> * which means it either needs to be in the process of being created or locked.</span>
<span class="cm"> * Returns zero on success, -EDESTADDRREQ if the domain is configured to use</span>
<span class="cm"> * network address selectors (can&#39;t blindly label the socket), and negative</span>
<span class="cm"> * values on all other failures.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_sock_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">dom_entry</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dom_entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_getentry</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dom_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">socket_setattr_return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">dom_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span>:
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDESTADDRREQ</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span>:
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cipso_v4_sock_setattr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
						    <span class="n">dom_entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">,</span>
						    <span class="n">secattr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span>:
			<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="cm">/* since we don&#39;t support any IPv6 labeling protocols right</span>
<span class="cm">		 * now we can optimize everything away until we do */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">socket_setattr_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_sock_delattr - Delete all the NetLabel labels on a socket</span>
<span class="cm"> * @sk: the socket</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Remove all the NetLabel labeling from @sk.  The caller is responsible for</span>
<span class="cm"> * ensuring that @sk is locked.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netlbl_sock_delattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cipso_v4_sock_delattr</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_sock_getattr - Determine the security attributes of a sock</span>
<span class="cm"> * @sk: the sock</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Examines the given sock to see if any NetLabel style labeling has been</span>
<span class="cm"> * applied to the sock, if so it parses the socket label and returns the</span>
<span class="cm"> * security attributes in @secattr.  Returns zero on success, negative values</span>
<span class="cm"> * on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_sock_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cipso_v4_sock_getattr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_conn_setattr - Label a connected socket using the correct protocol</span>
<span class="cm"> * @sk: the socket to label</span>
<span class="cm"> * @addr: the destination address</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Attach the correct label to the given connected socket using the security</span>
<span class="cm"> * attributes specified in @secattr.  The caller is responsible for ensuring</span>
<span class="cm"> * that @sk is locked.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_conn_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">addr4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">af4_entry</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">addr4</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">af4_entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_getentry_af4</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span>
						       <span class="n">addr4</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">af4_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">conn_setattr_return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">af4_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span>:
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cipso_v4_sock_setattr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
						   <span class="n">af4_entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">,</span>
						   <span class="n">secattr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span>:
			<span class="cm">/* just delete the protocols we support for right now</span>
<span class="cm">			 * but we could remove other protocols if needed */</span>
			<span class="n">cipso_v4_sock_delattr</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="cm">/* since we don&#39;t support any IPv6 labeling protocols right</span>
<span class="cm">		 * now we can optimize everything away until we do */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">conn_setattr_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_req_setattr - Label a request socket using the correct protocol</span>
<span class="cm"> * @req: the request socket to label</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Attach the correct label to the given socket using the security attributes</span>
<span class="cm"> * specified in @secattr.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_req_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_dom_map</span> <span class="o">*</span><span class="n">dom_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">af4_entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">proto_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">proto_cv4</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dom_entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_getentry</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dom_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">req_setattr_return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rsk_ops</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dom_entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NETLBL_NLTYPE_ADDRSELECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">inet_request_sock</span> <span class="o">*</span><span class="n">req_inet</span> <span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
			<span class="n">af4_entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_getentry_af4</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span>
							    <span class="n">req_inet</span><span class="o">-&gt;</span><span class="n">rmt_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">af4_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">req_setattr_return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">proto_type</span> <span class="o">=</span> <span class="n">af4_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">proto_cv4</span> <span class="o">=</span> <span class="n">af4_entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">proto_type</span> <span class="o">=</span> <span class="n">dom_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">proto_cv4</span> <span class="o">=</span> <span class="n">dom_entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">proto_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span>:
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cipso_v4_req_setattr</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">proto_cv4</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span>:
			<span class="cm">/* just delete the protocols we support for right now</span>
<span class="cm">			 * but we could remove other protocols if needed */</span>
			<span class="n">cipso_v4_req_delattr</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="cm">/* since we don&#39;t support any IPv6 labeling protocols right</span>
<span class="cm">		 * now we can optimize everything away until we do */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">req_setattr_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* netlbl_req_delattr - Delete all the NetLabel labels on a socket</span>
<span class="cm">* @req: the socket</span>
<span class="cm">*</span>
<span class="cm">* Description:</span>
<span class="cm">* Remove all the NetLabel labeling from @req.</span>
<span class="cm">*</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">netlbl_req_delattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cipso_v4_req_delattr</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_skbuff_setattr - Label a packet using the correct protocol</span>
<span class="cm"> * @skb: the packet</span>
<span class="cm"> * @family: protocol family</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Attach the correct label to the given packet using the security attributes</span>
<span class="cm"> * specified in @secattr.  Returns zero on success, negative values on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_skbuff_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">hdr4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_domaddr4_map</span> <span class="o">*</span><span class="n">af4_entry</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">hdr4</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">af4_entry</span> <span class="o">=</span> <span class="n">netlbl_domhsh_getentry_af4</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span>
						       <span class="n">hdr4</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">af4_entry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">skbuff_setattr_return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">af4_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_CIPSOV4</span>:
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cipso_v4_skbuff_setattr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						   <span class="n">af4_entry</span><span class="o">-&gt;</span><span class="n">type_def</span><span class="p">.</span><span class="n">cipsov4</span><span class="p">,</span>
						   <span class="n">secattr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NETLBL_NLTYPE_UNLABELED</span>:
			<span class="cm">/* just delete the protocols we support for right now</span>
<span class="cm">			 * but we could remove other protocols if needed */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">cipso_v4_skbuff_delattr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="cm">/* since we don&#39;t support any IPv6 labeling protocols right</span>
<span class="cm">		 * now we can optimize everything away until we do */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">skbuff_setattr_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_skbuff_getattr - Determine the security attributes of a packet</span>
<span class="cm"> * @skb: the packet</span>
<span class="cm"> * @family: protocol family</span>
<span class="cm"> * @secattr: the security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Examines the given packet to see if a recognized form of packet labeling</span>
<span class="cm"> * is present, if so it parses the packet label and returns the security</span>
<span class="cm"> * attributes in @secattr.  Returns zero on success, negative values on</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_skbuff_getattr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">CIPSO_V4_OPTEXIST</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cipso_v4_skbuff_getattr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">secattr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IPv6 */</span><span class="cp"></span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">netlbl_unlabel_getattr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_skbuff_err - Handle a LSM error on a sk_buff</span>
<span class="cm"> * @skb: the packet</span>
<span class="cm"> * @error: the error code</span>
<span class="cm"> * @gateway: true if host is acting as a gateway, false otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Deal with a LSM problem when handling the packet in @skb, typically this is</span>
<span class="cm"> * a permission denied problem (-EACCES).  The correct action is determined</span>
<span class="cm"> * according to the packet&#39;s labeling protocol.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netlbl_skbuff_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gateway</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CIPSO_V4_OPTEXIST</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">cipso_v4_error</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">gateway</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cache_invalidate - Invalidate all of the NetLabel protocol caches</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * For all of the NetLabel protocols that support some form of label mapping</span>
<span class="cm"> * cache, invalidate the cache.  Returns zero on success, negative values on</span>
<span class="cm"> * error.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netlbl_cache_invalidate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cipso_v4_cache_invalidate</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_cache_add - Add an entry to a NetLabel protocol cache</span>
<span class="cm"> * @skb: the packet</span>
<span class="cm"> * @secattr: the packet&#39;s security attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Add the LSM security attributes for the given packet to the underlying</span>
<span class="cm"> * NetLabel protocol&#39;s label mapping cache.  Returns zero on success, negative</span>
<span class="cm"> * values on error.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netlbl_cache_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_CACHE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CIPSO_V4_OPTEXIST</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cipso_v4_cache_add</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">secattr</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Protocol Engine Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_audit_start - Start an audit message</span>
<span class="cm"> * @type: audit message type</span>
<span class="cm"> * @audit_info: NetLabel audit information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Start an audit message using the type specified in @type and fill the audit</span>
<span class="cm"> * message with some fields common to all NetLabel audit messages.  This</span>
<span class="cm"> * function should only be used by protocol engines, not LSMs.  Returns a</span>
<span class="cm"> * pointer to the audit buffer on success, NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="nf">netlbl_audit_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netlbl_audit_start_common</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">audit_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup Functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_init - Initialize NetLabel</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Perform the required NetLabel initialization before first use.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">netlbl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NetLabel: Initializing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NetLabel:  domain hash size = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NETLBL_DOMHSH_BITSIZE</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NetLabel:  protocols =&quot;</span>
	       <span class="s">&quot; UNLABELED&quot;</span>
	       <span class="s">&quot; CIPSOv4&quot;</span>
	       <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_domhsh_init</span><span class="p">(</span><span class="n">NETLBL_DOMHSH_BITSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init_failure</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlabel_init</span><span class="p">(</span><span class="n">NETLBL_UNLHSH_BITSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init_failure</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_netlink_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init_failure</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">netlbl_unlabel_defconf</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init_failure</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NetLabel:  unlabeled traffic allowed by default</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">init_failure:</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;NetLabel: failed to initialize properly (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">netlbl_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
