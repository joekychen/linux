<!DOCTYPE html>
<html><head><title>joekychen/linux » net › can › bcm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>bcm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * bcm.c - Broadcast Manager to filter/send (cyclic) CAN content</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002-2007 Volkswagen Group Electronic Research</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the name of Volkswagen nor the names of its contributors</span>
<span class="cm"> *    may be used to endorse or promote products derived from this software</span>
<span class="cm"> *    without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, provided that this notice is retained in full, this</span>
<span class="cm"> * software may be distributed under the terms of the GNU General</span>
<span class="cm"> * Public License (&quot;GPL&quot;) version 2, in which case the provisions of the</span>
<span class="cm"> * GPL apply INSTEAD OF those given above.</span>
<span class="cm"> *</span>
<span class="cm"> * The provided data structures and external interfaces from this code</span>
<span class="cm"> * are not restricted to be used by modules with a GPL compatible license.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<span class="cm"> * DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/can.h&gt;</span>
<span class="cp">#include &lt;linux/can/core.h&gt;</span>
<span class="cp">#include &lt;linux/can/bcm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * To send multiple CAN frame content within TX_SETUP or to filter</span>
<span class="cm"> * CAN messages with multiplex index within RX_SETUP, the number of</span>
<span class="cm"> * different filters is limited to 256 due to the one byte index value.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_NFRAMES 256</span>

<span class="cm">/* use of last_frames[index].can_dlc */</span>
<span class="cp">#define RX_RECV    0x40 </span><span class="cm">/* received data for this element */</span><span class="cp"></span>
<span class="cp">#define RX_THR     0x80 </span><span class="cm">/* element not been sent due to throttle feature */</span><span class="cp"></span>
<span class="cp">#define BCM_CAN_DLC_MASK 0x0F </span><span class="cm">/* clean private flags in can_dlc by masking */</span><span class="cp"></span>

<span class="cm">/* get best masking value for can_rx_register() for a given single can_id */</span>
<span class="cp">#define REGMASK(id) ((id &amp; CAN_EFF_FLAG) ? \</span>
<span class="cp">		     (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \</span>
<span class="cp">		     (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))</span>

<span class="cp">#define CAN_BCM_VERSION CAN_VERSION</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">banner</span><span class="p">[]</span> <span class="o">=</span> <span class="n">KERN_INFO</span>
	<span class="s">&quot;can: broadcast manager protocol (rev &quot;</span> <span class="n">CAN_BCM_VERSION</span> <span class="s">&quot; t)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PF_CAN broadcast manager protocol&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Oliver Hartkopp &lt;oliver.hartkopp@volkswagen.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;can-proto-2&quot;</span><span class="p">);</span>

<span class="cm">/* easy access to can_frame payload */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">GET_U64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">bcm_op</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="n">canid_t</span> <span class="n">can_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">frames_abs</span><span class="p">,</span> <span class="n">frames_filtered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">ival1</span><span class="p">,</span> <span class="n">ival2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">timer</span><span class="p">,</span> <span class="n">thrtimer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tsklet</span><span class="p">,</span> <span class="n">thrtsklet</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">rx_stamp</span><span class="p">,</span> <span class="n">kt_ival1</span><span class="p">,</span> <span class="n">kt_ival2</span><span class="p">,</span> <span class="n">kt_lastmsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_ifindex</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nframes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">currframe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">frames</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">last_frames</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="n">sframe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="n">last_sframe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">rx_reg_dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_dir</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bound</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tx_ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dropped_usr_msgs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">bcm_proc_read</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">procname</span> <span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="cm">/* inode number in decimal with \0 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="nf">bcm_sk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CFSIZ sizeof(struct can_frame)</span>
<span class="cp">#define OPSIZ sizeof(struct bcm_op)</span>
<span class="cp">#define MHSIZ sizeof(struct bcm_msg_head)</span>

<span class="cm">/*</span>
<span class="cm"> * procfs functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">bcm_proc_getifname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifindex</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;any&quot;</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">&quot;???&quot;</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">ifname</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;&gt;&gt;&gt; socket %pK&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; / sk %pK&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; / bo %pK&quot;</span><span class="p">,</span> <span class="n">bo</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; / dropped %lu&quot;</span><span class="p">,</span> <span class="n">bo</span><span class="o">-&gt;</span><span class="n">dropped_usr_msgs</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; / bound %s&quot;</span><span class="p">,</span> <span class="n">bcm_proc_getifname</span><span class="p">(</span><span class="n">ifname</span><span class="p">,</span> <span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; &lt;&lt;&lt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reduction</span><span class="p">;</span>

		<span class="cm">/* print only active entries &amp; prevent division by zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;rx_op: %03X %-5s &quot;</span><span class="p">,</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span> <span class="n">bcm_proc_getifname</span><span class="p">(</span><span class="n">ifname</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">));</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;[%u]%c &quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">,</span>
				<span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_CHECK_DLC</span><span class="p">)</span><span class="o">?</span><span class="sc">&#39;d&#39;</span><span class="o">:</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;timeo=%lld &quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
					<span class="n">ktime_to_us</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;thr=%lld &quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
					<span class="n">ktime_to_us</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">));</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# recv %ld (%ld) =&gt; reduction: &quot;</span><span class="p">,</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_filtered</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span><span class="p">);</span>

		<span class="n">reduction</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_filtered</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s%ld%%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">reduction</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span><span class="o">?</span><span class="s">&quot;near &quot;</span><span class="o">:</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">reduction</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;tx_op: %03X %s [%u] &quot;</span><span class="p">,</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span>
				<span class="n">bcm_proc_getifname</span><span class="p">(</span><span class="n">ifname</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">),</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;t1=%lld &quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;t2=%lld &quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">));</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# sent %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">bcm_proc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">bcm_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">bcm_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_can_tx - send the (next) CAN frame to the appropriate CAN interface</span>
<span class="cm"> *              of the given bcm tx op</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_can_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">currframe</span><span class="p">];</span>

	<span class="cm">/* no target device? =&gt; exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RFC: should this bcm_op remove itself here? */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">CFSIZ</span><span class="p">,</span> <span class="n">gfp_any</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">),</span> <span class="n">cf</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">);</span>

	<span class="cm">/* send with loopback */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">can_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* update statistics */</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">currframe</span><span class="o">++</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* reached last frame? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">currframe</span> <span class="o">&gt;=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">currframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_send_to_user - send a BCM message to the userspace</span>
<span class="cm"> *                    (consisting of bcm_msg_head + x CAN frames)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_send_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">frames</span><span class="p">,</span> <span class="kt">int</span> <span class="n">has_timestamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">firstframe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">gfp_any</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">)),</span> <span class="n">head</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* can_frames starting here */</span>
		<span class="n">firstframe</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">datalen</span><span class="p">),</span> <span class="n">frames</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * the BCM uses the can_dlc-element of the can_frame</span>
<span class="cm">		 * structure for internal purposes. This is only</span>
<span class="cm">		 * relevant for updates that are generated by the</span>
<span class="cm">		 * BCM, where nframes is 1</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">firstframe</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">&amp;=</span> <span class="n">BCM_CAN_DLC_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_timestamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* restore rx timestamp */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_stamp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Put the datagram to the queue so that bcm_recvmsg() can</span>
<span class="cm">	 *  get it from there.  We need to pass the interface index to</span>
<span class="cm">	 *  bcm_recvmsg().  We pass a whole struct sockaddr_can in skb-&gt;cb</span>
<span class="cm">	 *  containing the interface index.</span>
<span class="cm">	 */</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_can</span><span class="p">));</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">can_family</span>  <span class="o">=</span> <span class="n">AF_CAN</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">can_ifindex</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_ifindex</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="cm">/* don&#39;t care about overflows in this statistic */</span>
		<span class="n">bo</span><span class="o">-&gt;</span><span class="n">dropped_usr_msgs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_tx_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span>
			      <span class="n">ktime_add</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">),</span>
			      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span>
			      <span class="n">ktime_add</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">),</span>
			      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_tx_timeout_tsklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">msg_head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TX_COUNTEVT</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* create notification to user */</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">TX_EXPIRED</span><span class="p">;</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">count</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">ival1</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">;</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">ival2</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">;</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">can_id</span>  <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>
			<span class="n">msg_head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">bcm_send_to_user</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bcm_can_tx</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="n">bcm_can_tx</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

	<span class="n">bcm_tx_start_timer</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_tx_timeout_handler - performs cyclic CAN frame transmissions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">bcm_tx_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">hrtimer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hrtimer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_op</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>

	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">tsklet</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_changed - create a RX_CHANGED notification due to changed content</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="cm">/* update statistics */</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_filtered</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* prevent statistics overflow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_filtered</span> <span class="o">&gt;</span> <span class="n">ULONG_MAX</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_filtered</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this element is not throttled anymore */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">BCM_CAN_DLC_MASK</span><span class="o">|</span><span class="n">RX_RECV</span><span class="p">);</span>

	<span class="n">head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">RX_CHANGED</span><span class="p">;</span>
	<span class="n">head</span><span class="p">.</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">head</span><span class="p">.</span><span class="n">count</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">head</span><span class="p">.</span><span class="n">ival1</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">;</span>
	<span class="n">head</span><span class="p">.</span><span class="n">ival2</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">;</span>
	<span class="n">head</span><span class="p">.</span><span class="n">can_id</span>  <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>
	<span class="n">head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">bcm_send_to_user</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_update_and_send - process a detected relevant receive content change</span>
<span class="cm"> *                          1. update the last received data</span>
<span class="cm"> *                          2. send a notification to the user (if possible)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_update_and_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">lastdata</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">rxdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">lastdata</span><span class="p">,</span> <span class="n">rxdata</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">);</span>

	<span class="cm">/* mark as used and throttled by default */</span>
	<span class="n">lastdata</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RX_RECV</span><span class="o">|</span><span class="n">RX_THR</span><span class="p">);</span>

	<span class="cm">/* throtteling mode inactive ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* send RX_CHANGED to the user immediately */</span>
		<span class="n">bcm_rx_changed</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">lastdata</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* with active throttling timer we are just done here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* first receiption with enabled throttling mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_lastmsg</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rx_changed_settime</span><span class="p">;</span>

	<span class="cm">/* got a second frame inside a potential throttle period? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ktime_us_delta</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_lastmsg</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* do not send the saved data - only start throttle timer */</span>
		<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">,</span>
			      <span class="n">ktime_add</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_lastmsg</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">),</span>
			      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the gap was that big, that throttling was not needed here */</span>
<span class="nl">rx_changed_settime:</span>
	<span class="n">bcm_rx_changed</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">lastdata</span><span class="p">);</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_lastmsg</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly</span>
<span class="cm"> *                       received data stored in op-&gt;last_frames[]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_cmp_to_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">rxdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * no one uses the MSBs of can_dlc for comparation,</span>
<span class="cm">	 * so we use it here to detect the first time of reception</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">can_dlc</span> <span class="o">&amp;</span> <span class="n">RX_RECV</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* received data for the first time =&gt; send update to user */</span>
		<span class="n">bcm_rx_update_and_send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">rxdata</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do a real check in can_frame data section */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">GET_U64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">GET_U64</span><span class="p">(</span><span class="n">rxdata</span><span class="p">))</span> <span class="o">!=</span>
	    <span class="p">(</span><span class="n">GET_U64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">GET_U64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">])))</span> <span class="p">{</span>
		<span class="n">bcm_rx_update_and_send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">rxdata</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_CHECK_DLC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* do a real check in can_frame dlc */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rxdata</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">!=</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">can_dlc</span> <span class="o">&amp;</span>
					<span class="n">BCM_CAN_DLC_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bcm_rx_update_and_send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
					       <span class="n">rxdata</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_starttimer - enable timeout monitoring for CAN frame receiption</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_starttimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_NO_AUTOTIMER</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_timeout_tsklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">msg_head</span><span class="p">;</span>

	<span class="cm">/* create notification to user */</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">RX_TIMEOUT</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">count</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">ival1</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">ival2</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">can_id</span>  <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bcm_send_to_user</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_timeout_handler - when the (cyclic) CAN frame receiption timed out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">bcm_rx_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">hrtimer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hrtimer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_op</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* schedule before NET_RX_SOFTIRQ */</span>
	<span class="n">tasklet_hi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">tsklet</span><span class="p">);</span>

	<span class="cm">/* no restart of the timer is done here! */</span>

	<span class="cm">/* if user wants to be informed, when cyclic CAN-Messages come back */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_ANNOUNCE_RESUME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* clear received can_frames to indicate &#39;nothing received&#39; */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_do_flush - helper for bcm_rx_thr_flush</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bcm_rx_do_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">can_dlc</span> <span class="o">&amp;</span> <span class="n">RX_THR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">update</span><span class="p">)</span>
			<span class="n">bcm_rx_changed</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_thr_flush - Check for throttled data and send it to the userspace</span>
<span class="cm"> *</span>
<span class="cm"> * update == 0 : just check if throttled data is available  (any irq context)</span>
<span class="cm"> * update == 1 : check and send throttled data to userspace (soft_irq context)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_rx_thr_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">updated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* for MUX filter we start at index 1 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">updated</span> <span class="o">+=</span> <span class="n">bcm_rx_do_flush</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* for RX_FILTER_ID and simple filter */</span>
		<span class="n">updated</span> <span class="o">+=</span> <span class="n">bcm_rx_do_flush</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">updated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_thr_tsklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* push the changed data to the userspace */</span>
	<span class="n">bcm_rx_thr_flush</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_thr_handler - the time for blocked content updates is over now:</span>
<span class="cm"> *                      Check for throttled data and send it to the userspace</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">bcm_rx_thr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">hrtimer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hrtimer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_op</span><span class="p">,</span> <span class="n">thrtimer</span><span class="p">);</span>

	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtsklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcm_rx_thr_flush</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">hrtimer</span><span class="p">,</span> <span class="n">ktime_get</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* rearm throttle handling */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_lastmsg</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_handler - handle a CAN frame receiption</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">rxframe</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* disable timeout */</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">!=</span> <span class="n">rxframe</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* save rx timestamp */</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_stamp</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>
	<span class="cm">/* save originator for recvfrom() */</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_ifindex</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
	<span class="cm">/* update statistics */</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames_abs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_RTR_FRAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* send reply for RTR-request (placed in op-&gt;frames[0]) */</span>
		<span class="n">bcm_can_tx</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_FILTER_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the easiest case */</span>
		<span class="n">bcm_rx_update_and_send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rxframe</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rx_starttimer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* simple compare with index 0 */</span>
		<span class="n">bcm_rx_cmp_to_index</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxframe</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">rx_starttimer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * multiplex compare</span>
<span class="cm">		 *</span>
<span class="cm">		 * find the first multiplex mask that fits.</span>
<span class="cm">		 * Remark: The MUX-mask is stored in index 0</span>
<span class="cm">		 */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">GET_U64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">GET_U64</span><span class="p">(</span><span class="n">rxframe</span><span class="p">))</span> <span class="o">==</span>
			    <span class="p">(</span><span class="n">GET_U64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
			     <span class="n">GET_U64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
				<span class="n">bcm_rx_cmp_to_index</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rxframe</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">rx_starttimer:</span>
	<span class="n">bcm_rx_starttimer</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helpers for bcm_op handling: find &amp; delete bcm [rx|tx] op elements</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="nf">bcm_find_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">==</span> <span class="n">can_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">ifindex</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">op</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_remove_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">tsklet</span><span class="p">.</span><span class="n">func</span><span class="p">)</span>
		<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">tsklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtsklet</span><span class="p">.</span><span class="n">func</span><span class="p">)</span>
		<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtsklet</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">sframe</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_sframe</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_rx_unreg</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">can_rx_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span> <span class="n">REGMASK</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">),</span>
				  <span class="n">bcm_rx_handler</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

		<span class="cm">/* mark as removed subscription */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;can-bcm: bcm_rx_unreg: registered device &quot;</span>
		       <span class="s">&quot;mismatch %p %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_delete_rx_op - find and remove a rx op (returns number of removed ops)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_delete_rx_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">==</span> <span class="n">can_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">ifindex</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t care if we&#39;re bound or not (due to netdev</span>
<span class="cm">			 * problems) can_rx_unregister() is always a save</span>
<span class="cm">			 * thing to do here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Only remove subscriptions that had not</span>
<span class="cm">				 * been removed due to NETDEV_UNREGISTER</span>
<span class="cm">				 * in bcm_notifier()</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

					<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span>
							       <span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">bcm_rx_unreg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
						<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">can_rx_unregister</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span>
						  <span class="n">REGMASK</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">),</span>
						  <span class="n">bcm_rx_handler</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">bcm_remove_op</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* done */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not found */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_delete_tx_op - find and remove a tx op (returns number of removed ops)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_delete_tx_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">==</span> <span class="n">can_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">ifindex</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">bcm_remove_op</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* done */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not found */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_read_op - read out a bcm_op and send it to the user (for bcm_sendmsg)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_read_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="o">*</span><span class="n">msg_head</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">bcm_find_op</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* put current values into msg_head */</span>
	<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">count</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival1</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival2</span>   <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">;</span>
	<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span>

	<span class="n">bcm_send_to_user</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">msg_head</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">MHSIZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_tx_setup - create or update a bcm tx op (for bcm_sendmsg)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_tx_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="o">*</span><span class="n">msg_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* we need a real device to send frames */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifindex</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* check nframes boundaries - we need at least one can_frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="n">MAX_NFRAMES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check the given can_id */</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">bcm_find_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">,</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* update existing BCM operation */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do we need more space for the can_frames than currently</span>
<span class="cm">		 * allocated? -&gt; This is a _really_ unusual use-case and</span>
<span class="cm">		 * therefore (complexity / locking) it is not supported.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

		<span class="cm">/* update can_frames content */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					       <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">can_dlc</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TX_CP_CAN_ID</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* copy can_id into frame */</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* insert new BCM operation for the given can_id */</span>

		<span class="n">op</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">OPSIZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span>    <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>

		<span class="cm">/* create array for can_frames and copy the data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">,</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">sframe</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					       <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">can_dlc</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">sframe</span><span class="p">)</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TX_CP_CAN_ID</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* copy can_id into frame */</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* tx_ops never compare with previous received messages */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* bcm_can_tx / bcm_tx_timeout_handler needs this */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="n">ifindex</span><span class="p">;</span>

		<span class="cm">/* initialize uninitialized (kzalloc) structure */</span>
		<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">bcm_tx_timeout_handler</span><span class="p">;</span>

		<span class="cm">/* initialize tasklet for tx countevent notification */</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">tsklet</span><span class="p">,</span> <span class="n">bcm_tx_timeout_tsklet</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">op</span><span class="p">);</span>

		<span class="cm">/* currently unused in tx_ops */</span>
		<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>

		<span class="cm">/* add this bcm_op to the list of the tx_ops */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">);</span>

	<span class="p">}</span> <span class="cm">/* if ((op = bcm_find_op(&amp;bo-&gt;tx_ops, msg_head-&gt;can_id, ifindex))) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">!=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span>   <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span>
		<span class="cm">/* start multiple frame transmission with index 0 */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">currframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check flags */</span>

	<span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TX_RESET_MULTI_IDX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* start multiple frame transmission with index 0 */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">currframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SETTIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set timer values */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">ival1</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">ival2</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span> <span class="o">=</span> <span class="n">timeval_to_ktime</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">);</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span> <span class="o">=</span> <span class="n">timeval_to_ktime</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">);</span>

		<span class="cm">/* disable an active timer due to zero values? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">STARTTIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="cm">/* spec: send can_frame when starting timer */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TX_ANNOUNCE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TX_ANNOUNCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcm_can_tx</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">STARTTIMER</span><span class="p">)</span>
		<span class="n">bcm_tx_start_timer</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span> <span class="o">+</span> <span class="n">MHSIZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_rx_setup - create or update a bcm rx op (for bcm_sendmsg)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_rx_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="o">*</span><span class="n">msg_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_rx_register</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_FILTER_ID</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* be robust against wrong usage ... */</span>
		<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">RX_FILTER_ID</span><span class="p">;</span>
		<span class="cm">/* ignore trailing garbage */</span>
		<span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the first element contains the mux-mask =&gt; MAX_NFRAMES + 1  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="n">MAX_NFRAMES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_RTR_FRAME</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_RTR_FLAG</span><span class="p">))))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check the given can_id */</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">bcm_find_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">,</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* update existing BCM operation */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do we need more space for the can_frames than currently</span>
<span class="cm">		 * allocated? -&gt; This is a _really_ unusual use-case and</span>
<span class="cm">		 * therefore (complexity / locking) it is not supported.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* update can_frames content */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">,</span>
					       <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span>
					       <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

			<span class="cm">/* clear last_frames to indicate &#39;nothing received&#39; */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span>

		<span class="cm">/* Only an update -&gt; do not call can_rx_register() */</span>
		<span class="n">do_rx_register</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* insert new BCM operation for the given can_id */</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">OPSIZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span>    <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">nframes</span>   <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* create array for can_frames and copy the data */</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">,</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* create and init array for received can_frames */</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">sframe</span><span class="p">;</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_sframe</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span>
					       <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">sframe</span><span class="p">)</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_sframe</span><span class="p">)</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">last_frames</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* bcm_can_tx / bcm_tx_timeout_handler needs this */</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="n">ifindex</span><span class="p">;</span>

		<span class="cm">/* initialize uninitialized (kzalloc) structure */</span>
		<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">bcm_rx_timeout_handler</span><span class="p">;</span>

		<span class="cm">/* initialize tasklet for rx timeout notification */</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">tsklet</span><span class="p">,</span> <span class="n">bcm_rx_timeout_tsklet</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">op</span><span class="p">);</span>

		<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">bcm_rx_thr_handler</span><span class="p">;</span>

		<span class="cm">/* initialize tasklet for rx throttle handling */</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtsklet</span><span class="p">,</span> <span class="n">bcm_rx_thr_tsklet</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">op</span><span class="p">);</span>

		<span class="cm">/* add this bcm_op to the list of the rx_ops */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">);</span>

		<span class="cm">/* call can_rx_register() */</span>
		<span class="n">do_rx_register</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="cm">/* if ((op = bcm_find_op(&amp;bo-&gt;rx_ops, msg_head-&gt;can_id, ifindex))) */</span>

	<span class="cm">/* check flags */</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RX_RTR_FRAME</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* no timers in RTR-mode */</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">);</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * funny feature in RX(!)_SETUP only for RTR-mode:</span>
<span class="cm">		 * copy can_id into frame BUT without RTR-flag to</span>
<span class="cm">		 * prevent a full-load-loopback-test ... ;-]</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TX_CP_CAN_ID</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_id</span> <span class="o">==</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">))</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CAN_RTR_FLAG</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SETTIMER</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* set timer value */</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">ival1</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">;</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">ival2</span> <span class="o">=</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">;</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span> <span class="o">=</span> <span class="n">timeval_to_ktime</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival1</span><span class="p">);</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival2</span> <span class="o">=</span> <span class="n">timeval_to_ktime</span><span class="p">(</span><span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">ival2</span><span class="p">);</span>

			<span class="cm">/* disable an active timer due to zero value? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
				<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * In any case cancel the throttle timer, flush</span>
<span class="cm">			 * potentially blocked msgs and reset throttle handling</span>
<span class="cm">			 */</span>
			<span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_lastmsg</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">thrtimer</span><span class="p">);</span>
			<span class="n">bcm_rx_thr_flush</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">STARTTIMER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">kt_ival1</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we can register for can_ids, if we added a new bcm_op */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_rx_register</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifindex</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

			<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">can_rx_register</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span>
						      <span class="n">REGMASK</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">),</span>
						      <span class="n">bcm_rx_handler</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span>
						      <span class="s">&quot;bcm&quot;</span><span class="p">);</span>

				<span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
				<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">can_rx_register</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span>
					      <span class="n">REGMASK</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">),</span>
					      <span class="n">bcm_rx_handler</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="s">&quot;bcm&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this bcm rx op is broken -&gt; remove it */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">bcm_remove_op</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">msg_head</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">CFSIZ</span> <span class="o">+</span> <span class="n">MHSIZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_tx_send - send a single CAN frame to the CAN interface (for bcm_sendmsg)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_tx_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* we need a real device to send frames */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifindex</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">CFSIZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">CFSIZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span>  <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">can_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* send with loopback */</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">CFSIZ</span> <span class="o">+</span> <span class="n">MHSIZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bcm_sendmsg - process BCM commands (opcodes) from the userspace</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ifindex</span> <span class="o">=</span> <span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span> <span class="cm">/* default ifindex for this bcm_op */</span>
	<span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">msg_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span> <span class="cm">/* read bytes or error codes as return value */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="cm">/* check for valid message length from userspace */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MHSIZ</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">MHSIZ</span><span class="p">)</span> <span class="o">%</span> <span class="n">CFSIZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check for alternative ifindex for this bcm_op */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifindex</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no bound device as default =&gt; check msg_name */</span>
		<span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">can_family</span> <span class="o">!=</span> <span class="n">AF_CAN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* ifindex from sendto() */</span>
		<span class="n">ifindex</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">can_ifindex</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ifindex</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

			<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_CAN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* read message head information */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">MHSIZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">TX_SETUP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bcm_tx_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RX_SETUP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bcm_rx_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TX_DELETE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">bcm_delete_tx_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">,</span> <span class="n">msg_head</span><span class="p">.</span><span class="n">can_id</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MHSIZ</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RX_DELETE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">bcm_delete_rx_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">,</span> <span class="n">msg_head</span><span class="p">.</span><span class="n">can_id</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MHSIZ</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TX_READ</span>:
		<span class="cm">/* reuse msg_head for the reply to TX_READ */</span>
		<span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">TX_STATUS</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bcm_read_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RX_READ</span>:
		<span class="cm">/* reuse msg_head for the reply to RX_READ */</span>
		<span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">RX_STATUS</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bcm_read_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_head</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TX_SEND</span>:
		<span class="cm">/* we need exactly one can_frame behind the msg head */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">msg_head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">CFSIZ</span> <span class="o">+</span> <span class="n">MHSIZ</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bcm_tx_send</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * notification handler for netdevice status changes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcm_sock</span><span class="p">,</span> <span class="n">notifier</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">notify_enodev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_CAN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">NETDEV_UNREGISTER</span>:
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* remove device specific receive entries */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
				<span class="n">bcm_rx_unreg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

		<span class="cm">/* remove device reference, if this is our bound device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span> <span class="o">&amp;&amp;</span> <span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">notify_enodev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">notify_enodev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NETDEV_DOWN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span> <span class="o">&amp;&amp;</span> <span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ENETDOWN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initial settings for all BCM sockets to be set at socket creation time</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span>            <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bo</span><span class="o">-&gt;</span><span class="n">dropped_usr_msgs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bo</span><span class="o">-&gt;</span><span class="n">bcm_proc_read</span>    <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">);</span>

	<span class="cm">/* set notifier */</span>
	<span class="n">bo</span><span class="o">-&gt;</span><span class="n">notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">bcm_notifier</span><span class="p">;</span>

	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * standard socket functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* remove bcm_ops, timer, rx_unregister(), etc. */</span>

	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">notifier</span><span class="p">);</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">tx_ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">bcm_remove_op</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">rx_ops</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t care if we&#39;re bound or not (due to netdev problems)</span>
<span class="cm">		 * can_rx_unregister() is always a save thing to do here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only remove subscriptions that had not</span>
<span class="cm">			 * been removed due to NETDEV_UNREGISTER</span>
<span class="cm">			 * in bcm_notifier()</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">rx_reg_dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

				<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bcm_rx_unreg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
					<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">can_rx_unregister</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">,</span>
					  <span class="n">REGMASK</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">can_id</span><span class="p">),</span>
					  <span class="n">bcm_rx_handler</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

		<span class="n">bcm_remove_op</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remove procfs entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_dir</span> <span class="o">&amp;&amp;</span> <span class="n">bo</span><span class="o">-&gt;</span><span class="n">bcm_proc_read</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">procname</span><span class="p">,</span> <span class="n">proc_dir</span><span class="p">);</span>

	<span class="cm">/* remove device reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bcm_sock</span> <span class="o">*</span><span class="n">bo</span> <span class="o">=</span> <span class="n">bcm_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>

	<span class="cm">/* bind a device to this socket */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">can_ifindex</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">can_ifindex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_CAN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no interface reference for ifindex = 0 (&#39;any&#39; CAN device) */</span>
		<span class="n">bo</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bo</span><span class="o">-&gt;</span><span class="n">bound</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* unique socket address as filename */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">procname</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">sock_i_ino</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="n">bo</span><span class="o">-&gt;</span><span class="n">bcm_proc_read</span> <span class="o">=</span> <span class="n">proc_create_data</span><span class="p">(</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">procname</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
						     <span class="n">proc_dir</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">bcm_proc_fops</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">noblock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">noblock</span> <span class="o">=</span>  <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="n">flags</span>   <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_toiovec</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock_recv_ts_and_drops</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_can</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">bcm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>        <span class="o">=</span> <span class="n">PF_CAN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>       <span class="o">=</span> <span class="n">bcm_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>          <span class="o">=</span> <span class="n">sock_no_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>       <span class="o">=</span> <span class="n">bcm_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>    <span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>        <span class="o">=</span> <span class="n">sock_no_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>       <span class="o">=</span> <span class="n">sock_no_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>          <span class="o">=</span> <span class="n">datagram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>         <span class="o">=</span> <span class="n">can_ioctl</span><span class="p">,</span>	<span class="cm">/* use can_ioctl() from af_can.c */</span>
	<span class="p">.</span><span class="n">listen</span>        <span class="o">=</span> <span class="n">sock_no_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>      <span class="o">=</span> <span class="n">sock_no_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>    <span class="o">=</span> <span class="n">sock_no_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>    <span class="o">=</span> <span class="n">sock_no_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>       <span class="o">=</span> <span class="n">bcm_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>       <span class="o">=</span> <span class="n">bcm_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>          <span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span>      <span class="o">=</span> <span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">bcm_proto</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>       <span class="o">=</span> <span class="s">&quot;CAN_BCM&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>      <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span>   <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcm_sock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">init</span>       <span class="o">=</span> <span class="n">bcm_init</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">can_proto</span> <span class="n">bcm_can_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span>       <span class="o">=</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">protocol</span>   <span class="o">=</span> <span class="n">CAN_BCM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ops</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcm_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prot</span>       <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcm_proto</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bcm_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">banner</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">can_proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcm_can_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;can: registration of bcm protocol failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create /proc/net/can-bcm directory */</span>
	<span class="n">proc_dir</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;can-bcm&quot;</span><span class="p">,</span> <span class="n">init_net</span><span class="p">.</span><span class="n">proc_net</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">bcm_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">can_proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcm_can_proto</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_dir</span><span class="p">)</span>
		<span class="n">proc_net_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="s">&quot;can-bcm&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">bcm_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">bcm_module_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
