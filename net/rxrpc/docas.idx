f | ar-call.c | s | 21K | 689 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-accept.c | s | 12K | 443 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | rxkad.c | s | 27K | 959 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | Makefile | g | 420B |  | Tracey Dent | tdent48227@gmail.com | 1290442575 |  | Net: rxrpc: Makefile: Remove deprecated kbuild goal definitions  Changed Makefile to use <modules>-y instead of <modules>-objs because -objs is deprecated and not mentioned in Documentation/kbuild/makefiles.txt.  Signed-off-by: Tracey Dent <tdent48227@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-transport.c | s | 7.1K | 233 | David S. Miller | davem@davemloft.net | 1305845510 |  | rxrpc: Fix set but unused variable 'usage' in rxrpc_get_transport()  This is identical to the case I fixed in rxrpc_get_peer()  Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-local.c | s | 7.5K | 256 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | ar-proc.c | s | 5.0K | 163 | Harvey Harrison | harvey.harrison@gmail.com | 1225439696 |  | net: replace NIPQUAD() in net/*/  Using NIPQUAD() with NIPQUAD_FMT, %d.%d.%d.%d or %u.%u.%u.%u can be replaced with %pI4  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-skbuff.c | s | 3.4K | 111 | David Howells | dhowells@redhat.com | 1177627817 |  | [AF_RXRPC]: Add an interface to the AF_RXRPC module for the AFS filesystem to use  Add an interface to the AF_RXRPC module so that the AFS filesystem module can more easily make use of the services available.  AFS still opens a socket but then uses the action functions in lieu of sendmsg() and registers an intercept functions to grab messages before they're queued on the socket Rx queue.  This permits AFS (or whatever) to:   (1) Avoid the overhead of using the recvmsg() call.   (2) Use different keys directly on individual client calls on one socket      rather than having to open a whole slew of sockets, one for each key it      might want to use.   (3) Avoid calling request_key() at the point of issue of a call or opening of      a socket.  This is done instead by AFS at the point of open(), unlink() or      other VFS operation and the key handed through.   (4) Request the use of something other than GFP_KERNEL to allocate memory.  Furthermore:   (*) The socket buffer markings used by RxRPC are made available for AFS so      that it can interpret the cooked RxRPC messages itself.   (*) rxgen (un)marshalling abort codes are made available.   The following documentation for the kernel interface is added to Documentation/networking/rxrpc.txt:  ========================= AF_RXRPC KERNEL INTERFACE =========================  The AF_RXRPC module also provides an interface for use by in-kernel utilities such as the AFS filesystem.  This permits such a utility to:   (1) Use different keys directly on individual client calls on one socket      rather than having to open a whole slew of sockets, one for each key it      might want to use.   (2) Avoid having RxRPC call request_key() at the point of issue of a call or      opening of a socket.  Instead the utility is responsible for requesting a      key at the appropriate point.  AFS, for instance, would do this during VFS      operations such as open() or unlink().  The key is then handed through      when the call is initiated.   (3) Request the use of something other than GFP_KERNEL to allocate memory.   (4) Avoid the overhead of using the recvmsg() call.  RxRPC messages can be      intercepted before they get put into the socket Rx queue and the socket      buffers manipulated directly.  To use the RxRPC facility, a kernel utility must still open an AF_RXRPC socket, bind an addess as appropriate and listen if it's to be a server socket, but then it passes this to the kernel interface functions.  The kernel interface functions are as follows:   (*) Begin a new client call.  	struct rxrpc_call * 	rxrpc_kernel_begin_call(struct socket *sock, 				struct sockaddr_rxrpc *srx, 				struct key *key, 				unsigned long user_call_ID, 				gfp_t gfp);       This allocates the infrastructure to make a new RxRPC call and assigns      call and connection numbers.  The call will be made on the UDP port that      the socket is bound to.  The call will go to the destination address of a      connected client socket unless an alternative is supplied (srx is      non-NULL).       If a key is supplied then this will be used to secure the call instead of      the key bound to the socket with the RXRPC_SECURITY_KEY sockopt.  Calls      secured in this way will still share connections if at all possible.       The user_call_ID is equivalent to that supplied to sendmsg() in the      control data buffer.  It is entirely feasible to use this to point to a      kernel data structure.       If this function is successful, an opaque reference to the RxRPC call is      returned.  The caller now holds a reference on this and it must be      properly ended.   (*) End a client call.  	void rxrpc_kernel_end_call(struct rxrpc_call *call);       This is used to end a previously begun call.  The user_call_ID is expunged      from AF_RXRPC's knowledge and will not be seen again in association with      the specified call.   (*) Send data through a call.  	int rxrpc_kernel_send_data(struct rxrpc_call *call, struct msghdr *msg, 				   size_t len);       This is used to supply either the request part of a client call or the      reply part of a server call.  msg.msg_iovlen and msg.msg_iov specify the      data buffers to be used.  msg_iov may not be NULL and must point      exclusively to in-kernel virtual addresses.  msg.msg_flags may be given      MSG_MORE if there will be subsequent data sends for this call.       The msg must not specify a destination address, control data or any flags      other than MSG_MORE.  len is the total amount of data to transmit.   (*) Abort a call.  	void rxrpc_kernel_abort_call(struct rxrpc_call *call, u32 abort_code);       This is used to abort a call if it's still in an abortable state.  The      abort code specified will be placed in the ABORT message sent.   (*) Intercept received RxRPC messages.  	typedef void (*rxrpc_interceptor_t)(struct sock *sk, 					    unsigned long user_call_ID, 					    struct sk_buff *skb);  	void 	rxrpc_kernel_intercept_rx_messages(struct socket *sock, 					   rxrpc_interceptor_t interceptor);       This installs an interceptor function on the specified AF_RXRPC socket.      All messages that would otherwise wind up in the socket's Rx queue are      then diverted to this function.  Note that care must be taken to process      the messages in the right order to maintain DATA message sequentiality.       The interceptor function itself is provided with the address of the socket      and handling the incoming message, the ID assigned by the kernel utility      to the call and the socket buffer containing the message.       The skb->mark field indicates the type of message:  	MARK				MEANING 	===============================	======================================= 	RXRPC_SKB_MARK_DATA		Data message 	RXRPC_SKB_MARK_FINAL_ACK	Final ACK received for an incoming call 	RXRPC_SKB_MARK_BUSY		Client call rejected as server busy 	RXRPC_SKB_MARK_REMOTE_ABORT	Call aborted by peer 	RXRPC_SKB_MARK_NET_ERROR	Network error detected 	RXRPC_SKB_MARK_LOCAL_ERROR	Local error encountered 	RXRPC_SKB_MARK_NEW_CALL		New incoming call awaiting acceptance       The remote abort message can be probed with rxrpc_kernel_get_abort_code().      The two error messages can be probed with rxrpc_kernel_get_error_number().      A new call can be accepted with rxrpc_kernel_accept_call().       Data messages can have their contents extracted with the usual bunch of      socket buffer manipulation functions.  A data message can be determined to      be the last one in a sequence with rxrpc_kernel_is_data_last().  When a      data message has been used up, rxrpc_kernel_data_delivered() should be      called on it..       Non-data messages should be handled to rxrpc_kernel_free_skb() to dispose      of.  It is possible to get extra refs on all types of message for later      freeing, but this may pin the state of a call until the message is finally      freed.   (*) Accept an incoming call.  	struct rxrpc_call * 	rxrpc_kernel_accept_call(struct socket *sock, 				 unsigned long user_call_ID);       This is used to accept an incoming call and to assign it a call ID.  This      function is similar to rxrpc_kernel_begin_call() and calls accepted must      be ended in the same way.       If this function is successful, an opaque reference to the RxRPC call is      returned.  The caller now holds a reference on this and it must be      properly ended.   (*) Reject an incoming call.  	int rxrpc_kernel_reject_call(struct socket *sock);       This is used to reject the first incoming call on the socket's queue with      a BUSY message.  -ENODATA is returned if there were no incoming calls.      Other errors may be returned if the call had been aborted (-ECONNABORTED)      or had timed out (-ETIME).   (*) Record the delivery of a data message and free it.  	void rxrpc_kernel_data_delivered(struct sk_buff *skb);       This is used to record a data message as having been delivered and to      update the ACK state for the call.  The socket buffer will be freed.   (*) Free a message.  	void rxrpc_kernel_free_skb(struct sk_buff *skb);       This is used to free a non-DATA socket buffer intercepted from an AF_RXRPC      socket.   (*) Determine if a data message is the last one on a call.  	bool rxrpc_kernel_is_data_last(struct sk_buff *skb);       This is used to determine if a socket buffer holds the last data message      to be received for a call (true will be returned if it does, false      if not).       The data message will be part of the reply on a client call and the      request on an incoming call.  In the latter case there will be more      messages, but in the former case there will not.   (*) Get the abort code from an abort message.  	u32 rxrpc_kernel_get_abort_code(struct sk_buff *skb);       This is used to extract the abort code from a remote abort message.   (*) Get the error number from a local or network error message.  	int rxrpc_kernel_get_error_number(struct sk_buff *skb);       This is used to extract the error number from a message indicating either      a local error occurred or a network error occurred.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-ack.c | s | 32K | 1109 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-output.c | s | 17K | 621 | Rusty Russell | rusty@rustcorp.com.au | 1324351649 |  | net: fix assignment of 0/1 to bool variables.  DaveM said:    Please, this kind of stuff rots forever and not using bool properly    drives me crazy.  Joe Perches <joe@perches.com> gave me the spatch script:  	@@ 	bool b; 	@@ 	-b = 0 	+b = false 	@@ 	bool b; 	@@ 	-b = 1 	+b = true  I merely installed coccinelle, read the documentation and took credit.  Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> Signed-off-by: David S. Miller <davem@davemloft.net>
f | af_rxrpc.c | s | 20K | 752 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-error.c | s | 5.8K | 214 | David S. Miller | davem@davemloft.net | 1305844631 |  | rxrpc: Kill set but unused variable 'local' in rxrpc_UDP_error_handler()  Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-key.c | s | 28K | 1031 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-input.c | s | 19K | 672 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-internal.h | s | 27K | 695 | Eric Dumazet | eric.dumazet@gmail.com | 1334508280 |  | net: cleanup unsigned to unsigned int  Use of "unsigned int" is preferred to bare "unsigned" in net tree.  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-connevent.c | s | 9.0K | 340 | David S. Miller | davem@davemloft.net | 1305844558 |  | rxrpc: Kill set but unused variable 'sp' in rxrpc_process_connection()  Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-peer.c | s | 7.2K | 252 | David S. Miller | davem@davemloft.net | 1305844863 |  | rxrpc: Fix set but unused variable 'usage' in rxrpc_get_peer().  I backed off from trying to just eliminate this variable, since transforming atomic_inc_return() into atomic_inc() takes away the memory barriers.  Signed-off-by: David S. Miller <davem@davemloft.net>
f | ar-recvmsg.c | s | 10K | 372 | Paul Gortmaker | paul.gortmaker@windriver.com | 1320103830 |  | net: Add export.h for EXPORT_SYMBOL/THIS_MODULE to non-modules  These files are non modular, but need to export symbols using the macros now living in export.h -- call out the include so that things won't break when we remove the implicit presence of module.h from everywhere.  Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
f | ar-connection.c | s | 22K | 770 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | Kconfig | g | 1.0K |  | David Howells | dhowells@redhat.com | 1196425840 |  | [RXRPC]: Add missing select on CRYPTO  AF_RXRPC uses the crypto services, so should depend on or select CRYPTO.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
f | ar-security.c | s | 5.6K | 220 | David Howells | dhowells@redhat.com | 1253007863 |  | RxRPC: Allow key payloads to be passed in XDR form  Allow add_key() and KEYCTL_INSTANTIATE to accept key payloads in XDR form as described by openafs-1.4.10/src/auth/afs_token.xg.  This provides a way of passing kaserver, Kerberos 4, Kerberos 5 and GSSAPI keys from userspace, and allows for future expansion.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: David S. Miller <davem@davemloft.net>
