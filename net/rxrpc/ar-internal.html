<!DOCTYPE html>
<html><head><title>joekychen/linux » net › rxrpc › ar-internal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ar-internal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* AF_RXRPC internal definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;rxrpc/packet.h&gt;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define CHECK_SLAB_OKAY(X)				     \</span>
<span class="c">	BUG_ON(atomic_read((X)) &gt;&gt; (sizeof(atomic_t) - 2) == \</span>
<span class="c">	       (POISON_FREE &lt;&lt; 8 | POISON_FREE))</span>
<span class="cp">#else</span>
<span class="cp">#define CHECK_SLAB_OKAY(X) do {} while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#define FCRYPT_BSIZE 8</span>
<span class="k">struct</span> <span class="n">rxrpc_crypt</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u8</span>	<span class="n">x</span><span class="p">[</span><span class="n">FCRYPT_BSIZE</span><span class="p">];</span>
		<span class="n">__be32</span>	<span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">};</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cp">#define rxrpc_queue_work(WS)	queue_work(rxrpc_workqueue, (WS))</span>
<span class="cp">#define rxrpc_queue_delayed_work(WS,D)	\</span>
<span class="cp">	queue_delayed_work(rxrpc_workqueue, (WS), (D))</span>

<span class="cp">#define rxrpc_queue_call(CALL)	rxrpc_queue_work(&amp;(CALL)-&gt;processor)</span>
<span class="cp">#define rxrpc_queue_conn(CONN)	rxrpc_queue_work(&amp;(CONN)-&gt;processor)</span>

<span class="cm">/*</span>
<span class="cm"> * sk_state for RxRPC sockets</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RXRPC_UNCONNECTED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RXRPC_CLIENT_BOUND</span><span class="p">,</span>		<span class="cm">/* client local address bound */</span>
	<span class="n">RXRPC_CLIENT_CONNECTED</span><span class="p">,</span>		<span class="cm">/* client is connected */</span>
	<span class="n">RXRPC_SERVER_BOUND</span><span class="p">,</span>		<span class="cm">/* server local address bound */</span>
	<span class="n">RXRPC_SERVER_LISTENING</span><span class="p">,</span>		<span class="cm">/* server listening for connections */</span>
	<span class="n">RXRPC_CLOSE</span><span class="p">,</span>			<span class="cm">/* socket is being closed */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC socket definition</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="p">{</span>
	<span class="cm">/* WARNING: sk has to be the first member */</span>
	<span class="k">struct</span> <span class="n">sock</span>		<span class="n">sk</span><span class="p">;</span>
	<span class="n">rxrpc_interceptor_t</span>	<span class="n">interceptor</span><span class="p">;</span>	<span class="cm">/* kernel service Rx interceptor function */</span>
	<span class="k">struct</span> <span class="n">rxrpc_local</span>	<span class="o">*</span><span class="n">local</span><span class="p">;</span>		<span class="cm">/* local endpoint */</span>
	<span class="k">struct</span> <span class="n">rxrpc_transport</span>	<span class="o">*</span><span class="n">trans</span><span class="p">;</span>		<span class="cm">/* transport handler */</span>
	<span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">;</span>	<span class="cm">/* virtual connection bundle */</span>
	<span class="k">struct</span> <span class="n">rxrpc_connection</span>	<span class="o">*</span><span class="n">conn</span><span class="p">;</span>		<span class="cm">/* exclusive virtual connection */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">listen_link</span><span class="p">;</span>	<span class="cm">/* link in the local endpoint&#39;s listen list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">secureq</span><span class="p">;</span>	<span class="cm">/* calls awaiting connection security clearance */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">acceptq</span><span class="p">;</span>	<span class="cm">/* calls awaiting acceptance */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* security for this socket */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">securities</span><span class="p">;</span>	<span class="cm">/* list of server security descriptors */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">calls</span><span class="p">;</span>		<span class="cm">/* outstanding calls on this socket */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define RXRPC_SOCK_EXCLUSIVE_CONN	1	</span><span class="cm">/* exclusive connection for a client socket */</span><span class="cp"></span>
	<span class="n">rwlock_t</span>		<span class="n">call_lock</span><span class="p">;</span>	<span class="cm">/* lock for calls */</span>
	<span class="n">u32</span>			<span class="n">min_sec_level</span><span class="p">;</span>	<span class="cm">/* minimum security level */</span>
<span class="cp">#define RXRPC_SECURITY_MAX	RXRPC_SECURITY_ENCRYPT</span>
	<span class="k">struct</span> <span class="n">sockaddr_rxrpc</span>	<span class="n">srx</span><span class="p">;</span>		<span class="cm">/* local address */</span>
	<span class="n">sa_family_t</span>		<span class="n">proto</span><span class="p">;</span>		<span class="cm">/* protocol created with */</span>
	<span class="n">__be16</span>			<span class="n">service_id</span><span class="p">;</span>	<span class="cm">/* service ID of local/remote service */</span>
<span class="p">};</span>

<span class="cp">#define rxrpc_sk(__sk) container_of((__sk), struct rxrpc_sock, sk)</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC socket buffer private variables</span>
<span class="cm"> * - max 48 bytes (struct sk_buff::cb)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_skb_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxrpc_call</span>	<span class="o">*</span><span class="n">call</span><span class="p">;</span>		<span class="cm">/* call with which associated */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">resend_at</span><span class="p">;</span>	<span class="cm">/* time in jiffies at which to resend */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* offset into buffer of next read */</span>
		<span class="kt">int</span>		<span class="n">remain</span><span class="p">;</span>		<span class="cm">/* amount of space remaining for next write */</span>
		<span class="n">u32</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* network error code */</span>
		<span class="n">bool</span>		<span class="n">need_resend</span><span class="p">;</span>	<span class="cm">/* T if needs resending */</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">rxrpc_header</span>	<span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* RxRPC packet header from this packet */</span>
<span class="p">};</span>

<span class="cp">#define rxrpc_skb(__skb) ((struct rxrpc_skb_priv *) &amp;(__skb)-&gt;cb)</span>

<span class="k">enum</span> <span class="n">rxrpc_command</span> <span class="p">{</span>
	<span class="n">RXRPC_CMD_SEND_DATA</span><span class="p">,</span>		<span class="cm">/* send data message */</span>
	<span class="n">RXRPC_CMD_SEND_ABORT</span><span class="p">,</span>		<span class="cm">/* request abort generation */</span>
	<span class="n">RXRPC_CMD_ACCEPT</span><span class="p">,</span>		<span class="cm">/* [server] accept incoming call */</span>
	<span class="n">RXRPC_CMD_REJECT_BUSY</span><span class="p">,</span>		<span class="cm">/* [server] reject a call as busy */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC security module interface</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_security</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>		<span class="cm">/* providing module */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in master list */</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* name of this service */</span>
	<span class="n">u8</span>			<span class="n">security_index</span><span class="p">;</span>	<span class="cm">/* security type provided */</span>

	<span class="cm">/* initialise a connection&#39;s security */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_connection_security</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* prime a connection&#39;s packet security */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prime_packet_security</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* impose security on a packet */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">secure_packet</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
			     <span class="kt">size_t</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* verify the security on a received packet */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">verify_packet</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* issue a challenge */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">issue_challenge</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* respond to a challenge */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">respond_to_challenge</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* verify a response */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">verify_response</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* clear connection security */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC local transport endpoint definition</span>
<span class="cm"> * - matched by local port, address and protocol type</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span>		<span class="o">*</span><span class="n">socket</span><span class="p">;</span>	<span class="cm">/* my UDP socket */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">destroyer</span><span class="p">;</span>	<span class="cm">/* endpoint destroyer */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">acceptor</span><span class="p">;</span>	<span class="cm">/* incoming call processor */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">rejecter</span><span class="p">;</span>	<span class="cm">/* packet reject writer */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">services</span><span class="p">;</span>	<span class="cm">/* services listening on this endpoint */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in endpoint list */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">defrag_sem</span><span class="p">;</span>	<span class="cm">/* control re-enablement of IP DF bit */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">accept_queue</span><span class="p">;</span>	<span class="cm">/* incoming calls awaiting acceptance */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">reject_queue</span><span class="p">;</span>	<span class="cm">/* packets awaiting rejection */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* access lock */</span>
	<span class="n">rwlock_t</span>		<span class="n">services_lock</span><span class="p">;</span>	<span class="cm">/* lock for services list */</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debug ID for printks */</span>
	<span class="k">volatile</span> <span class="kt">char</span>		<span class="n">error_rcvd</span><span class="p">;</span>	<span class="cm">/* T if received ICMP error outstanding */</span>
	<span class="k">struct</span> <span class="n">sockaddr_rxrpc</span>	<span class="n">srx</span><span class="p">;</span>		<span class="cm">/* local address */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC remote transport endpoint definition</span>
<span class="cm"> * - matched by remote port, address and protocol type</span>
<span class="cm"> * - holds the connection ID counter for connections between the two endpoints</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_peer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">destroyer</span><span class="p">;</span>	<span class="cm">/* peer destroyer */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in master peer list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">error_targets</span><span class="p">;</span>	<span class="cm">/* targets for net error distribution */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* access lock */</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">if_mtu</span><span class="p">;</span>		<span class="cm">/* interface MTU for this peer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mtu</span><span class="p">;</span>		<span class="cm">/* network MTU for this peer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">maxdata</span><span class="p">;</span>	<span class="cm">/* data size (MTU - hdrsize) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">hdrsize</span><span class="p">;</span>	<span class="cm">/* header size (IP + UDP + RxRPC) */</span>
	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debug ID for printks */</span>
	<span class="kt">int</span>			<span class="n">net_error</span><span class="p">;</span>	<span class="cm">/* network error distributed */</span>
	<span class="k">struct</span> <span class="n">sockaddr_rxrpc</span>	<span class="n">srx</span><span class="p">;</span>		<span class="cm">/* remote address */</span>

	<span class="cm">/* calculated RTT cache */</span>
<span class="cp">#define RXRPC_RTT_CACHE_SIZE 32</span>
	<span class="n">suseconds_t</span>		<span class="n">rtt</span><span class="p">;</span>		<span class="cm">/* current RTT estimate (in uS) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rtt_point</span><span class="p">;</span>	<span class="cm">/* next entry at which to insert */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rtt_usage</span><span class="p">;</span>	<span class="cm">/* amount of cache actually used */</span>
	<span class="n">suseconds_t</span>		<span class="n">rtt_cache</span><span class="p">[</span><span class="n">RXRPC_RTT_CACHE_SIZE</span><span class="p">];</span> <span class="cm">/* calculated RTT cache */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC point-to-point transport / connection manager definition</span>
<span class="cm"> * - handles a bundle of connections between two endpoints</span>
<span class="cm"> * - matched by { local, peer }</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxrpc_local</span>	<span class="o">*</span><span class="n">local</span><span class="p">;</span>		<span class="cm">/* local transport endpoint */</span>
	<span class="k">struct</span> <span class="n">rxrpc_peer</span>	<span class="o">*</span><span class="n">peer</span><span class="p">;</span>		<span class="cm">/* remote transport endpoint */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">error_handler</span><span class="p">;</span>	<span class="cm">/* network error distributor */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">bundles</span><span class="p">;</span>	<span class="cm">/* client connection bundles on this transport */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">client_conns</span><span class="p">;</span>	<span class="cm">/* client connections on this transport */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">server_conns</span><span class="p">;</span>	<span class="cm">/* server connections on this transport */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in master session list */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">error_queue</span><span class="p">;</span>	<span class="cm">/* error packets awaiting processing */</span>
	<span class="kt">time_t</span>			<span class="n">put_time</span><span class="p">;</span>	<span class="cm">/* time at which to reap */</span>
	<span class="n">spinlock_t</span>		<span class="n">client_lock</span><span class="p">;</span>	<span class="cm">/* client connection allocation lock */</span>
	<span class="n">rwlock_t</span>		<span class="n">conn_lock</span><span class="p">;</span>	<span class="cm">/* lock for active/dead connections */</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debug ID for printks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">conn_idcounter</span><span class="p">;</span>	<span class="cm">/* connection ID counter (client) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC client connection bundle</span>
<span class="cm"> * - matched by { transport, service_id, key }</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">node</span><span class="p">;</span>		<span class="cm">/* node in transport&#39;s lookup tree */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">unused_conns</span><span class="p">;</span>	<span class="cm">/* unused connections in this bundle */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">avail_conns</span><span class="p">;</span>	<span class="cm">/* available connections in this bundle */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">busy_conns</span><span class="p">;</span>	<span class="cm">/* busy connections in this bundle */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* security for this bundle */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">chanwait</span><span class="p">;</span>	<span class="cm">/* wait for channel to become available */</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debug ID for printks */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">num_conns</span><span class="p">;</span>	<span class="cm">/* number of connections in this bundle */</span>
	<span class="n">__be16</span>			<span class="n">service_id</span><span class="p">;</span>	<span class="cm">/* service ID */</span>
	<span class="n">u8</span>			<span class="n">security_ix</span><span class="p">;</span>	<span class="cm">/* security type */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC connection definition</span>
<span class="cm"> * - matched by { transport, service_id, conn_id, direction, key }</span>
<span class="cm"> * - each connection can only handle four simultaneous calls</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxrpc_transport</span>	<span class="o">*</span><span class="n">trans</span><span class="p">;</span>		<span class="cm">/* transport session */</span>
	<span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">;</span>	<span class="cm">/* connection bundle (client) */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">processor</span><span class="p">;</span>	<span class="cm">/* connection event processor */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">node</span><span class="p">;</span>		<span class="cm">/* node in transport&#39;s lookup tree */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in master connection list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">bundle_link</span><span class="p">;</span>	<span class="cm">/* link in bundle */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">calls</span><span class="p">;</span>		<span class="cm">/* calls on this connection */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">rx_queue</span><span class="p">;</span>	<span class="cm">/* received conn-level packets */</span>
	<span class="k">struct</span> <span class="n">rxrpc_call</span>	<span class="o">*</span><span class="n">channels</span><span class="p">[</span><span class="n">RXRPC_MAXCALLS</span><span class="p">];</span> <span class="cm">/* channels (active calls) */</span>
	<span class="k">struct</span> <span class="n">rxrpc_security</span>	<span class="o">*</span><span class="n">security</span><span class="p">;</span>	<span class="cm">/* applied security module */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* security for this connection (client) */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">server_key</span><span class="p">;</span>	<span class="cm">/* security for this service */</span>
	<span class="k">struct</span> <span class="n">crypto_blkcipher</span>	<span class="o">*</span><span class="n">cipher</span><span class="p">;</span>	<span class="cm">/* encryption handle */</span>
	<span class="k">struct</span> <span class="n">rxrpc_crypt</span>	<span class="n">csum_iv</span><span class="p">;</span>	<span class="cm">/* packet checksum base */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">events</span><span class="p">;</span>
<span class="cp">#define RXRPC_CONN_CHALLENGE	0		</span><span class="cm">/* send challenge packet */</span><span class="cp"></span>
	<span class="kt">time_t</span>			<span class="n">put_time</span><span class="p">;</span>	<span class="cm">/* time at which to reap */</span>
	<span class="n">rwlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* access lock */</span>
	<span class="n">spinlock_t</span>		<span class="n">state_lock</span><span class="p">;</span>	<span class="cm">/* state-change lock */</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">real_conn_id</span><span class="p">;</span>	<span class="cm">/* connection ID (host-endian) */</span>
	<span class="k">enum</span> <span class="p">{</span>					<span class="cm">/* current state of connection */</span>
		<span class="n">RXRPC_CONN_UNUSED</span><span class="p">,</span>		<span class="cm">/* - connection not yet attempted */</span>
		<span class="n">RXRPC_CONN_CLIENT</span><span class="p">,</span>		<span class="cm">/* - client connection */</span>
		<span class="n">RXRPC_CONN_SERVER_UNSECURED</span><span class="p">,</span>	<span class="cm">/* - server unsecured connection */</span>
		<span class="n">RXRPC_CONN_SERVER_CHALLENGING</span><span class="p">,</span>	<span class="cm">/* - server challenging for security */</span>
		<span class="n">RXRPC_CONN_SERVER</span><span class="p">,</span>		<span class="cm">/* - server secured connection */</span>
		<span class="n">RXRPC_CONN_REMOTELY_ABORTED</span><span class="p">,</span>	<span class="cm">/* - conn aborted by peer */</span>
		<span class="n">RXRPC_CONN_LOCALLY_ABORTED</span><span class="p">,</span>	<span class="cm">/* - conn aborted locally */</span>
		<span class="n">RXRPC_CONN_NETWORK_ERROR</span><span class="p">,</span>	<span class="cm">/* - conn terminated by network error */</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error code for local abort */</span>
	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debug ID for printks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">call_counter</span><span class="p">;</span>	<span class="cm">/* call ID counter */</span>
	<span class="n">atomic_t</span>		<span class="n">serial</span><span class="p">;</span>		<span class="cm">/* packet serial number counter */</span>
	<span class="n">atomic_t</span>		<span class="n">hi_serial</span><span class="p">;</span>	<span class="cm">/* highest serial number received */</span>
	<span class="n">u8</span>			<span class="n">avail_calls</span><span class="p">;</span>	<span class="cm">/* number of calls available */</span>
	<span class="n">u8</span>			<span class="n">size_align</span><span class="p">;</span>	<span class="cm">/* data size alignment (for security) */</span>
	<span class="n">u8</span>			<span class="n">header_size</span><span class="p">;</span>	<span class="cm">/* rxrpc + security header size */</span>
	<span class="n">u8</span>			<span class="n">security_size</span><span class="p">;</span>	<span class="cm">/* security header size */</span>
	<span class="n">u32</span>			<span class="n">security_level</span><span class="p">;</span>	<span class="cm">/* security level negotiated */</span>
	<span class="n">u32</span>			<span class="n">security_nonce</span><span class="p">;</span>	<span class="cm">/* response re-use preventer */</span>

	<span class="cm">/* the following are all in net order */</span>
	<span class="n">__be32</span>			<span class="n">epoch</span><span class="p">;</span>		<span class="cm">/* epoch of this connection */</span>
	<span class="n">__be32</span>			<span class="n">cid</span><span class="p">;</span>		<span class="cm">/* connection ID */</span>
	<span class="n">__be16</span>			<span class="n">service_id</span><span class="p">;</span>	<span class="cm">/* service ID */</span>
	<span class="n">u8</span>			<span class="n">security_ix</span><span class="p">;</span>	<span class="cm">/* security type */</span>
	<span class="n">u8</span>			<span class="n">in_clientflag</span><span class="p">;</span>	<span class="cm">/* RXRPC_CLIENT_INITIATED if we are server */</span>
	<span class="n">u8</span>			<span class="n">out_clientflag</span><span class="p">;</span>	<span class="cm">/* RXRPC_CLIENT_INITIATED if we are client */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RxRPC call definition</span>
<span class="cm"> * - matched by { connection, call_id }</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rxrpc_connection</span>	<span class="o">*</span><span class="n">conn</span><span class="p">;</span>		<span class="cm">/* connection carrying call */</span>
	<span class="k">struct</span> <span class="n">rxrpc_sock</span>	<span class="o">*</span><span class="n">socket</span><span class="p">;</span>	<span class="cm">/* socket responsible */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">lifetimer</span><span class="p">;</span>	<span class="cm">/* lifetime remaining on call */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">deadspan</span><span class="p">;</span>	<span class="cm">/* reap timer for re-ACK&#39;ing, etc  */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">ack_timer</span><span class="p">;</span>	<span class="cm">/* ACK generation timer */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">resend_timer</span><span class="p">;</span>	<span class="cm">/* Tx resend timer */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">destroyer</span><span class="p">;</span>	<span class="cm">/* call destroyer */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">processor</span><span class="p">;</span>	<span class="cm">/* packet processor and ACK generator */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in master call list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">error_link</span><span class="p">;</span>	<span class="cm">/* link in error distribution list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">accept_link</span><span class="p">;</span>	<span class="cm">/* calls awaiting acceptance */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">sock_node</span><span class="p">;</span>	<span class="cm">/* node in socket call tree */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">conn_node</span><span class="p">;</span>	<span class="cm">/* node in connection call tree */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">rx_queue</span><span class="p">;</span>	<span class="cm">/* received packets */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">rx_oos_queue</span><span class="p">;</span>	<span class="cm">/* packets received out of sequence */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">tx_pending</span><span class="p">;</span>	<span class="cm">/* Tx socket buffer being filled */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">tx_waitq</span><span class="p">;</span>	<span class="cm">/* wait for Tx window space to become available */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">user_call_ID</span><span class="p">;</span>	<span class="cm">/* user-defined call ID */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">creation_jif</span><span class="p">;</span>	<span class="cm">/* time of call creation */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define RXRPC_CALL_RELEASED	0	</span><span class="cm">/* call has been released - no more message to userspace */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_TERMINAL_MSG	1	</span><span class="cm">/* call has given the socket its final message */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RCVD_LAST	2	</span><span class="cm">/* all packets received */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RUN_RTIMER	3	</span><span class="cm">/* Tx resend timer started */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_TX_SOFT_ACK	4	</span><span class="cm">/* sent some soft ACKs */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_PROC_BUSY	5	</span><span class="cm">/* the processor is busy */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_INIT_ACCEPT	6	</span><span class="cm">/* acceptance was initiated */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_HAS_USERID	7	</span><span class="cm">/* has a user ID attached */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_EXPECT_OOS	8	</span><span class="cm">/* expect out of sequence packets */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">events</span><span class="p">;</span>
<span class="cp">#define RXRPC_CALL_RCVD_ACKALL	0	</span><span class="cm">/* ACKALL or reply received */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RCVD_BUSY	1	</span><span class="cm">/* busy packet received */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RCVD_ABORT	2	</span><span class="cm">/* abort packet received */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RCVD_ERROR	3	</span><span class="cm">/* network error received */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_ACK_FINAL	4	</span><span class="cm">/* need to generate final ACK (and release call) */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_ACK		5	</span><span class="cm">/* need to generate ACK */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_REJECT_BUSY	6	</span><span class="cm">/* need to generate busy message */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_ABORT	7	</span><span class="cm">/* need to generate abort */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_CONN_ABORT	8	</span><span class="cm">/* local connection abort generated */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RESEND_TIMER	9	</span><span class="cm">/* Tx resend timer expired */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RESEND	10	</span><span class="cm">/* Tx resend required */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_DRAIN_RX_OOS	11	</span><span class="cm">/* drain the Rx out of sequence queue */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_LIFE_TIMER	12	</span><span class="cm">/* call&#39;s lifetimer ran out */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_ACCEPTED	13	</span><span class="cm">/* incoming call accepted by userspace app */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_SECURED	14	</span><span class="cm">/* incoming call&#39;s connection is now secure */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_POST_ACCEPT	15	</span><span class="cm">/* need to post an &quot;accept?&quot; message to the app */</span><span class="cp"></span>
<span class="cp">#define RXRPC_CALL_RELEASE	16	</span><span class="cm">/* need to release the call&#39;s resources */</span><span class="cp"></span>

	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="n">rwlock_t</span>		<span class="n">state_lock</span><span class="p">;</span>	<span class="cm">/* lock for state transition */</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">sequence</span><span class="p">;</span>	<span class="cm">/* Tx data packet sequence counter */</span>
	<span class="n">u32</span>			<span class="n">abort_code</span><span class="p">;</span>	<span class="cm">/* local/remote abort code */</span>
	<span class="k">enum</span> <span class="p">{</span>					<span class="cm">/* current state of call */</span>
		<span class="n">RXRPC_CALL_CLIENT_SEND_REQUEST</span><span class="p">,</span>	<span class="cm">/* - client sending request phase */</span>
		<span class="n">RXRPC_CALL_CLIENT_AWAIT_REPLY</span><span class="p">,</span>	<span class="cm">/* - client awaiting reply */</span>
		<span class="n">RXRPC_CALL_CLIENT_RECV_REPLY</span><span class="p">,</span>	<span class="cm">/* - client receiving reply phase */</span>
		<span class="n">RXRPC_CALL_CLIENT_FINAL_ACK</span><span class="p">,</span>	<span class="cm">/* - client sending final ACK phase */</span>
		<span class="n">RXRPC_CALL_SERVER_SECURING</span><span class="p">,</span>	<span class="cm">/* - server securing request connection */</span>
		<span class="n">RXRPC_CALL_SERVER_ACCEPTING</span><span class="p">,</span>	<span class="cm">/* - server accepting request */</span>
		<span class="n">RXRPC_CALL_SERVER_RECV_REQUEST</span><span class="p">,</span>	<span class="cm">/* - server receiving request */</span>
		<span class="n">RXRPC_CALL_SERVER_ACK_REQUEST</span><span class="p">,</span>	<span class="cm">/* - server pending ACK of request */</span>
		<span class="n">RXRPC_CALL_SERVER_SEND_REPLY</span><span class="p">,</span>	<span class="cm">/* - server sending reply */</span>
		<span class="n">RXRPC_CALL_SERVER_AWAIT_ACK</span><span class="p">,</span>	<span class="cm">/* - server awaiting final ACK */</span>
		<span class="n">RXRPC_CALL_COMPLETE</span><span class="p">,</span>		<span class="cm">/* - call completed */</span>
		<span class="n">RXRPC_CALL_SERVER_BUSY</span><span class="p">,</span>		<span class="cm">/* - call rejected by busy server */</span>
		<span class="n">RXRPC_CALL_REMOTELY_ABORTED</span><span class="p">,</span>	<span class="cm">/* - call aborted by peer */</span>
		<span class="n">RXRPC_CALL_LOCALLY_ABORTED</span><span class="p">,</span>	<span class="cm">/* - call aborted locally on error or close */</span>
		<span class="n">RXRPC_CALL_NETWORK_ERROR</span><span class="p">,</span>	<span class="cm">/* - call terminated by network error */</span>
		<span class="n">RXRPC_CALL_DEAD</span><span class="p">,</span>		<span class="cm">/* - call is dead */</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debug ID for printks */</span>
	<span class="n">u8</span>			<span class="n">channel</span><span class="p">;</span>	<span class="cm">/* connection channel occupied by this call */</span>

	<span class="cm">/* transmission-phase ACK management */</span>
	<span class="n">u8</span>			<span class="n">acks_head</span><span class="p">;</span>	<span class="cm">/* offset into window of first entry */</span>
	<span class="n">u8</span>			<span class="n">acks_tail</span><span class="p">;</span>	<span class="cm">/* offset into window of last entry */</span>
	<span class="n">u8</span>			<span class="n">acks_winsz</span><span class="p">;</span>	<span class="cm">/* size of un-ACK&#39;d window */</span>
	<span class="n">u8</span>			<span class="n">acks_unacked</span><span class="p">;</span>	<span class="cm">/* lowest unacked packet in last ACK received */</span>
	<span class="kt">int</span>			<span class="n">acks_latest</span><span class="p">;</span>	<span class="cm">/* serial number of latest ACK received */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">acks_hard</span><span class="p">;</span>	<span class="cm">/* highest definitively ACK&#39;d msg seq */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="o">*</span><span class="n">acks_window</span><span class="p">;</span>	<span class="cm">/* sent packet window</span>
<span class="cm">						 * - elements are pointers with LSB set if ACK&#39;d</span>
<span class="cm">						 */</span>

	<span class="cm">/* receive-phase ACK management */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">rx_data_expect</span><span class="p">;</span>	<span class="cm">/* next data seq ID expected to be received */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">rx_data_post</span><span class="p">;</span>	<span class="cm">/* next data seq ID expected to be posted */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">rx_data_recv</span><span class="p">;</span>	<span class="cm">/* last data seq ID encountered by recvmsg */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">rx_data_eaten</span><span class="p">;</span>	<span class="cm">/* last data seq ID consumed by recvmsg */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">rx_first_oos</span><span class="p">;</span>	<span class="cm">/* first packet in rx_oos_queue (or 0) */</span>
	<span class="n">rxrpc_seq_t</span>		<span class="n">ackr_win_top</span><span class="p">;</span>	<span class="cm">/* top of ACK window (rx_data_eaten is bottom) */</span>
	<span class="n">rxrpc_seq_net_t</span>		<span class="n">ackr_prev_seq</span><span class="p">;</span>	<span class="cm">/* previous sequence number received */</span>
	<span class="n">u8</span>			<span class="n">ackr_reason</span><span class="p">;</span>	<span class="cm">/* reason to ACK */</span>
	<span class="n">__be32</span>			<span class="n">ackr_serial</span><span class="p">;</span>	<span class="cm">/* serial of packet being ACK&#39;d */</span>
	<span class="n">atomic_t</span>		<span class="n">ackr_not_idle</span><span class="p">;</span>	<span class="cm">/* number of packets in Rx queue */</span>

	<span class="cm">/* received packet records, 1 bit per record */</span>
<span class="cp">#define RXRPC_ACKR_WINDOW_ASZ DIV_ROUND_UP(RXRPC_MAXACKS, BITS_PER_LONG)</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ackr_window</span><span class="p">[</span><span class="n">RXRPC_ACKR_WINDOW_ASZ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* the following should all be in net order */</span>
	<span class="n">__be32</span>			<span class="n">cid</span><span class="p">;</span>		<span class="cm">/* connection ID + channel index  */</span>
	<span class="n">__be32</span>			<span class="n">call_id</span><span class="p">;</span>	<span class="cm">/* call ID on connection  */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * locally abort an RxRPC call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rxrpc_abort_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="n">u32</span> <span class="n">abort_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">RXRPC_CALL_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call</span><span class="o">-&gt;</span><span class="n">abort_code</span> <span class="o">=</span> <span class="n">abort_code</span><span class="p">;</span>
		<span class="n">call</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RXRPC_CALL_LOCALLY_ABORTED</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">RXRPC_CALL_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * af_rxrpc.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">rxrpc_n_skbs</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="n">rxrpc_epoch</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">rxrpc_debug_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">rxrpc_workqueue</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ar-accept.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_accept_incoming_calls</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="n">rxrpc_accept_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_reject_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-ack.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__rxrpc_propose_ACK</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">__be32</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_propose_ACK</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">__be32</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_process_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-call.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">rxrpc_call_jar</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rxrpc_calls</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">rwlock_t</span> <span class="n">rxrpc_call_lock</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="n">rxrpc_get_client_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="o">*</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="n">rxrpc_incoming_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">rxrpc_header</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="n">rxrpc_find_server_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_release_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_release_calls_on_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__rxrpc_put_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">rxrpc_destroy_all_calls</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-connection.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rxrpc_connections</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">rwlock_t</span> <span class="n">rxrpc_connection_lock</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="o">*</span><span class="n">rxrpc_get_bundle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
						  <span class="n">__be16</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_put_bundle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_connect_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">rxrpc_conn_bundle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span>
			      <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_put_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">rxrpc_destroy_all_connections</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="n">rxrpc_find_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">rxrpc_header</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span>
<span class="n">rxrpc_incoming_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxrpc_header</span> <span class="o">*</span><span class="p">,</span>
			  <span class="n">gfp_t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-connevent.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_process_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_reject_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_reject_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-error.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_UDP_error_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_UDP_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-input.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rxrpc_ack_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rxrpc_pkts</span><span class="p">[];</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_queue_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span>
			       <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_fast_process_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-local.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">rwlock_t</span> <span class="n">rxrpc_local_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="n">rxrpc_lookup_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_rxrpc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_put_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">rxrpc_destroy_all_locals</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-key.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">key_type</span> <span class="n">key_type_rxrpc</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">key_type</span> <span class="n">key_type_rxrpc_s</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_request_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_server_keyring</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_get_server_data_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
				     <span class="kt">time_t</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-output.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_resend_timeout</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_client_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_server_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-peer.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_peer</span> <span class="o">*</span><span class="n">rxrpc_get_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_rxrpc</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_put_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_peer</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_peer</span> <span class="o">*</span><span class="n">rxrpc_find_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="p">,</span>
					  <span class="n">__be32</span><span class="p">,</span> <span class="n">__be16</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">rxrpc_destroy_all_peers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-proc.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">rxrpc_call_states</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rxrpc_call_seq_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rxrpc_connection_seq_fops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ar-recvmsg.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_remove_user_ID</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span>
			 <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-security.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_register_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_security</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_unregister_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_security</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_init_client_conn_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_init_server_conn_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_secure_packet</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
			       <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rxrpc_verify_packet</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rxrpc_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_clear_conn_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_connection</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-skbuff.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_packet_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ar-transport.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="n">rxrpc_get_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">rxrpc_peer</span> <span class="o">*</span><span class="p">,</span>
						   <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rxrpc_put_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">rxrpc_destroy_all_transports</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rxrpc_transport</span> <span class="o">*</span><span class="n">rxrpc_find_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">rxrpc_peer</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * debug tracing</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxrpc_debug</span><span class="p">;</span>

<span class="cp">#define dbgprintk(FMT,...) \</span>
<span class="cp">	printk(&quot;[%-6.6s] &quot;FMT&quot;\n&quot;, current-&gt;comm ,##__VA_ARGS__)</span>

<span class="cp">#define kenter(FMT,...)	dbgprintk(&quot;==&gt; %s(&quot;FMT&quot;)&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define kleave(FMT,...)	dbgprintk(&quot;&lt;== %s()&quot;FMT&quot;&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define kdebug(FMT,...)	dbgprintk(&quot;    &quot;FMT ,##__VA_ARGS__)</span>
<span class="cp">#define kproto(FMT,...)	dbgprintk(&quot;### &quot;FMT ,##__VA_ARGS__)</span>
<span class="cp">#define knet(FMT,...)	dbgprintk(&quot;@@@ &quot;FMT ,##__VA_ARGS__)</span>


<span class="cp">#if defined(__KDEBUG)</span>
<span class="cp">#define _enter(FMT,...)	kenter(FMT,##__VA_ARGS__)</span>
<span class="cp">#define _leave(FMT,...)	kleave(FMT,##__VA_ARGS__)</span>
<span class="cp">#define _debug(FMT,...)	kdebug(FMT,##__VA_ARGS__)</span>
<span class="cp">#define _proto(FMT,...)	kproto(FMT,##__VA_ARGS__)</span>
<span class="cp">#define _net(FMT,...)	knet(FMT,##__VA_ARGS__)</span>

<span class="cp">#elif defined(CONFIG_AF_RXRPC_DEBUG)</span>
<span class="cp">#define RXRPC_DEBUG_KENTER	0x01</span>
<span class="cp">#define RXRPC_DEBUG_KLEAVE	0x02</span>
<span class="cp">#define RXRPC_DEBUG_KDEBUG	0x04</span>
<span class="cp">#define RXRPC_DEBUG_KPROTO	0x08</span>
<span class="cp">#define RXRPC_DEBUG_KNET	0x10</span>

<span class="cp">#define _enter(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(rxrpc_debug &amp; RXRPC_DEBUG_KENTER))	\</span>
<span class="cp">		kenter(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _leave(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(rxrpc_debug &amp; RXRPC_DEBUG_KLEAVE))	\</span>
<span class="cp">		kleave(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _debug(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(rxrpc_debug &amp; RXRPC_DEBUG_KDEBUG))	\</span>
<span class="cp">		kdebug(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _proto(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(rxrpc_debug &amp; RXRPC_DEBUG_KPROTO))	\</span>
<span class="cp">		kproto(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _net(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(rxrpc_debug &amp; RXRPC_DEBUG_KNET))	\</span>
<span class="cp">		knet(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#else</span>
<span class="cp">#define _enter(FMT,...)	no_printk(&quot;==&gt; %s(&quot;FMT&quot;)&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define _leave(FMT,...)	no_printk(&quot;&lt;== %s()&quot;FMT&quot;&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define _debug(FMT,...)	no_printk(&quot;    &quot;FMT ,##__VA_ARGS__)</span>
<span class="cp">#define _proto(FMT,...)	no_printk(&quot;### &quot;FMT ,##__VA_ARGS__)</span>
<span class="cp">#define _net(FMT,...)	no_printk(&quot;@@@ &quot;FMT ,##__VA_ARGS__)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * debug assertion checking</span>
<span class="cm"> */</span>
<span class="cp">#if 1 </span><span class="c1">// defined(__KDEBUGALL)</span>

<span class="cp">#define ASSERT(X)						\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely(!(X))) {					\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);				\</span>
<span class="cp">		printk(KERN_ERR &quot;RxRPC: Assertion failed\n&quot;);	\</span>
<span class="cp">		BUG();						\</span>
<span class="cp">	}							\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTCMP(X, OP, Y)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (unlikely(!((X) OP (Y)))) {					\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);					\</span>
<span class="cp">		printk(KERN_ERR &quot;RxRPC: Assertion failed\n&quot;);		\</span>
<span class="cp">		printk(KERN_ERR &quot;%lu &quot; #OP &quot; %lu is false\n&quot;,		\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		printk(KERN_ERR &quot;0x%lx &quot; #OP &quot; 0x%lx is false\n&quot;,	\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIF(C, X)						\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely((C) &amp;&amp; !(X))) {				\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);				\</span>
<span class="cp">		printk(KERN_ERR &quot;RxRPC: Assertion failed\n&quot;);	\</span>
<span class="cp">		BUG();						\</span>
<span class="cp">	}							\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIFCMP(C, X, OP, Y)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (unlikely((C) &amp;&amp; !((X) OP (Y)))) {				\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);					\</span>
<span class="cp">		printk(KERN_ERR &quot;RxRPC: Assertion failed\n&quot;);		\</span>
<span class="cp">		printk(KERN_ERR &quot;%lu &quot; #OP &quot; %lu is false\n&quot;,		\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		printk(KERN_ERR &quot;0x%lx &quot; #OP &quot; 0x%lx is false\n&quot;,	\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while(0)</span>

<span class="cp">#else</span>

<span class="cp">#define ASSERT(X)				\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTCMP(X, OP, Y)			\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIF(C, X)				\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIFCMP(C, X, OP, Y)		\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#endif </span><span class="cm">/* __KDEBUGALL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * socket buffer accounting / leak finding</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__rxrpc_new_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p><em>net("new skb %p %s [%d]", skb, fn, atomic</em>read(&amp;rxrpc<em>n</em>skbs));
atomic<em>inc(&amp;rxrpc</em>n_skbs);</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="cp">#define rxrpc_new_skb(skb) __rxrpc_new_skb((skb), __func__)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__rxrpc_kill_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p><em>net("kill skb %p %s [%d]", skb, fn, atomic</em>read(&amp;rxrpc<em>n</em>skbs));
atomic<em>dec(&amp;rxrpc</em>n_skbs);</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="cp">#define rxrpc_kill_skb(skb) __rxrpc_kill_skb((skb), __func__)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__rxrpc_free_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CHECK_SLAB_OKAY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p><em>net("free skb %p %s [%d]",
    skb, fn, atomic</em>read(&amp;rxrpc<em>n</em>skbs));
atomic<em>dec(&amp;rxrpc</em>n_skbs);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define rxrpc_free_skb(skb) __rxrpc_free_skb((skb), __func__)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rxrpc_purge_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">((</span><span class="n">list</span><span class="p">)))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">rxrpc_free_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__rxrpc_get_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxrpc_local</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CHECK_SLAB_OKAY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;resurrected (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define rxrpc_get_local(LOCAL) __rxrpc_get_local((LOCAL), __func__)</span>

<span class="cp">#define rxrpc_get_call(CALL)				\</span>
<span class="cp">do {							\</span>
<span class="cp">	CHECK_SLAB_OKAY(&amp;(CALL)-&gt;usage);		\</span>
<span class="cp">	if (atomic_inc_return(&amp;(CALL)-&gt;usage) == 1)	\</span>
<span class="cp">		BUG();					\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define rxrpc_put_call(CALL)				\</span>
<span class="cp">do {							\</span>
<span class="cp">	__rxrpc_put_call(CALL);				\</span>
<span class="cp">} while(0)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
