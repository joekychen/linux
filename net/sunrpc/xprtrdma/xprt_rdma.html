<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sunrpc › xprtrdma › xprt_rdma.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xprt_rdma.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2003-2007 Network Appliance, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the BSD-type</span>
<span class="cm"> * license below:</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      Redistributions of source code must retain the above copyright</span>
<span class="cm"> *      notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      Redistributions in binary form must reproduce the above</span>
<span class="cm"> *      copyright notice, this list of conditions and the following</span>
<span class="cm"> *      disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *      with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> *      Neither the name of the Network Appliance, Inc. nor the names of</span>
<span class="cm"> *      its contributors may be used to endorse or promote products</span>
<span class="cm"> *      derived from this software without specific prior written</span>
<span class="cm"> *      permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_SUNRPC_XPRT_RDMA_H</span>
<span class="cp">#define _LINUX_SUNRPC_XPRT_RDMA_H</span>

<span class="cp">#include &lt;linux/wait.h&gt; 		</span><span class="cm">/* wait_queue_head_t, etc */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/spinlock.h&gt; 		</span><span class="cm">/* spinlock_t, etc */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/atomic.h&gt;			</span><span class="cm">/* atomic_t, etc */</span><span class="cp"></span>

<span class="cp">#include &lt;rdma/rdma_cm.h&gt;		</span><span class="cm">/* RDMA connection api */</span><span class="cp"></span>
<span class="cp">#include &lt;rdma/ib_verbs.h&gt;		</span><span class="cm">/* RDMA verbs api */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt; 		</span><span class="cm">/* rpc_xprt */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/sunrpc/rpc_rdma.h&gt; 	</span><span class="cm">/* RPC/RDMA protocol */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/sunrpc/xprtrdma.h&gt; 	</span><span class="cm">/* xprt parameters */</span><span class="cp"></span>

<span class="cp">#define RDMA_RESOLVE_TIMEOUT	(5000)	</span><span class="cm">/* 5 seconds */</span><span class="cp"></span>
<span class="cp">#define RDMA_CONNECT_RETRY_MAX	(2)	</span><span class="cm">/* retries if no listener backlog */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Interface Adapter -- one per transport instance</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rdma_cm_id</span> 	<span class="o">*</span><span class="n">ri_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>		<span class="o">*</span><span class="n">ri_pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_mr</span>		<span class="o">*</span><span class="n">ri_bind_mem</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ri_dma_lkey</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ri_have_dma_lkey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">ri_done</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ri_async_rc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rpcrdma_memreg</span>	<span class="n">ri_memreg_strategy</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RDMA Endpoint -- one per transport instance</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">rep_cqcount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rep_cqinit</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rep_connected</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_ia</span>	<span class="o">*</span><span class="n">rep_ia</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>		<span class="o">*</span><span class="n">rep_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp_init_attr</span>	<span class="n">rep_attr</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> 	<span class="n">rep_connect_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>		<span class="n">rep_pad</span><span class="p">;</span>	<span class="cm">/* holds zeroed pad */</span>
	<span class="k">struct</span> <span class="n">ib_mr</span>		<span class="o">*</span><span class="n">rep_pad_mr</span><span class="p">;</span>	<span class="cm">/* holds zeroed pad */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">rep_func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span>		<span class="o">*</span><span class="n">rep_xprt</span><span class="p">;</span>	<span class="cm">/* for rep_func */</span>
	<span class="k">struct</span> <span class="n">rdma_conn_param</span>	<span class="n">rep_remote_cma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">rep_remote_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define INIT_CQCOUNT(ep) atomic_set(&amp;(ep)-&gt;rep_cqcount, (ep)-&gt;rep_cqinit)</span>
<span class="cp">#define DECR_CQCOUNT(ep) atomic_sub_return(1, &amp;(ep)-&gt;rep_cqcount)</span>

<span class="cm">/*</span>
<span class="cm"> * struct rpcrdma_rep -- this structure encapsulates state required to recv</span>
<span class="cm"> * and complete a reply, asychronously. It needs several pieces of</span>
<span class="cm"> * state:</span>
<span class="cm"> *   o recv buffer (posted to provider)</span>
<span class="cm"> *   o ib_sge (also donated to provider)</span>
<span class="cm"> *   o status of reply (length, success or not)</span>
<span class="cm"> *   o bookkeeping state to get run by tasklet (list, etc)</span>
<span class="cm"> *</span>
<span class="cm"> * These are allocated during initialization, per-transport instance;</span>
<span class="cm"> * however, the tasklet execution list itself is global, as it should</span>
<span class="cm"> * always be pretty short.</span>
<span class="cm"> *</span>
<span class="cm"> * N of these are associated with a transport instance, and stored in</span>
<span class="cm"> * struct rpcrdma_buffer. N is the max number of outstanding requests.</span>
<span class="cm"> */</span>

<span class="cm">/* temporary static scatter/gather max */</span>
<span class="cp">#define RPCRDMA_MAX_DATA_SEGS	(64)	</span><span class="cm">/* max scatter/gather */</span><span class="cp"></span>
<span class="cp">#define RPCRDMA_MAX_SEGS 	(RPCRDMA_MAX_DATA_SEGS + 2) </span><span class="cm">/* head+tail = 2 */</span><span class="cp"></span>
<span class="cp">#define MAX_RPCRDMAHDR	(\</span>
<span class="cp">	</span><span class="cm">/* max supported RPC/RDMA header */</span><span class="cp"> \</span>
<span class="cp">	sizeof(struct rpcrdma_msg) + (2 * sizeof(u32)) + \</span>
<span class="cp">	(sizeof(struct rpcrdma_read_chunk) * RPCRDMA_MAX_SEGS) + sizeof(u32))</span>

<span class="k">struct</span> <span class="n">rpcrdma_buffer</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">rpcrdma_rep</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rr_len</span><span class="p">;</span>		<span class="cm">/* actual received reply length */</span>
	<span class="k">struct</span> <span class="n">rpcrdma_buffer</span> <span class="o">*</span><span class="n">rr_buffer</span><span class="p">;</span> <span class="cm">/* home base for this structure */</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span>	<span class="o">*</span><span class="n">rr_xprt</span><span class="p">;</span>	<span class="cm">/* needed for request/reply matching */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rr_func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rpcrdma_rep</span> <span class="o">*</span><span class="p">);</span><span class="cm">/* called by tasklet in softint */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rr_list</span><span class="p">;</span>	<span class="cm">/* tasklet list */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">rr_unbind</span><span class="p">;</span>	<span class="cm">/* optional unbind wait */</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>	<span class="n">rr_iov</span><span class="p">;</span>		<span class="cm">/* for posting */</span>
	<span class="k">struct</span> <span class="n">ib_mr</span>	<span class="o">*</span><span class="n">rr_handle</span><span class="p">;</span>	<span class="cm">/* handle for mem in rr_iov */</span>
	<span class="kt">char</span>	<span class="n">rr_base</span><span class="p">[</span><span class="n">MAX_RPCRDMAHDR</span><span class="p">];</span> <span class="cm">/* minimal inline receive buffer */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct rpcrdma_req -- structure central to the request/reply sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * N of these are associated with a transport instance, and stored in</span>
<span class="cm"> * struct rpcrdma_buffer. N is the max number of outstanding requests.</span>
<span class="cm"> *</span>
<span class="cm"> * It includes pre-registered buffer memory for send AND recv.</span>
<span class="cm"> * The recv buffer, however, is not owned by this structure, and</span>
<span class="cm"> * is &quot;donated&quot; to the hardware when a recv is posted. When a</span>
<span class="cm"> * reply is handled, the recv buffer used is given back to the</span>
<span class="cm"> * struct rpcrdma_req associated with the request.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to the basic memory, this structure includes an array</span>
<span class="cm"> * of iovs for send operations. The reason is that the iovs passed to</span>
<span class="cm"> * ib_post_{send,recv} must not be modified until the work request</span>
<span class="cm"> * completes.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *   o RPCRDMA_MAX_SEGS is the max number of addressible chunk elements we</span>
<span class="cm"> *     marshal. The number needed varies depending on the iov lists that</span>
<span class="cm"> *     are passed to us, the memory registration mode we are in, and if</span>
<span class="cm"> *     physical addressing is used, the layout.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rpcrdma_mr_seg</span> <span class="p">{</span>		<span class="cm">/* chunk descriptors */</span>
	<span class="k">union</span> <span class="p">{</span>				<span class="cm">/* chunk memory handles */</span>
		<span class="k">struct</span> <span class="n">ib_mr</span>	<span class="o">*</span><span class="n">rl_mr</span><span class="p">;</span>		<span class="cm">/* if registered directly */</span>
		<span class="k">struct</span> <span class="n">rpcrdma_mw</span> <span class="p">{</span>		<span class="cm">/* if registered from region */</span>
			<span class="k">union</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ib_mw</span>	<span class="o">*</span><span class="n">mw</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">ib_fmr</span>	<span class="o">*</span><span class="n">fmr</span><span class="p">;</span>
				<span class="k">struct</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="o">*</span><span class="n">fr_pgl</span><span class="p">;</span>
					<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">fr_mr</span><span class="p">;</span>
					<span class="k">enum</span> <span class="p">{</span> <span class="n">FRMR_IS_INVALID</span><span class="p">,</span> <span class="n">FRMR_IS_VALID</span>  <span class="p">}</span> <span class="n">state</span><span class="p">;</span>
				<span class="p">}</span> <span class="n">frmr</span><span class="p">;</span>
			<span class="p">}</span> <span class="n">r</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mw_list</span><span class="p">;</span>
		<span class="p">}</span> <span class="o">*</span><span class="n">rl_mw</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">mr_chunk</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">mr_base</span><span class="p">;</span>	<span class="cm">/* registration result */</span>
	<span class="n">u32</span>		<span class="n">mr_rkey</span><span class="p">;</span>	<span class="cm">/* registration result */</span>
	<span class="n">u32</span>		<span class="n">mr_len</span><span class="p">;</span>		<span class="cm">/* length of chunk or segment */</span>
	<span class="kt">int</span>		<span class="n">mr_nsegs</span><span class="p">;</span>	<span class="cm">/* number of segments in chunk or 0 */</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span>	<span class="n">mr_dir</span><span class="p">;</span>	<span class="cm">/* segment mapping direction */</span>
	<span class="n">dma_addr_t</span>	<span class="n">mr_dma</span><span class="p">;</span>		<span class="cm">/* segment mapping address */</span>
	<span class="kt">size_t</span>		<span class="n">mr_dmalen</span><span class="p">;</span>	<span class="cm">/* segment mapping length */</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">mr_page</span><span class="p">;</span>	<span class="cm">/* owning page, if any */</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">mr_offset</span><span class="p">;</span>	<span class="cm">/* kva if no page, else offset */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rpcrdma_req</span> <span class="p">{</span>
	<span class="kt">size_t</span> 		<span class="n">rl_size</span><span class="p">;</span>	<span class="cm">/* actual length of buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rl_niovs</span><span class="p">;</span>	<span class="cm">/* 0, 2 or 4 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rl_nchunks</span><span class="p">;</span>	<span class="cm">/* non-zero if chunks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rl_connect_cookie</span><span class="p">;</span>	<span class="cm">/* retry detection */</span>
	<span class="k">struct</span> <span class="n">rpcrdma_buffer</span> <span class="o">*</span><span class="n">rl_buffer</span><span class="p">;</span> <span class="cm">/* home base for this structure */</span>
	<span class="k">struct</span> <span class="n">rpcrdma_rep</span>	<span class="o">*</span><span class="n">rl_reply</span><span class="p">;</span><span class="cm">/* holder for reply buffer */</span>
	<span class="k">struct</span> <span class="n">rpcrdma_mr_seg</span> <span class="n">rl_segments</span><span class="p">[</span><span class="n">RPCRDMA_MAX_SEGS</span><span class="p">];</span><span class="cm">/* chunk segments */</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>	<span class="n">rl_send_iov</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* for active requests */</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>	<span class="n">rl_iov</span><span class="p">;</span>		<span class="cm">/* for posting */</span>
	<span class="k">struct</span> <span class="n">ib_mr</span>	<span class="o">*</span><span class="n">rl_handle</span><span class="p">;</span>	<span class="cm">/* handle for mem in rl_iov */</span>
	<span class="kt">char</span>		<span class="n">rl_base</span><span class="p">[</span><span class="n">MAX_RPCRDMAHDR</span><span class="p">];</span> <span class="cm">/* start of actual buffer */</span>
	<span class="n">__u32</span> 		<span class="n">rl_xdr_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* start of returned rpc rq_buffer */</span>
<span class="p">};</span>
<span class="cp">#define rpcr_to_rdmar(r) \</span>
<span class="cp">	container_of((r)-&gt;rq_buffer, struct rpcrdma_req, rl_xdr_buf[0])</span>

<span class="cm">/*</span>
<span class="cm"> * struct rpcrdma_buffer -- holds list/queue of pre-registered memory for</span>
<span class="cm"> * inline requests/replies, and client/server credits.</span>
<span class="cm"> *</span>
<span class="cm"> * One of these is associated with a transport instance</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpcrdma_buffer</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	<span class="n">rb_lock</span><span class="p">;</span>	<span class="cm">/* protects indexes */</span>
	<span class="n">atomic_t</span>	<span class="n">rb_credits</span><span class="p">;</span>	<span class="cm">/* most recent server credits */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rb_cwndscale</span><span class="p">;</span>	<span class="cm">/* cached framework rpc_cwndscale */</span>
	<span class="kt">int</span>		<span class="n">rb_max_requests</span><span class="p">;</span><span class="cm">/* client max requests */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rb_mws</span><span class="p">;</span>	<span class="cm">/* optional memory windows/fmrs/frmrs */</span>
	<span class="kt">int</span>		<span class="n">rb_send_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_req</span>	<span class="o">**</span><span class="n">rb_send_bufs</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rb_recv_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_rep</span>	<span class="o">**</span><span class="n">rb_recv_bufs</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">rb_pool</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define rdmab_to_ia(b) (&amp;container_of((b), struct rpcrdma_xprt, rx_buf)-&gt;rx_ia)</span>

<span class="cm">/*</span>
<span class="cm"> * Internal structure for transport instance creation. This</span>
<span class="cm"> * exists primarily for modularity.</span>
<span class="cm"> *</span>
<span class="cm"> * This data should be set with mount options</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpcrdma_create_data_internal</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">addr</span><span class="p">;</span>	<span class="cm">/* RDMA server address */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">max_requests</span><span class="p">;</span>	<span class="cm">/* max requests (slots) in flight */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsize</span><span class="p">;</span>		<span class="cm">/* mount rsize - max read hdr+data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">wsize</span><span class="p">;</span>		<span class="cm">/* mount wsize - max write hdr+data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">inline_rsize</span><span class="p">;</span>	<span class="cm">/* max non-rdma read data payload */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">inline_wsize</span><span class="p">;</span>	<span class="cm">/* max non-rdma write data payload */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">padding</span><span class="p">;</span>	<span class="cm">/* non-rdma write header padding */</span>
<span class="p">};</span>

<span class="cp">#define RPCRDMA_INLINE_READ_THRESHOLD(rq) \</span>
<span class="cp">	(rpcx_to_rdmad(rq-&gt;rq_task-&gt;tk_xprt).inline_rsize)</span>

<span class="cp">#define RPCRDMA_INLINE_WRITE_THRESHOLD(rq)\</span>
<span class="cp">	(rpcx_to_rdmad(rq-&gt;rq_task-&gt;tk_xprt).inline_wsize)</span>

<span class="cp">#define RPCRDMA_INLINE_PAD_VALUE(rq)\</span>
<span class="cp">	rpcx_to_rdmad(rq-&gt;rq_task-&gt;tk_xprt).padding</span>

<span class="cm">/*</span>
<span class="cm"> * Statistics for RPCRDMA</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpcrdma_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">read_chunk_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">write_chunk_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">reply_chunk_count</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">total_rdma_request</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">total_rdma_reply</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">pullup_copy_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">fixup_copy_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">hardway_register_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">failed_marshal_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bad_reply_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RPCRDMA transport -- encapsulates the structures above for</span>
<span class="cm"> * integration with RPC.</span>
<span class="cm"> *</span>
<span class="cm"> * The contained structures are embedded, not pointers,</span>
<span class="cm"> * for convenience. This structure need not be visible externally.</span>
<span class="cm"> *</span>
<span class="cm"> * It is allocated and initialized during mount, and released</span>
<span class="cm"> * during unmount.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpcrdma_xprt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span>		<span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_ia</span>	<span class="n">rx_ia</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_ep</span>	<span class="n">rx_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_buffer</span>	<span class="n">rx_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_create_data_internal</span> <span class="n">rx_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">rdma_connect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpcrdma_stats</span>	<span class="n">rx_stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define rpcx_to_rdmax(x) container_of(x, struct rpcrdma_xprt, xprt)</span>
<span class="cp">#define rpcx_to_rdmad(x) (rpcx_to_rdmax(x)-&gt;rx_data)</span>

<span class="cm">/* Setting this to 0 ensures interoperability with early servers.</span>
<span class="cm"> * Setting this to 1 enhances certain unaligned read/write performance.</span>
<span class="cm"> * Default is 0, see sysctl entry and rpc_rdma.c rpcrdma_convert_iovs() */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xprt_rdma_pad_optimize</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Interface Adapter calls - xprtrdma/verbs.c</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rpcrdma_ia_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_xprt</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpcrdma_ia_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Endpoint calls - xprtrdma/verbs.c</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rpcrdma_ep_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpcrdma_create_data_internal</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rpcrdma_ep_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rpcrdma_ep_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rpcrdma_ep_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">rpcrdma_ep_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpcrdma_req</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rpcrdma_ep_post_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpcrdma_rep</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Buffer calls - xprtrdma/verbs.c</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rpcrdma_buffer_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_buffer</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpcrdma_create_data_internal</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpcrdma_buffer_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_buffer</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">rpcrdma_req</span> <span class="o">*</span><span class="n">rpcrdma_buffer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_buffer</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpcrdma_buffer_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_req</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpcrdma_recv_buffer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_req</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpcrdma_recv_buffer_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_rep</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">rpcrdma_register_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">**</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_sge</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rpcrdma_deregister_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ia</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_sge</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">rpcrdma_register_external</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_mr_seg</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_xprt</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rpcrdma_deregister_external</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_mr_seg</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">rpcrdma_xprt</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * RPC/RDMA connection management calls - xprtrdma/rpc_rdma.c</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rpcrdma_conn_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_ep</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpcrdma_reply_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpcrdma_rep</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * RPC/RDMA protocol calls - xprtrdma/rpc_rdma.c</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rpcrdma_marshal_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Temporary NFS request map cache. Created in svc_rdma.c  */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">svc_rdma_map_cachep</span><span class="p">;</span>
<span class="cm">/* WR context cache. Created in svc_rdma.c  */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">svc_rdma_ctxt_cachep</span><span class="p">;</span>
<span class="cm">/* Workqueue created in svc_rdma.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">svc_rdma_wq</span><span class="p">;</span>

<span class="cp">#endif				</span><span class="cm">/* _LINUX_SUNRPC_XPRT_RDMA_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
