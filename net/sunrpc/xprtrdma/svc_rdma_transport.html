<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sunrpc › xprtrdma › svc_rdma_transport.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>svc_rdma_transport.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2005-2007 Network Appliance, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the BSD-type</span>
<span class="cm"> * license below:</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      Redistributions of source code must retain the above copyright</span>
<span class="cm"> *      notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      Redistributions in binary form must reproduce the above</span>
<span class="cm"> *      copyright notice, this list of conditions and the following</span>
<span class="cm"> *      disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *      with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> *      Neither the name of the Network Appliance, Inc. nor the names of</span>
<span class="cm"> *      its contributors may be used to endorse or promote products</span>
<span class="cm"> *      derived from this software without specific prior written</span>
<span class="cm"> *      permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Tom Tucker &lt;tom@opengridcomputing.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sunrpc/svc_xprt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/debug.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/rpc_rdma.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;rdma/ib_verbs.h&gt;</span>
<span class="cp">#include &lt;rdma/rdma_cm.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svc_rdma.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;xprt_rdma.h&quot;</span>

<span class="cp">#define RPCDBG_FACILITY	RPCDBG_SVCXPRT</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">svc_rdma_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">salen</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">svc_rdma_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">svc_rdma_release_rqst</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dto_tasklet_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">svc_rdma_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">svc_rdma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">svc_rdma_has_wspace</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rq_cq_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sq_cq_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_TASKLET</span><span class="p">(</span><span class="n">dto_tasklet</span><span class="p">,</span> <span class="n">dto_tasklet_func</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dto_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dto_xprt_q</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_xprt_ops</span> <span class="n">svc_rdma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">xpo_create</span> <span class="o">=</span> <span class="n">svc_rdma_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_recvfrom</span> <span class="o">=</span> <span class="n">svc_rdma_recvfrom</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_sendto</span> <span class="o">=</span> <span class="n">svc_rdma_sendto</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_release_rqst</span> <span class="o">=</span> <span class="n">svc_rdma_release_rqst</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_detach</span> <span class="o">=</span> <span class="n">svc_rdma_detach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_free</span> <span class="o">=</span> <span class="n">svc_rdma_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_prep_reply_hdr</span> <span class="o">=</span> <span class="n">svc_rdma_prep_reply_hdr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_has_wspace</span> <span class="o">=</span> <span class="n">svc_rdma_has_wspace</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpo_accept</span> <span class="o">=</span> <span class="n">svc_rdma_accept</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">svc_xprt_class</span> <span class="n">svc_rdma_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">xcl_name</span> <span class="o">=</span> <span class="s">&quot;rdma&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xcl_owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xcl_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_rdma_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xcl_max_payload</span> <span class="o">=</span> <span class="n">RPCSVC_MAXPAYLOAD_TCP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="nf">svc_rdma_get_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctxt</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">svc_rdma_ctxt_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">dto_q</span><span class="p">);</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">frmr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_ctxt_used</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctxt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">svc_rdma_unmap_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unmap the DMA addr in the SGE if the lkey matches</span>
<span class="cm">		 * the sc_dma_lkey, otherwise, ignore it since it is</span>
<span class="cm">		 * an FRMR lkey and will be unmapped later when the</span>
<span class="cm">		 * last WR that uses it completes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lkey</span> <span class="o">==</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_lkey</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_used</span><span class="p">);</span>
			<span class="n">ib_dma_unmap_page</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					    <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span>
					    <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">,</span>
					    <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">svc_rdma_put_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_pages</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">svc_rdma_ctxt_cachep</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_ctxt_used</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Temporary NFS req mappings are shared across all transport</span>
<span class="cm"> * instances. These are short lived and should be bounded by the number</span>
<span class="cm"> * of concurrent server threads * depth of the SQ.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_rdma_req_map</span> <span class="o">*</span><span class="nf">svc_rdma_get_req_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rdma_req_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">svc_rdma_map_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">frmr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">svc_rdma_put_req_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rdma_req_map</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">svc_rdma_map_cachep</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ib_cq event handler */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cq_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: received CQ event id=%d, context=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* QP event handler */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qp_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* These are considered benign events */</span>
	<span class="k">case</span> <span class="n">IB_EVENT_PATH_MIG</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_COMM_EST</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_SQ_DRAINED</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_QP_LAST_WQE_REACHED</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: QP event %d received for QP=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">.</span><span class="n">qp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* These are considered fatal events */</span>
	<span class="k">case</span> <span class="n">IB_EVENT_PATH_MIG_ERR</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_QP_FATAL</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_QP_REQ_ERR</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_QP_ACCESS_ERR</span>:
	<span class="k">case</span> <span class="n">IB_EVENT_DEVICE_FATAL</span>:
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: QP ERROR event %d received for QP=%p, &quot;</span>
			<span class="s">&quot;closing transport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">.</span><span class="n">qp</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Data Transfer Operation Tasklet</span>
<span class="cm"> *</span>
<span class="cm"> * Walks a list of transports with I/O pending, removing entries as</span>
<span class="cm"> * they are added to the server&#39;s I/O pending list. Two bits indicate</span>
<span class="cm"> * if SQ, RQ, or both have I/O pending. The dto_lock is an irqsave</span>
<span class="cm"> * spinlock that serializes access to the transport list with the RQ</span>
<span class="cm"> * and SQ interrupt handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dto_tasklet_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_xprt_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xprt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">dto_xprt_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_dto_q</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dto_q</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">rq_cq_reap</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">sq_cq_reap</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Receive Queue Completion Handler</span>
<span class="cm"> *</span>
<span class="cm"> * Since an RQ completion handler is called on interrupt context, we</span>
<span class="cm"> * need to defer the handling of the I/O to a tasklet</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_comp_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cq_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">cq_context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Guard against unconditional flush call for destroyed QP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_ref</span><span class="p">.</span><span class="n">refcount</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the bit regardless of whether or not it&#39;s on the list</span>
<span class="cm">	 * because it may be on the list already due to an SQ</span>
<span class="cm">	 * completion.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">RDMAXPRT_RQ_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this transport is not already on the DTO transport queue,</span>
<span class="cm">	 * add it</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dto_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">svc_xprt_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dto_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dto_xprt_q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Tasklet does all the work to avoid irqsave locks. */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rq_cq_reap - Process the RQ CQ.</span>
<span class="cm"> *</span>
<span class="cm"> * Take all completing WC off the CQE and enqueue the associated DTO</span>
<span class="cm"> * context on the dto_q for the transport.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that caller must hold a transport reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_cq_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_wc</span> <span class="n">wc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">RDMAXPRT_RQ_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ib_req_notify_cq</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">,</span> <span class="n">IB_CQ_NEXT_COMP</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma_stat_rq_poll</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ib_poll_cq</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">wc</span><span class="p">.</span><span class="n">wr_id</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">wc_status</span> <span class="o">=</span> <span class="n">wc</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">byte_len</span> <span class="o">=</span> <span class="n">wc</span><span class="p">.</span><span class="n">byte_len</span><span class="p">;</span>
		<span class="n">svc_rdma_unmap_dma</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">IB_WC_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Close the transport */</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: transport closing putting ctxt %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
			<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">dto_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_q</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_lock</span><span class="p">);</span>
		<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma_stat_rq_prod</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If data arrived before established event,</span>
<span class="cm">	 * don&#39;t enqueue. This defers RPC I/O until the</span>
<span class="cm">	 * RDMA connection is complete.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">RDMAXPRT_CONN_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
		<span class="n">svc_xprt_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process a completion context</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">svc_rdma_unmap_dma</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">wr_op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_WR_SEND</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">RDMACTXT_F_FAST_UNREG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">svc_rdma_put_frmr</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">frmr</span><span class="p">);</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IB_WR_RDMA_WRITE</span>:
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IB_WR_RDMA_READ</span>:
	<span class="k">case</span> <span class="n">IB_WR_RDMA_READ_WITH_INV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">RDMACTXT_F_LAST_CTXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">read_hdr</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">read_hdr</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">read_hdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">RDMACTXT_F_FAST_UNREG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">svc_rdma_put_frmr</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">frmr</span><span class="p">);</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_lock</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_hdr</span><span class="o">-&gt;</span><span class="n">dto_q</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_read_complete_q</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_lock</span><span class="p">);</span>
			<span class="n">svc_xprt_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;svcrdma: unexpected completion type, &quot;</span>
		       <span class="s">&quot;opcode=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">wr_op</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send Queue Completion Handler - potentially called on interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that caller must hold a transport reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sq_cq_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_wc</span> <span class="n">wc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">RDMAXPRT_SQ_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ib_req_notify_cq</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">,</span> <span class="n">IB_CQ_NEXT_COMP</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma_stat_sq_poll</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ib_poll_cq</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">IB_WC_SUCCESS</span><span class="p">)</span>
			<span class="cm">/* Close the transport */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>

		<span class="cm">/* Decrement used SQ WR count */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_send_wait</span><span class="p">);</span>

		<span class="n">ctxt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">wc</span><span class="p">.</span><span class="n">wr_id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="p">)</span>
			<span class="n">process_context</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">ctxt</span><span class="p">);</span>

		<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma_stat_sq_prod</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sq_comp_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cq_context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">cq_context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Guard against unconditional flush call for destroyed QP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_ref</span><span class="p">.</span><span class="n">refcount</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the bit regardless of whether or not it&#39;s on the list</span>
<span class="cm">	 * because it may be on the list already due to an RQ</span>
<span class="cm">	 * completion.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">RDMAXPRT_SQ_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this transport is not already on the DTO transport queue,</span>
<span class="cm">	 * add it</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dto_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">svc_xprt_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dto_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dto_xprt_q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Tasklet does all the work to avoid irqsave locks. */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dto_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="nf">rdma_create_xprt</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">listener</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">cma_xprt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">cma_xprt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cma_xprt</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">svc_xprt_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">svc_rdma_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">,</span> <span class="n">serv</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_dto_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_read_complete_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_frmr_q</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_send_wait</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_frmr_q_lock</span><span class="p">);</span>

	<span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span> <span class="o">=</span> <span class="n">svcrdma_ord</span><span class="p">;</span>

	<span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_max_req_size</span> <span class="o">=</span> <span class="n">svcrdma_max_req_size</span><span class="p">;</span>
	<span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span> <span class="o">=</span> <span class="n">svcrdma_max_requests</span><span class="p">;</span>
	<span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span> <span class="o">=</span> <span class="n">svcrdma_max_requests</span> <span class="o">*</span> <span class="n">RPCRDMA_SQ_DEPTH_MULT</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_ctxt_used</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">listener</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_LISTENER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cma_xprt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">svc_rdma_get_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we can&#39;t get memory, wait a bit and try again */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;svcrdma: out of memory...retrying in 1000 &quot;</span>
		       <span class="s">&quot;jiffies.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">svc_rdma_post_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="n">recv_wr</span><span class="p">,</span> <span class="o">*</span><span class="n">bad_recv_wr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sge_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ctxt</span> <span class="o">=</span> <span class="n">svc_rdma_get_context</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">buflen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sge_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buflen</span> <span class="o">&lt;</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_max_req_size</span><span class="p">;</span> <span class="n">sge_no</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sge_no</span> <span class="o">&gt;=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">svc_rdma_get_page</span><span class="p">();</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">sge_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">pa</span> <span class="o">=</span> <span class="n">ib_dma_map_page</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
				     <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				     <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ib_dma_mapping_error</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_put_ctxt</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_used</span><span class="p">);</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">sge_no</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">sge_no</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="n">sge_no</span><span class="p">].</span><span class="n">lkey</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_lkey</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">sge_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">buflen</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">recv_wr</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">recv_wr</span><span class="p">.</span><span class="n">sg_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">recv_wr</span><span class="p">.</span><span class="n">num_sge</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">recv_wr</span><span class="p">.</span><span class="n">wr_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctxt</span><span class="p">;</span>

	<span class="n">svc_xprt_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ib_post_recv</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_wr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bad_recv_wr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">svc_rdma_unmap_dma</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

 <span class="nl">err_put_ctxt:</span>
	<span class="n">svc_rdma_unmap_dma</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function handles the CONNECT_REQUEST event on a listening</span>
<span class="cm"> * endpoint. It is passed the cma_id for the _new_ connection. The context in</span>
<span class="cm"> * this cma_id is inherited from the listening cma_id and is the svc_xprt</span>
<span class="cm"> * structure for the listening endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a new xprt for the new connection and enqueues it on</span>
<span class="cm"> * the accept queue for the listent xprt. When the listen thread is kicked, it</span>
<span class="cm"> * will call the recvfrom method on the listen xprt which will accept the new</span>
<span class="cm"> * connection.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_connect_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">rdma_cm_id</span> <span class="o">*</span><span class="n">new_cma_id</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">client_ird</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">listen_xprt</span> <span class="o">=</span> <span class="n">new_cma_id</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">newxprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>

	<span class="cm">/* Create a new transport */</span>
	<span class="n">newxprt</span> <span class="o">=</span> <span class="n">rdma_create_xprt</span><span class="p">(</span><span class="n">listen_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_server</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newxprt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: failed to create new transport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span> <span class="o">=</span> <span class="n">new_cma_id</span><span class="p">;</span>
	<span class="n">new_cma_id</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">newxprt</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Creating newxprt=%p, cm_id=%p, listenxprt=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">,</span> <span class="n">listen_xprt</span><span class="p">);</span>

	<span class="cm">/* Save client advertised inbound read limit for use later in accept. */</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span> <span class="o">=</span> <span class="n">client_ird</span><span class="p">;</span>

	<span class="cm">/* Set the local and remote addresses in the transport */</span>
	<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">dst_addr</span><span class="p">;</span>
	<span class="n">svc_xprt_set_remote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">svc_addr_len</span><span class="p">(</span><span class="n">sa</span><span class="p">));</span>
	<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">src_addr</span><span class="p">;</span>
	<span class="n">svc_xprt_set_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">svc_addr_len</span><span class="p">(</span><span class="n">sa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enqueue the new transport on the accept queue of the listening</span>
<span class="cm">	 * transport</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_xprt</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listen_xprt</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_xprt</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t use svc_xprt_received here because we are not on a</span>
<span class="cm">	 * rqstp thread</span>
<span class="cm">	*/</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CONN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listen_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
	<span class="n">svc_xprt_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handles events generated on the listening endpoint. These events will be</span>
<span class="cm"> * either be incoming connect requests or adapter removal  events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rdma_listen_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">rdma_cm_id</span> <span class="o">*</span><span class="n">cma_id</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">rdma_cm_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">cma_id</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RDMA_CM_EVENT_CONNECT_REQUEST</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Connect request on cma_id=%p, xprt = %p, &quot;</span>
			<span class="s">&quot;event=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">,</span> <span class="n">cma_id</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
		<span class="n">handle_connect_req</span><span class="p">(</span><span class="n">cma_id</span><span class="p">,</span>
				   <span class="n">event</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="n">initiator_depth</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RDMA_CM_EVENT_ESTABLISHED</span>:
		<span class="cm">/* Accept complete */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Connection completed on LISTEN xprt=%p, &quot;</span>
			<span class="s">&quot;cm_id=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">RDMA_CM_EVENT_DEVICE_REMOVAL</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Device removal xprt=%p, cm_id=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Unexpected event on listening endpoint %p, &quot;</span>
			<span class="s">&quot;event=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rdma_cma_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">rdma_cm_id</span> <span class="o">*</span><span class="n">cma_id</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">rdma_cm_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">cma_id</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_xprt</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RDMA_CM_EVENT_ESTABLISHED</span>:
		<span class="cm">/* Accept complete */</span>
		<span class="n">svc_xprt_get</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Connection completed on DTO xprt=%p, &quot;</span>
			<span class="s">&quot;cm_id=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">RDMAXPRT_CONN_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
		<span class="n">svc_xprt_enqueue</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RDMA_CM_EVENT_DISCONNECTED</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Disconnect on DTO xprt=%p, cm_id=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">);</span>
			<span class="n">svc_xprt_enqueue</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
			<span class="n">svc_xprt_put</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RDMA_CM_EVENT_DEVICE_REMOVAL</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Device removal cma_id=%p, xprt = %p, &quot;</span>
			<span class="s">&quot;event=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">);</span>
			<span class="n">svc_xprt_enqueue</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Unexpected event on DTO endpoint %p, &quot;</span>
			<span class="s">&quot;event=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cma_id</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a listening RDMA service endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="nf">svc_rdma_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">salen</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rdma_cm_id</span> <span class="o">*</span><span class="n">listen_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">cma_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Creating RDMA socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Address family %d is not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cma_xprt</span> <span class="o">=</span> <span class="n">rdma_create_xprt</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cma_xprt</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">;</span>

	<span class="n">listen_id</span> <span class="o">=</span> <span class="n">rdma_create_id</span><span class="p">(</span><span class="n">rdma_listen_handler</span><span class="p">,</span> <span class="n">cma_xprt</span><span class="p">,</span> <span class="n">RDMA_PS_TCP</span><span class="p">,</span>
				   <span class="n">IB_QPT_RC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">listen_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">listen_id</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: rdma_create_id failed = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rdma_bind_addr</span><span class="p">(</span><span class="n">listen_id</span><span class="p">,</span> <span class="n">sa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: rdma_bind_addr failed = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span> <span class="o">=</span> <span class="n">listen_id</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rdma_listen</span><span class="p">(</span><span class="n">listen_id</span><span class="p">,</span> <span class="n">RPCRDMA_LISTEN_BACKLOG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: rdma_listen failed = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to use the address from the cm_id in case the</span>
<span class="cm">	 * caller specified 0 for the port number.</span>
<span class="cm">	 */</span>
	<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">src_addr</span><span class="p">;</span>
	<span class="n">svc_xprt_set_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">salen</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cma_xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">;</span>

 <span class="nl">err1:</span>
	<span class="n">rdma_destroy_id</span><span class="p">(</span><span class="n">listen_id</span><span class="p">);</span>
 <span class="nl">err0:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cma_xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="nf">rdma_alloc_frmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="o">*</span><span class="n">pl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="n">frmr</span><span class="p">;</span>

	<span class="n">frmr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">frmr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frmr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mr</span> <span class="o">=</span> <span class="n">ib_alloc_fast_reg_mr</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">,</span> <span class="n">RPCSVC_MAXPAGES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free_frmr</span><span class="p">;</span>

	<span class="n">pl</span> <span class="o">=</span> <span class="n">ib_alloc_fast_reg_page_list</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="n">RPCSVC_MAXPAGES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pl</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free_mr</span><span class="p">;</span>

	<span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span> <span class="o">=</span> <span class="n">mr</span><span class="p">;</span>
	<span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list</span> <span class="o">=</span> <span class="n">pl</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">frmr_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">frmr</span><span class="p">;</span>

 <span class="nl">err_free_mr:</span>
	<span class="n">ib_dereg_mr</span><span class="p">(</span><span class="n">mr</span><span class="p">);</span>
 <span class="nl">err_free_frmr:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">frmr</span><span class="p">);</span>
 <span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rdma_dealloc_frmr_q</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="n">frmr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_frmr_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">frmr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_frmr_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span><span class="p">,</span> <span class="n">frmr_list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">frmr_list</span><span class="p">);</span>
		<span class="n">ib_dereg_mr</span><span class="p">(</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">);</span>
		<span class="n">ib_free_fast_reg_page_list</span><span class="p">(</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">frmr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="nf">svc_rdma_get_frmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="n">frmr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">frmr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span><span class="p">,</span> <span class="n">frmr_list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">frmr_list</span><span class="p">);</span>
		<span class="n">frmr</span><span class="o">-&gt;</span><span class="n">map_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frmr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">frmr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rdma_alloc_frmr</span><span class="p">(</span><span class="n">rdma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">frmr_unmap_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="n">frmr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_no</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">page_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_no</span> <span class="o">&lt;</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list_len</span><span class="p">;</span> <span class="n">page_no</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">[</span><span class="n">page_no</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ib_dma_mapping_error</span><span class="p">(</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_used</span><span class="p">);</span>
		<span class="n">ib_dma_unmap_page</span><span class="p">(</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">svc_rdma_put_frmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="n">frmr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frmr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frmr_unmap_dma</span><span class="p">(</span><span class="n">rdma</span><span class="p">,</span> <span class="n">frmr</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q_lock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">frmr_list</span><span class="p">));</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">frmr_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_frmr_q_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the xpo_recvfrom function for listening endpoints. Its</span>
<span class="cm"> * purpose is to accept incoming connections. The CMA callback handler</span>
<span class="cm"> * has already created a new transport and attached it to the new CMA</span>
<span class="cm"> * ID.</span>
<span class="cm"> *</span>
<span class="cm"> * There is a queue of pending connections hung on the listening</span>
<span class="cm"> * transport. This queue contains the new svc_xprt structure. This</span>
<span class="cm"> * function takes svc_xprt structures off the accept_q and completes</span>
<span class="cm"> * the connection.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="nf">svc_rdma_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">listen_rdma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">newxprt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rdma_conn_param</span> <span class="n">conn_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="n">qp_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_device_attr</span> <span class="n">devattr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">dma_mr_acc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">need_dma_mr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">listen_rdma</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_xprt</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPT_CONN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">);</span>
	<span class="cm">/* Get the next entry off the accept list */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_rdma</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_rdma</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">newxprt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">listen_rdma</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_accept_q</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_rdma</span><span class="o">-&gt;</span><span class="n">sc_accept_q</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CONN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listen_rdma</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_rdma</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newxprt</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: newxprt from accept queue = %p, cm_id=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ib_query_device</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: could not query device attributes on &quot;</span>
			<span class="s">&quot;device %p, rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Qualify the transport resource defaults with the</span>
<span class="cm">	 * capabilities of this particular device */</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">devattr</span><span class="p">.</span><span class="n">max_sge</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">RPCSVC_MAXPAGES</span><span class="p">);</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">devattr</span><span class="p">.</span><span class="n">max_qp_wr</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">svcrdma_max_requests</span><span class="p">);</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span> <span class="o">=</span> <span class="n">RPCRDMA_SQ_DEPTH_MULT</span> <span class="o">*</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit ORD based on client limit, local device limit, and</span>
<span class="cm">	 * configured svcrdma limit.</span>
<span class="cm">	 */</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">devattr</span><span class="p">.</span><span class="n">max_qp_rd_atom</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span><span class="p">);</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span>	<span class="n">svcrdma_ord</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span><span class="p">);</span>

	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span> <span class="o">=</span> <span class="n">ib_alloc_pd</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: error creating PD for connect request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span> <span class="o">=</span> <span class="n">ib_create_cq</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="n">sq_comp_handler</span><span class="p">,</span>
					 <span class="n">cq_event_handler</span><span class="p">,</span>
					 <span class="n">newxprt</span><span class="p">,</span>
					 <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: error creating SQ CQ for connect request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span> <span class="o">=</span> <span class="n">ib_create_cq</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="n">rq_comp_handler</span><span class="p">,</span>
					 <span class="n">cq_event_handler</span><span class="p">,</span>
					 <span class="n">newxprt</span><span class="p">,</span>
					 <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: error creating RQ CQ for connect request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qp_attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">qp_attr</span><span class="p">);</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">qp_event_handler</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">qp_context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">sq_sig_type</span> <span class="o">=</span> <span class="n">IB_SIGNAL_REQ_WR</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">qp_type</span> <span class="o">=</span> <span class="n">IB_QPT_RC</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">send_cq</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">recv_cq</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: newxprt-&gt;sc_cm_id=%p, newxprt-&gt;sc_pd=%p</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    cm_id-&gt;device=%p, sc_pd-&gt;device=%p</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    cap.max_send_wr = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    cap.max_recv_wr = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    cap.max_send_sge = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    cap.max_recv_sge = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
		<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="p">,</span>
		<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="p">,</span>
		<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span><span class="p">,</span>
		<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rdma_create_qp</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX: This is a hack. We need a xx_request_qp interface</span>
<span class="cm">		 * that will adjust the qp_attr&#39;s with a best-effort</span>
<span class="cm">		 * number</span>
<span class="cm">		 */</span>
		<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rdma_create_qp</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">,</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">qp_attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: failed to create QP, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span> <span class="o">=</span> <span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span><span class="p">;</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span> <span class="o">=</span> <span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">;</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span> <span class="o">=</span> <span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="p">;</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span> <span class="o">=</span> <span class="n">qp_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_qp</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the most secure set of MR resources based on the</span>
<span class="cm">	 * transport type and available memory management features in</span>
<span class="cm">	 * the device. Here&#39;s the table implemented below:</span>
<span class="cm">	 *</span>
<span class="cm">	 *		Fast	Global	DMA	Remote WR</span>
<span class="cm">	 *		Reg	LKEY	MR	Access</span>
<span class="cm">	 *		Sup&#39;d	Sup&#39;d	Needed	Needed</span>
<span class="cm">	 *</span>
<span class="cm">	 * IWARP	N	N	Y	Y</span>
<span class="cm">	 *		N	Y	Y	Y</span>
<span class="cm">	 *		Y	N	Y	N</span>
<span class="cm">	 *		Y	Y	N	-</span>
<span class="cm">	 *</span>
<span class="cm">	 * IB		N	N	Y	N</span>
<span class="cm">	 *		N	Y	N	-</span>
<span class="cm">	 *		Y	N	Y	N</span>
<span class="cm">	 *		Y	Y	N	-</span>
<span class="cm">	 *</span>
<span class="cm">	 * NB:	iWARP requires remote write access for the data sink</span>
<span class="cm">	 *	of an RDMA_READ. IB does not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devattr</span><span class="p">.</span><span class="n">device_cap_flags</span> <span class="o">&amp;</span> <span class="n">IB_DEVICE_MEM_MGT_EXTENSIONS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_frmr_pg_list_len</span> <span class="o">=</span>
			<span class="n">devattr</span><span class="p">.</span><span class="n">max_fast_reg_page_list_len</span><span class="p">;</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_dev_caps</span> <span class="o">|=</span> <span class="n">SVCRDMA_DEVCAP_FAST_REG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if a DMA MR is required and if so, what privs are required</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rdma_node_get_transport</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RDMA_TRANSPORT_IWARP</span>:
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_dev_caps</span> <span class="o">|=</span> <span class="n">SVCRDMA_DEVCAP_READ_W_INV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_dev_caps</span> <span class="o">&amp;</span> <span class="n">SVCRDMA_DEVCAP_FAST_REG</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">need_dma_mr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dma_mr_acc</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">IB_ACCESS_LOCAL_WRITE</span> <span class="o">|</span>
				 <span class="n">IB_ACCESS_REMOTE_WRITE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">devattr</span><span class="p">.</span><span class="n">device_cap_flags</span> <span class="o">&amp;</span> <span class="n">IB_DEVICE_LOCAL_DMA_LKEY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">need_dma_mr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dma_mr_acc</span> <span class="o">=</span> <span class="n">IB_ACCESS_LOCAL_WRITE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">need_dma_mr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RDMA_TRANSPORT_IB</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">devattr</span><span class="p">.</span><span class="n">device_cap_flags</span> <span class="o">&amp;</span> <span class="n">IB_DEVICE_LOCAL_DMA_LKEY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">need_dma_mr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dma_mr_acc</span> <span class="o">=</span> <span class="n">IB_ACCESS_LOCAL_WRITE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">need_dma_mr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create the DMA MR if needed, otherwise, use the DMA LKEY */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_dma_mr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Register all of physical memory */</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_phys_mr</span> <span class="o">=</span>
			<span class="n">ib_get_dma_mr</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">,</span> <span class="n">dma_mr_acc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_phys_mr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Failed to create DMA MR ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_dma_lkey</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_phys_mr</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_dma_lkey</span> <span class="o">=</span>
			<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">local_dma_lkey</span><span class="p">;</span>

	<span class="cm">/* Post receive buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">svc_rdma_post_recv</span><span class="p">(</span><span class="n">newxprt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: failure posting receive buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Swap out the handler */</span>
	<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">rdma_cma_handler</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Arm the CQs for the SQ and RQ before accepting so we can&#39;t</span>
<span class="cm">	 * miss the first message</span>
<span class="cm">	 */</span>
	<span class="n">ib_req_notify_cq</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">,</span> <span class="n">IB_CQ_NEXT_COMP</span><span class="p">);</span>
	<span class="n">ib_req_notify_cq</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">,</span> <span class="n">IB_CQ_NEXT_COMP</span><span class="p">);</span>

	<span class="cm">/* Accept Connection */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">RDMAXPRT_CONN_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">conn_param</span><span class="p">);</span>
	<span class="n">conn_param</span><span class="p">.</span><span class="n">responder_resources</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">conn_param</span><span class="p">.</span><span class="n">initiator_depth</span> <span class="o">=</span> <span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rdma_accept</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn_param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: failed to accept new connection, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: new connection %p accepted with the following &quot;</span>
		<span class="s">&quot;attributes:</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    local_ip        : %pI4</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    local_port	     : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    remote_ip       : %pI4</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    remote_port     : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    max_sge         : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    sq_depth        : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    max_requests    : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    ord             : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span>
			 <span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">src_addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span>
		<span class="n">ntohs</span><span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span>
		       <span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">src_addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span>
			 <span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">dst_addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span>
		<span class="n">ntohs</span><span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span>
		       <span class="n">route</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">dst_addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">),</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_sge</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_max_requests</span><span class="p">,</span>
		<span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_ord</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">;</span>

 <span class="nl">errout:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: failure accepting new connection rc=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="cm">/* Take a reference in case the DTO handler runs */</span>
	<span class="n">svc_xprt_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_qp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_qp</span><span class="p">))</span>
		<span class="n">ib_destroy_qp</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_qp</span><span class="p">);</span>
	<span class="n">rdma_destroy_id</span><span class="p">(</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">);</span>
	<span class="cm">/* This call to put will destroy the transport */</span>
	<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newxprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">svc_rdma_release_rqst</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When connected, an svc_xprt has at least two references:</span>
<span class="cm"> *</span>
<span class="cm"> * - A reference held by the cm_id between the ESTABLISHED and</span>
<span class="cm"> *   DISCONNECTED events. If the remote peer disconnected first, this</span>
<span class="cm"> *   reference could be gone.</span>
<span class="cm"> *</span>
<span class="cm"> * - A reference held by the svc_recv code that called this function</span>
<span class="cm"> *   as part of close processing.</span>
<span class="cm"> *</span>
<span class="cm"> * At a minimum one references should still be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">svc_rdma_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_xprt</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: svc_rdma_detach(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="cm">/* Disconnect and flush posted WQE */</span>
	<span class="n">rdma_disconnect</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__svc_rdma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_work</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: svc_rdma_free(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rdma</span><span class="p">);</span>

	<span class="cm">/* We should only be called from kref_put */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_ref</span><span class="p">.</span><span class="n">refcount</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Destroy queued, but not processed read completions. Note</span>
<span class="cm">	 * that this cleanup has to be done before destroying the</span>
<span class="cm">	 * cm_id because the device ptr is needed to unmap the dma in</span>
<span class="cm">	 * svc_rdma_put_context.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_read_complete_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">;</span>
		<span class="n">ctxt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_read_complete_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span><span class="p">,</span>
				  <span class="n">dto_q</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">dto_q</span><span class="p">);</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Destroy queued, but not processed recv completions */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">;</span>
		<span class="n">ctxt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_rq_dto_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span><span class="p">,</span>
				  <span class="n">dto_q</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">dto_q</span><span class="p">);</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Warn if we leaked a resource or under-referenced */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_ctxt_used</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_dma_used</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* De-allocate fastreg mr */</span>
	<span class="n">rdma_dealloc_frmr_q</span><span class="p">(</span><span class="n">rdma</span><span class="p">);</span>

	<span class="cm">/* Destroy the QP if present (not a listener) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_qp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_qp</span><span class="p">))</span>
		<span class="n">ib_destroy_qp</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_qp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">))</span>
		<span class="n">ib_destroy_cq</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_sq_cq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">))</span>
		<span class="n">ib_destroy_cq</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_rq_cq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_phys_mr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_phys_mr</span><span class="p">))</span>
		<span class="n">ib_dereg_mr</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_phys_mr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_pd</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">))</span>
		<span class="n">ib_dealloc_pd</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_pd</span><span class="p">);</span>

	<span class="cm">/* Destroy the CM ID */</span>
	<span class="n">rdma_destroy_id</span><span class="p">(</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rdma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">svc_rdma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_xprt</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_work</span><span class="p">,</span> <span class="n">__svc_rdma_free</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">svc_rdma_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">svc_rdma_has_wspace</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">rdma</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svcxprt_rdma</span><span class="p">,</span> <span class="n">sc_xprt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are fewer SQ WR available than required to send a</span>
<span class="cm">	 * simple response, return false.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span> <span class="o">-</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ...or there are already waiters on the SQ,</span>
<span class="cm">	 * return false.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma</span><span class="o">-&gt;</span><span class="n">sc_send_wait</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Otherwise return true. */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to register the kvec representing the RPC memory with the</span>
<span class="cm"> * device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  NULL : The device does not support fastreg or there were no more</span>
<span class="cm"> *         fastreg mr.</span>
<span class="cm"> *  frmr : The kvec register request was successfully posted.</span>
<span class="cm"> *    &lt;0 : An error was encountered attempting to register the kvec.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">svc_rdma_fastreg</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">svc_rdma_fastreg_mr</span> <span class="o">*</span><span class="n">frmr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="n">fastreg_wr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">;</span>

	<span class="cm">/* Bump the key */</span>
	<span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">lkey</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">);</span>
	<span class="n">ib_update_fast_reg_key</span><span class="p">(</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span> <span class="o">++</span><span class="n">key</span><span class="p">);</span>

	<span class="cm">/* Prepare FASTREG WR */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fastreg_wr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">fastreg_wr</span><span class="p">);</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">IB_WR_FAST_REG_MR</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">send_flags</span> <span class="o">=</span> <span class="n">IB_SEND_SIGNALED</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">iova_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">frmr</span><span class="o">-&gt;</span><span class="n">kva</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">page_list</span> <span class="o">=</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">page_list_len</span> <span class="o">=</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">page_list_len</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">page_shift</span> <span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">map_len</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">access_flags</span> <span class="o">=</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">access_flags</span><span class="p">;</span>
	<span class="n">fastreg_wr</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">fast_reg</span><span class="p">.</span><span class="n">rkey</span> <span class="o">=</span> <span class="n">frmr</span><span class="o">-&gt;</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">svc_rdma_send</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fastreg_wr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">svc_rdma_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="o">*</span><span class="n">wr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="o">*</span><span class="n">bad_wr</span><span class="p">,</span> <span class="o">*</span><span class="n">n_wr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wr_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wr</span><span class="o">-&gt;</span><span class="n">send_flags</span> <span class="o">!=</span> <span class="n">IB_SEND_SIGNALED</span><span class="p">);</span>
	<span class="n">wr_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n_wr</span> <span class="o">=</span> <span class="n">wr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">n_wr</span><span class="p">;</span> <span class="n">n_wr</span> <span class="o">=</span> <span class="n">n_wr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">wr_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If the SQ is full, wait until an SQ entry is available */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span> <span class="o">&lt;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">wr_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdma_stat_sq_starve</span><span class="p">);</span>

			<span class="cm">/* See if we can opportunistically reap SQ WR to make room */</span>
			<span class="n">sq_cq_reap</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

			<span class="cm">/* Wait until SQ WR available if SQ still full */</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_send_wait</span><span class="p">,</span>
				   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">)</span> <span class="o">&lt;</span>
				   <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Take a transport ref for each WR posted */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">svc_xprt_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>

		<span class="cm">/* Bump used SQ WR count and post */</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">wr_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ib_post_send</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_qp</span><span class="p">,</span> <span class="n">wr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bad_wr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">XPT_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">.</span><span class="n">xpt_flags</span><span class="p">);</span>
			<span class="n">atomic_sub</span><span class="p">(</span><span class="n">wr_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wr_count</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
				<span class="n">svc_xprt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_xprt</span><span class="p">);</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: failed to post SQ WR rc=%d, &quot;</span>
			       <span class="s">&quot;sc_sq_count=%d, sc_sq_depth=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ret</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_count</span><span class="p">),</span>
			       <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_sq_depth</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_send_wait</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">svc_rdma_send_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">svcxprt_rdma</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpcrdma_msg</span> <span class="o">*</span><span class="n">rmsgp</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">rpcrdma_errcode</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="n">err_wr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_rdma_op_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">svc_rdma_get_page</span><span class="p">();</span>
	<span class="n">va</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* XDR encode error */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">svc_rdma_xdr_encode_error</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">rmsgp</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>

	<span class="n">ctxt</span> <span class="o">=</span> <span class="n">svc_rdma_get_context</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Prepare SGE for local address */</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ib_dma_map_page</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					    <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ib_dma_mapping_error</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_used</span><span class="p">);</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lkey</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">sc_dma_lkey</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Prepare SEND WR */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err_wr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">err_wr</span><span class="p">);</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">wr_op</span> <span class="o">=</span> <span class="n">IB_WR_SEND</span><span class="p">;</span>
	<span class="n">err_wr</span><span class="p">.</span><span class="n">wr_id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctxt</span><span class="p">;</span>
	<span class="n">err_wr</span><span class="p">.</span><span class="n">sg_list</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">;</span>
	<span class="n">err_wr</span><span class="p">.</span><span class="n">num_sge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err_wr</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">IB_WR_SEND</span><span class="p">;</span>
	<span class="n">err_wr</span><span class="p">.</span><span class="n">send_flags</span> <span class="o">=</span> <span class="n">IB_SEND_SIGNALED</span><span class="p">;</span>

	<span class="cm">/* Post It */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">svc_rdma_send</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_wr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svcrdma: Error %d posting send for protocol error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">);</span>
		<span class="n">svc_rdma_unmap_dma</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
		<span class="n">svc_rdma_put_context</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
