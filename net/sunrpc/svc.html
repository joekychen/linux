<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sunrpc › svc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>svc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/net/sunrpc/svc.c</span>
<span class="cm"> *</span>
<span class="cm"> * High-level RPC service routines</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple threads pools and NUMAisation</span>
<span class="cm"> * Copyright (c) 2006 Silicon Graphics, Inc.</span>
<span class="cm"> * by Greg Banks &lt;gnb@melbourne.sgi.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>

<span class="cp">#include &lt;linux/sunrpc/types.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/xdr.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/stats.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svcsock.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/bc_xprt.h&gt;</span>

<span class="cp">#define RPCDBG_FACILITY	RPCDBG_SVCDSP</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">svc_unregister</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>

<span class="cp">#define svc_serv_is_pooled(serv)    ((serv)-&gt;sv_function)</span>

<span class="cm">/*</span>
<span class="cm"> * Mode for mapping cpus to pools.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SVC_POOL_AUTO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* choose one of the others */</span>
	<span class="n">SVC_POOL_GLOBAL</span><span class="p">,</span>	<span class="cm">/* no mapping, just a single global pool</span>
<span class="cm">				 * (legacy &amp; UP mode) */</span>
	<span class="n">SVC_POOL_PERCPU</span><span class="p">,</span>	<span class="cm">/* one pool per cpu */</span>
	<span class="n">SVC_POOL_PERNODE</span>	<span class="cm">/* one pool per numa node */</span>
<span class="p">};</span>
<span class="cp">#define SVC_POOL_DEFAULT	SVC_POOL_GLOBAL</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for mapping cpus to pools and vice versa.</span>
<span class="cm"> * Setup once during sunrpc initialisation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>			<span class="cm">/* How many svc_servs use us */</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>			<span class="cm">/* Note: int not enum to avoid</span>
<span class="cm">					 * warnings about &quot;enumeration value</span>
<span class="cm">					 * not handled in switch&quot; */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npools</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pool_to</span><span class="p">;</span>		<span class="cm">/* maps pool id to cpu or node */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">to_pool</span><span class="p">;</span>		<span class="cm">/* maps cpu or node to pool id */</span>
<span class="p">}</span> <span class="n">svc_pool_map</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">SVC_POOL_DEFAULT</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span><span class="cm">/* protects svc_pool_map.count only */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">param_set_pool_mode</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s">&quot;auto&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
		<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">SVC_POOL_AUTO</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s">&quot;global&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
		<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">SVC_POOL_GLOBAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s">&quot;percpu&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
		<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">SVC_POOL_PERCPU</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s">&quot;pernode&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
		<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">SVC_POOL_PERNODE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">param_get_pool_mode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">SVC_POOL_AUTO</span>:
		<span class="k">return</span> <span class="n">strlcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;auto&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SVC_POOL_GLOBAL</span>:
		<span class="k">return</span> <span class="n">strlcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;global&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SVC_POOL_PERCPU</span>:
		<span class="k">return</span> <span class="n">strlcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;percpu&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SVC_POOL_PERNODE</span>:
		<span class="k">return</span> <span class="n">strlcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;pernode&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">pool_mode</span><span class="p">,</span> <span class="n">param_set_pool_mode</span><span class="p">,</span> <span class="n">param_get_pool_mode</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Detect best pool mapping mode heuristically,</span>
<span class="cm"> * according to the machine&#39;s topology.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">svc_pool_map_choose_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Actually have multiple NUMA nodes,</span>
<span class="cm">		 * so split pools on NUMA node boundaries</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">SVC_POOL_PERNODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Non-trivial SMP, or CONFIG_NUMA on</span>
<span class="cm">		 * non-NUMA hardware, e.g. with a generic</span>
<span class="cm">		 * x86_64 kernel on Xeons.  In this case we</span>
<span class="cm">		 * want to divide the pools on cpu boundaries.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">SVC_POOL_PERCPU</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* default: one global pool */</span>
	<span class="k">return</span> <span class="n">SVC_POOL_GLOBAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate the to_pool[] and pool_to[] arrays.</span>
<span class="cm"> * Returns 0 on success or an errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">svc_pool_map_alloc_arrays</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxpools</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">maxpools</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">maxpools</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the pool map for SVC_POOL_PERCPU mode.</span>
<span class="cm"> * Returns number of pools or &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">svc_pool_map_init_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxpools</span> <span class="o">=</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">svc_pool_map_alloc_arrays</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">maxpools</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pidx</span> <span class="o">&gt;</span> <span class="n">maxpools</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">pidx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* cpus brought online later all get mapped to pool0, sorry */</span>

	<span class="k">return</span> <span class="n">pidx</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Initialise the pool map for SVC_POOL_PERNODE mode.</span>
<span class="cm"> * Returns number of pools or &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">svc_pool_map_init_pernode</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxpools</span> <span class="o">=</span> <span class="n">nr_node_ids</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">svc_pool_map_alloc_arrays</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">maxpools</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_node_with_cpus</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* some architectures (e.g. SN2) have cpuless nodes */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pidx</span> <span class="o">&gt;</span> <span class="n">maxpools</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="n">pidx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* nodes brought online later all get mapped to pool0, sorry */</span>

	<span class="k">return</span> <span class="n">pidx</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Add a reference to the global map of cpus to pools (and</span>
<span class="cm"> * vice versa).  Initialise the map if we&#39;re the first user.</span>
<span class="cm"> * Returns the number of pools.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">svc_pool_map_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npools</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">npools</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SVC_POOL_AUTO</span><span class="p">)</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">svc_pool_map_choose_mode</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SVC_POOL_PERCPU</span>:
		<span class="n">npools</span> <span class="o">=</span> <span class="n">svc_pool_map_init_percpu</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SVC_POOL_PERNODE</span>:
		<span class="n">npools</span> <span class="o">=</span> <span class="n">svc_pool_map_init_pernode</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">npools</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* default, or memory allocation failure */</span>
		<span class="n">npools</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">SVC_POOL_GLOBAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">npools</span> <span class="o">=</span> <span class="n">npools</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">npools</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Drop a reference to the global map of cpus to pools.</span>
<span class="cm"> * When the last reference is dropped, the map data is</span>
<span class="cm"> * freed; this allows the sysadmin to change the pool</span>
<span class="cm"> * mode using the pool_mode module option without</span>
<span class="cm"> * rebooting or re-loading sunrpc.ko.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">svc_pool_map_put</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">npools</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc_pool_map_mutex</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">svc_pool_map_get_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SVC_POOL_PERCPU</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">[</span><span class="n">pidx</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SVC_POOL_PERNODE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Set the given thread&#39;s cpus_allowed mask so that it</span>
<span class="cm"> * will only run on cpus in the given pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">svc_pool_map_set_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">pool_to</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * The caller checks for sv_nrpools &gt; 1, which</span>
<span class="cm">	 * implies that we&#39;ve been initialized.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SVC_POOL_PERCPU</span>:
	<span class="p">{</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">SVC_POOL_PERNODE</span>:
	<span class="p">{</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use the mapping mode to choose a pool for a given CPU.</span>
<span class="cm"> * Used when enqueueing an incoming RPC.  Always returns</span>
<span class="cm"> * a non-NULL pool pointer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span>
<span class="nf">svc_pool_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_pool_map</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_pool_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An uninitialised map happens in a pure client when</span>
<span class="cm">	 * lockd is brought up, so silently treat it the</span>
<span class="cm">	 * same as SVC_POOL_GLOBAL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc_serv_is_pooled</span><span class="p">(</span><span class="n">serv</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SVC_POOL_PERCPU</span>:
			<span class="n">pidx</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SVC_POOL_PERNODE</span>:
			<span class="n">pidx</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">to_pool</span><span class="p">[</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">[</span><span class="n">pidx</span> <span class="o">%</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">svc_rpcb_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rpcb_create_local</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Remove any stale portmap registrations */</span>
	<span class="n">svc_unregister</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_rpcb_setup</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">svc_rpcb_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">svc_unregister</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">rpcb_put_local</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_rpcb_cleanup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">svc_uses_rpcbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_program</span>	<span class="o">*</span><span class="n">progp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">progp</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span><span class="p">;</span> <span class="n">progp</span><span class="p">;</span> <span class="n">progp</span> <span class="o">=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_nvers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vs_hidden</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">svc_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc_uses_rpcbind</span><span class="p">(</span><span class="n">serv</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">svc_rpcb_setup</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_bind</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create an RPC service</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span>
<span class="nf">__svc_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npools</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_serv</span>	<span class="o">*</span><span class="n">serv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vers</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xdrsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">serv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">serv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_name</span>      <span class="o">=</span> <span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span>   <span class="o">=</span> <span class="n">prog</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span>     <span class="o">=</span> <span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_stats</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bufsize</span> <span class="o">&gt;</span> <span class="n">RPCSVC_MAXPAYLOAD</span><span class="p">)</span>
		<span class="n">bufsize</span> <span class="o">=</span> <span class="n">RPCSVC_MAXPAYLOAD</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_max_payload</span> <span class="o">=</span> <span class="n">bufsize</span><span class="o">?</span> <span class="n">bufsize</span> <span class="o">:</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_max_mesg</span>  <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_max_payload</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_shutdown</span>  <span class="o">=</span> <span class="n">shutdown</span><span class="p">;</span>
	<span class="n">xdrsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">prog</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_lovers</span> <span class="o">=</span> <span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_nvers</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vers</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">vers</span><span class="o">&lt;</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_nvers</span> <span class="p">;</span> <span class="n">vers</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">vers</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_hivers</span> <span class="o">=</span> <span class="n">vers</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_lovers</span> <span class="o">&gt;</span> <span class="n">vers</span><span class="p">)</span>
					<span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_lovers</span> <span class="o">=</span> <span class="n">vers</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vs_xdrsize</span> <span class="o">&gt;</span> <span class="n">xdrsize</span><span class="p">)</span>
					<span class="n">xdrsize</span> <span class="o">=</span> <span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vs_xdrsize</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="n">prog</span> <span class="o">=</span> <span class="n">prog</span><span class="o">-&gt;</span><span class="n">pg_next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_xdrsize</span>   <span class="o">=</span> <span class="n">xdrsize</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_tempsocks</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_permsocks</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_temptimer</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_lock</span><span class="p">);</span>

	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span> <span class="o">=</span> <span class="n">npools</span><span class="p">;</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span> <span class="o">=</span>
		<span class="n">kcalloc</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_pool</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">serv</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: initialising pool %u for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_name</span><span class="p">);</span>

		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_threads</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_sockets</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_all_threads</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">svc_uses_rpcbind</span><span class="p">(</span><span class="n">serv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_shutdown</span><span class="p">))</span>
		<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_shutdown</span> <span class="o">=</span> <span class="n">svc_rpcb_cleanup</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">serv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span>
<span class="nf">svc_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span>
	   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__svc_create</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="cm">/*npools*/</span><span class="mi">1</span><span class="p">,</span> <span class="n">shutdown</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_create</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span>
<span class="nf">svc_create_pooled</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span>
		  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">),</span>
		  <span class="n">svc_thread_fn</span> <span class="n">func</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npools</span> <span class="o">=</span> <span class="n">svc_pool_map_get</span><span class="p">();</span>

	<span class="n">serv</span> <span class="o">=</span> <span class="n">__svc_create</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">npools</span><span class="p">,</span> <span class="n">shutdown</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_function</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
		<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_module</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">serv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_create_pooled</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">svc_shutdown_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The set of xprts (contained in the sv_tempsocks and</span>
<span class="cm">	 * sv_permsocks lists) is now constant, since it is modified</span>
<span class="cm">	 * only by accepting new sockets (done by service threads in</span>
<span class="cm">	 * svc_recv) or aging old ones (done by sv_temptimer), or</span>
<span class="cm">	 * configuration changes (excluded by whatever locking the</span>
<span class="cm">	 * caller is using--nfsd_mutex in the case of nfsd).  So it&#39;s</span>
<span class="cm">	 * safe to traverse those lists and shut everything down:</span>
<span class="cm">	 */</span>
	<span class="n">svc_close_net</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_shutdown</span><span class="p">)</span>
		<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_shutdown</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_shutdown_net</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Destroy an RPC service. Should be called with appropriate locking to</span>
<span class="cm"> * protect the sv_nrthreads, sv_permsocks and sv_tempsocks.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">svc_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: svc_destroy(%s, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">,</span>
				<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">svc_sock_update_bufs</span><span class="p">(</span><span class="n">serv</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;svc_destroy: no threads for serv=%p!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">serv</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_temptimer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The last user is gone and thus all sockets have to be destroyed to</span>
<span class="cm">	 * the point. Check this.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_permsocks</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_tempsocks</span><span class="p">));</span>

	<span class="n">cache_clean_deferred</span><span class="p">(</span><span class="n">serv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">svc_serv_is_pooled</span><span class="p">(</span><span class="n">serv</span><span class="p">))</span>
		<span class="n">svc_pool_map_put</span><span class="p">();</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">serv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_destroy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an RPC server&#39;s buffer space.</span>
<span class="cm"> * We allocate pages and place them in rq_argpages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">svc_init_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">,</span> <span class="n">arghi</span><span class="p">;</span>

	<span class="cm">/* bc_xprt uses fore channel allocated buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc_is_backchannel</span><span class="p">(</span><span class="n">rqstp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* extra page as we hold both request and reply.</span>
<span class="cm">				       * We assume one is at most one page</span>
<span class="cm">				       */</span>
	<span class="n">arghi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pages</span> <span class="o">&gt;</span> <span class="n">RPCSVC_MAXPAGES</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_pages</span><span class="p">[</span><span class="n">arghi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">pages</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release an RPC server buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">svc_release_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_pages</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span>
<span class="nf">svc_prepare_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rqst</span>	<span class="o">*</span><span class="n">rqstp</span><span class="p">;</span>

	<span class="n">rqstp</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rqstp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rqstp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_enomem</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_wait</span><span class="p">);</span>

	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_nrthreads</span><span class="o">++</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_all_threads</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span> <span class="o">=</span> <span class="n">serv</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_pool</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>

	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_xdrsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_thread</span><span class="p">;</span>

	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_xdrsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_thread</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc_init_buffer</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_max_mesg</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_thread</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rqstp</span><span class="p">;</span>
<span class="nl">out_thread:</span>
	<span class="n">svc_exit_thread</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
<span class="nl">out_enomem:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_prepare_thread</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Choose a pool in which to create a new thread, for svc_set_num_threads</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span>
<span class="nf">choose_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">[(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span><span class="o">++</span> <span class="o">%</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Choose a thread to kill, for svc_set_num_threads</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="nf">choose_victim</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* choose a pool in round-robin fashion */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pool</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span> <span class="o">%</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">];</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_all_threads</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found_pool</span><span class="p">;</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">found_pool:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_all_threads</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove from the pool-&gt;sp_all_threads list</span>
<span class="cm">		 * so we don&#39;t try to kill it again.</span>
<span class="cm">		 */</span>
		<span class="n">rqstp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_all_threads</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_rqst</span><span class="p">,</span> <span class="n">rq_all</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_all</span><span class="p">);</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_task</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create or destroy enough new threads to make the number</span>
<span class="cm"> * of threads the given number.  If `pool&#39; is non-NULL, applies</span>
<span class="cm"> * only to threads in that pool, otherwise round-robins between</span>
<span class="cm"> * all pools.  Caller must ensure that mutual exclusion between this and</span>
<span class="cm"> * server startup or shutdown.</span>
<span class="cm"> *</span>
<span class="cm"> * Destroying threads relies on the service threads filling in</span>
<span class="cm"> * rqstp-&gt;rq_task, which only the nfs ones do.  Assumes the serv</span>
<span class="cm"> * has been created using svc_create_pooled().</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code that used to be in nfsd_svc() but tweaked</span>
<span class="cm"> * to be pool-aware.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">svc_set_num_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrservs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rqst</span>	<span class="o">*</span><span class="n">rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">chosen_pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The -1 assumes caller has done a svc_get() */</span>
		<span class="n">nrservs</span> <span class="o">-=</span> <span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
		<span class="n">nrservs</span> <span class="o">-=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_nrthreads</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* create new threads */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nrservs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nrservs</span><span class="o">--</span><span class="p">;</span>
		<span class="n">chosen_pool</span> <span class="o">=</span> <span class="n">choose_pool</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>

		<span class="n">node</span> <span class="o">=</span> <span class="n">svc_pool_map_get_node</span><span class="p">(</span><span class="n">chosen_pool</span><span class="o">-&gt;</span><span class="n">sp_id</span><span class="p">);</span>
		<span class="n">rqstp</span> <span class="o">=</span> <span class="n">svc_prepare_thread</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">chosen_pool</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rqstp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">__module_get</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_module</span><span class="p">);</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">kthread_create_on_node</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_function</span><span class="p">,</span> <span class="n">rqstp</span><span class="p">,</span>
					      <span class="n">node</span><span class="p">,</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_module</span><span class="p">);</span>
			<span class="n">svc_exit_thread</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">svc_pool_map_set_cpumask</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">chosen_pool</span><span class="o">-&gt;</span><span class="n">sp_id</span><span class="p">);</span>

		<span class="n">svc_sock_update_bufs</span><span class="p">(</span><span class="n">serv</span><span class="p">);</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* destroy old threads */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nrservs</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">choose_victim</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nrservs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_set_num_threads</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called from a server thread as it&#39;s exiting. Caller must hold the BKL or</span>
<span class="cm"> * the &quot;service mutex&quot;, whichever is appropriate for the service.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">svc_exit_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_serv</span>	<span class="o">*</span><span class="n">serv</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_pool</span>	<span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_pool</span><span class="p">;</span>

	<span class="n">svc_release_buffer</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_auth_data</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>
	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_nrthreads</span><span class="o">--</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_all</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sp_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>

	<span class="cm">/* Release the server */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">serv</span><span class="p">)</span>
		<span class="n">svc_destroy</span><span class="p">(</span><span class="n">serv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_exit_thread</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Register an &quot;inet&quot; protocol family netid with the local</span>
<span class="cm"> * rpcbind daemon via an rpcbind v4 SET request.</span>
<span class="cm"> *</span>
<span class="cm"> * No netconfig infrastructure is available in the kernel, so</span>
<span class="cm"> * we map IP_ protocol numbers to netids by hand.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; a negative errno value is returned</span>
<span class="cm"> * if any error occurs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__svc_rpcb_register4</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">program</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u32</span> <span class="n">version</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">protocol</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sin_family</span>		<span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span>	<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">sin_port</span>		<span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">port</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">netid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
		<span class="n">netid</span> <span class="o">=</span> <span class="n">RPCBIND_NETID_UDP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
		<span class="n">netid</span> <span class="o">=</span> <span class="n">RPCBIND_NETID_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">rpcb_v4_register</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span>
					<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="n">netid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * User space didn&#39;t support rpcbind v4, so retry this</span>
<span class="cm">	 * registration request with the legacy rpcbind v2 protocol.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">rpcb_register</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="cm">/*</span>
<span class="cm"> * Register an &quot;inet6&quot; protocol family netid with the local</span>
<span class="cm"> * rpcbind daemon via an rpcbind v4 SET request.</span>
<span class="cm"> *</span>
<span class="cm"> * No netconfig infrastructure is available in the kernel, so</span>
<span class="cm"> * we map IP_ protocol numbers to netids by hand.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; a negative errno value is returned</span>
<span class="cm"> * if any error occurs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__svc_rpcb_register6</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">program</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u32</span> <span class="n">version</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">protocol</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="n">sin6</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sin6_family</span>		<span class="o">=</span> <span class="n">AF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sin6_addr</span>		<span class="o">=</span> <span class="n">IN6ADDR_ANY_INIT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sin6_port</span>		<span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">port</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">netid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
		<span class="n">netid</span> <span class="o">=</span> <span class="n">RPCBIND_NETID_UDP6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
		<span class="n">netid</span> <span class="o">=</span> <span class="n">RPCBIND_NETID_TCP6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">rpcb_v4_register</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span>
					<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin6</span><span class="p">,</span> <span class="n">netid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * User space didn&#39;t support rpcbind version 4, so we won&#39;t</span>
<span class="cm">	 * use a PF_INET6 listener.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* IS_ENABLED(CONFIG_IPV6) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Register a kernel RPC service via rpcbind version 4.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; a negative errno value is returned</span>
<span class="cm"> * if any error occurs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__svc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">progname</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">u32</span> <span class="n">program</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">version</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">protocol</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_INET</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">__svc_rpcb_register4</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span>
						<span class="n">protocol</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">case</span> <span class="n">PF_INET6</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">__svc_rpcb_register6</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span>
						<span class="n">protocol</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;svc: failed to register %sv%u RPC &quot;</span>
			<span class="s">&quot;service (errno %d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="o">-</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * svc_register - register an RPC service with the local portmapper</span>
<span class="cm"> * @serv: svc_serv struct for the service to register</span>
<span class="cm"> * @net: net namespace for the service to register</span>
<span class="cm"> * @family: protocol family of service&#39;s listener socket</span>
<span class="cm"> * @proto: transport protocol number to advertise</span>
<span class="cm"> * @port: port to advertise</span>
<span class="cm"> *</span>
<span class="cm"> * Service is registered for any address in the passed-in protocol family</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">svc_register</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">proto</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_program</span>	<span class="o">*</span><span class="n">progp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">proto</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">progp</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span><span class="p">;</span> <span class="n">progp</span><span class="p">;</span> <span class="n">progp</span> <span class="o">=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_nvers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: svc_register(%sv%d, %s, %u, %u)%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span>
					<span class="n">proto</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="o">?</span>  <span class="s">&quot;udp&quot;</span> <span class="o">:</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span>
					<span class="n">port</span><span class="p">,</span>
					<span class="n">family</span><span class="p">,</span>
					<span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vs_hidden</span><span class="o">?</span>
						<span class="s">&quot; (but not telling portmap)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vs_hidden</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">__svc_register</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_prog</span><span class="p">,</span>
						<span class="n">i</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If user space is running rpcbind, it should take the v4 UNSET</span>
<span class="cm"> * and clear everything for this [program, version].  If user space</span>
<span class="cm"> * is running portmap, it will reject the v4 UNSET, but won&#39;t have</span>
<span class="cm"> * any &quot;inet6&quot; entries anyway.  So a PMAP_UNSET should be sufficient</span>
<span class="cm"> * in this case to clear all existing entries for [program, version].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__svc_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">program</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">version</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">progname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">rpcb_v4_register</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * User space didn&#39;t support rpcbind v4, so retry this</span>
<span class="cm">	 * request with the legacy rpcbind v2 protocol.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">rpcb_register</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: %s(%sv%u), error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All netids, bind addresses and ports registered for [program, version]</span>
<span class="cm"> * are removed from the local rpcbind database (if the service is not</span>
<span class="cm"> * hidden) to make way for a new instance of the service.</span>
<span class="cm"> *</span>
<span class="cm"> * The result of unregistration is reported via dprintk for those who want</span>
<span class="cm"> * verification of the result, but is otherwise not important.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">svc_unregister</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span><span class="n">progp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_SIGPENDING</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">progp</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span><span class="p">;</span> <span class="n">progp</span><span class="p">;</span> <span class="n">progp</span> <span class="o">=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_nvers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vs_hidden</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: attempting to unregister %sv%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">__svc_unregister</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_prog</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">recalc_sigpending</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Printk the given error with the address of the client that caused it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">svc_printk</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> 	<span class="n">buf</span><span class="p">[</span><span class="n">RPC_MAX_ADDRBUFLEN</span><span class="p">];</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;svc: %s: %pV&quot;</span><span class="p">,</span>
			     <span class="n">svc_print_addr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common routine for processing the RPC request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">svc_process_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">resv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_program</span>	<span class="o">*</span><span class="n">progp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_version</span>	<span class="o">*</span><span class="n">versp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* compiler food */</span>
	<span class="k">struct</span> <span class="n">svc_procedure</span>	<span class="o">*</span><span class="n">procp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_serv</span>		<span class="o">*</span><span class="n">serv</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="p">;</span>
	<span class="n">kxdrproc_t</span>		<span class="n">xdr</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="o">*</span><span class="n">statp</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">prog</span><span class="p">,</span> <span class="n">vers</span><span class="p">,</span> <span class="n">proc</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">auth_stat</span><span class="p">,</span> <span class="n">rpc_stat</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">auth_res</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="o">*</span><span class="n">reply_statp</span><span class="p">;</span>

	<span class="n">rpc_stat</span> <span class="o">=</span> <span class="n">rpc_success</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_short_len</span><span class="p">;</span>

	<span class="cm">/* Will be turned off only in gss privacy case: */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_splice_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Will be turned off only when NFSv4 Sessions are used */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_usedeferral</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_dropme</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Setup reply header */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">xpt_ops</span><span class="o">-&gt;</span><span class="n">xpo_prep_reply_hdr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>

	<span class="n">svc_putu32</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xid</span><span class="p">);</span>

	<span class="n">vers</span> <span class="o">=</span> <span class="n">svc_getnl</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>

	<span class="cm">/* First words of reply: */</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>		<span class="cm">/* REPLY */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vers</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>		<span class="cm">/* RPC version number */</span>
		<span class="k">goto</span> <span class="n">err_bad_rpc</span><span class="p">;</span>

	<span class="cm">/* Save position in case we later decide to reject: */</span>
	<span class="n">reply_statp</span> <span class="o">=</span> <span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>

	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>		<span class="cm">/* ACCEPT */</span>

	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_prog</span> <span class="o">=</span> <span class="n">prog</span> <span class="o">=</span> <span class="n">svc_getnl</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>	<span class="cm">/* program number */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">=</span> <span class="n">vers</span> <span class="o">=</span> <span class="n">svc_getnl</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>	<span class="cm">/* version number */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_proc</span> <span class="o">=</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">svc_getnl</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>	<span class="cm">/* procedure number */</span>

	<span class="n">progp</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">progp</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_program</span><span class="p">;</span> <span class="n">progp</span><span class="p">;</span> <span class="n">progp</span> <span class="o">=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prog</span> <span class="o">==</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_prog</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decode auth data, and add verifier to reply buffer.</span>
<span class="cm">	 * We do this before anything else in order to get a decent</span>
<span class="cm">	 * auth verifier.</span>
<span class="cm">	 */</span>
	<span class="n">auth_res</span> <span class="o">=</span> <span class="n">svc_authenticate</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">auth_stat</span><span class="p">);</span>
	<span class="cm">/* Also give the program a chance to reject this call: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">auth_res</span> <span class="o">==</span> <span class="n">SVC_OK</span> <span class="o">&amp;&amp;</span> <span class="n">progp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">auth_stat</span> <span class="o">=</span> <span class="n">rpc_autherr_badcred</span><span class="p">;</span>
		<span class="n">auth_res</span> <span class="o">=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_authenticate</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">auth_res</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SVC_OK</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SVC_GARBAGE</span>:
		<span class="k">goto</span> <span class="n">err_garbage</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SVC_SYSERR</span>:
		<span class="n">rpc_stat</span> <span class="o">=</span> <span class="n">rpc_system_err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_bad</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SVC_DENIED</span>:
		<span class="k">goto</span> <span class="n">err_bad_auth</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SVC_CLOSE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XPT_TEMP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">))</span>
			<span class="n">svc_close_xprt</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SVC_DROP</span>:
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SVC_COMPLETE</span>:
		<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">progp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_bad_prog</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vers</span> <span class="o">&gt;=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_nvers</span> <span class="o">||</span>
	  <span class="o">!</span><span class="p">(</span><span class="n">versp</span> <span class="o">=</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">vers</span><span class="p">]))</span>
		<span class="k">goto</span> <span class="n">err_bad_vers</span><span class="p">;</span>

	<span class="n">procp</span> <span class="o">=</span> <span class="n">versp</span><span class="o">-&gt;</span><span class="n">vs_proc</span> <span class="o">+</span> <span class="n">proc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc</span> <span class="o">&gt;=</span> <span class="n">versp</span><span class="o">-&gt;</span><span class="n">vs_nproc</span> <span class="o">||</span> <span class="o">!</span><span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_func</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_bad_proc</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_procinfo</span> <span class="o">=</span> <span class="n">procp</span><span class="p">;</span>

	<span class="cm">/* Syntactic check complete */</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpccnt</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Build the reply header. */</span>
	<span class="n">statp</span> <span class="o">=</span> <span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span><span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">RPC_SUCCESS</span><span class="p">);</span>

	<span class="cm">/* Bump per-procedure stats counter */</span>
	<span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Initialize storage for argp and resp */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_argsize</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_ressize</span><span class="p">);</span>

	<span class="cm">/* un-reserve some of the out-queue now that we have a</span>
<span class="cm">	 * better idea of reply size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_xdrressize</span><span class="p">)</span>
		<span class="n">svc_reserve_auth</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_xdrressize</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Call the function that processes the request. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">versp</span><span class="o">-&gt;</span><span class="n">vs_dispatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Decode arguments */</span>
		<span class="n">xdr</span> <span class="o">=</span> <span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_decode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xdr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xdr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">argv</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_garbage</span><span class="p">;</span>

		<span class="o">*</span><span class="n">statp</span> <span class="o">=</span> <span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_func</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">);</span>

		<span class="cm">/* Encode reply */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_dropme</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_release</span><span class="p">)</span>
				<span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_release</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">statp</span> <span class="o">==</span> <span class="n">rpc_success</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">xdr</span> <span class="o">=</span> <span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_encode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">xdr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="o">+</span><span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: failed to encode reply</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* serv-&gt;sv_stats-&gt;rpcsystemerr++; */</span>
			<span class="o">*</span><span class="n">statp</span> <span class="o">=</span> <span class="n">rpc_system_err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: calling dispatcher</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">versp</span><span class="o">-&gt;</span><span class="n">vs_dispatch</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">statp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Release reply info */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_release</span><span class="p">)</span>
				<span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_release</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check RPC status result */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">statp</span> <span class="o">!=</span> <span class="n">rpc_success</span><span class="p">)</span>
		<span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">statp</span><span class="p">)</span>  <span class="o">-</span> <span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Release reply info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_release</span><span class="p">)</span>
		<span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_release</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">procp</span><span class="o">-&gt;</span><span class="n">pc_encode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

 <span class="nl">sendit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc_authorise</span><span class="p">(</span><span class="n">rqstp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Caller can now send it */</span>

 <span class="nl">dropit:</span>
	<span class="n">svc_authorise</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>	<span class="cm">/* doesn&#39;t hurt to call this twice */</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: svc_process dropit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_short_len:</span>
	<span class="n">svc_printk</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="s">&quot;short len %Zd, dropping request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">argv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>			<span class="cm">/* drop request */</span>

<span class="nl">err_bad_rpc:</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadfmt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* REJECT */</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* RPC_MISMATCH */</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* Only RPCv2 supported */</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>

<span class="nl">err_bad_auth:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: authentication failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">auth_stat</span><span class="p">));</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadauth</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Restore write pointer to location of accept status: */</span>
	<span class="n">xdr_ressize_check</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">reply_statp</span><span class="p">);</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* REJECT */</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* AUTH_ERROR */</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">auth_stat</span><span class="p">));</span>	<span class="cm">/* status */</span>
	<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>

<span class="nl">err_bad_prog:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;svc: unknown program %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">prog</span><span class="p">);</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadfmt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">RPC_PROG_UNAVAIL</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>

<span class="nl">err_bad_vers:</span>
	<span class="n">svc_printk</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="s">&quot;unknown version (%d for prog %d, %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">vers</span><span class="p">,</span> <span class="n">prog</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_name</span><span class="p">);</span>

	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadfmt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">RPC_PROG_MISMATCH</span><span class="p">);</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_lovers</span><span class="p">);</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">progp</span><span class="o">-&gt;</span><span class="n">pg_hivers</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>

<span class="nl">err_bad_proc:</span>
	<span class="n">svc_printk</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="s">&quot;unknown procedure (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">proc</span><span class="p">);</span>

	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadfmt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">RPC_PROC_UNAVAIL</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>

<span class="nl">err_garbage:</span>
	<span class="n">svc_printk</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="s">&quot;failed to decode args</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rpc_stat</span> <span class="o">=</span> <span class="n">rpc_garbage_args</span><span class="p">;</span>
<span class="nl">err_bad:</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadfmt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">svc_putnl</span><span class="p">(</span><span class="n">resv</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">rpc_stat</span><span class="p">));</span>
	<span class="k">goto</span> <span class="n">sendit</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_process</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Process the RPC request.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">svc_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span>		<span class="o">*</span><span class="n">argv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_arg</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kvec</span>		<span class="o">*</span><span class="n">resv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">svc_serv</span>		<span class="o">*</span><span class="n">serv</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">dir</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup response xdr_buf.</span>
<span class="cm">	 * Initially it has just one page</span>
<span class="cm">	 */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_respages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_respages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">buflen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xid</span> <span class="o">=</span> <span class="n">svc_getu32</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>

	<span class="n">dir</span>  <span class="o">=</span> <span class="n">svc_getnl</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* direction != CALL */</span>
		<span class="n">svc_printk</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="s">&quot;bad direction %d, dropping request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_stats</span><span class="o">-&gt;</span><span class="n">rpcbadfmt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">svc_drop</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Returns 1 for send, 0 for drop */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc_process_common</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">resv</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">svc_send</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">svc_drop</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_SUNRPC_BACKCHANNEL)</span>
<span class="cm">/*</span>
<span class="cm"> * Process a backchannel RPC request that arrived over an existing</span>
<span class="cm"> * outbound connection</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">bc_svc_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span>	<span class="o">*</span><span class="n">argv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_arg</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kvec</span>	<span class="o">*</span><span class="n">resv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Build the svc_rqst used by the common processing routine */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xprt</span> <span class="o">=</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_bc_xprt</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xid</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_prot</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span> <span class="o">=</span> <span class="n">serv</span><span class="p">;</span>

	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_addrlen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_arg</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">));</span>

	<span class="cm">/* reset result send buffer &quot;put&quot; position */</span>
	<span class="n">resv</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_prot</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;No support for Non-TCP transports!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Skip the next two words because they&#39;ve already been</span>
<span class="cm">	 * processed in the trasport</span>
<span class="cm">	 */</span>
	<span class="n">svc_getu32</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>	<span class="cm">/* XID */</span>
	<span class="n">svc_getnl</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>	<span class="cm">/* CALLDIR */</span>

	<span class="cm">/* Returns 1 for send, 0 for drop */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc_process_common</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">resv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">bc_send</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* drop request */</span>
		<span class="n">xprt_free_bc_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bc_svc_process</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_BACKCHANNEL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Return (transport-specific) limit on the rpc payload.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">svc_max_payload</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">xpt_class</span><span class="o">-&gt;</span><span class="n">xcl_max_payload</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="o">-&gt;</span><span class="n">sv_max_payload</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="o">-&gt;</span><span class="n">sv_max_payload</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">svc_max_payload</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
