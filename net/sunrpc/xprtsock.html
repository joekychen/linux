<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sunrpc › xprtsock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xprtsock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/net/sunrpc/xprtsock.c</span>
<span class="cm"> *</span>
<span class="cm"> * Client-side transport implementation for sockets.</span>
<span class="cm"> *</span>
<span class="cm"> * TCP callback races fixes (C) 1998 Red Hat</span>
<span class="cm"> * TCP send fixes (C) 1998 Red Hat</span>
<span class="cm"> * TCP NFS related read + write fixes</span>
<span class="cm"> *  (C) 1999 Dave Airlie, University of Limerick, Ireland &lt;airlied@linux.ie&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Rewrite of larges part of the code in order to stabilize TCP stuff.</span>
<span class="cm"> * Fix behaviour when socket buffer is full.</span>
<span class="cm"> *  (C) 1999 Trond Myklebust &lt;trond.myklebust@fys.uio.no&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * IP socket transport implementation, (C) 2005 Chuck Lever &lt;cel@netapp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * IPv6 support contributed by Gilles Quillard, Bull Open Source, 2005.</span>
<span class="cm"> *   &lt;gilles.quillard@bull.net&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/un.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/sched.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svcsock.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/xprtsock.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#ifdef CONFIG_SUNRPC_BACKCHANNEL</span>
<span class="cp">#include &lt;linux/sunrpc/bc_xprt.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/udp.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>

<span class="cp">#include &quot;sunrpc.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">xs_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * xprtsock tunables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_udp_slot_table_entries</span> <span class="o">=</span> <span class="n">RPC_DEF_SLOT_TABLE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_tcp_slot_table_entries</span> <span class="o">=</span> <span class="n">RPC_MIN_SLOT_TABLE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_max_tcp_slot_table_entries</span> <span class="o">=</span> <span class="n">RPC_MAX_SLOT_TABLE</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_min_resvport</span> <span class="o">=</span> <span class="n">RPC_DEF_MIN_RESVPORT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_max_resvport</span> <span class="o">=</span> <span class="n">RPC_DEF_MAX_RESVPORT</span><span class="p">;</span>

<span class="cp">#define XS_TCP_LINGER_TO	(15U * HZ)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xs_tcp_fin_timeout</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">XS_TCP_LINGER_TO</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We can register our own files under /proc/sys/sunrpc by</span>
<span class="cm"> * calling register_sysctl_table() again.  The files in that</span>
<span class="cm"> * directory become the union of all files registered there.</span>
<span class="cm"> *</span>
<span class="cm"> * We simply need to make sure that we don&#39;t collide with</span>
<span class="cm"> * someone else&#39;s file names!</span>
<span class="cm"> */</span>

<span class="cp">#ifdef RPC_DEBUG</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_slot_table_size</span> <span class="o">=</span> <span class="n">RPC_MIN_SLOT_TABLE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_slot_table_size</span> <span class="o">=</span> <span class="n">RPC_MAX_SLOT_TABLE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_tcp_slot_table_limit</span> <span class="o">=</span> <span class="n">RPC_MAX_SLOT_TABLE_LIMIT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_min_resvport_limit</span> <span class="o">=</span> <span class="n">RPC_MIN_RESVPORT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xprt_max_resvport_limit</span> <span class="o">=</span> <span class="n">RPC_MAX_RESVPORT</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">sunrpc_table_header</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: changing the UDP slot table size should also resize the UDP</span>
<span class="cm"> *        socket buffers for existing UDP transports</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">xs_tunables_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;udp_slot_table_entries&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_udp_slot_table_entries</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">min_slot_table_size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">max_slot_table_size</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;tcp_slot_table_entries&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_tcp_slot_table_entries</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">min_slot_table_size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">max_slot_table_size</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;tcp_max_slot_table_entries&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_max_tcp_slot_table_entries</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">min_slot_table_size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">max_tcp_slot_table_limit</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;min_resvport&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_min_resvport</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_min_resvport_limit</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_max_resvport_limit</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;max_resvport&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_max_resvport</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_min_resvport_limit</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xprt_max_resvport_limit</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;tcp_fin_timeout&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_tcp_fin_timeout</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xs_tcp_fin_timeout</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec_jiffies</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">sunrpc_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;sunrpc&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">child</span>		<span class="o">=</span> <span class="n">xs_tunables_table</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Wait duration for a reply from the RPC portmapper.</span>
<span class="cm"> */</span>
<span class="cp">#define XS_BIND_TO		(60U * HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * Delay if a UDP socket connect error occurs.  This is most likely some</span>
<span class="cm"> * kind of resource problem on the local host.</span>
<span class="cm"> */</span>
<span class="cp">#define XS_UDP_REEST_TO		(2U * HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * The reestablish timeout allows clients to delay for a bit before attempting</span>
<span class="cm"> * to reconnect to a server that just dropped our connection.</span>
<span class="cm"> *</span>
<span class="cm"> * We implement an exponential backoff when trying to reestablish a TCP</span>
<span class="cm"> * transport connection with the server.  Some servers like to drop a TCP</span>
<span class="cm"> * connection when they are overworked, so we start with a short timeout and</span>
<span class="cm"> * increase over time if the server is down or not responding.</span>
<span class="cm"> */</span>
<span class="cp">#define XS_TCP_INIT_REEST_TO	(3U * HZ)</span>
<span class="cp">#define XS_TCP_MAX_REEST_TO	(5U * 60 * HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * TCP idle timeout; client drops the transport socket if it is idle</span>
<span class="cm"> * for this long.  Note that we also timeout UDP sockets to prevent</span>
<span class="cm"> * holding port numbers when there is no RPC traffic.</span>
<span class="cm"> */</span>
<span class="cp">#define XS_IDLE_DISC_TO		(5U * 60 * HZ)</span>

<span class="cp">#ifdef RPC_DEBUG</span>
<span class="cp"># undef  RPC_DEBUG_DATA</span>
<span class="cp"># define RPCDBG_FACILITY	RPCDBG_TRANS</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef RPC_DEBUG_DATA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_pktdump</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;0x%04x &quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%02x%02x%02x%02x &quot;</span><span class="p">,</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_pktdump</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* NOP */</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span>		<span class="n">xprt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Network layer</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span>		<span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span>		<span class="n">inet</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * State of TCP reply receive</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>			<span class="n">tcp_fraghdr</span><span class="p">,</span>
				<span class="n">tcp_xid</span><span class="p">,</span>
				<span class="n">tcp_calldir</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">tcp_offset</span><span class="p">,</span>
				<span class="n">tcp_reclen</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tcp_copied</span><span class="p">,</span>
				<span class="n">tcp_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Connection of transports</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">connect_worker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">srcaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">srcport</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * UDP socket buffer size parameters</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span>			<span class="n">rcvsize</span><span class="p">,</span>
				<span class="n">sndsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Saved socket callback addresses</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">old_data_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">old_state_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">old_write_space</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">old_error_report</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * TCP receive state flags</span>
<span class="cm"> */</span>
<span class="cp">#define TCP_RCV_LAST_FRAG	(1UL &lt;&lt; 0)</span>
<span class="cp">#define TCP_RCV_COPY_FRAGHDR	(1UL &lt;&lt; 1)</span>
<span class="cp">#define TCP_RCV_COPY_XID	(1UL &lt;&lt; 2)</span>
<span class="cp">#define TCP_RCV_COPY_DATA	(1UL &lt;&lt; 3)</span>
<span class="cp">#define TCP_RCV_READ_CALLDIR	(1UL &lt;&lt; 4)</span>
<span class="cp">#define TCP_RCV_COPY_CALLDIR	(1UL &lt;&lt; 5)</span>

<span class="cm">/*</span>
<span class="cm"> * TCP RPC flags</span>
<span class="cm"> */</span>
<span class="cp">#define TCP_RPC_REPLY		(1UL &lt;&lt; 6)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="nf">xs_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="nf">xs_addr_un</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="nf">xs_addr_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="nf">xs_addr_in6</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_format_common_peer_addresses</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span> <span class="o">=</span> <span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sin6</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sun</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_LOCAL</span>:
		<span class="n">sun</span> <span class="o">=</span> <span class="n">xs_addr_un</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">sun</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rpc_ntop</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">sin</span> <span class="o">=</span> <span class="n">xs_addr_in</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rpc_ntop</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">sin6</span> <span class="o">=</span> <span class="n">xs_addr_in6</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%pi6&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_HEX_ADDR</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_format_common_peer_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span> <span class="o">=</span> <span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="n">rpc_get_port</span><span class="p">(</span><span class="n">sap</span><span class="p">));</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%4hx&quot;</span><span class="p">,</span> <span class="n">rpc_get_port</span><span class="p">(</span><span class="n">sap</span><span class="p">));</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_HEX_PORT</span><span class="p">]</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_format_peer_addresses</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">protocol</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">netid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">]</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_NETID</span><span class="p">]</span> <span class="o">=</span> <span class="n">netid</span><span class="p">;</span>
	<span class="n">xs_format_common_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xs_format_common_peer_ports</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_update_peer_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_HEX_PORT</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">]);</span>

	<span class="n">xs_format_common_peer_ports</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_free_peer_addresses</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RPC_DISPLAY_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RPC_DISPLAY_PROTO</span>:
		<span class="k">case</span> <span class="n">RPC_DISPLAY_NETID</span>:
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define XS_SENDMSG_FLAGS	(MSG_DONTWAIT | MSG_NOSIGNAL)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_send_kvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">msg_name</span>	<span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">msg_namelen</span>	<span class="o">=</span> <span class="n">addrlen</span><span class="p">,</span>
		<span class="p">.</span><span class="n">msg_flags</span>	<span class="o">=</span> <span class="n">XS_SENDMSG_FLAGS</span> <span class="o">|</span> <span class="p">(</span><span class="n">more</span> <span class="o">?</span> <span class="n">MSG_MORE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">iov_base</span>	<span class="o">=</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">base</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iov_len</span>	<span class="o">=</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">base</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kernel_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kernel_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_send_pagedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ppage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remainder</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">remainder</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">page_len</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">base</span> <span class="o">+=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">page_base</span><span class="p">;</span>
	<span class="n">ppage</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">+</span> <span class="p">(</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">base</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">base</span><span class="p">,</span> <span class="n">remainder</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">XS_SENDMSG_FLAGS</span><span class="p">;</span>

		<span class="n">remainder</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">more</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_MORE</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sendpage</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">*</span><span class="n">ppage</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sent</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">ppage</span><span class="o">++</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sent</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_sendpages - write pages directly to a socket</span>
<span class="cm"> * @sock: socket to send on</span>
<span class="cm"> * @addr: UDP only -- address of destination</span>
<span class="cm"> * @addrlen: UDP only -- length of destination address</span>
<span class="cm"> * @xdr: buffer containing this request</span>
<span class="cm"> * @base: starting position in the buffer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_sendpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSOCK</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">addrlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">remainder</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">xs_send_kvec</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">sent</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">base</span> <span class="o">-=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">page_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">page_len</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">remainder</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">xs_send_pagedata</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">xdr</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">sent</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">base</span> <span class="o">-=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">page_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sent</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">xs_send_kvec</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sent</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_nospace_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span><span class="o">--</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_nospace - place task on wait queue if transmit was incomplete</span>
<span class="cm"> * @task: task to put to sleep</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_nospace</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u xmit incomplete (%u left of %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span><span class="p">);</span>

	<span class="cm">/* Protect against races with write_space */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t race with disconnect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Notify TCP that we&#39;re limited by the application</span>
<span class="cm">			 * window size</span>
<span class="cm">			 */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* ...and wait for more buffer space */</span>
			<span class="n">xprt_wait_for_buffer_space</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">xs_nospace_callback</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Construct a stream transport record marker in @buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_encode_stream_record_marker</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reclen</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">);</span>
	<span class="n">rpc_fraghdr</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">RPC_LAST_STREAM_FRAGMENT</span> <span class="o">|</span> <span class="n">reclen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_local_send_request - write an RPC request to an AF_LOCAL socket</span>
<span class="cm"> * @task: RPC task that manages the state of an RPC request</span>
<span class="cm"> *</span>
<span class="cm"> * Return values:</span>
<span class="cm"> *        0:	The request has been sent</span>
<span class="cm"> *   EAGAIN:	The socket was blocked, please call again later to</span>
<span class="cm"> *		complete the request</span>
<span class="cm"> * ENOTCONN:	Caller needs to invoke connect logic then call again</span>
<span class="cm"> *    other:	Some other error occured, the request was not sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_local_send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">xs_encode_stream_record_marker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">);</span>

	<span class="n">xs_pktdump</span><span class="p">(</span><span class="s">&quot;packet data:&quot;</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">xs_sendpages</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">xdr</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s(%u) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xmit_bytes_sent</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">&gt;=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">xs_nospace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       sendmsg returned unrecognized error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">-</span><span class="n">status</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">xs_close</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_udp_send_request - write an RPC request to a UDP socket</span>
<span class="cm"> * @task: address of RPC task that manages the state of an RPC request</span>
<span class="cm"> *</span>
<span class="cm"> * Return values:</span>
<span class="cm"> *        0:	The request has been sent</span>
<span class="cm"> *   EAGAIN:	The socket was blocked, please call again later to</span>
<span class="cm"> *		complete the request</span>
<span class="cm"> * ENOTCONN:	Caller needs to invoke connect logic then call again</span>
<span class="cm"> *    other:	Some other error occurred, the request was not sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_udp_send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">xs_pktdump</span><span class="p">(</span><span class="s">&quot;packet data:&quot;</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">xs_sendpages</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">,</span>
			      <span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">),</span>
			      <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">,</span> <span class="n">xdr</span><span class="p">,</span>
			      <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_udp_send_request(%u) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xmit_bytes_sent</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Still some bytes left; set up for a retry later. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTSOCK</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="cm">/* Should we call xs_close() here? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">xs_nospace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       sendmsg returned unrecognized error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">-</span><span class="n">status</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:
		<span class="cm">/* When the server has died, an ICMP port unreachable message</span>
<span class="cm">		 * prompts ECONNREFUSED. */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_shutdown - gracefully shut down a TCP socket</span>
<span class="cm"> * @xprt: transport</span>
<span class="cm"> *</span>
<span class="cm"> * Initiates a graceful shutdown of the TCP socket by calling the</span>
<span class="cm"> * equivalent of shutdown(SHUT_WR);</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kernel_sock_shutdown</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SHUT_WR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_send_request - write an RPC request to a TCP socket</span>
<span class="cm"> * @task: address of RPC task that manages the state of an RPC request</span>
<span class="cm"> *</span>
<span class="cm"> * Return values:</span>
<span class="cm"> *        0:	The request has been sent</span>
<span class="cm"> *   EAGAIN:	The socket was blocked, please call again later to</span>
<span class="cm"> *		complete the request</span>
<span class="cm"> * ENOTCONN:	Caller needs to invoke connect logic then call again</span>
<span class="cm"> *    other:	Some other error occurred, the request was not sent</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: In the case of soft timeouts, should we eventually give up</span>
<span class="cm"> *	if sendmsg is not able to make progress?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_tcp_send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">xs_encode_stream_record_marker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">);</span>

	<span class="n">xs_pktdump</span><span class="p">(</span><span class="s">&quot;packet data:&quot;</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span>
				<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">);</span>

	<span class="cm">/* Continue transmitting the packet/record. We must be careful</span>
<span class="cm">	 * to cope with writespace callbacks arriving _after_ we have</span>
<span class="cm">	 * called sendmsg(). */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">xs_sendpages</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xdr</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">);</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_tcp_send_request(%u) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* If we&#39;ve sent the entire packet, immediately</span>
<span class="cm">		 * reset the count of bytes sent. */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xmit_bytes_sent</span> <span class="o">+=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">&gt;=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTSOCK</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="cm">/* Should we call xs_close() here? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">xs_nospace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       sendmsg returned unrecognized error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">-</span><span class="n">status</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">xs_tcp_shutdown</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTCONN</span>:
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_release_xprt - clean up after a tcp transmission</span>
<span class="cm"> * @xprt: transport</span>
<span class="cm"> * @task: rpc task</span>
<span class="cm"> *</span>
<span class="cm"> * This cleans up if an error causes us to abort the transmission of a request.</span>
<span class="cm"> * In this case, the socket may need to be reset in order to avoid confusing</span>
<span class="cm"> * the server.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_release_xprt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">snd_task</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">XPRT_CLOSE_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="nl">out_release:</span>
	<span class="n">xprt_release_xprt</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_save_old_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_data_ready</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_state_change</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_write_space</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_error_report</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_restore_old_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_data_ready</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_state_change</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_write_space</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">old_error_report</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_reset_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">xs_restore_old_callbacks</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_close - close a socket</span>
<span class="cm"> * @xprt: transport</span>
<span class="cm"> *</span>
<span class="cm"> * This is used when all requests are complete; ie, no DRC state remains</span>
<span class="cm"> * on the server we want to save.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller _must_ be holding XPRT_LOCKED in order to avoid issues with</span>
<span class="cm"> * xs_reset_transport() zeroing the socket from underneath a writer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_close xprt %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">xs_reset_transport</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CLOSE_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">xprt_disconnect_done</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">xs_close</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xs_tcp_shutdown</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_destroy - prepare to shutdown a transport</span>
<span class="cm"> * @xprt: doomed transport</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_destroy xprt %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">);</span>

	<span class="n">xs_close</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xs_free_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xprt_free</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="nf">xprt_from_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="p">)</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_local_copy_to_xdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="n">desc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">skb</span>		<span class="o">=</span> <span class="n">skb</span><span class="p">,</span>
		<span class="p">.</span><span class="n">offset</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">),</span>
		<span class="p">.</span><span class="n">count</span>		<span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xdr_partial_copy_from_skb</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="n">xdr_skb_read_bits</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_local_data_ready - &quot;data ready&quot; callback for AF_LOCAL sockets</span>
<span class="cm"> * @sk: socket with data to read</span>
<span class="cm"> * @len: how much data to read</span>
<span class="cm"> *</span>
<span class="cm"> * Currently this assumes we can read the whole reply in a single gulp.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_local_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">rovr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">repsize</span><span class="p">,</span> <span class="n">copied</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_xid</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="n">repsize</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">repsize</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       impossible RPC reply size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">repsize</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the XID from the skb... */</span>
	<span class="n">xp</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_xid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_xid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="cm">/* Look up and lock the request corresponding to the given XID */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
	<span class="n">rovr</span> <span class="o">=</span> <span class="n">xprt_lookup_rqst</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">*</span><span class="n">xp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rovr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">rovr</span><span class="o">-&gt;</span><span class="n">rq_task</span><span class="p">;</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="n">rovr</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">.</span><span class="n">buflen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">repsize</span><span class="p">)</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">repsize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xs_local_copy_to_xdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rovr</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       sk_buff copy failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xprt_complete_rqst</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
 <span class="nl">dropit:</span>
	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_udp_data_ready - &quot;data ready&quot; callback for UDP sockets</span>
<span class="cm"> * @sk: socket with data to read</span>
<span class="cm"> * @len: how much data to read</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">rovr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">repsize</span><span class="p">,</span> <span class="n">copied</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_xid</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_udp_data_ready...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="n">repsize</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">repsize</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       impossible RPC reply size %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">repsize</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the XID from the skb... */</span>
	<span class="n">xp</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">_xid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_xid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="cm">/* Look up and lock the request corresponding to the given XID */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
	<span class="n">rovr</span> <span class="o">=</span> <span class="n">xprt_lookup_rqst</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">*</span><span class="n">xp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rovr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">rovr</span><span class="o">-&gt;</span><span class="n">rq_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">copied</span> <span class="o">=</span> <span class="n">rovr</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">.</span><span class="n">buflen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">repsize</span><span class="p">)</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">repsize</span><span class="p">;</span>

	<span class="cm">/* Suck it into the iovec, verify checksum if not done by hw. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csum_partial_copy_to_xdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rovr</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">UDPX_INC_STATS_BH</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP_MIB_INERRORS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">UDPX_INC_STATS_BH</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">UDP_MIB_INDATAGRAMS</span><span class="p">);</span>

	<span class="cm">/* Something worked... */</span>
	<span class="n">dst_confirm</span><span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="n">xprt_adjust_cwnd</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">xprt_complete_rqst</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
 <span class="nl">dropit:</span>
	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_tcp_read_fraghdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_fraghdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_fraghdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">;</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">xdr_skb_read_bits</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_fraghdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">&amp;</span> <span class="n">RPC_LAST_STREAM_FRAGMENT</span><span class="p">)</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_LAST_FRAG</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_LAST_FRAG</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">&amp;=</span> <span class="n">RPC_FRAGMENT_SIZE_MASK</span><span class="p">;</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_FRAGHDR</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Sanity check of the record length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       invalid TCP record fragment length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xprt_force_disconnect</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       reading TCP record fragment of length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_check_fraghdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">==</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_COPY_FRAGHDR</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_LAST_FRAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_COPY_XID</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_tcp_read_xid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">)</span> <span class="o">-</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       reading XID (%Zu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">)</span> <span class="o">+</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">;</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">xdr_skb_read_bits</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_XID</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_READ_CALLDIR</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       reading %s XID %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RPC_REPLY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;reply for&quot;</span>
							      <span class="o">:</span> <span class="s">&quot;request with&quot;</span><span class="p">,</span>
			<span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">));</span>
	<span class="n">xs_tcp_check_fraghdr</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_tcp_read_calldir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want transport-&gt;tcp_offset to be 8 at the end of this routine</span>
<span class="cm">	 * (4 bytes for the xid and 4 bytes for the call/reply flag).</span>
<span class="cm">	 * When this function is called for the first time,</span>
<span class="cm">	 * transport-&gt;tcp_offset is 4 (after having already read the xid).</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_calldir</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       reading CALL/REPLY flag (%Zu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_calldir</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">xdr_skb_read_bits</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_READ_CALLDIR</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t yet have the XDR buffer, so we will write the calldir</span>
<span class="cm">	 * out after we get the buffer from the &#39;struct rpc_rqst&#39;</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_calldir</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RPC_REPLY</span>:
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_COPY_CALLDIR</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RPC_REPLY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RPC_CALL</span>:
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_COPY_CALLDIR</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RPC_REPLY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       invalid request message type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xprt_force_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xs_tcp_check_fraghdr</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_tcp_read_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">rcvbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">rcvbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_COPY_CALLDIR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Save the RPC direction in the XDR buffer</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">rcvbuf</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_calldir</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_calldir</span><span class="p">));</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_calldir</span><span class="p">);</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_CALLDIR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">-</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="n">my_desc</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">-</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_desc</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_desc</span><span class="p">));</span>
		<span class="n">my_desc</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">xdr_partial_copy_from_skb</span><span class="p">(</span><span class="n">rcvbuf</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">my_desc</span><span class="p">,</span> <span class="n">xdr_skb_read_bits</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">r</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">xdr_partial_copy_from_skb</span><span class="p">(</span><span class="n">rcvbuf</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">,</span>
					  <span class="n">desc</span><span class="p">,</span> <span class="n">xdr_skb_read_bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Error when copying to the receive buffer,</span>
<span class="cm">		 * usually because we weren&#39;t able to allocate</span>
<span class="cm">		 * additional buffer pages. All we can do now</span>
<span class="cm">		 * is turn off TCP_RCV_COPY_DATA, so the request</span>
<span class="cm">		 * will not receive any additional updates,</span>
<span class="cm">		 * and time out.</span>
<span class="cm">		 * Any remaining data from this record will</span>
<span class="cm">		 * be discarded.</span>
<span class="cm">		 */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       XID %08x truncated request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">));</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xprt = %p, tcp_copied = %lu, &quot;</span>
				<span class="s">&quot;tcp_offset = %u, tcp_reclen = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">,</span>
				<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       XID %08x read %Zd bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">),</span> <span class="n">r</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xprt = %p, tcp_copied = %lu, tcp_offset = %u, &quot;</span>
			<span class="s">&quot;tcp_reclen = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">,</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">.</span><span class="n">buflen</span><span class="p">)</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">==</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_LAST_FRAG</span><span class="p">)</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finds the request corresponding to the RPC xid and invokes the common</span>
<span class="cm"> * tcp read code to read the data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xs_tcp_read_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       read reply XID %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">));</span>

	<span class="cm">/* Find and lock the request corresponding to this xid */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">xprt_lookup_rqst</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       XID %08x request not found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntohl</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xs_tcp_read_common</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_COPY_DATA</span><span class="p">))</span>
		<span class="n">xprt_complete_rqst</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_task</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_SUNRPC_BACKCHANNEL)</span>
<span class="cm">/*</span>
<span class="cm"> * Obtains an rpc_rqst previously allocated and invokes the common</span>
<span class="cm"> * tcp read code to read the data.  The result is placed in the callback</span>
<span class="cm"> * queue.</span>
<span class="cm"> * If we&#39;re unable to obtain the rpc_rqst we schedule the closing of the</span>
<span class="cm"> * connection and return -1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xs_tcp_read_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">xprt_alloc_bc_request</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Callback slot table overflowed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xprt_force_disconnect</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xid</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_xid</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       read callback  XID %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xid</span><span class="p">));</span>
	<span class="n">xs_tcp_read_common</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_COPY_DATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">bc_serv</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bc_serv</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Add callback request to callback list.  The callback</span>
<span class="cm">		 * service sleeps on the sv_cb_waitq waiting for new</span>
<span class="cm">		 * requests.  Wake it up after adding enqueing the</span>
<span class="cm">		 * request.</span>
<span class="cm">		 */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       add callback request to list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_serv</span><span class="o">-&gt;</span><span class="n">sv_cb_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bc_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bc_serv</span><span class="o">-&gt;</span><span class="n">sv_cb_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_serv</span><span class="o">-&gt;</span><span class="n">sv_cb_lock</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_serv</span><span class="o">-&gt;</span><span class="n">sv_cb_waitq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_xs_tcp_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RPC_REPLY</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">xs_tcp_read_reply</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">xs_tcp_read_callback</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_xs_tcp_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xs_tcp_read_reply</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_BACKCHANNEL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Read data off the transport.  This can be either an RPC_CALL or an</span>
<span class="cm"> * RPC_REPLY.  Relay the processing to helper functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_xs_tcp_read_data</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xs_tcp_check_fraghdr</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The transport_lock protects the request handling.</span>
<span class="cm">		 * There&#39;s no need to hold it to update the tcp_flags.</span>
<span class="cm">		 */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_RCV_COPY_DATA</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_tcp_read_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">-</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       discarded %Zu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">xs_tcp_check_fraghdr</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_tcp_data_recv</span><span class="p">(</span><span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">rd_desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">rd_desc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xdr_skb_reader</span> <span class="n">desc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">skb</span>	<span class="o">=</span> <span class="n">skb</span><span class="p">,</span>
		<span class="p">.</span><span class="n">offset</span>	<span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">count</span>	<span class="o">=</span> <span class="n">len</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_tcp_data_recv started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Read in a new fragment marker if necessary */</span>
		<span class="cm">/* Can we ever really expect to get completely empty fragments? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_COPY_FRAGHDR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xs_tcp_read_fraghdr</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Read in the xid if necessary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_COPY_XID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xs_tcp_read_xid</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Read in the call/reply flag */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_READ_CALLDIR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xs_tcp_read_calldir</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Read in the request data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCP_RCV_COPY_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xs_tcp_read_data</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Skip over any trailing bytes on short reads */</span>
		<span class="n">xs_tcp_read_discard</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_tcp_data_recv done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">-</span> <span class="n">desc</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_data_ready - &quot;data ready&quot; callback for TCP sockets</span>
<span class="cm"> * @sk: socket with data to read</span>
<span class="cm"> * @bytes: how much data to read</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_data_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="n">read_descriptor_t</span> <span class="n">rd_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_tcp_data_ready...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Any data means we had a useful conversation, so</span>
<span class="cm">	 * the we don&#39;t need to delay the next reconnect</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span><span class="p">)</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We use rd_desc to pass struct xprt to xs_tcp_data_recv */</span>
	<span class="n">rd_desc</span><span class="p">.</span><span class="n">arg</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rd_desc</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
		<span class="n">read</span> <span class="o">=</span> <span class="n">tcp_read_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rd_desc</span><span class="p">,</span> <span class="n">xs_tcp_data_recv</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the equivalent of linger/linger2 handling for dealing with</span>
<span class="cm"> * broken servers that don&#39;t close the socket in a timely</span>
<span class="cm"> * fashion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_schedule_linger_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_test_and_set_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">rpciod_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
			   <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_cancel_linger_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">xprt_clear_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_sock_mark_closed</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CLOSE_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="cm">/* Mark transport as closed and wake up all pending tasks */</span>
	<span class="n">xprt_disconnect_done</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_state_change - callback to handle TCP socket state changes</span>
<span class="cm"> * @sk: socket whose state has changed</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_tcp_state_change client %p...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       state %x conn %d dead %d zapped %d sk_shutdown %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">,</span> <span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">),</span>
			<span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">),</span>
			<span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">),</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_ESTABLISHED</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt_test_and_set_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

			<span class="cm">/* Reset TCP record info */</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_reclen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span>
				<span class="n">TCP_RCV_COPY_FRAGHDR</span> <span class="o">|</span> <span class="n">TCP_RCV_COPY_XID</span><span class="p">;</span>

			<span class="n">xprt_wake_pending_tasks</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">transport_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_FIN_WAIT1</span>:
		<span class="cm">/* The client initiated a shutdown of the socket */</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">connect_cookie</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">XPRT_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CLOSE_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="n">xs_tcp_schedule_linger_timeout</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">xs_tcp_fin_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE_WAIT</span>:
		<span class="cm">/* The server initiated a shutdown of the socket */</span>
		<span class="n">xprt_force_disconnect</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">connect_cookie</span><span class="o">++</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CLOSING</span>:
		<span class="cm">/*</span>
<span class="cm">		 * If the server closed down the connection, make sure that</span>
<span class="cm">		 * we back off before reconnecting</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">&lt;</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">)</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_LAST_ACK</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">XPRT_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">xs_tcp_schedule_linger_timeout</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">xs_tcp_fin_timeout</span><span class="p">);</span>
		<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE</span>:
		<span class="n">xs_tcp_cancel_linger_timeout</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">xs_sock_mark_closed</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_error_report - callback mainly for catching socket errors</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_error_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s client %p...</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;RPC:       error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">);</span>
	<span class="n">xprt_wake_pending_tasks</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">))))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xprt_write_space</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_udp_write_space - callback invoked when socket buffer space</span>
<span class="cm"> *                             becomes available</span>
<span class="cm"> * @sk: socket whose state has changed</span>
<span class="cm"> *</span>
<span class="cm"> * Called when more output buffer space is available for this socket.</span>
<span class="cm"> * We try not to wake our writers until they can make &quot;significant&quot;</span>
<span class="cm"> * progress, otherwise we&#39;ll waste resources thrashing kernel_sendmsg</span>
<span class="cm"> * with a bunch of small requests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="cm">/* from net/core/sock.c:sock_def_write_space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">xs_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_write_space - callback invoked when socket buffer space</span>
<span class="cm"> *                             becomes available</span>
<span class="cm"> * @sk: socket whose state has changed</span>
<span class="cm"> *</span>
<span class="cm"> * Called when more output buffer space is available for this socket.</span>
<span class="cm"> * We try not to wake our writers until they can make &quot;significant&quot;</span>
<span class="cm"> * progress, otherwise we&#39;ll waste resources thrashing kernel_sendmsg</span>
<span class="cm"> * with a bunch of small requests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

	<span class="cm">/* from net/core/stream.c:sk_stream_write_space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_stream_wspace</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sk_stream_min_wspace</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">xs_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_do_set_buffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">rcvsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">|=</span> <span class="n">SOCK_RCVBUF_LOCK</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">rcvsize</span> <span class="o">*</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">max_reqs</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sndsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">|=</span> <span class="n">SOCK_SNDBUF_LOCK</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sndsize</span> <span class="o">*</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">max_reqs</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_udp_set_buffer_size - set send and receive limits</span>
<span class="cm"> * @xprt: generic transport</span>
<span class="cm"> * @sndsize: requested size of send buffer, in bytes</span>
<span class="cm"> * @rcvsize: requested size of receive buffer, in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Set socket send and receive buffer size limits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_set_buffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sndsize</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">rcvsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sndsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sndsize</span><span class="p">)</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sndsize</span> <span class="o">=</span> <span class="n">sndsize</span> <span class="o">+</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">rcvsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcvsize</span><span class="p">)</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">rcvsize</span> <span class="o">=</span> <span class="n">rcvsize</span> <span class="o">+</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="n">xs_udp_do_set_buffer_size</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_udp_timer - called when a retransmit timeout occurs on a UDP transport</span>
<span class="cm"> * @task: task that timed out</span>
<span class="cm"> *</span>
<span class="cm"> * Adjust the congestion window after a retransmit timeout has occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xprt_adjust_cwnd</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">xs_get_random_port</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">range</span> <span class="o">=</span> <span class="n">xprt_max_resvport</span> <span class="o">-</span> <span class="n">xprt_min_resvport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">rand</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="n">net_random</span><span class="p">()</span> <span class="o">%</span> <span class="n">range</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rand</span> <span class="o">+</span> <span class="n">xprt_min_resvport</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_set_port - reset the port number in the remote endpoint address</span>
<span class="cm"> * @xprt: generic transport</span>
<span class="cm"> * @port: new port number</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_set_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       setting port for xprt %p to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">rpc_set_port</span><span class="p">(</span><span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">),</span> <span class="n">port</span><span class="p">);</span>
	<span class="n">xs_update_peer_port</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">xs_get_srcport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">.</span><span class="n">resvport</span><span class="p">)</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">xs_get_random_port</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">xs_next_srcport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">.</span><span class="n">resvport</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;=</span> <span class="n">xprt_min_resvport</span> <span class="o">||</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="n">xprt_max_resvport</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xprt_max_resvport</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">--</span><span class="n">port</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">myaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">nloop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span> <span class="o">=</span> <span class="n">xs_get_srcport</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">last</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcaddr</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">.</span><span class="n">addrlen</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rpc_set_port</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myaddr</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">kernel_bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myaddr</span><span class="p">,</span>
				<span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">.</span><span class="n">addrlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">xs_next_srcport</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
			<span class="n">nloop</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EADDRINUSE</span> <span class="o">&amp;&amp;</span> <span class="n">nloop</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">myaddr</span><span class="p">.</span><span class="n">ss_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s %pI4:%u: %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myaddr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">,</span>
				<span class="n">port</span><span class="p">,</span> <span class="n">err</span> <span class="o">?</span> <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;ok&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s %pI6:%u: %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myaddr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">,</span>
				<span class="n">port</span><span class="p">,</span> <span class="n">err</span> <span class="o">?</span> <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;ok&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We don&#39;t support autobind on AF_LOCAL sockets</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_local_rpcbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_local_set_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">xs_key</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">xs_slock_key</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socketu</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sock_lock_init_class_and_name</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;slock-AF_LOCAL-RPC&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">xs_slock_key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;sk_lock-AF_LOCAL-RPC&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xs_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socket4</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sock_lock_init_class_and_name</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;slock-AF_INET-RPC&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">xs_slock_key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;sk_lock-AF_INET-RPC&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xs_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socket6</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sock_lock_init_class_and_name</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;slock-AF_INET6-RPC&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">xs_slock_key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;sk_lock-AF_INET6-RPC&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xs_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_LOCAL</span>:
		<span class="n">xs_reclassify_socketu</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">xs_reclassify_socket4</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">xs_reclassify_socket6</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socketu</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socket4</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socket6</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xs_reclassify_socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">xs_create_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__sock_create</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xprt_net</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       can&#39;t create %d transport socket (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">protocol</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xs_reclassify_socket</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xs_bind</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_local_finish_connecting</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span>
									<span class="n">xprt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

		<span class="n">xs_save_old_callbacks</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="n">xprt</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">xs_local_data_ready</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">xs_udp_write_space</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span> <span class="o">=</span> <span class="n">xs_error_report</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

		<span class="n">xprt_clear_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="cm">/* Reset to new socket */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>

		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the socket layer to start connecting... */</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kernel_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">),</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_local_setup_socket - create AF_LOCAL socket, connect to a local endpoint</span>
<span class="cm"> * @xprt: RPC transport to connect</span>
<span class="cm"> * @transport: socket transport to connect</span>
<span class="cm"> * @create_sock: function to create a socket of the correct type</span>
<span class="cm"> *</span>
<span class="cm"> * Invoked by a work queue tasklet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_local_setup_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">connect_worker</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">__sock_create</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xprt_net</span><span class="p">,</span> <span class="n">AF_LOCAL</span><span class="p">,</span>
					<span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       can&#39;t create AF_LOCAL &quot;</span>
			<span class="s">&quot;transport socket (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xs_reclassify_socketu</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       worker connecting xprt %p via AF_LOCAL to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">xs_local_finish_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xprt %p connected to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]);</span>
		<span class="n">xprt_set_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xprt %p: socket %s does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unhandled error (%d) connecting to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="o">-</span><span class="n">status</span><span class="p">,</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">xprt_clear_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xprt_wake_pending_tasks</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_finish_connecting</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

		<span class="n">xs_save_old_callbacks</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="n">xprt</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">xs_udp_data_ready</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">xs_udp_write_space</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span> <span class="o">=</span> <span class="n">xs_error_report</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span> <span class="o">=</span> <span class="n">UDP_CSUM_NORCV</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

		<span class="n">xprt_set_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="cm">/* Reset to new socket */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>

		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xs_udp_do_set_buffer_size</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_setup_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">connect_worker</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Start by resetting any existing state */</span>
	<span class="n">xs_reset_transport</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">xs_create_sock</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span>
			<span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">IPPROTO_UDP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       worker connecting xprt %p via %s to &quot;</span>
				<span class="s">&quot;%s (port %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">],</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">]);</span>

	<span class="n">xs_udp_finish_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">xprt_clear_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xprt_wake_pending_tasks</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to preserve the port number so the reply cache on the server can</span>
<span class="cm"> * find our cached RPC replies when we get around to reconnecting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_abort_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">any</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       disconnecting xprt %p to reuse port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">transport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disconnect the transport socket by doing a connect operation</span>
<span class="cm">	 * with AF_UNSPEC.  This should return immediately...</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">any</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">any</span><span class="p">));</span>
	<span class="n">any</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">kernel_connect</span><span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">any</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">any</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="n">xs_sock_mark_closed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       AF_UNSPEC connect return code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_reuse_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span> <span class="o">&amp;&amp;</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we don&#39;t need to abort the connection if the socket</span>
<span class="cm">		 * hasn&#39;t undergone a shutdown</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: TCP_CLOSEd and sk_shutdown set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_ESTABLISHED</span><span class="o">|</span><span class="n">TCPF_SYN_SENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we don&#39;t need to abort the connection if the socket</span>
<span class="cm">		 * hasn&#39;t undergone a shutdown</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: ESTABLISHED/SYN_SENT &quot;</span>
				<span class="s">&quot;sk_shutdown set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xs_abort_connection</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_tcp_finish_connecting</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>

		<span class="n">xs_save_old_callbacks</span><span class="p">(</span><span class="n">transport</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_user_data</span> <span class="o">=</span> <span class="n">xprt</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span> <span class="o">=</span> <span class="n">xs_tcp_data_ready</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span> <span class="o">=</span> <span class="n">xs_tcp_state_change</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">xs_tcp_write_space</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span> <span class="o">=</span> <span class="n">xs_error_report</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

		<span class="cm">/* socket options */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">|=</span> <span class="n">SOCK_BINDPORT_LOCK</span><span class="p">;</span>
		<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">);</span>
		<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">|=</span> <span class="n">TCP_NAGLE_OFF</span><span class="p">;</span>

		<span class="n">xprt_clear_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="cm">/* Reset to new socket */</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
		<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>

		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Tell the socket layer to start connecting... */</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kernel_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">),</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">,</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
		<span class="cm">/* SYN_SENT! */</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">connect_cookie</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">&lt;</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">)</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_setup_socket - create a TCP socket and connect to a remote endpoint</span>
<span class="cm"> * @xprt: RPC transport to connect</span>
<span class="cm"> * @transport: socket transport to connect</span>
<span class="cm"> * @create_sock: function to create a socket of the correct type</span>
<span class="cm"> *</span>
<span class="cm"> * Invoked by a work queue tasklet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_setup_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">connect_worker</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">sock</span> <span class="o">=</span> <span class="n">xs_create_sock</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span>
				<span class="n">xs_addr</span><span class="p">(</span><span class="n">xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">abort_and_exit</span><span class="p">;</span>

		<span class="n">abort_and_exit</span> <span class="o">=</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_ABORT</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="cm">/* &quot;close&quot; the socket, preserving the local port */</span>
		<span class="n">xs_tcp_reuse_connection</span><span class="p">(</span><span class="n">transport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">abort_and_exit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_eagain</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       worker connecting xprt %p via %s to &quot;</span>
				<span class="s">&quot;%s (port %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">],</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">]);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">xs_tcp_finish_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %p connect status %d connected %d sock state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="p">,</span> <span class="o">-</span><span class="n">status</span><span class="p">,</span> <span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">),</span>
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: connect returned unhandled error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span>:
		<span class="cm">/* We&#39;re probably in TIME_WAIT. Get rid of existing socket,</span>
<span class="cm">		 * and retry</span>
<span class="cm">		 */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">XPRT_CONNECTION_CLOSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">xprt_force_disconnect</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
		<span class="cm">/* retry with existing socket, after a delay */</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EALREADY</span>:
		<span class="n">xprt_clear_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
		<span class="cm">/* Happens, for instance, if the user specified a link</span>
<span class="cm">		 * local IPv6 address without a scope-id.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_eagain:</span>
	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">xprt_clear_connecting</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xprt_wake_pending_tasks</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_connect - connect a socket to a remote endpoint</span>
<span class="cm"> * @task: address of RPC task that manages state of connect request</span>
<span class="cm"> *</span>
<span class="cm"> * TCP: If the remote end dropped the connection, delay reconnecting.</span>
<span class="cm"> *</span>
<span class="cm"> * UDP socket connects are synchronous, but we use a work queue anyway</span>
<span class="cm"> * to guarantee that even unprivileged user processes can set up a</span>
<span class="cm"> * socket on a privileged port.</span>
<span class="cm"> *</span>
<span class="cm"> * If a UDP socket connect fails, the delay behavior here prevents</span>
<span class="cm"> * retry floods (hard mounts).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">RPC_IS_SOFTCONN</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_connect delayed xprt %p for %lu &quot;</span>
				<span class="s">&quot;seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">rpciod_workqueue</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
				   <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span><span class="p">);</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">&lt;</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">)</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">&gt;</span> <span class="n">XS_TCP_MAX_REEST_TO</span><span class="p">)</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_TCP_MAX_REEST_TO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_connect scheduled xprt %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">rpciod_workqueue</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_local_print_stats - display AF_LOCAL socket-specifc stats</span>
<span class="cm"> * @xprt: rpc_xprt struct containing statistics</span>
<span class="cm"> * @seq: output file</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_local_print_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">idle_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="n">idle_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">last_used</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xprt:</span><span class="se">\t</span><span class="s">local %lu %lu %lu %ld %lu %lu %lu &quot;</span>
			<span class="s">&quot;%llu %llu %lu %llu %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bind_count</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_count</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_time</span><span class="p">,</span>
			<span class="n">idle_time</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sends</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">recvs</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bad_xids</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">req_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bklog_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">max_slots</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sending_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pending_u</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_udp_print_stats - display UDP socket-specifc stats</span>
<span class="cm"> * @xprt: rpc_xprt struct containing statistics</span>
<span class="cm"> * @seq: output file</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_udp_print_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xprt:</span><span class="se">\t</span><span class="s">udp %u %lu %lu %lu %lu %llu %llu &quot;</span>
			<span class="s">&quot;%lu %llu %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bind_count</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sends</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">recvs</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bad_xids</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">req_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bklog_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">max_slots</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sending_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pending_u</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_tcp_print_stats - display TCP socket-specifc stats</span>
<span class="cm"> * @xprt: rpc_xprt struct containing statistics</span>
<span class="cm"> * @seq: output file</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xs_tcp_print_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">idle_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="n">idle_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">last_used</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xprt:</span><span class="se">\t</span><span class="s">tcp %u %lu %lu %lu %ld %lu %lu %lu &quot;</span>
			<span class="s">&quot;%llu %llu %lu %llu %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">transport</span><span class="o">-&gt;</span><span class="n">srcport</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bind_count</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_count</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">connect_time</span><span class="p">,</span>
			<span class="n">idle_time</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sends</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">recvs</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bad_xids</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">req_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">bklog_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">max_slots</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sending_u</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pending_u</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a bunch of pages for a scratch buffer for the rpc code. The reason</span>
<span class="cm"> * we allocate pages instead doing a kmalloc like rpc_malloc is because we want</span>
<span class="cm"> * to use the server side send routines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">bc_malloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_buffer</span><span class="p">));</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free the space allocated in the bc_alloc routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bc_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_buffer</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use the svc_sock to send the callback. Must be called with svsk-&gt;sk_mutex</span>
<span class="cm"> * held. Borrows heavily from svc_tcp_sendto and xs_tcp_send_request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bc_sendto</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xbufp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">headoff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tailoff</span><span class="p">;</span>

	<span class="n">xs_encode_stream_record_marker</span><span class="p">(</span><span class="n">xbufp</span><span class="p">);</span>

	<span class="n">tailoff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">headoff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">svc_send_common</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">xbufp</span><span class="p">,</span>
			      <span class="n">virt_to_page</span><span class="p">(</span><span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">),</span> <span class="n">headoff</span><span class="p">,</span>
			      <span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">tailoff</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Error sending entire callback!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The send routine. Borrows from svc_send</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bc_send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span>	<span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_sock</span>         <span class="o">*</span><span class="n">svsk</span><span class="p">;</span>
	<span class="n">u32</span>                     <span class="n">len</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;sending request with xid: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xid</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the server socket associated with this callback xprt</span>
<span class="cm">	 */</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="p">;</span>
	<span class="n">svsk</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_sock</span><span class="p">,</span> <span class="n">sk_xprt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab the mutex to serialize data as the connection is shared</span>
<span class="cm">	 * with the fore channel</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rpc_sleep_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_bc_pending</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_mutex</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">rpc_wake_up_queued_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_bc_pending</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XPT_DEAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_flags</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">bc_sendto</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xpt_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The close routine. Since this is client initiated, we do nothing</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The xprt destroy routine. Again, because this connection is client</span>
<span class="cm"> * initiated, we do nothing</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bc_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt_ops</span> <span class="n">xs_local_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">reserve_xprt</span>		<span class="o">=</span> <span class="n">xprt_reserve_xprt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_xprt</span>		<span class="o">=</span> <span class="n">xs_tcp_release_xprt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rpcbind</span>		<span class="o">=</span> <span class="n">xs_local_rpcbind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_port</span>		<span class="o">=</span> <span class="n">xs_local_set_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>		<span class="o">=</span> <span class="n">xs_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_alloc</span>		<span class="o">=</span> <span class="n">rpc_malloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_free</span>		<span class="o">=</span> <span class="n">rpc_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_request</span>		<span class="o">=</span> <span class="n">xs_local_send_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_retrans_timeout</span>	<span class="o">=</span> <span class="n">xprt_set_retrans_timeout_def</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>			<span class="o">=</span> <span class="n">xs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>		<span class="o">=</span> <span class="n">xs_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">print_stats</span>		<span class="o">=</span> <span class="n">xs_local_print_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt_ops</span> <span class="n">xs_udp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set_buffer_size</span>	<span class="o">=</span> <span class="n">xs_udp_set_buffer_size</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reserve_xprt</span>		<span class="o">=</span> <span class="n">xprt_reserve_xprt_cong</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_xprt</span>		<span class="o">=</span> <span class="n">xprt_release_xprt_cong</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rpcbind</span>		<span class="o">=</span> <span class="n">rpcb_getport_async</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_port</span>		<span class="o">=</span> <span class="n">xs_set_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>		<span class="o">=</span> <span class="n">xs_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_alloc</span>		<span class="o">=</span> <span class="n">rpc_malloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_free</span>		<span class="o">=</span> <span class="n">rpc_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_request</span>		<span class="o">=</span> <span class="n">xs_udp_send_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_retrans_timeout</span>	<span class="o">=</span> <span class="n">xprt_set_retrans_timeout_rtt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">timer</span>			<span class="o">=</span> <span class="n">xs_udp_timer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_request</span>	<span class="o">=</span> <span class="n">xprt_release_rqst_cong</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>			<span class="o">=</span> <span class="n">xs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>		<span class="o">=</span> <span class="n">xs_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">print_stats</span>		<span class="o">=</span> <span class="n">xs_udp_print_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt_ops</span> <span class="n">xs_tcp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">reserve_xprt</span>		<span class="o">=</span> <span class="n">xprt_reserve_xprt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_xprt</span>		<span class="o">=</span> <span class="n">xs_tcp_release_xprt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rpcbind</span>		<span class="o">=</span> <span class="n">rpcb_getport_async</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_port</span>		<span class="o">=</span> <span class="n">xs_set_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>		<span class="o">=</span> <span class="n">xs_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_alloc</span>		<span class="o">=</span> <span class="n">rpc_malloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_free</span>		<span class="o">=</span> <span class="n">rpc_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_request</span>		<span class="o">=</span> <span class="n">xs_tcp_send_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_retrans_timeout</span>	<span class="o">=</span> <span class="n">xprt_set_retrans_timeout_def</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>			<span class="o">=</span> <span class="n">xs_tcp_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>		<span class="o">=</span> <span class="n">xs_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">print_stats</span>		<span class="o">=</span> <span class="n">xs_tcp_print_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The rpc_xprt_ops for the server backchannel</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt_ops</span> <span class="n">bc_tcp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">reserve_xprt</span>		<span class="o">=</span> <span class="n">xprt_reserve_xprt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_xprt</span>		<span class="o">=</span> <span class="n">xprt_release_xprt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rpcbind</span>		<span class="o">=</span> <span class="n">xs_local_rpcbind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_alloc</span>		<span class="o">=</span> <span class="n">bc_malloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_free</span>		<span class="o">=</span> <span class="n">bc_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_request</span>		<span class="o">=</span> <span class="n">bc_send_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_retrans_timeout</span>	<span class="o">=</span> <span class="n">xprt_set_retrans_timeout_def</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>			<span class="o">=</span> <span class="n">bc_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>		<span class="o">=</span> <span class="n">bc_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">print_stats</span>		<span class="o">=</span> <span class="n">xs_tcp_print_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xs_init_anyaddr</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sin_family</span>		<span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span>	<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="n">sin6</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sin6_family</span>		<span class="o">=</span> <span class="n">AF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sin6_addr</span>		<span class="o">=</span> <span class="n">IN6ADDR_ANY_INIT</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_LOCAL</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin6</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin6</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: Bad address family</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="nf">xs_setup_xprt</span><span class="p">(</span><span class="k">struct</span> <span class="n">xprt_create</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot_table_size</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_slot_table_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_setup_xprt: address too large</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_alloc</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">),</span> <span class="n">slot_table_size</span><span class="p">,</span>
			<span class="n">max_slot_table_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       xs_setup_xprt: couldn&#39;t allocate &quot;</span>
				<span class="s">&quot;rpc_xprt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">);</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addrlen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">srcaddr</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">srcaddr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">srcaddr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">xs_init_anyaddr</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">srcaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xprt_free</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_timeout</span> <span class="n">xs_local_default_timeout</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">to_initval</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_maxval</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_retries</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * xs_setup_local - Set up transport to use an AF_LOCAL socket</span>
<span class="cm"> * @args: rpc transport creation arguments</span>
<span class="cm"> *</span>
<span class="cm"> * AF_LOCAL is a &quot;tpi_cots_ord&quot; transport, just like TCP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="nf">xs_setup_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">xprt_create</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sun</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xs_setup_xprt</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xprt_tcp_slot_table_entries</span><span class="p">,</span>
			<span class="n">xprt_max_tcp_slot_table_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">tsh_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">max_payload</span> <span class="o">=</span> <span class="n">RPC_MAX_FRAGMENT_SIZE</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bind_timeout</span> <span class="o">=</span> <span class="n">XS_BIND_TO</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">idle_timeout</span> <span class="o">=</span> <span class="n">XS_IDLE_DISC_TO</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_local_ops</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_local_default_timeout</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sun</span><span class="o">-&gt;</span><span class="n">sun_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_LOCAL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sun</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       bad AF_LOCAL address: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sun</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
					<span class="n">xs_local_setup_socket</span><span class="p">);</span>
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;local&quot;</span><span class="p">,</span> <span class="n">RPCBIND_NETID_LOCAL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       set up xprt to %s via AF_LOCAL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">xprt_free</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_timeout</span> <span class="n">xs_udp_default_timeout</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">to_initval</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_maxval</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_increment</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_retries</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * xs_setup_udp - Set up transport to use a UDP socket</span>
<span class="cm"> * @args: rpc transport creation arguments</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="nf">xs_setup_udp</span><span class="p">(</span><span class="k">struct</span> <span class="n">xprt_create</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xs_setup_xprt</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xprt_udp_slot_table_entries</span><span class="p">,</span>
			<span class="n">xprt_udp_slot_table_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">tsh_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* XXX: header size can vary due to auth type, IPv6, etc. */</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">max_payload</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">MAX_HEADER</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bind_timeout</span> <span class="o">=</span> <span class="n">XS_BIND_TO</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_UDP_REEST_TO</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">idle_timeout</span> <span class="o">=</span> <span class="n">XS_IDLE_DISC_TO</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_udp_ops</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_udp_default_timeout</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_port</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
					<span class="n">xs_udp_setup_socket</span><span class="p">);</span>
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;udp&quot;</span><span class="p">,</span> <span class="n">RPCBIND_NETID_UDP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin6_port</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
					<span class="n">xs_udp_setup_socket</span><span class="p">);</span>
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;udp&quot;</span><span class="p">,</span> <span class="n">RPCBIND_NETID_UDP6</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       set up xprt to %s (port %s) via %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">],</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       set up xprt to %s (autobind) via %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">xprt_free</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_timeout</span> <span class="n">xs_tcp_default_timeout</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">to_initval</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_maxval</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">to_retries</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * xs_setup_tcp - Set up transport to use a TCP socket</span>
<span class="cm"> * @args: rpc transport creation arguments</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="nf">xs_setup_tcp</span><span class="p">(</span><span class="k">struct</span> <span class="n">xprt_create</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xs_setup_xprt</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xprt_tcp_slot_table_entries</span><span class="p">,</span>
			<span class="n">xprt_max_tcp_slot_table_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">tsh_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">max_payload</span> <span class="o">=</span> <span class="n">RPC_MAX_FRAGMENT_SIZE</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bind_timeout</span> <span class="o">=</span> <span class="n">XS_BIND_TO</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="n">XS_TCP_INIT_REEST_TO</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">idle_timeout</span> <span class="o">=</span> <span class="n">XS_IDLE_DISC_TO</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_tcp_ops</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_tcp_default_timeout</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_port</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
					<span class="n">xs_tcp_setup_socket</span><span class="p">);</span>
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="n">RPCBIND_NETID_TCP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin6_port</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>

		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">connect_worker</span><span class="p">,</span>
					<span class="n">xs_tcp_setup_socket</span><span class="p">);</span>
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="n">RPCBIND_NETID_TCP6</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       set up xprt to %s (port %s) via %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">],</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       set up xprt to %s (autobind) via %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
				<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">]);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">xprt_free</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * xs_setup_bc_tcp - Set up transport to use a TCP backchannel socket</span>
<span class="cm"> * @args: rpc transport creation arguments</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="nf">xs_setup_bc_tcp</span><span class="p">(</span><span class="k">struct</span> <span class="n">xprt_create</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_xprt</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_sock</span> <span class="o">*</span><span class="n">bc_sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="o">-&gt;</span><span class="n">xpt_bc_xprt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This server connection already has a backchannel</span>
<span class="cm">		 * export; we can&#39;t create a new one, as we wouldn&#39;t be</span>
<span class="cm">		 * able to match replies based on xid any more.  So,</span>
<span class="cm">		 * reuse the already-existing one:</span>
<span class="cm">		 */</span>
		 <span class="k">return</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="o">-&gt;</span><span class="n">xpt_bc_xprt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xs_setup_xprt</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xprt_tcp_slot_table_entries</span><span class="p">,</span>
			<span class="n">xprt_tcp_slot_table_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">transport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">prot</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">tsh_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_fraghdr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">max_payload</span> <span class="o">=</span> <span class="n">RPC_MAX_FRAGMENT_SIZE</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs_tcp_default_timeout</span><span class="p">;</span>

	<span class="cm">/* backchannel */</span>
	<span class="n">xprt_set_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bind_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">reestablish_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">idle_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bc_tcp_ops</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span>
					 <span class="n">RPCBIND_NETID_TCP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">xs_format_peer_addresses</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span>
				   <span class="n">RPCBIND_NETID_TCP6</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       set up xprt to %s (port %s) via %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_ADDR</span><span class="p">],</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PORT</span><span class="p">],</span>
			<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">RPC_DISPLAY_PROTO</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once we&#39;ve associated a backchannel xprt with a connection,</span>
<span class="cm">	 * we want to keep it around as long as long as the connection</span>
<span class="cm">	 * lasts, in case we need to start using it for a backchannel</span>
<span class="cm">	 * again; this reference won&#39;t be dropped until bc_xprt is</span>
<span class="cm">	 * destroyed.</span>
<span class="cm">	 */</span>
	<span class="n">xprt_get</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="o">-&gt;</span><span class="n">xpt_bc_xprt</span> <span class="o">=</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bc_xprt</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="p">;</span>
	<span class="n">bc_sock</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_sock</span><span class="p">,</span> <span class="n">sk_xprt</span><span class="p">);</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">bc_sock</span><span class="o">-&gt;</span><span class="n">sk_sock</span><span class="p">;</span>
	<span class="n">transport</span><span class="o">-&gt;</span><span class="n">inet</span> <span class="o">=</span> <span class="n">bc_sock</span><span class="o">-&gt;</span><span class="n">sk_sk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we don&#39;t want connections for the backchannel, we set</span>
<span class="cm">	 * the xprt status to connected</span>
<span class="cm">	 */</span>
	<span class="n">xprt_set_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="p">;</span>
	<span class="n">xprt_put</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">xprt_free</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xprt_class</span>	<span class="n">xs_local_transport</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">list</span>		<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">xs_local_transport</span><span class="p">.</span><span class="n">list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;named UNIX socket&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ident</span>		<span class="o">=</span> <span class="n">XPRT_TRANSPORT_LOCAL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">xs_setup_local</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xprt_class</span>	<span class="n">xs_udp_transport</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">list</span>		<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">xs_udp_transport</span><span class="p">.</span><span class="n">list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;udp&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ident</span>		<span class="o">=</span> <span class="n">XPRT_TRANSPORT_UDP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">xs_setup_udp</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xprt_class</span>	<span class="n">xs_tcp_transport</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">list</span>		<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">xs_tcp_transport</span><span class="p">.</span><span class="n">list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ident</span>		<span class="o">=</span> <span class="n">XPRT_TRANSPORT_TCP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">xs_setup_tcp</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xprt_class</span>	<span class="n">xs_bc_tcp_transport</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">list</span>		<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">xs_bc_tcp_transport</span><span class="p">.</span><span class="n">list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;tcp NFSv4.1 backchannel&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ident</span>		<span class="o">=</span> <span class="n">XPRT_TRANSPORT_BC_TCP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">xs_setup_bc_tcp</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * init_socket_xprt - set up xprtsock&#39;s sysctls, register with RPC client</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">init_socket_xprt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef RPC_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sunrpc_table_header</span><span class="p">)</span>
		<span class="n">sunrpc_table_header</span> <span class="o">=</span> <span class="n">register_sysctl_table</span><span class="p">(</span><span class="n">sunrpc_table</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">xprt_register_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_local_transport</span><span class="p">);</span>
	<span class="n">xprt_register_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_udp_transport</span><span class="p">);</span>
	<span class="n">xprt_register_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_tcp_transport</span><span class="p">);</span>
	<span class="n">xprt_register_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_bc_tcp_transport</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cleanup_socket_xprt - remove xprtsock&#39;s sysctls, unregister</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cleanup_socket_xprt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef RPC_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sunrpc_table_header</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_sysctl_table</span><span class="p">(</span><span class="n">sunrpc_table_header</span><span class="p">);</span>
		<span class="n">sunrpc_table_header</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">xprt_unregister_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_local_transport</span><span class="p">);</span>
	<span class="n">xprt_unregister_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_udp_transport</span><span class="p">);</span>
	<span class="n">xprt_unregister_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_tcp_transport</span><span class="p">);</span>
	<span class="n">xprt_unregister_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs_bc_tcp_transport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">param_set_uint_minmax</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">||</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="o">||</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">param_set_portnr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">param_set_uint_minmax</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span>
			<span class="n">RPC_MIN_RESVPORT</span><span class="p">,</span>
			<span class="n">RPC_MAX_RESVPORT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_portnr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set</span> <span class="o">=</span> <span class="n">param_set_portnr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">param_get_uint</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define param_check_portnr(name, p) \</span>
<span class="cp">	__param_check(name, p, unsigned int);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">min_resvport</span><span class="p">,</span> <span class="n">xprt_min_resvport</span><span class="p">,</span> <span class="n">portnr</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">max_resvport</span><span class="p">,</span> <span class="n">xprt_max_resvport</span><span class="p">,</span> <span class="n">portnr</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">param_set_slot_table_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">param_set_uint_minmax</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span>
			<span class="n">RPC_MIN_SLOT_TABLE</span><span class="p">,</span>
			<span class="n">RPC_MAX_SLOT_TABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_slot_table_size</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set</span> <span class="o">=</span> <span class="n">param_set_slot_table_size</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">param_get_uint</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define param_check_slot_table_size(name, p) \</span>
<span class="cp">	__param_check(name, p, unsigned int);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">param_set_max_slot_table_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">param_set_uint_minmax</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span>
			<span class="n">RPC_MIN_SLOT_TABLE</span><span class="p">,</span>
			<span class="n">RPC_MAX_SLOT_TABLE_LIMIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_max_slot_table_size</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set</span> <span class="o">=</span> <span class="n">param_set_max_slot_table_size</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">param_get_uint</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define param_check_max_slot_table_size(name, p) \</span>
<span class="cp">	__param_check(name, p, unsigned int);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">tcp_slot_table_entries</span><span class="p">,</span> <span class="n">xprt_tcp_slot_table_entries</span><span class="p">,</span>
		   <span class="n">slot_table_size</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">tcp_max_slot_table_entries</span><span class="p">,</span> <span class="n">xprt_max_tcp_slot_table_entries</span><span class="p">,</span>
		   <span class="n">max_slot_table_size</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">udp_slot_table_entries</span><span class="p">,</span> <span class="n">xprt_udp_slot_table_entries</span><span class="p">,</span>
		   <span class="n">slot_table_size</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
