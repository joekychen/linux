<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sunrpc › clnt.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clnt.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/net/sunrpc/clnt.c</span>
<span class="cm"> *</span>
<span class="cm"> *  This file contains the high-level RPC interface.</span>
<span class="cm"> *  It is modeled as a finite state machine to support both synchronous</span>
<span class="cm"> *  and asynchronous requests.</span>
<span class="cm"> *</span>
<span class="cm"> *  -	RPC header generation and argument serialization.</span>
<span class="cm"> *  -	Credential refresh.</span>
<span class="cm"> *  -	TCP connect handling.</span>
<span class="cm"> *  -	Retry of operation when it is suspected the operation failed because</span>
<span class="cm"> *	of uid squashing on the server, or when the credentials were stale</span>
<span class="cm"> *	and need to be refreshed, or when a packet was damaged in transit.</span>
<span class="cm"> *	This may be have to be moved to the VFS layer.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1992,1993 Rick Sladkey &lt;jrs@world.std.com&gt;</span>
<span class="cm"> *  Copyright (C) 1995,1996 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/un.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/rpc_pipe_fs.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/metrics.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/bc_xprt.h&gt;</span>
<span class="cp">#include &lt;trace/events/sunrpc.h&gt;</span>

<span class="cp">#include &quot;sunrpc.h&quot;</span>
<span class="cp">#include &quot;netns.h&quot;</span>

<span class="cp">#ifdef RPC_DEBUG</span>
<span class="cp"># define RPCDBG_FACILITY	RPCDBG_CALL</span>
<span class="cp">#endif</span>

<span class="cp">#define dprint_status(t)					\</span>
<span class="cp">	dprintk(&quot;RPC: %5u %s (status %d)\n&quot;, t-&gt;tk_pid,		\</span>
<span class="cp">			__func__, t-&gt;tk_status)</span>

<span class="cm">/*</span>
<span class="cm"> * All RPC clients are linked into this list</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">destroy_wait</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_reserveresult</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_bind_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_SUNRPC_BACKCHANNEL)</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_bc_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_BACKCHANNEL */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_transmit_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_refresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_refreshresult</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>	<span class="n">call_connect_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__be32</span>	<span class="o">*</span><span class="n">rpc_encode_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="n">__be32</span>	<span class="o">*</span><span class="n">rpc_verify_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">rpc_ping</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpc_register_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">rpc_net_ns</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sunrpc_net</span> <span class="o">*</span><span class="n">sn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunrpc_net_id</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_clients</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">all_clients</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpc_unregister_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">rpc_net_ns</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sunrpc_net</span> <span class="o">*</span><span class="n">sn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunrpc_net_id</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_clients</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span> <span class="o">&amp;&amp;</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="o">-&gt;</span><span class="n">au_ops</span><span class="o">-&gt;</span><span class="n">pipes_destroy</span><span class="p">)</span>
			<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="o">-&gt;</span><span class="n">au_ops</span><span class="o">-&gt;</span><span class="n">pipes_destroy</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="p">);</span>
		<span class="n">rpc_remove_client_dir</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">rpc_net_ns</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">pipefs_sb</span><span class="p">;</span>

	<span class="n">pipefs_sb</span> <span class="o">=</span> <span class="n">rpc_get_sb_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipefs_sb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="n">rpc_put_sb_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">rpc_setup_pipedir_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dir_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">clntid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">q</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">rpc_d_lookup_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dir</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">q</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;clnt%x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">clntid</span><span class="o">++</span><span class="p">);</span>
		<span class="n">name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">q</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">rpc_create_client_dir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">clnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;RPC: Couldn&#39;t create pipefs entry&quot;</span>
					<span class="s">&quot; %s/%s, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dir_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rpc_setup_pipedir</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dir_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">rpc_net_ns</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">pipefs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pipefs_sb</span> <span class="o">=</span> <span class="n">rpc_get_sb_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipefs_sb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">rpc_setup_pipedir_sb</span><span class="p">(</span><span class="n">pipefs_sb</span><span class="p">,</span> <span class="n">clnt</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">);</span>
	<span class="n">rpc_put_sb_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rpc_clnt_skip_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">event</span> <span class="o">==</span> <span class="n">RPC_PIPEFS_MOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">event</span> <span class="o">==</span> <span class="n">RPC_PIPEFS_UMOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rpc_clnt_handle_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RPC_PIPEFS_MOUNT</span>:
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">rpc_setup_pipedir_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">clnt</span><span class="p">,</span>
					      <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_program</span><span class="o">-&gt;</span><span class="n">pipe_dir_name</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dentry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="o">-&gt;</span><span class="n">au_ops</span><span class="o">-&gt;</span><span class="n">pipes_create</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="o">-&gt;</span><span class="n">au_ops</span><span class="o">-&gt;</span><span class="n">pipes_create</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="n">__rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RPC_PIPEFS_UMOUNT</span>:
		<span class="n">__rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unknown event: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rpc_pipefs_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;</span> <span class="n">clnt</span> <span class="o">=</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rpc_clnt_skip_event</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">__rpc_clnt_handle_event</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">clnt</span> <span class="o">==</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_parent</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="nf">rpc_get_client_for_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sunrpc_net</span> <span class="o">*</span><span class="n">sn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunrpc_net_id</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">all_clients</span><span class="p">,</span> <span class="n">cl_clients</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_program</span><span class="o">-&gt;</span><span class="n">pipe_dir_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rpc_clnt_skip_event</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">clnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpc_pipefs_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">rpc_get_client_for_event</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">,</span> <span class="n">event</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">__rpc_pipefs_event</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
		<span class="n">rpc_release_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">rpc_clients_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">rpc_pipefs_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">SUNRPC_PIPEFS_RPC_PRIO</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">rpc_clients_notifier_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rpc_pipefs_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpc_clients_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rpc_clients_notifier_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rpc_pipefs_notifier_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpc_clients_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpc_clnt_set_nodename</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nodename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_nodelen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">nodename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_nodelen</span> <span class="o">&gt;</span> <span class="n">UNX_MAXNODENAME</span><span class="p">)</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_nodelen</span> <span class="o">=</span> <span class="n">UNX_MAXNODENAME</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_nodename</span><span class="p">,</span> <span class="n">nodename</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_nodelen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span> <span class="nf">rpc_new_client</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_create_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_program</span> <span class="o">*</span><span class="n">program</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">program</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>		<span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_auth</span>		<span class="o">*</span><span class="n">auth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* sanity check the name before trying to print it */</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       creating %s client for %s (xprt %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">program</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rpciod_up</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_rpciod</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_xprt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">nrvers</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">clnt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">clnt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_parent</span> <span class="o">=</span> <span class="n">clnt</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_procinfo</span> <span class="o">=</span> <span class="n">version</span><span class="o">-&gt;</span><span class="n">procs</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_maxproc</span>  <span class="o">=</span> <span class="n">version</span><span class="o">-&gt;</span><span class="n">nrprocs</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span> <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_prog</span>     <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prognumber</span> <span class="o">?</span> <span class="o">:</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span>     <span class="o">=</span> <span class="n">version</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span>    <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_metrics</span>  <span class="o">=</span> <span class="n">rpc_alloc_iostats</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_metrics</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_stats</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_program</span>  <span class="o">=</span> <span class="n">program</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_autobind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout_default</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout_default</span><span class="p">));</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout_default</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_rtt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_rtt_default</span><span class="p">;</span>
	<span class="n">rpc_init_rtt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_rtt_default</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout</span><span class="o">-&gt;</span><span class="n">to_initval</span><span class="p">);</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">client_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">client_name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_no_principal</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rpc_setup_pipedir</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">pipe_dir_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_path</span><span class="p">;</span>

	<span class="n">auth</span> <span class="o">=</span> <span class="n">rpcauth_create</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">authflavor</span><span class="p">,</span> <span class="n">clnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">auth</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;RPC: Couldn&#39;t create auth handle (flavor %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">authflavor</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">auth</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_auth</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save the nodename */</span>
	<span class="n">rpc_clnt_set_nodename</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">);</span>
	<span class="n">rpc_register_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">clnt</span><span class="p">;</span>

<span class="nl">out_no_auth:</span>
	<span class="n">rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
<span class="nl">out_no_path:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span><span class="p">);</span>
<span class="nl">out_no_principal:</span>
	<span class="n">rpc_free_iostats</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_metrics</span><span class="p">);</span>
<span class="nl">out_no_stats:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">xprt_put</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="nl">out_no_xprt:</span>
	<span class="n">rpciod_down</span><span class="p">();</span>
<span class="nl">out_no_rpciod:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rpc_create - create an RPC client and transport with one call</span>
<span class="cm"> * @args: rpc_clnt create argument structure</span>
<span class="cm"> *</span>
<span class="cm"> * Creates and initializes an RPC transport and an RPC client.</span>
<span class="cm"> *</span>
<span class="cm"> * It can ping the server in order to determine if it is up, and to see if</span>
<span class="cm"> * it supports this program and version.  RPC_CLNT_CREATE_NOPING disables</span>
<span class="cm"> * this behavior so asynchronous tasks can also use rpc_create.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="nf">rpc_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_create_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xprt_create</span> <span class="n">xprtargs</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">,</span>
		<span class="p">.</span><span class="n">srcaddr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">saddress</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dstaddr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
		<span class="p">.</span><span class="n">addrlen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">addrsize</span><span class="p">,</span>
		<span class="p">.</span><span class="n">servername</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bc_xprt</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">bc_xprt</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">char</span> <span class="n">servername</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the caller chooses not to specify a hostname, whip</span>
<span class="cm">	 * up a string representation of the passed-in address.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprtargs</span><span class="p">.</span><span class="n">servername</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sun</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sin6</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>

		<span class="n">servername</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AF_LOCAL</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">servername</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servername</span><span class="p">),</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				 <span class="n">sun</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AF_INET</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">servername</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servername</span><span class="p">),</span> <span class="s">&quot;%pI4&quot;</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AF_INET6</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">servername</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servername</span><span class="p">),</span> <span class="s">&quot;%pI6&quot;</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* caller wants default server name, but</span>
<span class="cm">			 * address family isn&#39;t recognized. */</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xprtargs</span><span class="p">.</span><span class="n">servername</span> <span class="o">=</span> <span class="n">servername</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_create_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xprtargs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="p">)</span><span class="n">xprt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * By default, kernel RPC client connects from a reserved port.</span>
<span class="cm">	 * CAP_NET_BIND_SERVICE will not be set for unprivileged requesters,</span>
<span class="cm">	 * but it is always enabled for rpciod, which handles the connect</span>
<span class="cm">	 * operation.</span>
<span class="cm">	 */</span>
	<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">resvport</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_CLNT_CREATE_NONPRIVPORT</span><span class="p">)</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">resvport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clnt</span> <span class="o">=</span> <span class="n">rpc_new_client</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">clnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">clnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_CLNT_CREATE_NOPING</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">rpc_ping</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rpc_shutdown_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_softrtry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_CLNT_CREATE_HARDRTRY</span><span class="p">)</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_softrtry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_CLNT_CREATE_AUTOBIND</span><span class="p">)</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_autobind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_CLNT_CREATE_DISCRTRY</span><span class="p">)</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_discrtry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_CLNT_CREATE_QUIET</span><span class="p">))</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_chatty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_create</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This function clones the RPC client structure. It allows us to share the</span>
<span class="cm"> * same transport while varying parameters such as the authentication</span>
<span class="cm"> * flavour.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span>
<span class="nf">rpc_clone_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_clnt</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_parent</span> <span class="o">=</span> <span class="n">clnt</span><span class="p">;</span>
	<span class="cm">/* Turn off autobind on clones */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_autobind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">rpc_init_rtt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_rtt_default</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_timeout</span><span class="o">-&gt;</span><span class="n">to_initval</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_metrics</span> <span class="o">=</span> <span class="n">rpc_alloc_iostats</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_metrics</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_stats</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_principal</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_principal</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_no_principal</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">xprt_get</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_transport</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">,</span> <span class="n">xprt</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">rpc_setup_pipedir</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_program</span><span class="o">-&gt;</span><span class="n">pipe_dir_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_path</span><span class="p">;</span>
	<span class="n">rpc_clnt_set_nodename</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="o">-&gt;</span><span class="n">au_count</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">);</span>
	<span class="n">rpc_register_client</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">rpciod_up</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="nl">out_no_path:</span>
	<span class="n">xprt_put</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
<span class="nl">out_no_transport:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_principal</span><span class="p">);</span>
<span class="nl">out_no_principal:</span>
	<span class="n">rpc_free_iostats</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cl_metrics</span><span class="p">);</span>
<span class="nl">out_no_stats:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
<span class="nl">out_no_clnt:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: returned error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_clone_client</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Kill all tasks for the given client.</span>
<span class="cm"> * XXX: kill their descendants as well?</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rpc_killall_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span>	<span class="o">*</span><span class="n">rovr</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       killing all tasks for client %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clnt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Spin lock all_tasks to prevent changes...</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rovr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">,</span> <span class="n">tk_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RPC_IS_ACTIVATED</span><span class="p">(</span><span class="n">rovr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rovr</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">&amp;</span> <span class="n">RPC_TASK_KILLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rovr</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">|=</span> <span class="n">RPC_TASK_KILLED</span><span class="p">;</span>
			<span class="n">rpc_exit</span><span class="p">(</span><span class="n">rovr</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">RPC_IS_QUEUED</span><span class="p">(</span><span class="n">rovr</span><span class="p">))</span>
				<span class="n">rpc_wake_up_queued_task</span><span class="p">(</span><span class="n">rovr</span><span class="o">-&gt;</span><span class="n">tk_waitqueue</span><span class="p">,</span>
							<span class="n">rovr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_killall_tasks</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Properly shut down an RPC client, terminating all outstanding</span>
<span class="cm"> * requests.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rpc_shutdown_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk_rcu</span><span class="p">(</span><span class="s">&quot;RPC:       shutting down %s client for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span>
			<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rpc_killall_tasks</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">destroy_wait</span><span class="p">,</span>
			<span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">),</span> <span class="mi">1</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rpc_release_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_shutdown_client</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Free an RPC client</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rpc_free_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk_rcu</span><span class="p">(</span><span class="s">&quot;RPC:       destroying %s client for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span>
			<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_parent</span> <span class="o">!=</span> <span class="n">clnt</span><span class="p">)</span>
		<span class="n">rpc_release_client</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_parent</span><span class="p">);</span>
	<span class="n">rpc_unregister_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="n">rpc_clnt_remove_pipedir</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="n">rpc_free_iostats</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_metrics</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_principal</span><span class="p">);</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_metrics</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xprt_put</span><span class="p">(</span><span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">));</span>
	<span class="n">rpciod_down</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free an RPC client</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rpc_free_auth</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpc_free_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: RPCSEC_GSS may need to send NULL RPC calls in order to</span>
<span class="cm">	 *       release remaining GSS contexts. This mechanism ensures</span>
<span class="cm">	 *       that it can do so safely.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">);</span>
	<span class="n">rpcauth_release</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span><span class="p">);</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_auth</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">))</span>
		<span class="n">rpc_free_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release reference to the RPC client</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">rpc_release_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       rpc_release_client(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">destroy_wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">))</span>
		<span class="n">rpc_free_auth</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_bind_new_program - bind a new RPC program to an existing client</span>
<span class="cm"> * @old: old rpc_client</span>
<span class="cm"> * @program: rpc program to set</span>
<span class="cm"> * @vers: rpc program version</span>
<span class="cm"> *</span>
<span class="cm"> * Clones the rpc client and sets up a new RPC program. This is mainly</span>
<span class="cm"> * of use for enabling different RPC programs to share the same transport.</span>
<span class="cm"> * The Sun NFSv2/v3 ACL protocol can do this.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="nf">rpc_bind_new_program</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_program</span> <span class="o">*</span><span class="n">program</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">vers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vers</span> <span class="o">&gt;=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">nrvers</span> <span class="o">||</span> <span class="o">!</span><span class="n">program</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">[</span><span class="n">vers</span><span class="p">]);</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">[</span><span class="n">vers</span><span class="p">];</span>
	<span class="n">clnt</span> <span class="o">=</span> <span class="n">rpc_clone_client</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">clnt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_procinfo</span> <span class="o">=</span> <span class="n">version</span><span class="o">-&gt;</span><span class="n">procs</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_maxproc</span>  <span class="o">=</span> <span class="n">version</span><span class="o">-&gt;</span><span class="n">nrprocs</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span> <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_prog</span>     <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span>     <span class="o">=</span> <span class="n">version</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span>    <span class="o">=</span> <span class="n">program</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">rpc_ping</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpc_shutdown_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="n">clnt</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">clnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_bind_new_program</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rpc_task_release_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Remove from client task list */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_task</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">rpc_release_client</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">rpc_task_set_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpc_task_release_client</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span> <span class="o">=</span> <span class="n">clnt</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_softrtry</span><span class="p">)</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">|=</span> <span class="n">RPC_TASK_SOFT</span><span class="p">;</span>
		<span class="cm">/* Add to the client&#39;s list of all tasks */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rpc_task_reset_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rpc_task_release_client</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rpc_task_set_client</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">clnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_task_reset_client</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rpc_task_set_rpc_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">rpc_proc</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_argp</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">rpc_argp</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_resp</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">rpc_resp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">rpc_cred</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">rpc_cred</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Default callback for async RPC calls</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rpc_default_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="n">rpc_default_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">rpc_call_done</span> <span class="o">=</span> <span class="n">rpc_default_callback</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_run_task - Allocate a new RPC task, then run rpc_execute against it</span>
<span class="cm"> * @task_setup_data: pointer to task initialisation data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="nf">rpc_run_task</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_task_setup</span> <span class="o">*</span><span class="n">task_setup_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">rpc_new_task</span><span class="p">(</span><span class="n">task_setup_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rpc_task_set_client</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">task_setup_data</span><span class="o">-&gt;</span><span class="n">rpc_client</span><span class="p">);</span>
	<span class="n">rpc_task_set_rpc_message</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">task_setup_data</span><span class="o">-&gt;</span><span class="n">rpc_message</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">rpc_call_start</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_count</span><span class="p">);</span>
	<span class="n">rpc_execute</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_run_task</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_call_sync - Perform a synchronous RPC call</span>
<span class="cm"> * @clnt: pointer to RPC client</span>
<span class="cm"> * @msg: RPC call parameters</span>
<span class="cm"> * @flags: RPC call flags</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rpc_call_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span>	<span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_task_setup</span> <span class="n">task_setup_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rpc_client</span> <span class="o">=</span> <span class="n">clnt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rpc_message</span> <span class="o">=</span> <span class="n">msg</span><span class="p">,</span>
		<span class="p">.</span><span class="n">callback_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpc_default_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RPC_TASK_ASYNC</span><span class="p">);</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">rpc_run_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_setup_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">;</span>
	<span class="n">rpc_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_call_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_call_async - Perform an asynchronous RPC call</span>
<span class="cm"> * @clnt: pointer to RPC client</span>
<span class="cm"> * @msg: RPC call parameters</span>
<span class="cm"> * @flags: RPC call flags</span>
<span class="cm"> * @tk_ops: RPC call ops</span>
<span class="cm"> * @data: user call data</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">rpc_call_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
	       <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">tk_ops</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span>	<span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_task_setup</span> <span class="n">task_setup_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rpc_client</span> <span class="o">=</span> <span class="n">clnt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rpc_message</span> <span class="o">=</span> <span class="n">msg</span><span class="p">,</span>
		<span class="p">.</span><span class="n">callback_ops</span> <span class="o">=</span> <span class="n">tk_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">|</span><span class="n">RPC_TASK_ASYNC</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">rpc_run_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_setup_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rpc_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_call_async</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SUNRPC_BACKCHANNEL)</span>
<span class="cm">/**</span>
<span class="cm"> * rpc_run_bc_task - Allocate a new RPC task for backchannel use, then run</span>
<span class="cm"> * rpc_execute against it</span>
<span class="cm"> * @req: RPC request</span>
<span class="cm"> * @tk_ops: RPC call ops</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="nf">rpc_run_bc_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">tk_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">xbufp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_task_setup</span> <span class="n">task_setup_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">callback_ops</span> <span class="o">=</span> <span class="n">tk_ops</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: rpc_run_bc_task req= %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create an rpc_task to send the data</span>
<span class="cm">	 */</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">rpc_new_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_setup_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xprt_free_bc_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the xdr_buf length.</span>
<span class="cm">	 * This also indicates that the buffer is XDR encoded already.</span>
<span class="cm">	 */</span>
	<span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">+</span> <span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">page_len</span> <span class="o">+</span>
			<span class="n">xbufp</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bc_transmit</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">rpc_execute</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: rpc_run_bc_task: task= %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_BACKCHANNEL */</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">rpc_call_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_start</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_call_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_peeraddr - extract remote peer address from clnt&#39;s xprt</span>
<span class="cm"> * @clnt: RPC client structure</span>
<span class="cm"> * @buf: target buffer</span>
<span class="cm"> * @bufsize: length of target buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes that are actually in the stored address.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">rpc_peeraddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">);</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">bufsize</span><span class="p">)</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">bufsize</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_peeraddr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_peeraddr2str - return remote peer address in printable format</span>
<span class="cm"> * @clnt: RPC client structure</span>
<span class="cm"> * @format: address format</span>
<span class="cm"> *</span>
<span class="cm"> * NB: the lifetime of the memory referenced by the returned pointer is</span>
<span class="cm"> * the same as the rpc_xprt itself.  As long as the caller uses this</span>
<span class="cm"> * pointer, it must hold the RCU read lock.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">rpc_peeraddr2str</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">rpc_display_format_t</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">format</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">address_strings</span><span class="p">[</span><span class="n">format</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;unprintable&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_peeraddr2str</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">rpc_inaddr_loopback</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sin_family</span>		<span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span>	<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="n">rpc_in6addr_loopback</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sin6_family</span>		<span class="o">=</span> <span class="n">AF_INET6</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sin6_addr</span>		<span class="o">=</span> <span class="n">IN6ADDR_ANY_INIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Try a getsockname() on a connected datagram socket.  Using a</span>
<span class="cm"> * connected datagram socket prevents leaving a socket in TIME_WAIT.</span>
<span class="cm"> * This conserves the ephemeral port number space.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero and fills in &quot;buf&quot; if successful; otherwise, a</span>
<span class="cm"> * negative errno is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpc_sockname</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">salen</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__sock_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sap</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">,</span>
				<span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">IPPROTO_UDP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       can&#39;t create UDP socket (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">kernel_bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rpc_inaddr_loopback</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_inaddr_loopback</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">kernel_bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rpc_in6addr_loopback</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_in6addr_loopback</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       can&#39;t bind UDP socket (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kernel_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sap</span><span class="p">,</span> <span class="n">salen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       can&#39;t connect UDP socket (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kernel_getsockname</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       getsockname failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sin6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
		<span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_scope_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="nl">out_release:</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scraping a connected socket failed, so we don&#39;t have a useable</span>
<span class="cm"> * local address.  Fallback: generate an address that will prevent</span>
<span class="cm"> * the server from calling us back.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero and fills in &quot;buf&quot; if successful; otherwise, a</span>
<span class="cm"> * negative errno is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpc_anyaddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_inaddr_loopback</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpc_inaddr_loopback</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_inaddr_loopback</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_in6addr_loopback</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpc_in6addr_loopback</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">rpc_in6addr_loopback</span><span class="p">));</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: address family not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_localaddr - discover local endpoint address for an RPC client</span>
<span class="cm"> * @clnt: RPC client structure</span>
<span class="cm"> * @buf: target buffer</span>
<span class="cm"> * @buflen: size of target buffer, in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero and fills in &quot;buf&quot; and &quot;buflen&quot; if successful;</span>
<span class="cm"> * otherwise, a negative errno is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This works even if the underlying transport is not currently connected,</span>
<span class="cm"> * or if the upper layer never previously provided a source address.</span>
<span class="cm"> *</span>
<span class="cm"> * The result of this function call is transient: multiple calls in</span>
<span class="cm"> * succession may give different results, depending on how local</span>
<span class="cm"> * networking configuration changes over time.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rpc_localaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">salen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">);</span>
	<span class="n">salen</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addrlen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">salen</span><span class="p">);</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">get_net</span><span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">xprt_net</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">rpc_set_port</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">rpc_sockname</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sap</span><span class="p">,</span> <span class="n">salen</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">put_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Couldn&#39;t discover local address, return ANYADDR */</span>
		<span class="k">return</span> <span class="n">rpc_anyaddr</span><span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_localaddr</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">rpc_setbufsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sndsize</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rcvsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_buffer_size</span><span class="p">)</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_buffer_size</span><span class="p">(</span><span class="n">xprt</span><span class="p">,</span> <span class="n">sndsize</span><span class="p">,</span> <span class="n">rcvsize</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_setbufsize</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_protocol - Get transport protocol number for an RPC client</span>
<span class="cm"> * @clnt: RPC client to query</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rpc_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">protocol</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">protocol</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">protocol</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_protocol</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_net_ns - Get the network namespace for this RPC client</span>
<span class="cm"> * @clnt: RPC client to query</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">rpc_net_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xprt_net</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_net_ns</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_max_payload - Get maximum payload size for a transport, in bytes</span>
<span class="cm"> * @clnt: RPC client to query</span>
<span class="cm"> *</span>
<span class="cm"> * For stream transports, this is one RPC record fragment (see RFC</span>
<span class="cm"> * 1831), as we don&#39;t support multi-record requests yet.  For datagram</span>
<span class="cm"> * transports, this is the size of an IP packet minus the IP, UDP, and</span>
<span class="cm"> * RPC header sizes.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">rpc_max_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">max_payload</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_max_payload</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpc_force_rebind - force transport to check that remote port is unchanged</span>
<span class="cm"> * @clnt: client to rebind</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rpc_force_rebind</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_autobind</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">xprt_clear_bound</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">));</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_force_rebind</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Restart an (async) RPC call from the call_prepare state.</span>
<span class="cm"> * Usually called from within the exit handler.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">rpc_restart_call_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RPC_ASSASSINATED</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_ops</span><span class="o">-&gt;</span><span class="n">rpc_call_prepare</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">rpc_prepare_task</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_restart_call_prepare</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Restart an (async) RPC call. Usually called from within the</span>
<span class="cm"> * exit handler.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">rpc_restart_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RPC_ASSASSINATED</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_start</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_restart_call</span><span class="p">);</span>

<span class="cp">#ifdef RPC_DEBUG</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">rpc_proc_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_procinfo</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_name</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_name</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="s">&quot;NULL&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;no proc&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * 0.  Initial state</span>
<span class="cm"> *</span>
<span class="cm"> *     Other FSM states can be visited zero or more times, but</span>
<span class="cm"> *     this state is visited exactly once for each RPC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>	<span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u call_start %s%d proc %s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span>
			<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span><span class="p">,</span>
			<span class="n">rpc_proc_name</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
			<span class="p">(</span><span class="n">RPC_IS_ASYNC</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;async&quot;</span> <span class="o">:</span> <span class="s">&quot;sync&quot;</span><span class="p">));</span>

	<span class="cm">/* Increment call count */</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="o">-&gt;</span><span class="n">p_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span><span class="o">-&gt;</span><span class="n">rpccnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_reserve</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 1.	Reserve an RPC call slot</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span>  <span class="o">=</span> <span class="n">call_reserveresult</span><span class="p">;</span>
	<span class="n">xprt_reserve</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 1b.	Grok the result of xprt_reserve()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_reserveresult</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * After a call to xprt_reserve(), we must have either</span>
<span class="cm">	 * a request slot or else an error status.</span>
<span class="cm">	 */</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_refresh</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: status=%d, but no request slot, exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even though there was an error, we may have acquired</span>
<span class="cm">	 * a request slot somehow.  Make sure not to leak it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: status=%d, request allocated anyway</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">xprt_release</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span>:
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:	<span class="cm">/* woken up; retry */</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_reserve</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:	<span class="cm">/* probably a shutdown */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unrecognized error %d, exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.	Bind and/or refresh the credentials</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_refresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_refreshresult</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="o">-&gt;</span><span class="n">cl_stats</span><span class="o">-&gt;</span><span class="n">rpcauthrefresh</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rpcauth_refreshcred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2a.	Process the results of a credential refresh</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_refreshresult</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_refresh</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rpcauth_uptodatecred</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_allocate</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_cred_retry</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_cred_retry</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: retry refresh creds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: refresh creds failed with error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2b.	Allocate the buffer. For details, see sched.c:rpc_malloc.</span>
<span class="cm"> *	(Note: buffer memory is freed in xprt_release).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slack</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_cred</span><span class="o">-&gt;</span><span class="n">cr_auth</span><span class="o">-&gt;</span><span class="n">au_cslack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_procinfo</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_buffer</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_proc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_arglen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_decode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_replen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the size (in quads) of the RPC call</span>
<span class="cm">	 * and reply headers, and convert both values</span>
<span class="cm">	 * to byte sizes.</span>
<span class="cm">	 */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_callsize</span> <span class="o">=</span> <span class="n">RPC_CALLHDRSIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">slack</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_arglen</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_callsize</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcvsize</span> <span class="o">=</span> <span class="n">RPC_REPHDRSIZE</span> <span class="o">+</span> <span class="n">slack</span> <span class="o">+</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">p_replen</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcvsize</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_buffer</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">buf_alloc</span><span class="p">(</span><span class="n">task</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_callsize</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcvsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u rpc_buffer allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RPC_IS_ASYNC</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_allocate</span><span class="p">;</span>
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">HZ</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rpc_task_need_encode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rpc_task_force_reencode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rpc_xdr_buf_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">page_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.	Encode arguments of an RPC call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rpc_xdr_encode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="n">kxdreproc_t</span>	<span class="n">encode</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">rpc_xdr_buf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_snd_buf</span><span class="p">,</span>
			 <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_buffer</span><span class="p">,</span>
			 <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_callsize</span><span class="p">);</span>
	<span class="n">rpc_xdr_buf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_buffer</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_callsize</span><span class="p">,</span>
			 <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcvsize</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rpc_encode_header</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;RPC: couldn&#39;t encode RPC header, exit EIO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">encode</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="o">-&gt;</span><span class="n">p_encode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">encode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">rpcauth_wrap_req</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">encode</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_argp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 4.	Get the server port number if not yet set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_connect</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt_bound</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind_status</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_timeout</span> <span class="o">=</span> <span class="n">xprt</span><span class="o">-&gt;</span><span class="n">bind_timeout</span><span class="p">;</span>
		<span class="n">xprt</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">rpcbind</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 4a.	Sort out bind result</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_bind_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_connect</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_rpc_bind_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u rpcbind out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry_timeout</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EACCES</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u remote rpcbind: RPC program/version &quot;</span>
				<span class="s">&quot;unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
		<span class="cm">/* fail immediately if this is an RPC ping */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="o">-&gt;</span><span class="n">p_proc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rebind_retry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rebind_retry</span><span class="o">--</span><span class="p">;</span>
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry_timeout</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u rpcbind request timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry_timeout</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span>:
		<span class="cm">/* server doesn&#39;t support any rpcbind version we know of */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u unrecognized remote rpcbind service</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u remote rpcbind version unavailable, retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:		<span class="cm">/* connection problems */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTCONN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTDOWN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u remote rpcbind unreachable: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RPC_IS_SOFTCONN</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry_timeout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u unrecognized rpcbind error (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="o">-</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">retry_timeout:</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 4b.	Connect to the RPC server</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_xprt</span> <span class="o">*</span><span class="n">xprt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u call_connect xprt %p %s connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">xprt</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;is&quot;</span> <span class="o">:</span> <span class="s">&quot;is not&quot;</span><span class="p">));</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_transmit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xprt_connected</span><span class="p">(</span><span class="n">xprt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_connect_status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">xprt_connect</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 4c.	Sort out connect result</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_connect_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span><span class="o">-&gt;</span><span class="n">netreconn</span><span class="o">++</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_transmit</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_rpc_connect_status</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if soft mounted, test if we&#39;ve timed out */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_timeout</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 5.	Transmit the RPC request, and wait for reply</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">xprt_prepare_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_transmit_status</span><span class="p">;</span>
	<span class="cm">/* Encode here so that rpcsec_gss can use correct sequence number. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpc_task_need_encode</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">rpc_xdr_encode</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="cm">/* Did the encode result in an error condition? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Was the error nonfatal? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xprt_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * On success, ensure that we call xprt_end_transmit() before sleeping</span>
<span class="cm">	 * in order to allow access to the socket to other RPC requests.</span>
<span class="cm">	 */</span>
	<span class="n">call_transmit_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpc_reply_expected</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">rpc_exit_task</span><span class="p">;</span>
	<span class="n">rpc_wake_up_queued_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 5a.	Handle cleanup after a transmission</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_transmit_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Common case: success.  Force the compiler to put this</span>
<span class="cm">	 * test first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xprt_end_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">rpc_task_force_reencode</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">xprt_end_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">rpc_task_force_reencode</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Special cases: if we&#39;ve been waiting on the</span>
<span class="cm">		 * socket&#39;s write_space() callback, or if the</span>
<span class="cm">		 * socket just returned a connection error,</span>
<span class="cm">		 * then hold onto the transport lock.</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTDOWN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">RPC_IS_SOFTCONN</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xprt_end_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTCONN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="n">rpc_task_force_reencode</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_SUNRPC_BACKCHANNEL)</span>
<span class="cm">/*</span>
<span class="cm"> * 5b.	Send the backchannel RPC reply.  On error, drop the reply.  In</span>
<span class="cm"> * addition, disconnect on connectivity errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_bc_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">xprt_prepare_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Could not reserve the transport. Try again after the</span>
<span class="cm">		 * transport is released.</span>
<span class="cm">		 */</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bc_transmit</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">rpc_exit_task</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;RPC: Could not send backchannel reply &quot;</span>
			<span class="s">&quot;error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xprt_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">xprt_end_transmit</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* Success */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTDOWN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Problem reaching the server.  Disconnect and let the</span>
<span class="cm">		 * forechannel reestablish the connection.  The server will</span>
<span class="cm">		 * have to retransmit the backchannel request and we&#39;ll</span>
<span class="cm">		 * reprocess it.  Since these ops are idempotent, there&#39;s no</span>
<span class="cm">		 * need to cache our reply at this time.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;RPC: Could not send backchannel reply &quot;</span>
			<span class="s">&quot;error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
		<span class="n">xprt_conditional_disconnect</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_connect_cookie</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * We were unable to reply and will have to drop the</span>
<span class="cm">		 * request.  The server should reconnect and retransmit.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;RPC: Could not send backchannel reply &quot;</span>
			<span class="s">&quot;error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rpc_wake_up_queued_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xprt</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_BACKCHANNEL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 6.	Sort out the RPC call status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>	<span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_reply_bytes_recvd</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_bytes_sent</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_reply_bytes_recvd</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_decode</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_rpc_call_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTDOWN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Delay any retries for 3 seconds, then handle as if it</span>
<span class="cm">		 * were a timeout.</span>
<span class="cm">		 */</span>
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_timeout</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="o">-&gt;</span><span class="n">cl_discrtry</span><span class="p">)</span>
			<span class="n">xprt_conditional_disconnect</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_connect_cookie</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:
		<span class="n">rpc_force_rebind</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTCONN</span>:
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_transmit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
		<span class="cm">/* shutdown or soft timeout */</span>
		<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_chatty</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: RPC call returned error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span> <span class="o">-</span><span class="n">status</span><span class="p">);</span>
		<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 6a.	Handle RPC timeout</span>
<span class="cm"> * 	We do not release the request slot, so we keep using the</span>
<span class="cm"> *	same XID for all retransmits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>	<span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xprt_adjust_timeout</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u call_timeout (minor)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u call_timeout (major)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_timeouts</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RPC_IS_SOFTCONN</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RPC_IS_SOFT</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_chatty</span><span class="p">)</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: server %s not responding, timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span>
				<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">&amp;</span> <span class="n">RPC_TASK_TIMEOUT</span><span class="p">)</span>
			<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">&amp;</span> <span class="n">RPC_CALL_MAJORSEEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">|=</span> <span class="n">RPC_CALL_MAJORSEEN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_chatty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: server %s not responding, still trying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span>
			<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rpc_force_rebind</span><span class="p">(</span><span class="n">clnt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Did our request time out due to an RPCSEC_GSS out-of-sequence</span>
<span class="cm">	 * event? RFC2203 requires the server to drop all such requests.</span>
<span class="cm">	 */</span>
	<span class="n">rpcauth_invalcred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span><span class="o">-&gt;</span><span class="n">rpcretrans</span><span class="o">++</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 7.	Decode the RPC reply</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">call_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>	<span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="n">kxdrdproc_t</span>	<span class="n">decode</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="o">-&gt;</span><span class="n">p_decode</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">dprint_status</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">&amp;</span> <span class="n">RPC_CALL_MAJORSEEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_chatty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: server %s OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span>
				<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RPC_CALL_MAJORSEEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that we see all writes made by xprt_complete_rqst()</span>
<span class="cm">	 * before it changed req-&gt;rq_reply_bytes_recvd.</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Check that the softirq receive buffer is valid */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_private_buf</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RPC_IS_SOFT</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>
			<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span><span class="o">-&gt;</span><span class="n">rpcretrans</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       %s: too small RPC reply size (%d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_timeout</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rpc_verify_header</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">rpc_exit_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">decode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">rpcauth_unwrap_resp</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">decode</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
						      <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_resp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u call_decode result %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_retry:</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Note: rpc_verify_header() may have freed the RPC slot */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span> <span class="o">==</span> <span class="n">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_reply_bytes_recvd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="o">-&gt;</span><span class="n">cl_discrtry</span><span class="p">)</span>
			<span class="n">xprt_conditional_disconnect</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">,</span>
					<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_connect_cookie</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">rpc_encode_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_rqst</span>	<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>

	<span class="cm">/* FIXME: check buffer size? */</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xprt_skip_transport_header</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_xprt</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_xid</span><span class="p">;</span>		<span class="cm">/* XID */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">RPC_CALL</span><span class="p">);</span>		<span class="cm">/* CALL */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">RPC_VERSION</span><span class="p">);</span>	<span class="cm">/* RPC version */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_prog</span><span class="p">);</span>	<span class="cm">/* program number */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span><span class="p">);</span>	<span class="cm">/* program version */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_proc</span><span class="o">-&gt;</span><span class="n">p_proc</span><span class="p">);</span>	<span class="cm">/* procedure */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">rpcauth_marshcred</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span> <span class="o">=</span> <span class="n">xdr_adjust_iovec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_svec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">rpc_verify_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RFC-1014 says that the representation of XDR data must be a</span>
<span class="cm">		 * multiple of four bytes</span>
<span class="cm">		 * - if it isn&#39;t pointer subtraction in the NFS client may give</span>
<span class="cm">		 *   undefined results</span>
<span class="cm">		 */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: XDR representation not a multiple of&quot;</span>
		       <span class="s">&quot; 4 bytes: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_eio</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* skip XID */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">))</span> <span class="o">!=</span> <span class="n">RPC_REPLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: not an RPC reply: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_garbage</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">))</span> <span class="o">!=</span> <span class="n">RPC_MSG_ACCEPTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RPC_AUTH_ERROR</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RPC_MISMATCH</span>:
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: RPC call version mismatch!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: RPC call rejected, &quot;</span>
				<span class="s">&quot;unknown error: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_eio</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RPC_AUTH_REJECTEDCRED</span>:
		<span class="k">case</span> <span class="n">RPC_AUTH_REJECTEDVERF</span>:
		<span class="k">case</span> <span class="n">RPCSEC_GSS_CREDPROBLEM</span>:
		<span class="k">case</span> <span class="n">RPCSEC_GSS_CTXPROBLEM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_cred_retry</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_cred_retry</span><span class="o">--</span><span class="p">;</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: retry stale creds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">rpcauth_invalcred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="cm">/* Ensure we obtain a new XID! */</span>
			<span class="n">xprt_release</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_reserve</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RPC_AUTH_BADCRED</span>:
		<span class="k">case</span> <span class="n">RPC_AUTH_BADVERF</span>:
			<span class="cm">/* possibly garbled cred/verf? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_garb_retry</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_garb_retry</span><span class="o">--</span><span class="p">;</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: retry garbled creds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RPC_AUTH_TOOWEAK</span>:
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;RPC: server %s requires stronger &quot;</span>
			       <span class="s">&quot;authentication.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: unknown auth error: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: call rejected %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rpcauth_checkverf</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: auth check failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_garbage</span><span class="p">;</span>		<span class="cm">/* bad verifier, retry */</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RPC_SUCCESS</span>:
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RPC_PROG_UNAVAIL</span>:
		<span class="n">dprintk_rcu</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: program %u is unsupported &quot;</span>
				<span class="s">&quot;by server %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_prog</span><span class="p">,</span>
				<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RPC_PROG_MISMATCH</span>:
		<span class="n">dprintk_rcu</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: program %u, version %u unsupported &quot;</span>
				<span class="s">&quot;by server %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_prog</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span><span class="p">,</span>
				<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RPC_PROC_UNAVAIL</span>:
		<span class="n">dprintk_rcu</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: proc %s unsupported by program %u, &quot;</span>
				<span class="s">&quot;version %u on server %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">rpc_proc_name</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
				<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_prog</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span><span class="p">,</span>
				<span class="n">rcu_dereference</span><span class="p">(</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_xprt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">servername</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RPC_GARBAGE_ARGS</span>:
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: server saw garbage</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>			<span class="cm">/* retry */</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: server accept status: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="cm">/* Also retry */</span>
	<span class="p">}</span>

<span class="nl">out_garbage:</span>
	<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_stats</span><span class="o">-&gt;</span><span class="n">rpcgarbage</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_garb_retry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_garb_retry</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span> <span class="o">=</span> <span class="n">call_bind</span><span class="p">;</span>
<span class="nl">out_retry:</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_eio:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">rpc_exit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: call failed with error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="nl">out_overflow:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC: %5u %s: server reply was truncated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_garbage</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpcproc_encode_null</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpcproc_decode_null</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_procinfo</span> <span class="n">rpcproc_null</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">p_encode</span> <span class="o">=</span> <span class="n">rpcproc_encode_null</span><span class="p">,</span>
	<span class="p">.</span><span class="n">p_decode</span> <span class="o">=</span> <span class="n">rpcproc_decode_null</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rpc_ping</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_message</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rpc_proc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpcproc_null</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">rpc_cred</span> <span class="o">=</span> <span class="n">authnull_ops</span><span class="p">.</span><span class="n">lookup_cred</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">rpc_call_sync</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">RPC_TASK_SOFT</span> <span class="o">|</span> <span class="n">RPC_TASK_SOFTCONN</span><span class="p">);</span>
	<span class="n">put_rpccred</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">rpc_cred</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="nf">rpc_call_null</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_message</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rpc_proc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpcproc_null</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rpc_cred</span> <span class="o">=</span> <span class="n">cred</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">rpc_task_setup</span> <span class="n">task_setup_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rpc_client</span> <span class="o">=</span> <span class="n">clnt</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rpc_message</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span>
		<span class="p">.</span><span class="n">callback_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rpc_default_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">rpc_run_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_setup_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rpc_call_null</span><span class="p">);</span>

<span class="cp">#ifdef RPC_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpc_show_header</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;-pid- flgs status -client- --rqstp- &quot;</span>
		<span class="s">&quot;-timeout ---ops--</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rpc_show_task</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rpc_waitq</span> <span class="o">=</span> <span class="s">&quot;none&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RPC_IS_QUEUED</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="n">rpc_waitq</span> <span class="o">=</span> <span class="n">rpc_qname</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_waitqueue</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%5u %04x %6d %8p %8p %8ld %8p %sv%u %s a:%ps q:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_pid</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_flags</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">,</span>
		<span class="n">clnt</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_rqstp</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_timeout</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_ops</span><span class="p">,</span>
		<span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_protname</span><span class="p">,</span> <span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_vers</span><span class="p">,</span> <span class="n">rpc_proc_name</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_action</span><span class="p">,</span> <span class="n">rpc_waitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rpc_show_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sunrpc_net</span> <span class="o">*</span><span class="n">sn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunrpc_net_id</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">all_clients</span><span class="p">,</span> <span class="n">cl_clients</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_tasks</span><span class="p">,</span> <span class="n">tk_task</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">header</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rpc_show_header</span><span class="p">();</span>
				<span class="n">header</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rpc_show_task</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clnt</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn</span><span class="o">-&gt;</span><span class="n">rpc_client_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
