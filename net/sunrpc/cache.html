<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sunrpc › cache.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cache.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/sunrpc/cache.c</span>
<span class="cm"> *</span>
<span class="cm"> * Generic code for various authentication-related caches</span>
<span class="cm"> * used by sunrpc clients and servers.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002 Neil Brown &lt;neilb@cse.unsw.edu.au&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Released under terms in GPL version 2.  See COPYING.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;asm/ioctls.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/types.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/cache.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/stats.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/rpc_pipe_fs.h&gt;</span>
<span class="cp">#include &quot;netns.h&quot;</span>

<span class="cp">#define	 RPCDBG_FACILITY RPCDBG_CACHE</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">cache_defer_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cache_revisit_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">();</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">expiry_time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">CACHE_NEW_EXPIRY</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">last_refresh</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cache_is_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">expiry_time</span> <span class="o">&lt;</span> <span class="n">seconds_since_boot</span><span class="p">())</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">flush_time</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">last_refresh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="nf">sunrpc_cache_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span>  <span class="o">**</span><span class="n">hp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">freeme</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">hp</span><span class="o">=</span><span class="n">head</span><span class="p">;</span> <span class="o">*</span><span class="n">hp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">;</span> <span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">hp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache_is_expired</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">tmp</span><span class="p">))</span>
				<span class="cm">/* This entry is expired, we will discard it. */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cache_get</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="cm">/* Didn&#39;t find anything, insert an empty entry */</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* must fully initialise &#39;new&#39;, else</span>
<span class="cm">	 * we might get lose if we need to</span>
<span class="cm">	 * cache_put it soon.</span>
<span class="cm">	 */</span>
	<span class="n">cache_init</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

	<span class="cm">/* check if entry appeared while we slept */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">hp</span><span class="o">=</span><span class="n">head</span><span class="p">;</span> <span class="o">*</span><span class="n">hp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">;</span> <span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">hp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache_is_expired</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">detail</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">--</span><span class="p">;</span>
				<span class="n">freeme</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cache_get</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
			<span class="n">cache_put</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cache_get</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freeme</span><span class="p">)</span>
		<span class="n">cache_put</span><span class="p">(</span><span class="n">freeme</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_cache_lookup</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">cache_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">ch</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_fresh_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">expiry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">expiry_time</span> <span class="o">=</span> <span class="n">expiry</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">last_refresh</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">();</span>
	<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* paired with smp_rmb() in cache_is_valid() */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CACHE_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_fresh_unlocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cache_revisit_request</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
		<span class="n">cache_dequeue</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="nf">sunrpc_cache_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The &#39;old&#39; entry is to be replaced by &#39;new&#39;.</span>
<span class="cm">	 * If &#39;old&#39; is not VALID, we update it directly,</span>
<span class="cm">	 * otherwise we need to replace it</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">**</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">CACHE_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">detail</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
			<span class="n">cache_fresh_locked</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">expiry_time</span><span class="p">);</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
			<span class="n">cache_fresh_unlocked</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* We need to insert a new entry */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache_put</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cache_init</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CACHE_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">detail</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cache_get</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">cache_fresh_locked</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">expiry_time</span><span class="p">);</span>
	<span class="n">cache_fresh_locked</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">cache_fresh_unlocked</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="n">cache_fresh_unlocked</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="n">cache_put</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_cache_update</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_make_upcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_upcall</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_upcall</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cache_is_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* entry is valid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In combination with write barrier in</span>
<span class="cm">			 * sunrpc_cache_update, ensures that anyone</span>
<span class="cm">			 * using the cache entry after this sees the</span>
<span class="cm">			 * updated contents:</span>
<span class="cm">			 */</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_negate_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">cache_is_valid</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CACHE_NEGATIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cache_fresh_locked</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">seconds_since_boot</span><span class="p">()</span><span class="o">+</span><span class="n">CACHE_NEW_EXPIRY</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">cache_fresh_unlocked</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the generic cache management routine for all</span>
<span class="cm"> * the authentication caches.</span>
<span class="cm"> * It checks the currency of a cache item and will (later)</span>
<span class="cm"> * initiate an upcall to fill it if needed.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the cache_head can be used, or cache_puts it and returns</span>
<span class="cm"> * -EAGAIN if upcall is pending and request has been queued</span>
<span class="cm"> * -ETIMEDOUT if upcall failed or request could not be queue or</span>
<span class="cm"> *           upcall completed but item is still invalid (implying that</span>
<span class="cm"> *           the cache item has been replaced with a newer one).</span>
<span class="cm"> * -ENOENT if cache entry was negative</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cache_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_req</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">refresh_age</span><span class="p">,</span> <span class="n">age</span><span class="p">;</span>

	<span class="cm">/* First decide return status as best we can */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">cache_is_valid</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* now see if we want to start an upcall */</span>
	<span class="n">refresh_age</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">expiry_time</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">last_refresh</span><span class="p">);</span>
	<span class="n">age</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">()</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">last_refresh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="n">refresh_age</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       Want update, refage=%ld, age=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">refresh_age</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">cache_make_upcall</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">cache_revisit_request</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="n">try_to_negate_entry</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">cache_revisit_request</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_defer_req</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Request was not deferred; handle it as best</span>
<span class="cm">			 * we can ourselves:</span>
<span class="cm">			 */</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">cache_is_valid</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">cache_put</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_check</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * caches need to be periodically cleaned.</span>
<span class="cm"> * For this we maintain a list of cache_detail and</span>
<span class="cm"> * a current pointer into that list and into the table</span>
<span class="cm"> * for that entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Each time clean_cache is called it finds the next non-empty entry</span>
<span class="cm"> * in the current table and walks the list in that entry</span>
<span class="cm"> * looking for entries that can be removed.</span>
<span class="cm"> *</span>
<span class="cm"> * An entry gets removed if:</span>
<span class="cm"> * - The expiry is before current time</span>
<span class="cm"> * - The last_refresh time is before the flush_time for that cache</span>
<span class="cm"> *</span>
<span class="cm"> * later we might drop old entries with non-NEVER expiry if that table</span>
<span class="cm"> * is getting &#39;full&#39; for some definition of &#39;full&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * The question of &quot;how often to scan a table&quot; is an interesting one</span>
<span class="cm"> * and is answered in part by the use of the &quot;nextcheck&quot; field in the</span>
<span class="cm"> * cache_detail.</span>
<span class="cm"> * When a scan of a table begins, the nextcheck field is set to a time</span>
<span class="cm"> * that is well into the future.</span>
<span class="cm"> * While scanning, if an expiry time is found that is earlier than the</span>
<span class="cm"> * current nextcheck time, nextcheck is set to that expiry time.</span>
<span class="cm"> * If the flush_time is ever set to a time earlier than the nextcheck</span>
<span class="cm"> * time, the nextcheck time is then set to that flush_time.</span>
<span class="cm"> *</span>
<span class="cm"> * A table is then only scanned if the current time is at least</span>
<span class="cm"> * the nextcheck time.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">cache_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cache_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">current_detail</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">current_index</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">do_cache_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">cache_cleaner</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">sunrpc_init_cache_detail</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">last_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">last_warn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">others</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>

	<span class="cm">/* start the cleaning process */</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cleaner</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_init_cache_detail</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sunrpc_destroy_cache_detail</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cache_purge</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_detail</span> <span class="o">==</span> <span class="n">cd</span><span class="p">)</span>
		<span class="n">current_detail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">others</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* module must be being unloaded so its safe to kill the worker */</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cleaner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nfsd: failed to unregister %s cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_destroy_cache_detail</span><span class="p">);</span>

<span class="cm">/* clean cache tries to find something to clean</span>
<span class="cm"> * and cleans it.</span>
<span class="cm"> * It returns 1 if it cleaned something,</span>
<span class="cm"> *            0 if it didn&#39;t find anything this time</span>
<span class="cm"> *           -1 if it fell off the end of the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_clean</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>

	<span class="cm">/* find a suitable table if we don&#39;t already have one */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">current_detail</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="n">current_index</span> <span class="o">&gt;=</span> <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_detail</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">others</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">cache_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cache_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current_detail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">current_detail</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_detail</span><span class="p">,</span> <span class="n">others</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">&gt;</span> <span class="n">seconds_since_boot</span><span class="p">())</span>
			<span class="n">current_index</span> <span class="o">=</span> <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">current_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">()</span><span class="o">+</span><span class="mi">30</span><span class="o">*</span><span class="mi">60</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* find a non-empty bucket in the table */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">current_detail</span> <span class="o">&amp;&amp;</span>
	       <span class="n">current_index</span> <span class="o">&lt;</span> <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">&amp;&amp;</span>
	       <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">current_index</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">current_index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* find a cleanable entry in the bucket and clean it, or set to next bucket */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_detail</span> <span class="o">&amp;&amp;</span> <span class="n">current_index</span> <span class="o">&lt;</span> <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="o">**</span><span class="n">cp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

		<span class="cm">/* Ok, now to clean this strand */</span>

		<span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">current_index</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span> <span class="p">;</span> <span class="n">ch</span> <span class="p">;</span> <span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">&gt;</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">expiry_time</span><span class="p">)</span>
				<span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">expiry_time</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_is_expired</span><span class="p">(</span><span class="n">current_detail</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">--</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_detail</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">current_detail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
			<span class="n">current_index</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">cache_dequeue</span><span class="p">(</span><span class="n">current_detail</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
			<span class="n">cache_revisit_request</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
			<span class="n">cache_put</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We want to regularly clean the cache, so we need to schedule some work ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_cache_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_clean</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">round_jiffies_relative</span><span class="p">(</span><span class="mi">30</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_list</span><span class="p">))</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cleaner</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Clean all caches promptly.  This just calls cache_clean</span>
<span class="cm"> * repeatedly until we are sure that every cache has had a chance to</span>
<span class="cm"> * be fully cleaned</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cache_flush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache_clean</span><span class="p">()</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache_clean</span><span class="p">()</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cond_resched</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_flush</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cache_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">flush_time</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">;</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">();</span>
	<span class="n">cache_flush</span><span class="p">();</span>
	<span class="n">detail</span><span class="o">-&gt;</span><span class="n">flush_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_purge</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Deferral and Revisiting of Requests.</span>
<span class="cm"> *</span>
<span class="cm"> * If a cache lookup finds a pending entry, we</span>
<span class="cm"> * need to defer the request and revisit it later.</span>
<span class="cm"> * All deferred requests are stored in a hash table,</span>
<span class="cm"> * indexed by &quot;struct cache_head *&quot;.</span>
<span class="cm"> * As it may be wasteful to store a whole request</span>
<span class="cm"> * structure, we allow the request to provide a</span>
<span class="cm"> * deferred form, which must contain a</span>
<span class="cm"> * &#39;struct cache_deferred_req&#39;</span>
<span class="cm"> * This cache_deferred_req contains a method to allow</span>
<span class="cm"> * it to be revisited when cache info is available</span>
<span class="cm"> */</span>

<span class="cp">#define	DFR_HASHSIZE	(PAGE_SIZE/sizeof(struct list_head))</span>
<span class="cp">#define	DFR_HASH(item)	((((long)item)&gt;&gt;4 ^ (((long)item)&gt;&gt;13)) % DFR_HASHSIZE)</span>

<span class="cp">#define	DFR_MAX	300	</span><span class="cm">/* ??? */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cache_defer_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">cache_defer_list</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">cache_defer_hash</span><span class="p">[</span><span class="n">DFR_HASHSIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cache_defer_cnt</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unhash_deferred_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">);</span>
		<span class="n">cache_defer_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__hash_deferred_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">DFR_HASH</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_defer_hash</span><span class="p">[</span><span class="n">hash</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_deferral</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">count_me</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">dreq</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

	<span class="n">__hash_deferred_req</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count_me</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache_defer_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_defer_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">struct</span> <span class="n">thread_deferred_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">completion</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_restart_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">too_many</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_deferred_req</span> <span class="o">*</span><span class="n">dr</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">thread_deferred_req</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_wait_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_deferred_req</span> <span class="n">sleeper</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sleeper</span><span class="p">.</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">sleeper</span><span class="p">.</span><span class="n">completion</span> <span class="o">=</span> <span class="n">COMPLETION_INITIALIZER_ONSTACK</span><span class="p">(</span><span class="n">sleeper</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
	<span class="n">dreq</span><span class="o">-&gt;</span><span class="n">revisit</span> <span class="o">=</span> <span class="n">cache_restart_thread</span><span class="p">;</span>

	<span class="n">setup_deferral</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
		    <span class="o">&amp;</span><span class="n">sleeper</span><span class="p">.</span><span class="n">completion</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">thread_wait</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The completion wasn&#39;t completed, so we need</span>
<span class="cm">		 * to clean up</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleeper</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">hash</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__unhash_deferred_req</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleeper</span><span class="p">.</span><span class="n">handle</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* cache_revisit_request already removed</span>
<span class="cm">			 * this from the hash table, but hasn&#39;t</span>
<span class="cm">			 * called -&gt;revisit yet.  It will very soon</span>
<span class="cm">			 * and we need to wait for it.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>
			<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleeper</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_limit_defers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make sure we haven&#39;t exceed the limit of allowed deferred</span>
<span class="cm">	 * requests.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">discard</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_defer_cnt</span> <span class="o">&lt;=</span> <span class="n">DFR_MAX</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

	<span class="cm">/* Consider removing either the first or the last */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_defer_cnt</span> <span class="o">&gt;</span> <span class="n">DFR_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_random</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">discard</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cache_defer_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">cache_deferred_req</span><span class="p">,</span> <span class="n">recent</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">discard</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cache_defer_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">cache_deferred_req</span><span class="p">,</span> <span class="n">recent</span><span class="p">);</span>
		<span class="n">__unhash_deferred_req</span><span class="p">(</span><span class="n">discard</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">discard</span><span class="p">)</span>
		<span class="n">discard</span><span class="o">-&gt;</span><span class="n">revisit</span><span class="p">(</span><span class="n">discard</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return true if and only if a deferred request is queued. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">cache_defer_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">thread_wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache_wait_req</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dreq</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">defer</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dreq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">setup_deferral</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="cm">/* Bit could have been cleared before we managed to</span>
<span class="cm">		 * set up the deferral, so need to revisit just in case</span>
<span class="cm">		 */</span>
		<span class="n">cache_revisit_request</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

	<span class="n">cache_limit_defers</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_revisit_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">DFR_HASH</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_defer_hash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">hash</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">==</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__unhash_deferred_req</span><span class="p">(</span><span class="n">dreq</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dreq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pending</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_deferred_req</span><span class="p">,</span> <span class="n">recent</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">);</span>
		<span class="n">dreq</span><span class="o">-&gt;</span><span class="n">revisit</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cache_clean_deferred</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span><span class="n">dreq</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pending</span><span class="p">;</span>


	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_defer_list</span><span class="p">,</span> <span class="n">recent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__unhash_deferred_req</span><span class="p">(</span><span class="n">dreq</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_defer_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dreq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pending</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_deferred_req</span><span class="p">,</span> <span class="n">recent</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">recent</span><span class="p">);</span>
		<span class="n">dreq</span><span class="o">-&gt;</span><span class="n">revisit</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * communicate with user-space</span>
<span class="cm"> *</span>
<span class="cm"> * We have a magic /proc file - /proc/sunrpc/&lt;cachename&gt;/channel.</span>
<span class="cm"> * On read, you get a full request, or block.</span>
<span class="cm"> * On write, an update request is processed.</span>
<span class="cm"> * Poll works if anything to read, and always allows write.</span>
<span class="cm"> *</span>
<span class="cm"> * Implemented by linked list of requests.  Each open file has</span>
<span class="cm"> * a -&gt;private that also exists in this list.  New requests are added</span>
<span class="cm"> * to the end and may wakeup and preceding readers.</span>
<span class="cm"> * New readers are added to the head.  If, on read, an item is found with</span>
<span class="cm"> * CACHE_UPCALLING clear, we free it from the list.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">queue_io_mutex</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">cache_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">reader</span><span class="p">;</span>	<span class="cm">/* if 0, then request */</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">cache_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_queue</span>	<span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_head</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">readers</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">cache_reader</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_queue</span>	<span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">offset</span><span class="p">;</span>	<span class="cm">/* if non-0, we have a refcnt on next request */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			  <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_reader</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span> <span class="cm">/* protect against multiple concurrent</span>
<span class="cm">			      * readers on this file */</span>
 <span class="nl">again:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* need to find next request */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">&amp;&amp;</span>
	       <span class="n">list_entry</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	       <span class="o">-&gt;</span><span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_request</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">reader</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* need to release rq */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CACHE_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="n">cache_put</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span>  <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_do_downcall</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">kaddr</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_parse</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_slow_downcall</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">write_buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span> <span class="cm">/* protected by queue_io_mutex */</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">write_buf</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_io_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_do_downcall</span><span class="p">(</span><span class="n">write_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_io_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_downcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_slow</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_slow</span><span class="p">;</span>

	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_do_downcall</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_slow:</span>
	<span class="k">return</span> <span class="n">cache_slow_downcall</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_parse</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_downcall</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">queue_wait</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cache_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_reader</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/* alway allow write */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">POLL_OUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cq</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	     <span class="n">cq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_reader</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">FIONREAD</span> <span class="o">||</span> <span class="o">!</span><span class="n">rp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="cm">/* only find the length remaining in current request,</span>
<span class="cm">	 * or the length of the next request</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cq</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	     <span class="n">cq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cache_request</span> <span class="o">*</span><span class="n">cr</span> <span class="o">=</span>
				<span class="n">container_of</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_request</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">cr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_reader</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cd</span> <span class="o">||</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">reader</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_reader</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cache_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">cq</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
			     <span class="n">cq</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">container_of</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_request</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
						<span class="o">-&gt;</span><span class="n">readers</span><span class="o">--</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>

		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">last_close</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">();</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cache_request</span> <span class="o">*</span><span class="n">cr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_request</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">!=</span> <span class="n">ch</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="n">cache_put</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">detail</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Support routines for text-based upcalls.</span>
<span class="cm"> * Fields are separated by spaces.</span>
<span class="cm"> * Fields are either mangled to quote space tab newline slosh with slosh</span>
<span class="cm"> * or a hexified with a leading \x</span>
<span class="cm"> * Record is terminated with newline.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">qword_add</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">bpp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">*</span><span class="n">bpp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">c</span><span class="o">=*</span><span class="n">str</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39; &#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;\t&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;\n&#39;</span>:
		<span class="k">case</span> <span class="sc">&#39;\\&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
				<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">0300</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">6</span><span class="p">);</span>
				<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">0070</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">);</span>
				<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">0007</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
			<span class="n">len</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">qword_add</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">qword_addhex</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">bpp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">*</span><span class="n">bpp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
		<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">blen</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span><span class="o">&amp;</span><span class="mh">0xf0</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span><span class="o">&gt;=</span><span class="mh">0xa0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="o">-</span><span class="sc">&#39;9&#39;</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">)</span><span class="o">&gt;=</span><span class="mh">0x0a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="o">-</span><span class="sc">&#39;9&#39;</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">blen</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blen</span> <span class="o">||</span> <span class="n">len</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">qword_addhex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">warn_no_listener</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_warn</span> <span class="o">!=</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_close</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_warn</span> <span class="o">=</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_close</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">warn_no_listener</span><span class="p">)</span>
			<span class="n">detail</span><span class="o">-&gt;</span><span class="n">warn_no_listener</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_close</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cache_listeners_exist</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_close</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* This cache was never opened */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">last_close</span> <span class="o">&lt;</span> <span class="n">seconds_since_boot</span><span class="p">()</span> <span class="o">-</span> <span class="mi">30</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We allow for the possibility that someone might</span>
<span class="cm">		 * restart a userspace daemon without restarting the</span>
<span class="cm">		 * server; but after 30 seconds, we give up.</span>
<span class="cm">		 */</span>
		 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * register an upcall request to user-space and queue it up for read() by the</span>
<span class="cm"> * upcall daemon.</span>
<span class="cm"> *</span>
<span class="cm"> * Each request is at most one page long.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sunrpc_cache_pipe_upcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">detail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cache_request</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">**</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_request</span> <span class="o">*</span><span class="n">crq</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_listeners_exist</span><span class="p">(</span><span class="n">detail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">warn_no_listener</span><span class="p">(</span><span class="n">detail</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">crq</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">crq</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">cache_request</span><span class="p">(</span><span class="n">detail</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">crq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">crq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">reader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">crq</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">cache_get</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">crq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">crq</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">crq</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_cache_pipe_upcall</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * parse a message from user-space and pass it</span>
<span class="cm"> * to an appropriate cache</span>
<span class="cm"> * Messages are, like requests, separated into fields by</span>
<span class="cm"> * spaces and dequotes as \xHEXSTRING or embedded \nnn octal</span>
<span class="cm"> *</span>
<span class="cm"> * Message is</span>
<span class="cm"> *   reply cachename expiry key ... content....</span>
<span class="cm"> *</span>
<span class="cm"> * key and content are both parsed by cache</span>
<span class="cm"> */</span>

<span class="cp">#define isodigit(c) (isdigit(c) &amp;&amp; c &lt;= &#39;7&#39;)</span>
<span class="kt">int</span> <span class="nf">qword_get</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">bpp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* return bytes copied, or -1 on error */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">*</span><span class="n">bpp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="n">bp</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">bp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* HEX STRING */</span>
		<span class="n">bp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">bufsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>

			<span class="n">h</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">l</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="o">*</span><span class="n">dest</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">l</span><span class="p">;</span>
			<span class="n">bp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* text with \nnn octal quoting */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bp</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bp</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">bufsize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span> <span class="o">&amp;&amp;</span>
			    <span class="n">isodigit</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">isodigit</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="n">isodigit</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="o">*++</span><span class="n">bp</span> <span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">);</span>
				<span class="n">bp</span><span class="o">++</span><span class="p">;</span>
				<span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
				<span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
				<span class="o">*</span><span class="n">dest</span><span class="o">++</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>
				<span class="n">len</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">dest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">bp</span><span class="o">++</span><span class="p">;</span>
				<span class="n">len</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bp</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">bp</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="n">bp</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">qword_get</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * support /proc/sunrpc/cache/$CACHENAME/content</span>
<span class="cm"> * as a seqfile.</span>
<span class="cm"> * We call -&gt;cache_show passing NULL for the item to</span>
<span class="cm"> * get a header, then pass each real item in the cache</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">handle</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">c_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">handle</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">;</span>


	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span> <span class="n">ch</span><span class="p">;</span> <span class="n">ch</span><span class="o">=</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">--</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">hash</span><span class="o">++</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">&amp;&amp;</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">]</span><span class="o">==</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">c_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">handle</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pos</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">&amp;&amp;</span>
	       <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1LL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">c_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">handle</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">c_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">handle</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ifdebug</span><span class="p">(</span><span class="n">CACHE</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# expiry=%ld refcnt=%d flags=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">convert_to_wallclock</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">expiry_time</span><span class="p">),</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">.</span><span class="n">refcount</span><span class="p">),</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cache_get</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_check</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="cm">/* cache_check does a cache_put on failure */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# &quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cache_put</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cache_content_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">c_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">c_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">c_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">c_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">content_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">handle</span> <span class="o">*</span><span class="n">han</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cd</span> <span class="o">||</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">han</span> <span class="o">=</span> <span class="n">__seq_open_private</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_content_op</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">han</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">han</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">han</span><span class="o">-&gt;</span><span class="n">cd</span> <span class="o">=</span> <span class="n">cd</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">content_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">seq_release_private</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">open_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cd</span> <span class="o">||</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">release_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tbuf</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">convert_to_wallclock</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">flush_time</span><span class="p">));</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">tbuf</span><span class="o">+</span><span class="n">p</span><span class="p">),</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tbuf</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tbuf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">tbuf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">simple_strtoul</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ep</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">ep</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">tbuf</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">flush_time</span> <span class="o">=</span> <span class="n">get_expiry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">nextcheck</span> <span class="o">=</span> <span class="n">seconds_since_boot</span><span class="p">();</span>
	<span class="n">cache_flush</span><span class="p">();</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_read_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_read</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_write_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_write</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cache_poll_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_poll</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">cache_ioctl_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_ioctl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_open_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_release_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cache_file_operations_procfs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">cache_read_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">cache_write_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">cache_poll_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">cache_ioctl_procfs</span><span class="p">,</span> <span class="cm">/* for FIONREAD */</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">cache_open_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">cache_release_procfs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">content_open_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">content_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">content_release_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">content_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">content_file_operations_procfs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">content_open_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">content_release_procfs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">open_flush_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">open_flush</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">release_flush_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">release_flush</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_flush_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">read_flush</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_flush_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">write_flush</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cache_flush_operations_procfs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">open_flush_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">read_flush_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">write_flush_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">release_flush_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_cache_proc_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sunrpc_net</span> <span class="o">*</span><span class="n">sn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">flush_ent</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;flush&quot;</span><span class="p">,</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">channel_ent</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;channel&quot;</span><span class="p">,</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">content_ent</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunrpc_net_id</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sn</span><span class="o">-&gt;</span><span class="n">proc_net_rpc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_cache_proc_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sunrpc_net</span> <span class="o">*</span><span class="n">sn</span><span class="p">;</span>

	<span class="n">sn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunrpc_net_id</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sn</span><span class="o">-&gt;</span><span class="n">proc_net_rpc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">channel_ent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">content_ent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">proc_create_data</span><span class="p">(</span><span class="s">&quot;flush&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span>
			     <span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">cache_flush_operations_procfs</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">flush_ent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_upcall</span> <span class="o">||</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_parse</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">proc_create_data</span><span class="p">(</span><span class="s">&quot;channel&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span>
				     <span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cache_file_operations_procfs</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">channel_ent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">cache_show</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">proc_create_data</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span>
				<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">proc_ent</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">content_file_operations_procfs</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">procfs</span><span class="p">.</span><span class="n">content_ent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_nomem:</span>
	<span class="n">remove_cache_proc_entries</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_cache_proc_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">cache_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_DELAYED_WORK_DEFERRABLE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_cleaner</span><span class="p">,</span> <span class="n">do_cache_clean</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cache_register_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sunrpc_init_cache_detail</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">create_cache_proc_entries</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">sunrpc_destroy_cache_detail</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_register_net</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cache_unregister_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_cache_proc_entries</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">sunrpc_destroy_cache_detail</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_unregister_net</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="nf">cache_create_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>

	<span class="n">cd</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">tmpl</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_head</span> <span class="o">*</span><span class="p">),</span>
				 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_create_net</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cache_destroy_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cache_destroy_net</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_read_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_read</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_write_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_write</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cache_poll_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_poll</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">cache_ioctl_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_ioctl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_open_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_release_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cache_file_operations_pipefs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">cache_read_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">cache_write_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">cache_poll_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">cache_ioctl_pipefs</span><span class="p">,</span> <span class="cm">/* for FIONREAD */</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">cache_open_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">cache_release_pipefs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">content_open_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">content_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">content_release_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">content_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">content_file_operations_pipefs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">content_open_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">content_release_pipefs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">open_flush_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">open_flush</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">release_flush_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">release_flush</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_flush_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">read_flush</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_flush_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">RPC_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">write_flush</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cache_flush_operations_pipefs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">open_flush_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">read_flush_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">write_flush_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">release_flush_pipefs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sunrpc_cache_register_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">umode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">q</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">q</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">rpc_create_cache_dir</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">umode</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pipefs</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dir</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_cache_register_pipefs</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sunrpc_cache_unregister_pipefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_detail</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rpc_remove_cache_dir</span><span class="p">(</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pipefs</span><span class="p">.</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">pipefs</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sunrpc_cache_unregister_pipefs</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
