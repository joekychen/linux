<!DOCTYPE html>
<html><head><title>joekychen/linux » net › bridge › br_netfilter.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>br_netfilter.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Handle firewalling</span>
<span class="cm"> *	Linux ethernet bridge</span>
<span class="cm"> *</span>
<span class="cm"> *	Authors:</span>
<span class="cm"> *	Lennert Buytenhek		&lt;buytenh@gnu.org&gt;</span>
<span class="cm"> *	Bart De Schuymer		&lt;bdschuym@pandora.be&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	Lennert dedicates this file to Kerstin Wurdinger.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/if_pppox.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_defs.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_bridge.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv4.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_arp.h&gt;</span>
<span class="cp">#include &lt;linux/in_route.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>

<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &quot;br_private.h&quot;</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define skb_origaddr(skb)	 (((struct bridge_skb_cb *) \</span>
<span class="cp">				 (skb-&gt;nf_bridge-&gt;data))-&gt;daddr.ipv4)</span>
<span class="cp">#define store_orig_dstaddr(skb)	 (skb_origaddr(skb) = ip_hdr(skb)-&gt;daddr)</span>
<span class="cp">#define dnat_took_place(skb)	 (skb_origaddr(skb) != ip_hdr(skb)-&gt;daddr)</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">brnf_sysctl_header</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">brnf_call_iptables</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">brnf_call_ip6tables</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">brnf_call_arptables</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">brnf_filter_vlan_tagged</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">brnf_filter_pppoe_tagged</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">brnf_pass_vlan_indev</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define brnf_call_iptables 1</span>
<span class="cp">#define brnf_call_ip6tables 1</span>
<span class="cp">#define brnf_call_arptables 1</span>
<span class="cp">#define brnf_filter_vlan_tagged 0</span>
<span class="cp">#define brnf_filter_pppoe_tagged 0</span>
<span class="cp">#define brnf_pass_vlan_indev 0</span>
<span class="cp">#endif</span>

<span class="cp">#define IS_IP(skb) \</span>
<span class="cp">	(!vlan_tx_tag_present(skb) &amp;&amp; skb-&gt;protocol == htons(ETH_P_IP))</span>

<span class="cp">#define IS_IPV6(skb) \</span>
<span class="cp">	(!vlan_tx_tag_present(skb) &amp;&amp; skb-&gt;protocol == htons(ETH_P_IPV6))</span>

<span class="cp">#define IS_ARP(skb) \</span>
<span class="cp">	(!vlan_tx_tag_present(skb) &amp;&amp; skb-&gt;protocol == htons(ETH_P_ARP))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be16</span> <span class="nf">vlan_proto</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vlan_eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IS_VLAN_IP(skb) \</span>
<span class="cp">	(vlan_proto(skb) == htons(ETH_P_IP) &amp;&amp; \</span>
<span class="cp">	 brnf_filter_vlan_tagged)</span>

<span class="cp">#define IS_VLAN_IPV6(skb) \</span>
<span class="cp">	(vlan_proto(skb) == htons(ETH_P_IPV6) &amp;&amp; \</span>
<span class="cp">	 brnf_filter_vlan_tagged)</span>

<span class="cp">#define IS_VLAN_ARP(skb) \</span>
<span class="cp">	(vlan_proto(skb) == htons(ETH_P_ARP) &amp;&amp;	\</span>
<span class="cp">	 brnf_filter_vlan_tagged)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be16</span> <span class="nf">pppoe_proto</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pppoe_hdr</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cp">#define IS_PPPOE_IP(skb) \</span>
<span class="cp">	(skb-&gt;protocol == htons(ETH_P_PPP_SES) &amp;&amp; \</span>
<span class="cp">	 pppoe_proto(skb) == htons(PPP_IP) &amp;&amp; \</span>
<span class="cp">	 brnf_filter_pppoe_tagged)</span>

<span class="cp">#define IS_PPPOE_IPV6(skb) \</span>
<span class="cp">	(skb-&gt;protocol == htons(ETH_P_PPP_SES) &amp;&amp; \</span>
<span class="cp">	 pppoe_proto(skb) == htons(PPP_IPV6) &amp;&amp; \</span>
<span class="cp">	 brnf_filter_pppoe_tagged)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fake_update_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mtu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="o">*</span><span class="nf">fake_cow_metrics</span><span class="p">(</span><span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="nf">fake_neigh_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">daddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fake_mtu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dst_ops</span> <span class="n">fake_dst_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">protocol</span> <span class="o">=</span>		<span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">),</span>
	<span class="p">.</span><span class="n">update_pmtu</span> <span class="o">=</span>		<span class="n">fake_update_pmtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cow_metrics</span> <span class="o">=</span>		<span class="n">fake_cow_metrics</span><span class="p">,</span>
	<span class="p">.</span><span class="n">neigh_lookup</span> <span class="o">=</span>		<span class="n">fake_neigh_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mtu</span> <span class="o">=</span>			<span class="n">fake_mtu</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize bogus route table used to keep netfilter happy.</span>
<span class="cm"> * Currently, we fill in the PMTU entry because netfilter</span>
<span class="cm"> * refragmentation needs it, and the rt_flags entry because</span>
<span class="cm"> * ipt_REJECT needs it.  Future netfilter modules might</span>
<span class="cm"> * require us to fill additional fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">br_dst_default_metrics</span><span class="p">[</span><span class="n">RTAX_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">RTAX_MTU</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">br_netfilter_rtable_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">fake_rtable</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">__refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>
	<span class="n">dst_init_metrics</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">br_dst_default_metrics</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">DST_NOXFRM</span> <span class="o">|</span> <span class="n">DST_NOPEER</span> <span class="o">|</span> <span class="n">DST_FAKE_RTABLE</span><span class="p">;</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_dst_ops</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="nf">bridge_parent_rtable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">port</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">fake_rtable</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">bridge_parent</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">port</span> <span class="o">?</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="nf">nf_bridge_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_bridge_info</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">))</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="nf">nf_bridge_unshare</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">nf_bridge_alloc</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">nf_bridge</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_bridge_info</span><span class="p">));</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nf_bridge_put</span><span class="p">(</span><span class="n">nf_bridge</span><span class="p">);</span>
		<span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nf_bridge</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_push_encap_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_pull_encap_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_pull_encap_header_rcsum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb_pull_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_save_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">header_size</span> <span class="o">=</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">header_size</span><span class="p">,</span>
					 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">header_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_update_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_8021Q</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_PPPoE</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_PPP_SES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* When handing a packet over to the IP layer</span>
<span class="cm"> * check whether we have a skb that is in the</span>
<span class="cm"> * expected format</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_parse_ip_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_options</span> <span class="o">*</span><span class="n">opt</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">opt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">IPCB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">);</span>

	<span class="cm">/* Basic sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">inhdr_error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">inhdr_error</span><span class="p">;</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ip_fast_csum</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">inhdr_error</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IP_INC_STATS_BH</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">IPSTATS_MIB_INTRUNCATEDPKTS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">inhdr_error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pskb_trim_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IP_INC_STATS_BH</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">IPSTATS_MIB_INDISCARDS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">IPCB</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_skb_parm</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">opt</span><span class="o">-&gt;</span><span class="n">optlen</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_options_compile</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">opt</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">inhdr_error</span><span class="p">;</span>

	<span class="cm">/* Check correct handling of SRR option */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">srr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_dev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IN_DEV_SOURCE_ROUTE</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ip_options_rcv_srr</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">inhdr_error:</span>
	<span class="n">IP_INC_STATS_BH</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">IPSTATS_MIB_INHDRERRORS</span><span class="p">);</span>
<span class="nl">drop:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fill in the header for fragmented IP packets handled by</span>
<span class="cm"> * the IPv4 connection tracking code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nf_bridge_copy_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_size</span><span class="p">;</span>

	<span class="n">nf_bridge_update_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">header_size</span> <span class="o">=</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_cow_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">header_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">header_size</span><span class="p">,</span>
				       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">header_size</span><span class="p">);</span>
	<span class="n">__skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* PF_BRIDGE/PRE_ROUTING *********************************************/</span>
<span class="cm">/* Undo the changes made for ip6tables PREROUTING and continue the</span>
<span class="cm"> * bridge PRE_ROUTING hook. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_nf_pre_routing_finish_ipv6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OTHERHOST</span><span class="p">;</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">^=</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">^=</span> <span class="n">BRNF_NF_BRIDGE_PREROUTING</span><span class="p">;</span>

	<span class="n">rt</span> <span class="o">=</span> <span class="n">bridge_parent_rtable</span><span class="p">(</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_dst_set_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">;</span>
	<span class="n">nf_bridge_update_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">nf_bridge_push_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">NF_HOOK_THRESH</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">NF_BR_PRE_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		       <span class="n">br_handle_frame_finish</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Obtain the correct destination MAC address, while preserving the original</span>
<span class="cm"> * source MAC address. If we already know this address, we just copy it. If we</span>
<span class="cm"> * don&#39;t, we use the neighbour framework to find out. In both cases, we make</span>
<span class="cm"> * sure that br_handle_frame_finish() is called afterwards.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_nf_pre_routing_finish_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bridge_parent</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_skb</span><span class="p">;</span>
	<span class="n">dst</span> <span class="o">=</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">neigh</span> <span class="o">=</span> <span class="n">dst_get_neighbour_noref</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">hh</span><span class="p">.</span><span class="n">hh_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">neigh_hh_bridge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">hh</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">br_handle_frame_finish</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* the neighbour function below overwrites the complete</span>
<span class="cm">		 * MAC header, so we save the Ethernet source address and</span>
<span class="cm">		 * protocol number. */</span>
		<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">ETH_HLEN</span><span class="o">-</span><span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="o">-</span><span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="cm">/* tell br_dev_xmit to continue with forwarding */</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_BRIDGED_DNAT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">free_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This requires some explaining. If DNAT has taken place,</span>
<span class="cm"> * we will need to fix up the destination Ethernet address.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two cases to consider:</span>
<span class="cm"> * 1. The packet was DNAT&#39;ed to a device in the same bridge</span>
<span class="cm"> *    port group as it was received on. We can still bridge</span>
<span class="cm"> *    the packet.</span>
<span class="cm"> * 2. The packet was DNAT&#39;ed to a different device, either</span>
<span class="cm"> *    a non-bridged device or another bridge port group.</span>
<span class="cm"> *    The packet will need to be routed.</span>
<span class="cm"> *</span>
<span class="cm"> * The correct way of distinguishing between these two cases is to</span>
<span class="cm"> * call ip_route_input() and to look at skb-&gt;dst-&gt;dev, which is</span>
<span class="cm"> * changed to the destination device if ip_route_input() succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * Let&#39;s first consider the case that ip_route_input() succeeds:</span>
<span class="cm"> *</span>
<span class="cm"> * If the output device equals the logical bridge device the packet</span>
<span class="cm"> * came in on, we can consider this bridging. The corresponding MAC</span>
<span class="cm"> * address will be obtained in br_nf_pre_routing_finish_bridge.</span>
<span class="cm"> * Otherwise, the packet is considered to be routed and we just</span>
<span class="cm"> * change the destination MAC address so that the packet will</span>
<span class="cm"> * later be passed up to the IP stack to be routed. For a redirected</span>
<span class="cm"> * packet, ip_route_input() will give back the localhost as output device,</span>
<span class="cm"> * which differs from the bridge device.</span>
<span class="cm"> *</span>
<span class="cm"> * Let&#39;s now consider the case that ip_route_input() fails:</span>
<span class="cm"> *</span>
<span class="cm"> * This can be because the destination address is martian, in which case</span>
<span class="cm"> * the packet will be dropped.</span>
<span class="cm"> * If IP forwarding is disabled, ip_route_input() will fail, while</span>
<span class="cm"> * ip_route_output_key() can return success. The source</span>
<span class="cm"> * address for ip_route_output_key() is set to zero, so ip_route_output_key()</span>
<span class="cm"> * thinks we&#39;re handling a locally generated packet and won&#39;t care</span>
<span class="cm"> * if IP forwarding is enabled. If the output device equals the logical bridge</span>
<span class="cm"> * device, we proceed as if ip_route_input() succeeded. If it differs from the</span>
<span class="cm"> * logical bridge port or if ip_route_output_key() fails we drop the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_nf_pre_routing_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OTHERHOST</span><span class="p">;</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">^=</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">^=</span> <span class="n">BRNF_NF_BRIDGE_PREROUTING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dnat_took_place</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">ip_route_input</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">tos</span><span class="p">,</span> <span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="cm">/* If err equals -EHOSTUNREACH the error is due to a</span>
<span class="cm">			 * martian destination or due to the fact that</span>
<span class="cm">			 * forwarding is disabled. For most martian packets,</span>
<span class="cm">			 * ip_route_output_key() will fail. It won&#39;t fail for 2 types of</span>
<span class="cm">			 * martian destinations: loopback destinations and destination</span>
<span class="cm">			 * 0.0.0.0. In both cases the packet will be dropped because the</span>
<span class="cm">			 * destination is the loopback device and not the bridge. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span> <span class="o">||</span> <span class="o">!</span><span class="n">in_dev</span> <span class="o">||</span> <span class="n">IN_DEV_FORWARD</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">free_skb</span><span class="p">;</span>

			<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">RT_TOS</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">tos</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* - Bridged-and-DNAT&#39;ed traffic doesn&#39;t</span>
<span class="cm">				 *   require ip_forwarding. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">skb_dst_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">bridged_dnat</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
			<span class="p">}</span>
<span class="nl">free_skb:</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">bridged_dnat:</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">;</span>
				<span class="n">nf_bridge_update_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">nf_bridge_push_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">NF_HOOK_THRESH</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span>
					       <span class="n">NF_BR_PRE_ROUTING</span><span class="p">,</span>
					       <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					       <span class="n">br_nf_pre_routing_finish_bridge</span><span class="p">,</span>
					       <span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_HOST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rt</span> <span class="o">=</span> <span class="n">bridge_parent_rtable</span><span class="p">(</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb_dst_set_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">;</span>
	<span class="n">nf_bridge_update_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">nf_bridge_push_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">NF_HOOK_THRESH</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">NF_BR_PRE_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		       <span class="n">br_handle_frame_finish</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">brnf_get_logical_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">vlan</span><span class="p">,</span> <span class="o">*</span><span class="n">br</span><span class="p">;</span>

	<span class="n">br</span> <span class="o">=</span> <span class="n">bridge_parent</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">brnf_pass_vlan_indev</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">br</span><span class="p">;</span>

	<span class="n">vlan</span> <span class="o">=</span> <span class="n">__vlan_find_dev_deep</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VLAN_VID_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vlan</span> <span class="o">?</span> <span class="n">vlan</span> <span class="o">:</span> <span class="n">br</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some common code for IPv4/IPv6 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">setup_pre_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_OTHERHOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_HOST</span><span class="p">;</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_NF_BRIDGE_PREROUTING</span><span class="p">;</span>
	<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">brnf_get_logical_dev</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_8021Q</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_PPP_SES</span><span class="p">))</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_PPPoE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We only check the length. A bridge shouldn&#39;t do any hop-by-hop stuff anyway */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_hbh_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">pkt_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nh</span> <span class="o">=</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">raw</span> <span class="o">-</span> <span class="n">nh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">raw</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">optlen</span> <span class="o">=</span> <span class="n">nh</span><span class="p">[</span><span class="n">off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">nh</span><span class="p">[</span><span class="n">off</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IPV6_TLV_PAD1</span>:
			<span class="n">optlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IPV6_TLV_PADN</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IPV6_TLV_JUMBO</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">nh</span><span class="p">[</span><span class="n">off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">||</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;=</span> <span class="n">IPV6_MAXPLEN</span> <span class="o">||</span>
			    <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pskb_trim_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					    <span class="n">pkt_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="n">nh</span> <span class="o">=</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="n">optlen</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">optlen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">bad:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* Replicate the checks that IPv6 does on packet reception and pass the packet</span>
<span class="cm"> * to ip6tables, which doesn&#39;t support NAT, so things are fairly simple. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">br_nf_pre_routing_ipv6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pkt_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">payload_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">||</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">!=</span> <span class="n">NEXTHDR_HOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pskb_trim_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">NEXTHDR_HOP</span> <span class="o">&amp;&amp;</span> <span class="n">check_hbh_len</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">nf_bridge_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_bridge_alloc</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup_pre_routing</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">);</span>
	<span class="n">NF_HOOK</span><span class="p">(</span><span class="n">NFPROTO_IPV6</span><span class="p">,</span> <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="n">br_nf_pre_routing_finish_ipv6</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Direct IPv6 traffic to br_nf_pre_routing_ipv6.</span>
<span class="cm"> * Replicate the checks that IPv4 does on packet reception.</span>
<span class="cm"> * Set skb-&gt;dev to the bridge device (i.e. parent of the</span>
<span class="cm"> * receiving device) to make netfilter happy, the REDIRECT</span>
<span class="cm"> * target in particular.  Save the original destination IP</span>
<span class="cm"> * address to be able to detect DNAT afterwards. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">br_nf_pre_routing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nf_bridge_encap_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="n">br</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_VLAN_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_PPPOE_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brnf_call_ip6tables</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">nf_call_ip6tables</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

		<span class="n">nf_bridge_pull_encap_header_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">br_nf_pre_routing_ipv6</span><span class="p">(</span><span class="n">hook</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">okfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brnf_call_iptables</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">nf_call_iptables</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_VLAN_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_PPPOE_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">nf_bridge_pull_encap_header_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_parse_ip_options</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">nf_bridge_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_bridge_alloc</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup_pre_routing</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="n">store_orig_dstaddr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>

	<span class="n">NF_HOOK</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="n">br_nf_pre_routing_finish</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* PF_BRIDGE/LOCAL_IN ************************************************/</span>
<span class="cm">/* The packet is locally destined, which requires a real</span>
<span class="cm"> * dst_entry, so detach the fake one.  On the way up, the</span>
<span class="cm"> * packet would pass through PRE_ROUTING again (which already</span>
<span class="cm"> * took place when the packet entered the bridge), but we</span>
<span class="cm"> * register an IPv4 PRE_ROUTING &#39;sabotage&#39; hook that will</span>
<span class="cm"> * prevent this from happening. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">br_nf_local_in</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">br_drop_fake_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* PF_BRIDGE/FORWARD *************************************************/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_nf_forward_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ARP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_VLAN_ARP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">in</span> <span class="o">=</span> <span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physindev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OTHERHOST</span><span class="p">;</span>
			<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">^=</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nf_bridge_update_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">in</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">nf_bridge_push_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">NF_HOOK_THRESH</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">NF_BR_FORWARD</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span>
		       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">br_forward_finish</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* This is the &#39;purely bridged&#39; case.  For IP, we pass the packet to</span>
<span class="cm"> * netfilter with indev and outdev set to the bridge device,</span>
<span class="cm"> * but we are still able to filter on the &#39;real&#39; indev/outdev</span>
<span class="cm"> * because of the physdev module. For ARP, indev and outdev are the</span>
<span class="cm"> * bridge ports. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">br_nf_forward_ip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* Need exclusive nf_bridge_info since we might have multiple</span>
<span class="cm">	 * different physoutdevs. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_bridge_unshare</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">bridge_parent</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_VLAN_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_PPPOE_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_VLAN_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_PPPOE_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET6</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">nf_bridge_pull_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_OTHERHOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_HOST</span><span class="p">;</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pf</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">br_parse_ip_options</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="cm">/* The physdev module checks on this */</span>
	<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_BRIDGED</span><span class="p">;</span>
	<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">physoutdev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pf</span> <span class="o">==</span> <span class="n">PF_INET</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">);</span>

	<span class="n">NF_HOOK</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">NF_INET_FORWARD</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">brnf_get_logical_dev</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="p">),</span> <span class="n">parent</span><span class="p">,</span>
		<span class="n">br_nf_forward_finish</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">br_nf_forward_arp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">br</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brnf_call_arptables</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">nf_call_arptables</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ARP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_VLAN_ARP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="n">nf_bridge_pull_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ar_pln</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_VLAN_ARP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">nf_bridge_push_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">;</span>
	<span class="n">NF_HOOK</span><span class="p">(</span><span class="n">NFPROTO_ARP</span><span class="p">,</span> <span class="n">NF_ARP_FORWARD</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">in</span><span class="p">,</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">out</span><span class="p">,</span> <span class="n">br_nf_forward_finish</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_nf_dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">nf_bridge_mtu_reduction</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">br_parse_ip_options</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="cm">/* Drop invalid packet */</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ip_fragment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">br_dev_queue_push_xmit</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">br_dev_queue_push_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">br_nf_dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">br_dev_queue_push_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* PF_BRIDGE/POST_ROUTING ********************************************/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">br_nf_post_routing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">realoutdev</span> <span class="o">=</span> <span class="n">bridge_parent</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_bridge</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_BRIDGED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realoutdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_VLAN_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_PPPOE_IP</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_VLAN_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_PPPOE_IPV6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET6</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* We assume any code from br_dev_queue_push_xmit onwards doesn&#39;t care</span>
<span class="cm">	 * about the value of skb-&gt;pkt_type. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_OTHERHOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_HOST</span><span class="p">;</span>
		<span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">BRNF_PKT_TYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nf_bridge_pull_encap_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">nf_bridge_save_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pf</span> <span class="o">==</span> <span class="n">PF_INET</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">);</span>

	<span class="n">NF_HOOK</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">realoutdev</span><span class="p">,</span>
		<span class="n">br_nf_dev_queue_xmit</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* IP/SABOTAGE *****************************************************/</span>
<span class="cm">/* Don&#39;t hand locally destined packets to PF_INET(6)/PRE_ROUTING</span>
<span class="cm"> * for the second time. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ip_sabotage_in</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">BRNF_NF_BRIDGE_PREROUTING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">NF_STOP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For br_nf_post_routing, we need (prio = NF_BR_PRI_LAST), because</span>
<span class="cm"> * br_dev_queue_push_xmit is called afterwards */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">br_nf_ops</span><span class="p">[]</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">br_nf_pre_routing</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_BRIDGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_BR_PRE_ROUTING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_BR_PRI_BRNF</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">br_nf_local_in</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_BRIDGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_BR_LOCAL_IN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_BR_PRI_BRNF</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">br_nf_forward_ip</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_BRIDGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_BR_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_BR_PRI_BRNF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">br_nf_forward_arp</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_BRIDGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_BR_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_BR_PRI_BRNF</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">br_nf_post_routing</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_BRIDGE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_BR_POST_ROUTING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_BR_PRI_LAST</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">ip_sabotage_in</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_IP_PRI_FIRST</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">ip_sabotage_in</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_IP6_PRI_FIRST</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">brnf_sysctl_call_tables</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span> <span class="n">ctl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">ctl</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">brnf_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;bridge-nf-call-arptables&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">brnf_call_arptables</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">brnf_sysctl_call_tables</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;bridge-nf-call-iptables&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">brnf_call_iptables</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">brnf_sysctl_call_tables</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;bridge-nf-call-ip6tables&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">brnf_call_ip6tables</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">brnf_sysctl_call_tables</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;bridge-nf-filter-vlan-tagged&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">brnf_filter_vlan_tagged</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">brnf_sysctl_call_tables</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;bridge-nf-filter-pppoe-tagged&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">brnf_filter_pppoe_tagged</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">brnf_sysctl_call_tables</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;bridge-nf-pass-vlan-input-dev&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">brnf_pass_vlan_indev</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">brnf_sysctl_call_tables</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">br_netfilter_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dst_entries_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_dst_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_register_hooks</span><span class="p">(</span><span class="n">br_nf_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">br_nf_ops</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dst_entries_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_dst_ops</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="n">brnf_sysctl_header</span> <span class="o">=</span> <span class="n">register_net_sysctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="s">&quot;net/bridge&quot;</span><span class="p">,</span> <span class="n">brnf_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">brnf_sysctl_header</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;br_netfilter: can&#39;t register to sysctl.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nf_unregister_hooks</span><span class="p">(</span><span class="n">br_nf_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">br_nf_ops</span><span class="p">));</span>
		<span class="n">dst_entries_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_dst_ops</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Bridge firewalling registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">br_netfilter_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nf_unregister_hooks</span><span class="p">(</span><span class="n">br_nf_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">br_nf_ops</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="n">unregister_net_sysctl_table</span><span class="p">(</span><span class="n">brnf_sysctl_header</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dst_entries_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_dst_ops</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
