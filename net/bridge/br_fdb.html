<!DOCTYPE html>
<html><head><title>joekychen/linux » net › bridge › br_fdb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>br_fdb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Forwarding database</span>
<span class="cm"> *	Linux ethernet bridge</span>
<span class="cm"> *</span>
<span class="cm"> *	Authors:</span>
<span class="cm"> *	Lennert Buytenhek		&lt;buytenh@gnu.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/times.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;br_private.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">br_fdb_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fdb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fdb_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">fdb_salt</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">br_fdb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">br_fdb_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;bridge_fdb_cache&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span>
					 <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">br_fdb_cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdb_salt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fdb_salt</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">br_fdb_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">br_fdb_cache</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* if topology_changing then use forward_delay (default 15 sec)</span>
<span class="cm"> * otherwise keep longer (default 5 minutes)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hold_time</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">topology_change</span> <span class="o">?</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">forward_delay</span> <span class="o">:</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">ageing_time</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">has_expired</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">&amp;&amp;</span>
		<span class="n">time_before_eq</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">updated</span> <span class="o">+</span> <span class="n">hold_time</span><span class="p">(</span><span class="n">br</span><span class="p">),</span> <span class="n">jiffies</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">br_mac_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use 1 byte of OUI cnd 3 bytes of NIC */</span>
	<span class="n">u32</span> <span class="n">key</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">mac</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">jhash_1word</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fdb_salt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BR_HASH_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fdb_rcu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">ent</span>
		<span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">br_fdb_cache</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fdb_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">fdb_notify</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">RTM_DELNEIGH</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">fdb_rcu_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">br_fdb_changeaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

	<span class="cm">/* Search all chains since old address/hash is unknown */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BR_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
		<span class="n">hlist_for_each</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

			<span class="n">f</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span><span class="p">,</span> <span class="n">hlist</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">==</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* maybe another port has same hw addr? */</span>
				<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
				<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">port_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span>
					    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
							     <span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">insert</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="cm">/* delete old one */</span>
				<span class="n">fdb_delete</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">insert</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">insert:</span>
	<span class="cm">/* insert new address,  may fail if invalid address or dup. */</span>
	<span class="n">fdb_insert</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">newaddr</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">br_fdb_change_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">newaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

	<span class="cm">/* If old entry was unassociated with any port, then delete it. */</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">__br_fdb_get</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span>
		<span class="n">fdb_delete</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="n">fdb_insert</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">newaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">br_fdb_cleanup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="p">)</span><span class="n">_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">hold_time</span><span class="p">(</span><span class="n">br</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_timer</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">ageing_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BR_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_timer</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">is_static</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">this_timer</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">updated</span> <span class="o">+</span> <span class="n">delay</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">this_timer</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span>
				<span class="n">fdb_delete</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">this_timer</span><span class="p">,</span> <span class="n">next_timer</span><span class="p">))</span>
				<span class="n">next_timer</span> <span class="o">=</span> <span class="n">this_timer</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">gc_timer</span><span class="p">,</span> <span class="n">round_jiffies_up</span><span class="p">(</span><span class="n">next_timer</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Completely flush all dynamic entries in forwarding database.*/</span>
<span class="kt">void</span> <span class="nf">br_fdb_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BR_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">is_static</span><span class="p">)</span>
				<span class="n">fdb_delete</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Flush all entries referring to a specific port.</span>
<span class="cm"> * if do_all is set also flush static entries</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">br_fdb_delete_by_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">do_all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BR_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>

		<span class="n">hlist_for_each_safe</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span>
				<span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span><span class="p">,</span> <span class="n">hlist</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">do_all</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * if multiple ports all have the same device address</span>
<span class="cm">			 * then when one port is deleted, assign</span>
<span class="cm">			 * the local entry to other port</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
				<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">port_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span>
					    <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
							     <span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">skip_delete</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">fdb_delete</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="nl">skip_delete:</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* No locking or refcounting, assumes caller has rcu_read_lock */</span>
<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="nf">__br_fdb_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">fdb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">br_mac_hash</span><span class="p">(</span><span class="n">addr</span><span class="p">)],</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">has_expired</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">fdb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_ATM_LANE)</span>
<span class="cm">/* Interface used by ATM LANE hook to test</span>
<span class="cm"> * if an addr is on some other bridge port */</span>
<span class="kt">int</span> <span class="nf">br_fdb_test_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">fdb</span> <span class="o">=</span> <span class="n">__br_fdb_get</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fdb</span> <span class="o">&amp;&amp;</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BR_STATE_FORWARDING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATM_LANE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Fill buffer with forwarding table records in</span>
<span class="cm"> * the API format.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">br_fdb_fillbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">skip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__fdb_entry</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxnum</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__fdb_entry</span><span class="p">));</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BR_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">maxnum</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">has_expired</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* ignore pseudo entry for local MAC address */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">--</span><span class="n">skip</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* convert from internal format to API */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

			<span class="cm">/* due to ABI compat need to split into hi/lo */</span>
			<span class="n">fe</span><span class="o">-&gt;</span><span class="n">port_no</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">;</span>
			<span class="n">fe</span><span class="o">-&gt;</span><span class="n">port_hi</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">port_no</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>

			<span class="n">fe</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">is_static</span><span class="p">)</span>
				<span class="n">fe</span><span class="o">-&gt;</span><span class="n">ageing_timer_value</span> <span class="o">=</span> <span class="n">jiffies_to_clock_t</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">);</span>
			<span class="o">++</span><span class="n">fe</span><span class="p">;</span>
			<span class="o">++</span><span class="n">num</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="nf">fdb_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">fdb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">fdb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="nf">fdb_find_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
						 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">fdb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">fdb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="nf">fdb_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="n">fdb</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">br_fdb_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
		<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">updated</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fdb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">br_mac_hash</span><span class="p">(</span><span class="n">addr</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* it is okay to have multiple ports with same</span>
<span class="cm">		 * address, just use the first one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">br_warn</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="s">&quot;adding interface %s with same address &quot;</span>
		       <span class="s">&quot;as a received packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">source</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fdb_delete</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_create</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fdb_notify</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">,</span> <span class="n">RTM_NEWNEIGH</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add entry for local address of interface */</span>
<span class="kt">int</span> <span class="nf">br_fdb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fdb_insert</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">br_fdb_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">br_mac_hash</span><span class="p">(</span><span class="n">addr</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="cm">/* some users want to always flood. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hold_time</span><span class="p">(</span><span class="n">br</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* ignore packets unless we are using this port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BR_STATE_LEARNING</span> <span class="o">||</span>
	      <span class="n">source</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">BR_STATE_FORWARDING</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_find_rcu</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fdb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* attempt to update an entry for a local interface */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
				<span class="n">br_warn</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="s">&quot;received packet on %s with &quot;</span>
					<span class="s">&quot;own address as source address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">source</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* fastpath: update of existing entry */</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">updated</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">fdb_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_create</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fdb</span><span class="p">)</span>
				<span class="n">fdb_notify</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">,</span> <span class="n">RTM_NEWNEIGH</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* else  we lose race and someone else inserts</span>
<span class="cm">		 * it first, don&#39;t bother updating</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdb_to_nud</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NUD_PERMANENT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NUD_NOARP</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">has_expired</span><span class="p">(</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NUD_STALE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">NUD_REACHABLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdb_fill_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nda_cacheinfo</span> <span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ndmsg</span> <span class="o">*</span><span class="n">ndm</span><span class="p">;</span>

	<span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ndm</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="n">ndm</span> <span class="o">=</span> <span class="n">nlmsg_data</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_family</span>	 <span class="o">=</span> <span class="n">AF_BRIDGE</span><span class="p">;</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_pad1</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_pad2</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_flags</span>	 <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_type</span>	 <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_ifindex</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">?</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">:</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
	<span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_state</span>   <span class="o">=</span> <span class="n">fdb_to_nud</span><span class="p">(</span><span class="n">fdb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NDA_LLADDR</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdb</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">ndm_used</span>	 <span class="o">=</span> <span class="n">jiffies_to_clock_t</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">ndm_confirmed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">ndm_updated</span>	 <span class="o">=</span> <span class="n">jiffies_to_clock_t</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">);</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">ndm_refcnt</span>	 <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NDA_CACHEINFO</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nlmsg_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">);</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">nlmsg_cancel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">fdb_nlmsg_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NLMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ndmsg</span><span class="p">))</span>
		<span class="o">+</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="n">ETH_ALEN</span><span class="p">)</span> <span class="cm">/* NDA_LLADDR */</span>
		<span class="o">+</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nda_cacheinfo</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fdb_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">nlmsg_new</span><span class="p">(</span><span class="n">fdb_nlmsg_size</span><span class="p">(),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fdb_fill_info</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* -EMSGSIZE implies BUG in fdb_nlmsg_size() */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rtnl_notify</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTNLGRP_NEIGH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rtnl_set_sk_err</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">RTNLGRP_NEIGH</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Dump information about entries, in response to GETNEIGH */</span>
<span class="kt">int</span> <span class="nf">br_fdb_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_EBRIDGE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BR_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fdb_fill_info</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
					  <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span>
					  <span class="n">cb</span><span class="o">-&gt;</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">,</span>
					  <span class="n">RTM_NEWNEIGH</span><span class="p">,</span>
					  <span class="n">NLM_F_MULTI</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
<span class="nl">skip:</span>
			<span class="o">++</span><span class="n">idx</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update (create or replace) forwarding database entry */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdb_add_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			 <span class="n">__u16</span> <span class="n">state</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="n">source</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">br_mac_hash</span><span class="p">(</span><span class="n">addr</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_CREATE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

		<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_create</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">fdb_notify</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">,</span> <span class="n">RTM_NEWNEIGH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_EXCL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fdb_to_nud</span><span class="p">(</span><span class="n">fdb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">NUD_PERMANENT</span><span class="p">)</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">NUD_NOARP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_local</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">is_static</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">fdb</span><span class="o">-&gt;</span><span class="n">updated</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">fdb_notify</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">,</span> <span class="n">RTM_NEWNEIGH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add new permanent fdb entry with RTM_NEWNEIGH */</span>
<span class="kt">int</span> <span class="nf">br_fdb_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ndmsg</span> <span class="o">*</span><span class="n">ndm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">nlh_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NUD_PERMANENT</span><span class="o">|</span><span class="n">NUD_NOARP</span><span class="o">|</span><span class="n">NUD_REACHABLE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;bridge: RTM_NEWNEIGH with invalid state %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">br_port_get_rtnl</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;bridge: RTM_NEWNEIGH %s not a bridge port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_flags</span> <span class="o">&amp;</span> <span class="n">NTF_USE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">br_fdb_update</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fdb_add_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ndm</span><span class="o">-&gt;</span><span class="n">ndm_state</span><span class="p">,</span> <span class="n">nlh_flags</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fdb_delete_by_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">br_mac_hash</span><span class="p">(</span><span class="n">addr</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">net_bridge_fdb_entry</span> <span class="o">*</span><span class="n">fdb</span><span class="p">;</span>

	<span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb_find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">fdb_delete</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">,</span> <span class="n">fdb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove neighbor entry with RTM_DELNEIGH */</span>
<span class="kt">int</span> <span class="nf">br_fdb_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ndmsg</span> <span class="o">*</span><span class="n">ndm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">br_port_get_rtnl</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;bridge: RTM_DELNEIGH %s not a bridge port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fdb_delete_by_addr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">hash_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
