<!DOCTYPE html>
<html><head><title>joekychen/linux » net › bridge › netfilter › ebtables.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ebtables.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  ebtables</span>
<span class="cm"> *</span>
<span class="cm"> *  Author:</span>
<span class="cm"> *  Bart De Schuymer		&lt;bdschuym@pandora.be&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  ebtables.c,v 2.0, July, 2002</span>
<span class="cm"> *</span>
<span class="cm"> *  This code is stongly inspired on the iptables code which is</span>
<span class="cm"> *  Copyright (C) 1999 Paul `Rusty&#39; Russell &amp; Michael J. Neuling</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter/x_tables.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_bridge/ebtables.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cm">/* needed for logical [in,out]-dev filtering */</span>
<span class="cp">#include &quot;../br_private.h&quot;</span>

<span class="cp">#define BUGPRINT(format, args...) printk(&quot;kernel msg: ebtables bug: please &quot;\</span>
<span class="cp">					 &quot;report to author: &quot;format, ## args)</span>
<span class="cm">/* #define BUGPRINT(format, args...) */</span>

<span class="cm">/*</span>
<span class="cm"> * Each cpu has its own set of counters, so there is no need for write_lock in</span>
<span class="cm"> * the softirq</span>
<span class="cm"> * For reading or updating the counters, the user context needs to</span>
<span class="cm"> * get a write_lock</span>
<span class="cm"> */</span>

<span class="cm">/* The size of each set of counters is altered to get cache alignment */</span>
<span class="cp">#define SMP_ALIGN(x) (((x) + SMP_CACHE_BYTES-1) &amp; ~(SMP_CACHE_BYTES-1))</span>
<span class="cp">#define COUNTER_OFFSET(n) (SMP_ALIGN(n * sizeof(struct ebt_counter)))</span>
<span class="cp">#define COUNTER_BASE(c, n, cpu) ((struct ebt_counter *)(((char *)c) + \</span>
<span class="cp">   COUNTER_OFFSET(n) * cpu))</span>



<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ebt_mutex</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ebt_standard_compat_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">compat_int_t</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">+=</span> <span class="n">xt_compat_calc_jump</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_standard_compat_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compat_int_t</span> <span class="n">cv</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cv</span> <span class="o">-=</span> <span class="n">xt_compat_calc_jump</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">cv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cv</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="n">ebt_standard_target</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>       <span class="o">=</span> <span class="s">&quot;standard&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">revision</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">family</span>     <span class="o">=</span> <span class="n">NFPROTO_BRIDGE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">targetsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compatsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_int_t</span><span class="p">),</span>
	<span class="p">.</span><span class="n">compat_from_user</span> <span class="o">=</span> <span class="n">ebt_standard_compat_from_user</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_to_user</span> <span class="o">=</span>  <span class="n">ebt_standard_compat_to_user</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_do_watcher</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">par</span><span class="o">-&gt;</span><span class="n">target</span>   <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">watcher</span><span class="p">;</span>
	<span class="n">par</span><span class="o">-&gt;</span><span class="n">targinfo</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">watcher</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">par</span><span class="p">);</span>
	<span class="cm">/* watchers don&#39;t give a verdict */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_do_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">par</span><span class="o">-&gt;</span><span class="n">match</span>     <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span><span class="p">;</span>
	<span class="n">par</span><span class="o">-&gt;</span><span class="n">matchinfo</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span> <span class="o">?</span> <span class="n">EBT_MATCH</span> <span class="o">:</span> <span class="n">EBT_NOMATCH</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_dev_check</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">devname</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="cm">/* 1 is the wildcard token */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">devname</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">devname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define FWINV2(bool,invflg) ((bool) ^ !!(e-&gt;invflags &amp; invflg))</span>
<span class="cm">/* process standard matches */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_basic_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_bridge_port</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">ethproto</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">verdict</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">ethproto</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ethproto</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">h_proto</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_802_3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FWINV2</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ethproto</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1536</span><span class="p">,</span> <span class="n">EBT_IPROTO</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_NOPROTO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="n">FWINV2</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ethproto</span> <span class="o">!=</span> <span class="n">ethproto</span><span class="p">,</span> <span class="n">EBT_IPROTO</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FWINV2</span><span class="p">(</span><span class="n">ebt_dev_check</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">in</span><span class="p">),</span> <span class="n">EBT_IIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FWINV2</span><span class="p">(</span><span class="n">ebt_dev_check</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">),</span> <span class="n">EBT_IOUT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* rcu_read_lock()ed by nf_hook_slow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">FWINV2</span><span class="p">(</span><span class="n">ebt_dev_check</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">logical_in</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">EBT_ILOGICALIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">br_port_get_rcu</span><span class="p">(</span><span class="n">out</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">FWINV2</span><span class="p">(</span><span class="n">ebt_dev_check</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">logical_out</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">EBT_ILOGICALOUT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_SOURCEMAC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">verdict</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">verdict</span> <span class="o">|=</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">sourcemac</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span>
			   <span class="n">e</span><span class="o">-&gt;</span><span class="n">sourcemsk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FWINV2</span><span class="p">(</span><span class="n">verdict</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EBT_ISOURCE</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_DESTMAC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">verdict</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">verdict</span> <span class="o">|=</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">destmac</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span>
			   <span class="n">e</span><span class="o">-&gt;</span><span class="n">destmsk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FWINV2</span><span class="p">(</span><span class="n">verdict</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EBT_IDEST</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__pure</span>
<span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="nf">ebt_next_entry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do some firewalling */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ebt_do_table</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
   <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">point</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">counter_base</span><span class="p">,</span> <span class="o">*</span><span class="n">cb_base</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">verdict</span><span class="p">,</span> <span class="n">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_chainstack</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="n">chaininfo</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_action_param</span> <span class="n">acpar</span><span class="p">;</span>

	<span class="n">acpar</span><span class="p">.</span><span class="n">family</span>  <span class="o">=</span> <span class="n">NFPROTO_BRIDGE</span><span class="p">;</span>
	<span class="n">acpar</span><span class="p">.</span><span class="n">in</span>      <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
	<span class="n">acpar</span><span class="p">.</span><span class="n">out</span>     <span class="o">=</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">acpar</span><span class="p">.</span><span class="n">hotdrop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">acpar</span><span class="p">.</span><span class="n">hooknum</span> <span class="o">=</span> <span class="n">hook</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">private</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">cb_base</span> <span class="o">=</span> <span class="n">COUNTER_BASE</span><span class="p">(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">,</span>
	   <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="k">else</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">chaininfo</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">hook</span><span class="p">];</span>
	<span class="n">nentries</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">hook</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
	<span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">hook</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">counter_base</span> <span class="o">=</span> <span class="n">cb_base</span> <span class="o">+</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">hook</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">counter_offset</span><span class="p">;</span>
	<span class="cm">/* base for chain jumps */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ebt_basic_match</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">letscontinue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">ebt_do_match</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acpar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">letscontinue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acpar</span><span class="p">.</span><span class="n">hotdrop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* increase counter */</span>
		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">counter_base</span> <span class="o">+</span> <span class="n">i</span><span class="p">)).</span><span class="n">pcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">counter_base</span> <span class="o">+</span> <span class="n">i</span><span class="p">)).</span><span class="n">bcnt</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* these should only watch: not modify, nor tell us</span>
<span class="cm">		   what to do with the packet */</span>
		<span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">ebt_do_watcher</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acpar</span><span class="p">);</span>

		<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)</span>
		   <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">point</span><span class="p">)</span> <span class="o">+</span> <span class="n">point</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>
		<span class="cm">/* standard target */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span>
			<span class="n">verdict</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ebt_standard_target</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">verdict</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">acpar</span><span class="p">.</span><span class="n">target</span>   <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
			<span class="n">acpar</span><span class="p">.</span><span class="n">targinfo</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">verdict</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acpar</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">==</span> <span class="n">EBT_ACCEPT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">==</span> <span class="n">EBT_DROP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">==</span> <span class="n">EBT_RETURN</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">letsreturn:</span>
<span class="cp">#ifdef CONFIG_NETFILTER_DEBUG</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;RETURN on base chain&quot;</span><span class="p">);</span>
				<span class="cm">/* act like this is EBT_CONTINUE */</span>
				<span class="k">goto</span> <span class="n">letscontinue</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* put all the local variables right */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">n</span><span class="p">;</span>
			<span class="n">chaininfo</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">chaininfo</span><span class="p">;</span>
			<span class="n">nentries</span> <span class="o">=</span> <span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
			<span class="n">point</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">e</span><span class="p">;</span>
			<span class="n">counter_base</span> <span class="o">=</span> <span class="n">cb_base</span> <span class="o">+</span>
			   <span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">counter_offset</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">==</span> <span class="n">EBT_CONTINUE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">letscontinue</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NETFILTER_DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;bogus standard verdict</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="cm">/* jump to a udc */</span>
		<span class="n">cs</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">n</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cs</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">chaininfo</span> <span class="o">=</span> <span class="n">chaininfo</span><span class="p">;</span>
		<span class="n">cs</span><span class="p">[</span><span class="n">sp</span><span class="p">].</span><span class="n">e</span> <span class="o">=</span> <span class="n">ebt_next_entry</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chaininfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">verdict</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NETFILTER_DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">distinguisher</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;jump to non-chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">nentries</span> <span class="o">=</span> <span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">counter_base</span> <span class="o">=</span> <span class="n">cb_base</span> <span class="o">+</span> <span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">counter_offset</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>
<span class="nl">letscontinue:</span>
		<span class="n">point</span> <span class="o">=</span> <span class="n">ebt_next_entry</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* I actually like this :) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">EBT_RETURN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">letsreturn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">EBT_ACCEPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If it succeeds, returns element and locks mutex */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">find_inlist_lock_noload</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span>
   <span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">find_inlist_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">try_then_request_module</span><span class="p">(</span>
			<span class="n">find_inlist_lock_noload</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mutex</span><span class="p">),</span>
			<span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span>
<span class="nf">find_table_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_inlist_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xt</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">NFPROTO_BRIDGE</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span>
				<span class="s">&quot;ebtable_&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_check_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xt_mtchk_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">entryinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">watchers_offset</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">left</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">match</span> <span class="o">=</span> <span class="n">xt_request_find_match</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">match</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="p">;</span>

	<span class="n">par</span><span class="o">-&gt;</span><span class="n">match</span>     <span class="o">=</span> <span class="n">match</span><span class="p">;</span>
	<span class="n">par</span><span class="o">-&gt;</span><span class="n">matchinfo</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xt_check_match</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">,</span>
	      <span class="n">e</span><span class="o">-&gt;</span><span class="n">ethproto</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">invflags</span> <span class="o">&amp;</span> <span class="n">EBT_IPROTO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_check_watcher</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xt_tgchk_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">entryinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">watcher</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_watcher</span><span class="p">)</span> <span class="o">||</span>
	   <span class="n">left</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_watcher</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">watcher_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">watcher</span> <span class="o">=</span> <span class="n">xt_request_find_target</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">watcher</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">watcher</span><span class="p">);</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">watcher</span> <span class="o">=</span> <span class="n">watcher</span><span class="p">;</span>

	<span class="n">par</span><span class="o">-&gt;</span><span class="n">target</span>   <span class="o">=</span> <span class="n">watcher</span><span class="p">;</span>
	<span class="n">par</span><span class="o">-&gt;</span><span class="n">targinfo</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xt_check_target</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">watcher_size</span><span class="p">,</span>
	      <span class="n">e</span><span class="o">-&gt;</span><span class="n">ethproto</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">invflags</span> <span class="o">&amp;</span> <span class="n">EBT_IPROTO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">watcher</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_verify_pointers</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_replace</span> <span class="o">*</span><span class="n">repl</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">valid_hooks</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span>
			     <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">NF_BR_NUMHOOKS</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_ENTRY_OR_ENTRIES</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we make userspace set this right,</span>
<span class="cm">				   so there is no misunderstanding */</span>
				<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;EBT_ENTRY_OR_ENTRIES shouldn&#39;t be set &quot;</span>
					 <span class="s">&quot;in distinguisher</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">)</span>
				<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;entries_size too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if all valid hooks have a chain */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">valid_hooks</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Valid hook without chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this one is very careful, as it is the first function</span>
<span class="cm"> * to parse the userspace data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_check_entry_size_and_hooks</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
   <span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">,</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">,</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">totalcnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">udc_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* beginning of a new chain</span>
<span class="cm">	   if i == NF_BR_NUMHOOKS it must be a user defined chain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">NF_BR_NUMHOOKS</span> <span class="o">||</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this checks if the previous chain has as many entries</span>
<span class="cm">		   as it said it has */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">!=</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;nentries does not equal the nr of entries &quot;</span>
				 <span class="s">&quot;in the chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">EBT_DROP</span> <span class="o">&amp;&amp;</span>
		   <span class="p">((</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">EBT_ACCEPT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* only RETURN from udc */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">NF_BR_NUMHOOKS</span> <span class="o">||</span>
			   <span class="p">((</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">EBT_RETURN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;bad policy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">)</span> <span class="cm">/* it&#39;s a user defined chain */</span>
			<span class="p">(</span><span class="o">*</span><span class="n">udc_cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter_offset</span> <span class="o">!=</span> <span class="o">*</span><span class="n">totalcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;counter_offset != totalcnt&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* a plain old entry, heh */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">watchers_offset</span> <span class="o">||</span>
	   <span class="n">e</span><span class="o">-&gt;</span><span class="n">watchers_offset</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">||</span>
	   <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;entry offsets not in right order</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* this is not checked anywhere else */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;target size too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">*</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">totalcnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ebt_cl_stack</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_chainstack</span> <span class="n">cs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">from</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hookmask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * we need these positions to check that the jumps to a different part of the</span>
<span class="cm"> * entries is a jump to the beginning of a new chain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_get_udc_positions</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">,</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ebt_cl_stack</span> <span class="o">*</span><span class="n">udc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* we&#39;re only interested in chain starts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* only care about udc */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">udc</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">chaininfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>
	<span class="cm">/* these initialisations are depended on later in check_chainloops() */</span>
	<span class="n">udc</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">udc</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">hookmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_cleanup_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xt_mtdtor_param</span> <span class="n">par</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">par</span><span class="p">.</span><span class="n">net</span>       <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">match</span>     <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">matchinfo</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">family</span>    <span class="o">=</span> <span class="n">NFPROTO_BRIDGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">.</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">par</span><span class="p">.</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">par</span><span class="p">.</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_cleanup_watcher</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xt_tgdtor_param</span> <span class="n">par</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">par</span><span class="p">.</span><span class="n">net</span>      <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">target</span>   <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">watcher</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">targinfo</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">family</span>   <span class="o">=</span> <span class="n">NFPROTO_BRIDGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">par</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">par</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_cleanup_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xt_tgdtor_param</span> <span class="n">par</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">cnt</span><span class="p">)</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_cleanup_watcher</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_cleanup_match</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>

	<span class="n">par</span><span class="p">.</span><span class="n">net</span>      <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">target</span>   <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">targinfo</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">par</span><span class="p">.</span><span class="n">family</span>   <span class="o">=</span> <span class="n">NFPROTO_BRIDGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">par</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">par</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_check_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
   <span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">,</span>
   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cnt</span><span class="p">,</span>
   <span class="k">struct</span> <span class="n">ebt_cl_stack</span> <span class="o">*</span><span class="n">cl_s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udc_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">hook</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hookmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">gap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_mtchk_param</span> <span class="n">mtpar</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_tgchk_param</span> <span class="n">tgpar</span><span class="p">;</span>

	<span class="cm">/* don&#39;t mess with the struct ebt_entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EBT_F_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Unknown flag for bitmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">invflags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EBT_INV_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Unknown flag for inv bitmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_NOPROTO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">EBT_802_3</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;NOPROTO &amp; 802_3 not allowed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* what hook do we belong to? */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span>
			<span class="n">hook</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* (1 &lt;&lt; NF_BR_NUMHOOKS) tells the check functions the rule is on</span>
<span class="cm">	   a base chain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">)</span>
		<span class="n">hookmask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hook</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">chaininfo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hookmask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hook</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">hookmask</span> <span class="o">=</span> <span class="n">cl_s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hookmask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mtpar</span><span class="p">.</span><span class="n">net</span>	<span class="o">=</span> <span class="n">tgpar</span><span class="p">.</span><span class="n">net</span>       <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">mtpar</span><span class="p">.</span><span class="n">table</span>     <span class="o">=</span> <span class="n">tgpar</span><span class="p">.</span><span class="n">table</span>     <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">mtpar</span><span class="p">.</span><span class="n">entryinfo</span> <span class="o">=</span> <span class="n">tgpar</span><span class="p">.</span><span class="n">entryinfo</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">mtpar</span><span class="p">.</span><span class="n">hook_mask</span> <span class="o">=</span> <span class="n">tgpar</span><span class="p">.</span><span class="n">hook_mask</span> <span class="o">=</span> <span class="n">hookmask</span><span class="p">;</span>
	<span class="n">mtpar</span><span class="p">.</span><span class="n">family</span>    <span class="o">=</span> <span class="n">tgpar</span><span class="p">.</span><span class="n">family</span>    <span class="o">=</span> <span class="n">NFPROTO_BRIDGE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_check_match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtpar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_matches</span><span class="p">;</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_check_watcher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tgpar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_watchers</span><span class="p">;</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>
	<span class="n">gap</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">xt_request_find_target</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup_watchers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ebt_standard_target</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_standard_target</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Standard target size too big</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup_watchers</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">ebt_standard_target</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">verdict</span> <span class="o">&lt;</span>
		   <span class="o">-</span><span class="n">NUM_STANDARD_TARGETS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Invalid standard target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup_watchers</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">target_size</span> <span class="o">&gt;</span> <span class="n">gap</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup_watchers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tgpar</span><span class="p">.</span><span class="n">target</span>   <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">tgpar</span><span class="p">.</span><span class="n">targinfo</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xt_check_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tgpar</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">target_size</span><span class="p">,</span>
	      <span class="n">e</span><span class="o">-&gt;</span><span class="n">ethproto</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">invflags</span> <span class="o">&amp;</span> <span class="n">EBT_IPROTO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup_watchers</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">*</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">cleanup_watchers:</span>
	<span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_cleanup_watcher</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
<span class="nl">cleanup_matches:</span>
	<span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_cleanup_match</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * checks for loops and sets the hook mask for udc</span>
<span class="cm"> * the hook mask for udc tells us from which base chains the udc can be</span>
<span class="cm"> * accessed. This mask is a parameter to the check() functions of the extensions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_chainloops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="n">chain</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ebt_cl_stack</span> <span class="o">*</span><span class="n">cl_s</span><span class="p">,</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udc_cnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">chain_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nentries</span> <span class="o">=</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">,</span> <span class="n">verdict</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">chain</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">nentries</span> <span class="o">||</span> <span class="n">chain_nr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* end of udc, go back one &#39;recursion&#39; step */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* put back values of the time when this chain was called */</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">cl_s</span><span class="p">[</span><span class="n">chain_nr</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl_s</span><span class="p">[</span><span class="n">chain_nr</span><span class="p">].</span><span class="n">from</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">nentries</span> <span class="o">=</span>
				<span class="n">cl_s</span><span class="p">[</span><span class="n">cl_s</span><span class="p">[</span><span class="n">chain_nr</span><span class="p">].</span><span class="n">from</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">chaininfo</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">nentries</span> <span class="o">=</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">cl_s</span><span class="p">[</span><span class="n">chain_nr</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
			<span class="cm">/* make sure we won&#39;t see a loop that isn&#39;t one */</span>
			<span class="n">cl_s</span><span class="p">[</span><span class="n">chain_nr</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">chain_nr</span> <span class="o">=</span> <span class="n">cl_s</span><span class="p">[</span><span class="n">chain_nr</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">nentries</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)</span>
		   <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">EBT_STANDARD_TARGET</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">letscontinue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_standard_target</span><span class="p">)</span> <span class="o">&gt;</span>
		   <span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Standard target size too big</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">verdict</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ebt_standard_target</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">verdict</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verdict</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* jump to another chain */</span>
			<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="n">hlp2</span> <span class="o">=</span>
			   <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)(</span><span class="n">base</span> <span class="o">+</span> <span class="n">verdict</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">udc_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hlp2</span> <span class="o">==</span> <span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">chaininfo</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* bad destination or loop */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">udc_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;bad destination</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hookmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hooknr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">letscontinue</span><span class="p">;</span>
			<span class="cm">/* this can&#39;t be 0, so the loop test is correct */</span>
			<span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cs</span><span class="p">.</span><span class="n">e</span> <span class="o">=</span> <span class="n">ebt_next_entry</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
			<span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">hlp2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">nentries</span> <span class="o">=</span> <span class="n">hlp2</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
			<span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span> <span class="o">=</span> <span class="n">chain_nr</span><span class="p">;</span>
			<span class="n">chain_nr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="cm">/* this udc is accessible from the base chain for hooknr */</span>
			<span class="n">cl_s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hookmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hooknr</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">letscontinue:</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">ebt_next_entry</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="n">pos</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* do the parsing of the table/chains/entries/matches/watchers/targets, heh */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">translate_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">udc_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_cl_stack</span> <span class="o">*</span><span class="n">cl_s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* used in the checking for chain loops */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;No valid hooks specified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="p">)</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Chains don&#39;t start at beginning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* make sure chains are ordered after each other in same order</span>
<span class="cm">	   as their corresponding hooks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Hook order must be followed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do some early checkings and initialize some things */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* holds the expected nr. of entries for the chain */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* holds the up to now counted entries for the chain */</span>
	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* holds the total nr. of entries, should equal</span>
<span class="cm">		  newinfo-&gt;nentries afterwards */</span>
	<span class="n">udc_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* will hold the nr. of user defined chains (udc) */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
	   <span class="n">ebt_check_entry_size_and_hooks</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">,</span>
	   <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udc_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;nentries does not equal the nr of entries in the &quot;</span>
			 <span class="s">&quot;(last) chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Total nentries is wrong</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the location of the udc, put them in an array</span>
<span class="cm">	   while we&#39;re at it, allocate the chainstack */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udc_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this will get free&#39;d in do_replace()/ebt_register_table()</span>
<span class="cm">		   if an error occurs */</span>
		<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span> <span class="o">=</span>
			<span class="n">vmalloc</span><span class="p">(</span><span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			  <span class="n">vmalloc</span><span class="p">(</span><span class="n">udc_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
					<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="o">--</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">);</span>
				<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">cl_s</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">udc_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cl_s</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl_s</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* the i&#39;th udc */</span>
		<span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
		   <span class="n">ebt_get_udc_positions</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">cl_s</span><span class="p">);</span>
		<span class="cm">/* sanity check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">udc_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;i != udc_cnt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">cl_s</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check for loops */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">check_chainloops</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			   <span class="n">cl_s</span><span class="p">,</span> <span class="n">udc_cnt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">vfree</span><span class="p">(</span><span class="n">cl_s</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

	<span class="cm">/* we now know the following (along with E=mc²):</span>
<span class="cm">	   - the nr of entries in each chain is right</span>
<span class="cm">	   - the size of the allocated space is right</span>
<span class="cm">	   - all valid hooks have a corresponding chain</span>
<span class="cm">	   - there are no loops</span>
<span class="cm">	   - wrong data can still be on the level of a single entry</span>
<span class="cm">	   - could be there are jumps to places that are not the</span>
<span class="cm">	     beginning of a chain. This can only occur in chains that</span>
<span class="cm">	     are not accessible from any base chains, so we don&#39;t care. */</span>

	<span class="cm">/* used to know what we need to clean up if something goes wrong */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
	   <span class="n">ebt_check_entry</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">cl_s</span><span class="p">,</span> <span class="n">udc_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
				  <span class="n">ebt_cleanup_entry</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">cl_s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called under write_lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_counters</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">oldcounters</span><span class="p">,</span>
   <span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">counters</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nentries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">counter_base</span><span class="p">;</span>

	<span class="cm">/* counters of cpu 0 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">counters</span><span class="p">,</span> <span class="n">oldcounters</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">)</span> <span class="o">*</span> <span class="n">nentries</span><span class="p">);</span>

	<span class="cm">/* add other counters to those of cpu 0 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">counter_base</span> <span class="o">=</span> <span class="n">COUNTER_BASE</span><span class="p">(</span><span class="n">oldcounters</span><span class="p">,</span> <span class="n">nentries</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nentries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcnt</span> <span class="o">+=</span> <span class="n">counter_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcnt</span><span class="p">;</span>
			<span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bcnt</span> <span class="o">+=</span> <span class="n">counter_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bcnt</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_replace_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ebt_replace</span> <span class="o">*</span><span class="n">repl</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">counterstmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* used to be able to unlock earlier */</span>
	<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* the user wants counters back</span>
<span class="cm">	   the check on the size is done later, when we have the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">counterstmp</span><span class="p">);</span>
		<span class="n">counterstmp</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">counterstmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ebt_verify_pointers</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_counterstmp</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">translate_table</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_counterstmp</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">find_table_lock</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_iterate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the table doesn&#39;t like it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">(</span><span class="n">newinfo</span><span class="p">,</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">free_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">&amp;&amp;</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">!=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Wrong nr. of counters requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we have the mutex lock, so no danger in reading this pointer */</span>
	<span class="n">table</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="cm">/* make sure the table can only be rmmod&#39;ed if it contains no rules */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nentries</span> <span class="o">&amp;&amp;</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">nentries</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_unlock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nentries</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
	<span class="cm">/* we need an atomic snapshot of the counters */</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span><span class="p">)</span>
		<span class="n">get_counters</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span> <span class="n">counterstmp</span><span class="p">,</span>
		   <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">newinfo</span><span class="p">;</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="cm">/* so, a user can change the chains while having messed up her counter</span>
<span class="cm">	   allocation. Only reason why this is done is because this way the lock</span>
<span class="cm">	   is held only once, while this doesn&#39;t bring the kernel into a</span>
<span class="cm">	   dangerous state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">&amp;&amp;</span>
	   <span class="n">copy_to_user</span><span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span> <span class="n">counterstmp</span><span class="p">,</span>
	   <span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* decrease module count and free resources */</span>
	<span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
			  <span class="n">ebt_cleanup_entry</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">counterstmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">free_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
<span class="nl">free_iterate:</span>
	<span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
			  <span class="n">ebt_cleanup_entry</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">free_counterstmp:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">counterstmp</span><span class="p">);</span>
	<span class="cm">/* can be initialized in translate_table() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* replace the table */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">countersize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_replace</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Wrong len argument</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Entries_size never zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* overflow check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">&gt;=</span> <span class="p">((</span><span class="n">INT_MAX</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_table_info</span><span class="p">))</span> <span class="o">/</span>
			<span class="n">NR_CPUS</span> <span class="o">-</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">&gt;=</span> <span class="n">INT_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tmp</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">countersize</span> <span class="o">=</span> <span class="n">COUNTER_OFFSET</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="n">newinfo</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newinfo</span><span class="p">)</span> <span class="o">+</span> <span class="n">countersize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">countersize</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">countersize</span><span class="p">);</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_newinfo</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span>
	   <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t copy entries from userspace</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_entries</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_replace_finish</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">free_entries:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
<span class="nl">free_newinfo:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span>
<span class="nf">ebt_register_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">input_table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_replace_kernel</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">countersize</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">input_table</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="p">(</span><span class="n">repl</span> <span class="o">=</span> <span class="n">input_table</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">repl</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">input_table</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Bad table data for ebt_register_table!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t add one table to multiple lists. */</span>
	<span class="n">table</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">input_table</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_table</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">countersize</span> <span class="o">=</span> <span class="n">COUNTER_OFFSET</span><span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="n">newinfo</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newinfo</span><span class="p">)</span> <span class="o">+</span> <span class="n">countersize</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_table</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_newinfo</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">);</span>
	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">countersize</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">countersize</span><span class="p">);</span>

	<span class="cm">/* fill in newinfo and parse the entries */</span>
	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">valid_hooks</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span>
				<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">translate_table</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">repl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Translate_table failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_chainstack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">(</span><span class="n">newinfo</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;The table doesn&#39;t like its own initial data, lol</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_chainstack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">newinfo</span><span class="p">;</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_chainstack</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xt</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">NFPROTO_BRIDGE</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Table name already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Hold a reference count if the chains aren&#39;t empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">nentries</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xt</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">NFPROTO_BRIDGE</span><span class="p">]);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="nl">free_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
<span class="nl">free_chainstack:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
<span class="nl">free_newinfo:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="p">);</span>
<span class="nl">free_table:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ebt_unregister_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Request to unregister NULL table!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">,</span>
			  <span class="n">ebt_cleanup_entry</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">chainstack</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* userspace just supplied us with counters */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_update_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="n">__user</span> <span class="o">*</span><span class="n">counters</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_counters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">num_counters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">find_table_lock</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_counters</span> <span class="o">!=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Wrong nr of counters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span> <span class="n">num_counters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">counters</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we want an atomic add of the counters */</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* we add to the counters of the first cpu */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcnt</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcnt</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bcnt</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bcnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
<span class="nl">free_tmp:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_replace</span> <span class="n">hlp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hlp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hlp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hlp</span><span class="p">)</span> <span class="o">+</span> <span class="n">hlp</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_update_counters</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hlp</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">hlp</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
				<span class="n">hlp</span><span class="p">.</span><span class="n">num_counters</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ebt_make_matchname</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">hlp</span> <span class="o">=</span> <span class="n">ubase</span> <span class="o">+</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

	<span class="cm">/* ebtables expects 32 bytes long names but xt_match names are 29 bytes</span>
<span class="cm">	   long. Copy 29 bytes and fill remaining bytes with zeroes. */</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">hlp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ebt_make_watchername</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">hlp</span> <span class="o">=</span> <span class="n">ubase</span> <span class="o">+</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">w</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">watcher</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">hlp</span> <span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ebt_make_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">hlp</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hlp</span> <span class="o">=</span> <span class="n">ubase</span> <span class="o">+</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_make_matchname</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">ubase</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ebt_make_watchername</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">ubase</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">hlp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_counters_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">oldcounters</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nentries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">counterstmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* userspace might not need the counters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_counters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_counters</span> <span class="o">!=</span> <span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Num_counters wrong</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">counterstmp</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">nentries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">counterstmp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">counterstmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">get_counters</span><span class="p">(</span><span class="n">oldcounters</span><span class="p">,</span> <span class="n">counterstmp</span><span class="p">,</span> <span class="n">nentries</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">counterstmp</span><span class="p">,</span>
	   <span class="n">nentries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">counterstmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called with ebt_mutex locked */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_everything_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_replace</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">oldcounters</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entries_size</span><span class="p">,</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">EBT_SO_GET_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
		<span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="n">oldcounters</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
		<span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="n">oldcounters</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">)</span> <span class="o">+</span> <span class="n">entries_size</span> <span class="o">+</span>
	   <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span><span class="o">?</span> <span class="n">nentries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">)</span><span class="o">:</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">!=</span> <span class="n">nentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Nentries wrong</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">!=</span> <span class="n">entries_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Wrong size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_counters_to_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">oldcounters</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
					<span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span><span class="p">,</span> <span class="n">nentries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">entries_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t copy entries to userspace</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* set the match/watcher/target names right */</span>
	<span class="k">return</span> <span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">entries_size</span><span class="p">,</span>
	   <span class="n">ebt_make_names</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_ebt_set_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EBT_SO_SET_ENTRIES</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_replace</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EBT_SO_SET_COUNTERS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_counters</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_ebt_get_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_replace</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">find_table_lock</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">tmp</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EBT_SO_GET_INFO</span>:
	<span class="k">case</span> <span class="n">EBT_SO_GET_INIT_INFO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">)){</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">EBT_SO_GET_INFO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">valid_hooks</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">valid_hooks</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
			<span class="n">BUGPRINT</span><span class="p">(</span><span class="s">&quot;c2u Didn&#39;t work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EBT_SO_GET_ENTRIES</span>:
	<span class="k">case</span> <span class="n">EBT_SO_GET_INIT_ENTRIES</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_everything_to_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cm">/* 32 bit-userspace compatibility definitions. */</span>
<span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_TABLE_MAXNAMELEN</span><span class="p">];</span>
	<span class="n">compat_uint_t</span> <span class="n">valid_hooks</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">entries_size</span><span class="p">;</span>
	<span class="cm">/* start of the chains */</span>
	<span class="n">compat_uptr_t</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_BR_NUMHOOKS</span><span class="p">];</span>
	<span class="cm">/* nr of counters userspace expects back */</span>
	<span class="n">compat_uint_t</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="cm">/* where the kernel will put the old counters. */</span>
	<span class="n">compat_uptr_t</span> <span class="n">counters</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* struct ebt_entry_match, _target and _watcher have same layout */</span>
<span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
		<span class="n">compat_uptr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">match_size</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* account for possible padding between match_size and -&gt;data */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_compat_entry_padsize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">XT_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span><span class="p">))</span> <span class="o">&lt;</span>
			<span class="n">COMPAT_XT_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span><span class="p">)));</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">XT_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span><span class="p">))</span> <span class="o">-</span>
			<span class="n">COMPAT_XT_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_compat_match_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">userlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * ebt_among needs special handling. The kernel .matchsize is</span>
<span class="cm">	 * set to -1 at registration time; at runtime an EBT_ALIGN()ed</span>
<span class="cm">	 * value is expected.</span>
<span class="cm">	 * Example: userspace sends 4500, ebt_among.c wants 4504.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">matchsize</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XT_ALIGN</span><span class="p">(</span><span class="n">userlen</span><span class="p">)</span> <span class="o">-</span> <span class="n">COMPAT_XT_ALIGN</span><span class="p">(</span><span class="n">userlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xt_compat_match_offset</span><span class="p">(</span><span class="n">match</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_match_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">**</span><span class="n">dstptr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cm</span> <span class="o">=</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">ebt_compat_match_offset</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">);</span>
	<span class="n">compat_uint_t</span> <span class="n">msize</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match_size</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">match</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	    <span class="n">strlen</span><span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">put_user</span><span class="p">(</span><span class="n">msize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">compat_to_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">compat_to_user</span><span class="p">(</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">msize</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">()</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">cm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">+=</span> <span class="n">msize</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_target_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="n">__user</span> <span class="o">**</span><span class="n">dstptr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cm</span> <span class="o">=</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">xt_compat_target_offset</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="n">compat_uint_t</span> <span class="n">tsize</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">target_size</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">target_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	    <span class="n">strlen</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">put_user</span><span class="p">(</span><span class="n">tsize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">compat_to_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">compat_to_user</span><span class="p">(</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">cm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">tsize</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">()</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">cm</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">+=</span> <span class="n">tsize</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_watcher_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__user</span> <span class="o">**</span><span class="n">dstptr</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">compat_target_to_user</span><span class="p">((</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)</span><span class="n">w</span><span class="p">,</span>
							<span class="n">dstptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_copy_entry_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">**</span><span class="n">dstptr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">watchers_offset</span><span class="p">,</span> <span class="n">target_offset</span><span class="p">,</span> <span class="n">next_offset</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">origsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">*</span><span class="n">dstptr</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="o">*</span><span class="n">dstptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">);</span>
		<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ce</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ce</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ce</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">origsize</span> <span class="o">=</span> <span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ce</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compat_match_to_user</span><span class="p">,</span> <span class="n">dstptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">watchers_offset</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">watchers_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">origsize</span> <span class="o">-</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compat_watcher_to_user</span><span class="p">,</span> <span class="n">dstptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">target_offset</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">origsize</span> <span class="o">-</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_target_to_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dstptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">next_offset</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">origsize</span> <span class="o">-</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">watchers_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">watchers_offset</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">put_user</span><span class="p">(</span><span class="n">target_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">put_user</span><span class="p">(</span><span class="n">next_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">next_offset</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ce</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_calc_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">off</span> <span class="o">+=</span> <span class="n">ebt_compat_match_offset</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">match</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">off</span> <span class="o">+=</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_calc_watcher</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">off</span> <span class="o">+=</span> <span class="n">xt_compat_target_offset</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">watcher</span><span class="p">);</span>
	<span class="o">*</span><span class="n">off</span> <span class="o">+=</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_calc_entry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entry_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">EBT_MATCH_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compat_calc_match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">);</span>
	<span class="n">EBT_WATCHER_ITERATE</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compat_calc_watcher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">);</span>

	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>

	<span class="n">off</span> <span class="o">+=</span> <span class="n">xt_compat_target_offset</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">target</span><span class="p">);</span>
	<span class="n">off</span> <span class="o">+=</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">();</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span> <span class="o">-=</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xt_compat_add_offset</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">entry_offset</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hookptr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">base</span> <span class="o">-</span> <span class="n">hookptr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">off</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;0x%08X -&gt; 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>
					<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_table_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">entries</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">xt_compat_init_offsets</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">compat_calc_entry</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span>
							<span class="n">entries</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_copy_everything_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="n">repl</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">oldcounters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="n">tinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tinfo</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">EBT_SO_GET_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tinfo</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="p">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="n">oldcounters</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tinfo</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="p">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="n">oldcounters</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="p">.</span><span class="n">nentries</span> <span class="o">||</span>
	   <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="p">.</span><span class="n">nentries</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">repl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">repl</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">EBT_SO_GET_ENTRIES</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_table_info</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_table_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">repl</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">+</span>
	   <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span><span class="o">?</span> <span class="n">tinfo</span><span class="p">.</span><span class="n">nentries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">)</span><span class="o">:</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;wrong size: *len %d, entries_size %u, replsz %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">.</span><span class="n">entries_size</span><span class="p">,</span> <span class="n">repl</span><span class="p">.</span><span class="n">entries_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* userspace might not need the counters */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_counters_to_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">oldcounters</span><span class="p">,</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">counters</span><span class="p">),</span>
					<span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">.</span><span class="n">nentries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">tinfo</span><span class="p">.</span><span class="n">entries</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">.</span><span class="n">entries_size</span><span class="p">,</span>
			<span class="n">compat_copy_entry_to_user</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf_kern_start</span><span class="p">;</span>	<span class="cm">/* kernel buffer to copy (translated) data to */</span>
	<span class="n">u32</span> <span class="n">buf_kern_len</span><span class="p">;</span>	<span class="cm">/* total size of kernel buffer */</span>
	<span class="n">u32</span> <span class="n">buf_kern_offset</span><span class="p">;</span>	<span class="cm">/* amount of data copied so far */</span>
	<span class="n">u32</span> <span class="n">buf_user_offset</span><span class="p">;</span>	<span class="cm">/* read position in userspace buffer */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_buf_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span> <span class="o">&gt;=</span> <span class="n">sz</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_buf_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">count_only</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_len</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>

 <span class="nl">count_only:</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_user_offset</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ebt_buf_count</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_buf_add_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
	<span class="cm">/* do not adjust -&gt;buf_user_offset here, we added kernel-side padding */</span>
	<span class="k">return</span> <span class="n">ebt_buf_count</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">compat_mwt</span> <span class="p">{</span>
	<span class="n">EBT_COMPAT_MATCH</span><span class="p">,</span>
	<span class="n">EBT_COMPAT_WATCHER</span><span class="p">,</span>
	<span class="n">EBT_COMPAT_TARGET</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_mtw_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="o">*</span><span class="n">mwt</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">compat_mwt</span> <span class="n">compat_mwt</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">wt</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_kern</span><span class="p">,</span> <span class="n">match_size</span> <span class="o">=</span> <span class="n">mwt</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mwt</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span><span class="p">)</span>
		<span class="n">dst</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">compat_mwt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EBT_COMPAT_MATCH</span>:
		<span class="n">match</span> <span class="o">=</span> <span class="n">xt_request_find_match</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">match</span><span class="p">);</span>

		<span class="n">off</span> <span class="o">=</span> <span class="n">ebt_compat_match_offset</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">match_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">compat_from_user</span><span class="p">)</span>
				<span class="n">match</span><span class="o">-&gt;</span><span class="n">compat_from_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mwt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mwt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">match_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">size_kern</span> <span class="o">=</span> <span class="n">match</span><span class="o">-&gt;</span><span class="n">matchsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size_kern</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">size_kern</span> <span class="o">=</span> <span class="n">match_size</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EBT_COMPAT_WATCHER</span>: <span class="cm">/* fallthrough */</span>
	<span class="k">case</span> <span class="n">EBT_COMPAT_TARGET</span>:
		<span class="n">wt</span> <span class="o">=</span> <span class="n">xt_request_find_target</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">wt</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">wt</span><span class="p">);</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">xt_compat_target_offset</span><span class="p">(</span><span class="n">wt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wt</span><span class="o">-&gt;</span><span class="n">compat_from_user</span><span class="p">)</span>
				<span class="n">wt</span><span class="o">-&gt;</span><span class="n">compat_from_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mwt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mwt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">match_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">size_kern</span> <span class="o">=</span> <span class="n">wt</span><span class="o">-&gt;</span><span class="n">targetsize</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">wt</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span> <span class="o">+=</span> <span class="n">match_size</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_user_offset</span> <span class="o">+=</span> <span class="n">match_size</span><span class="p">;</span>
	<span class="n">pad</span> <span class="o">=</span> <span class="n">XT_ALIGN</span><span class="p">(</span><span class="n">size_kern</span><span class="p">)</span> <span class="o">-</span> <span class="n">size_kern</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_len</span> <span class="o">&lt;=</span> <span class="n">pad</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span> <span class="o">-</span> <span class="p">(</span><span class="n">match_size</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">+</span> <span class="n">size_kern</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_len</span> <span class="o">-</span> <span class="n">pad</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">size_kern</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">off</span> <span class="o">+</span> <span class="n">match_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return size of all matches, watchers or target, including necessary</span>
<span class="cm"> * alignment and padding.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ebt_size_mwt</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="o">*</span><span class="n">match32</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_left</span><span class="p">,</span> <span class="k">enum</span> <span class="n">compat_mwt</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">growth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">match32</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size_left</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">match32</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="n">match_kern</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">match_kern</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="p">)</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_kern</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span><span class="p">;</span>
			<span class="n">match_kern</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ebt_buf_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">match32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">size_left</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">match32</span><span class="p">);</span>

		<span class="cm">/* add padding before match-&gt;data (if any) */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ebt_buf_add_pad</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match32</span><span class="o">-&gt;</span><span class="n">match_size</span> <span class="o">&gt;</span> <span class="n">size_left</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">size_left</span> <span class="o">-=</span> <span class="n">match32</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_mtw_from_user</span><span class="p">(</span><span class="n">match32</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">match32</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">);</span>
		<span class="n">growth</span> <span class="o">+=</span> <span class="n">ret</span> <span class="o">-</span> <span class="n">match32</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">;</span>
		<span class="n">growth</span> <span class="o">+=</span> <span class="n">ebt_compat_entry_padsize</span><span class="p">();</span>

		<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">match32</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">match32</span><span class="o">-&gt;</span><span class="n">match_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match_kern</span><span class="p">)</span>
			<span class="n">match_kern</span><span class="o">-&gt;</span><span class="n">match_size</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">EBT_COMPAT_TARGET</span> <span class="o">&amp;&amp;</span> <span class="n">size_left</span><span class="p">);</span>
		<span class="n">match32</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">growth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called for all ebt_entry structures. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">size_entry_mwt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">startoff</span><span class="p">,</span> <span class="n">new_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* stores match/watchers/targets &amp; offset of next struct ebt_entry: */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offsets_update</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">total</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">bitmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">total</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ebt_buf_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">total</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">||</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next_offset</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">startoff</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_user_offset</span><span class="p">;</span>
	<span class="cm">/* pull in most part of ebt_entry, it does not need to be changed. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ebt_buf_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span><span class="p">,</span> <span class="n">watchers_offset</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entry</span><span class="p">);</span> <span class="cm">/* matches come first */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">watchers_offset</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf_start</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span><span class="p">;</span>
		<span class="n">offsets_update</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf_start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ebt_buf_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">buf_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">entry</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * 0: matches offset, always follows ebt_entry.</span>
<span class="cm">	 * 1: watchers offset, from ebt_entry structure</span>
<span class="cm">	 * 2: target offset, from ebt_entry structure</span>
<span class="cm">	 * 3: next ebt_entry offset, from ebt_entry structure</span>
<span class="cm">	 *</span>
<span class="cm">	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="o">*</span><span class="n">match32</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf_start</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">buf_start</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">offsets</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">match32</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_ebt_entry_mwt</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ebt_size_mwt</span><span class="p">(</span><span class="n">match32</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">new_offset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offsets_update</span> <span class="o">&amp;&amp;</span> <span class="n">new_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;change offset %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">offsets_update</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">offsets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_offset</span><span class="p">);</span>
			<span class="n">offsets_update</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_offset</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_start</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buf_start</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">xt_compat_add_offset</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">new_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">startoff</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_user_offset</span> <span class="o">-</span> <span class="n">startoff</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">*</span><span class="n">total</span> <span class="o">&lt;</span> <span class="n">startoff</span><span class="p">);</span>
	<span class="o">*</span><span class="n">total</span> <span class="o">-=</span> <span class="n">startoff</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * repl-&gt;entries_size is the size of the ebt_entry blob in userspace.</span>
<span class="cm"> * It might need more memory when copied to a 64 bit kernel in case</span>
<span class="cm"> * userspace is 32-bit. So, first task: find out how much memory is needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Called before validation is performed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_copy_entries</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_user</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_remaining</span> <span class="o">=</span> <span class="n">size_user</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">EBT_ENTRY_ITERATE</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size_user</span><span class="p">,</span> <span class="n">size_entry_mwt</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">size_remaining</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">size_remaining</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf_kern_offset</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_copy_ebt_replace_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span> <span class="o">*</span><span class="n">repl</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">&gt;=</span> <span class="p">((</span><span class="n">INT_MAX</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_table_info</span><span class="p">))</span> <span class="o">/</span>
			<span class="n">NR_CPUS</span> <span class="o">-</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">&gt;=</span> <span class="n">INT_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">,</span> <span class="n">hook_entry</span><span class="p">));</span>

	<span class="cm">/* starting with hook_entry, 32 vs. 64 bit structures are different */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">repl</span><span class="o">-&gt;</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">repl</span><span class="o">-&gt;</span><span class="n">num_counters</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span>
	<span class="n">repl</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">counters</span><span class="p">);</span>
	<span class="n">repl</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_do_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">countersize</span><span class="p">,</span> <span class="n">size64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_replace</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_entries_buf_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">entries_tmp</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_copy_ebt_replace_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* try real handler in case userland supplied needed padding */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">&amp;&amp;</span> <span class="n">do_replace</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">countersize</span> <span class="o">=</span> <span class="n">COUNTER_OFFSET</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="n">newinfo</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newinfo</span><span class="p">)</span> <span class="o">+</span> <span class="n">countersize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">countersize</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">countersize</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>

	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_newinfo</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span>
	   <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_entries</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entries_tmp</span> <span class="o">=</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>

	<span class="n">xt_compat_lock</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>

	<span class="n">xt_compat_init_offsets</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_copy_entries</span><span class="p">(</span><span class="n">entries_tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tmp.entries_size %d, kern off %d, user off %d delta %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">buf_kern_offset</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">buf_user_offset</span><span class="p">,</span>
		<span class="n">xt_compat_calc_jump</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">));</span>

	<span class="n">size64</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">entries_tmp</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
	<span class="n">state</span><span class="p">.</span><span class="n">buf_kern_start</span> <span class="o">=</span> <span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="n">state</span><span class="p">.</span><span class="n">buf_kern_len</span> <span class="o">=</span> <span class="n">size64</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_copy_entries</span><span class="p">(</span><span class="n">entries_tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* parses same data again */</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">entries_tmp</span><span class="p">);</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">size64</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NF_BR_NUMHOOKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">usrptr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">usrptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="p">.</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">usrptr</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">.</span><span class="n">entries</span><span class="p">;</span>
			<span class="n">usrptr</span> <span class="o">+=</span> <span class="n">xt_compat_calc_jump</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ebt_entries</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">usrptr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xt_compat_flush_offsets</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>
	<span class="n">xt_compat_unlock</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_replace_finish</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">free_entries:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
<span class="nl">free_newinfo:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">newinfo</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">xt_compat_flush_offsets</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>
	<span class="n">xt_compat_unlock</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">free_entries</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_update_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="n">hlp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hlp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hlp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* try real handler in case userland supplied needed padding */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hlp</span><span class="p">)</span> <span class="o">+</span> <span class="n">hlp</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_counter</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">update_counters</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">do_update_counters</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hlp</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">hlp</span><span class="p">.</span><span class="n">counters</span><span class="p">),</span>
					<span class="n">hlp</span><span class="p">.</span><span class="n">num_counters</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_do_ebt_set_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EBT_SO_SET_ENTRIES</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_do_replace</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EBT_SO_SET_COUNTERS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_update_counters</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_do_ebt_get_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_ebt_replace</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* try real handler in case userland supplied needed padding */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">EBT_SO_GET_INFO</span> <span class="o">||</span>
	     <span class="n">cmd</span> <span class="o">==</span> <span class="n">EBT_SO_GET_INIT_INFO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">do_ebt_get_ctl</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">find_table_lock</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">tmp</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xt_compat_lock</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EBT_SO_GET_INFO</span>:
		<span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_table_info</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">valid_hooks</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EBT_SO_GET_INIT_INFO</span>:
		<span class="n">tmp</span><span class="p">.</span><span class="n">nentries</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nentries</span><span class="p">;</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">entries_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">;</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">valid_hooks</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">valid_hooks</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EBT_SO_GET_ENTRIES</span>:
	<span class="k">case</span> <span class="n">EBT_SO_GET_INIT_ENTRIES</span>:
		<span class="cm">/*</span>
<span class="cm">		 * try real handler first in case of userland-side padding.</span>
<span class="cm">		 * in case we are dealing with an &#39;ordinary&#39; 32 bit binary</span>
<span class="cm">		 * without 64bit compatibility padding, this will fail right</span>
<span class="cm">		 * after copy_from_user when the *len argument is validated.</span>
<span class="cm">		 *</span>
<span class="cm">		 * the compat_ variant needs to do one pass over the kernel</span>
<span class="cm">		 * data set to adjust for size differences before it the check.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_everything_to_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_copy_everything_to_user</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">xt_compat_flush_offsets</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>
	<span class="n">xt_compat_unlock</span><span class="p">(</span><span class="n">NFPROTO_BRIDGE</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_sockopt_ops</span> <span class="n">ebt_sockopts</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_optmin</span>	<span class="o">=</span> <span class="n">EBT_BASE_CTL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_optmax</span>	<span class="o">=</span> <span class="n">EBT_SO_SET_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set</span>		<span class="o">=</span> <span class="n">do_ebt_set_ctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_set</span>	<span class="o">=</span> <span class="n">compat_do_ebt_set_ctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">get_optmin</span>	<span class="o">=</span> <span class="n">EBT_BASE_CTL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_optmax</span>	<span class="o">=</span> <span class="n">EBT_SO_GET_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>		<span class="o">=</span> <span class="n">do_ebt_get_ctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_get</span>	<span class="o">=</span> <span class="n">compat_do_ebt_get_ctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ebtables_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xt_register_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_standard_target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_register_sockopt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_sockopts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xt_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_standard_target</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Ebtables v2.0 registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ebtables_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nf_unregister_sockopt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_sockopts</span><span class="p">);</span>
	<span class="n">xt_unregister_target</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ebt_standard_target</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Ebtables v2.0 unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ebt_register_table</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ebt_unregister_table</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ebt_do_table</span><span class="p">);</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ebtables_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ebtables_fini</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
