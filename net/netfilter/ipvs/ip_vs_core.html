<!DOCTYPE html>
<html><head><title>joekychen/linux » net › netfilter › ipvs › ip_vs_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ip_vs_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IPVS         An implementation of the IP virtual server support for the</span>
<span class="cm"> *              LINUX operating system.  IPVS is now implemented as a module</span>
<span class="cm"> *              over the Netfilter framework. IPVS can be used to build a</span>
<span class="cm"> *              high-performance and highly available server based on a</span>
<span class="cm"> *              cluster of servers.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:     Wensong Zhang &lt;wensong@linuxvirtualserver.org&gt;</span>
<span class="cm"> *              Peter Kese &lt;peter.kese@ijs.si&gt;</span>
<span class="cm"> *              Julian Anastasov &lt;ja@ssi.bg&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *              This program is free software; you can redistribute it and/or</span>
<span class="cm"> *              modify it under the terms of the GNU General Public License</span>
<span class="cm"> *              as published by the Free Software Foundation; either version</span>
<span class="cm"> *              2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * The IPVS code for kernel 2.2 was done by Wensong Zhang and Peter Kese,</span>
<span class="cm"> * with changes/fixes from Julian Anastasov, Lars Marowsky-Bree, Horms</span>
<span class="cm"> * and others.</span>
<span class="cm"> *</span>
<span class="cm"> * Changes:</span>
<span class="cm"> *	Paul `Rusty&#39; Russell		properly handle non-linear skbs</span>
<span class="cm"> *	Harald Welte			don&#39;t use nfcache</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define KMSG_COMPONENT &quot;IPVS&quot;</span>
<span class="cp">#define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/sctp.h&gt;</span>
<span class="cp">#include &lt;linux/icmp.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;net/udp.h&gt;</span>
<span class="cp">#include &lt;net/icmp.h&gt;                   </span><span class="cm">/* for icmp_send */</span><span class="cp"></span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>
<span class="cp">#include &lt;net/netns/generic.h&gt;		</span><span class="cm">/* net_generic() */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/netfilter.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv4.h&gt;</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv6.h&gt;</span>
<span class="cp">#include &lt;net/ip6_route.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;net/ip_vs.h&gt;</span>


<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_ip_vs_scheduler</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_ip_vs_scheduler</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_proto_name</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_conn_new</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_conn_in_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_conn_out_get</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IP_VS_PROTO_TCP</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_tcp_conn_listen</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_conn_put</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IP_VS_DEBUG</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_get_debug_level</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">ip_vs_net_id</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="cp">#ifdef IP_VS_GENERIC_NETNS</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_vs_net_id</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cm">/* netns cnt used for uniqueness */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">ipvs_netns_cnt</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/* ID used in ICMP lookups */</span>
<span class="cp">#define icmp_id(icmph)          (((icmph)-&gt;un).echo.id)</span>
<span class="cp">#define icmpv6_id(icmph)        (icmph-&gt;icmp6_dataun.u_echo.identifier)</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ip_vs_proto_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_IP</span>:
		<span class="k">return</span> <span class="s">&quot;IP&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
		<span class="k">return</span> <span class="s">&quot;UDP&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
		<span class="k">return</span> <span class="s">&quot;TCP&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_SCTP</span>:
		<span class="k">return</span> <span class="s">&quot;SCTP&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_ICMP</span>:
		<span class="k">return</span> <span class="s">&quot;ICMP&quot;</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">case</span> <span class="n">IPPROTO_ICMPV6</span>:
		<span class="k">return</span> <span class="s">&quot;ICMPv6&quot;</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;IP_%d&quot;</span><span class="p">,</span> <span class="n">proto</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ip_vs_init_hash_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="n">rows</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip_vs_in_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_DEST_F_AVAILABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ip_vs_cpu_stats</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">inpkts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">inbytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">inpkts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">inbytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">tot_stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">inpkts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">inbytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip_vs_out_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_DEST_F_AVAILABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ip_vs_cpu_stats</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">outpkts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">outbytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">outpkts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">outbytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">tot_stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">outpkts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">outbytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip_vs_conn_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ip_vs_cpu_stats</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">conns</span><span class="o">++</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">conns</span><span class="o">++</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">tot_stats</span><span class="p">.</span><span class="n">cpustats</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ustats</span><span class="p">.</span><span class="n">conns</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip_vs_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">state_transition</span><span class="p">))</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">state_transition</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ip_vs_conn_fill_param_persist</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">caddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">cport</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">vport</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ip_vs_conn_fill_param</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">caddr</span><span class="p">,</span> <span class="n">cport</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span>
			      <span class="n">vport</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pe</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">pe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pe</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">fill_param</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">fill_param</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  IPVS persistent scheduling function</span>
<span class="cm"> *  It creates a connection entry according to its template if exists,</span>
<span class="cm"> *  or selects a server and creates a connection entry plus a template.</span>
<span class="cm"> *  Locking: we are svc user (svc-&gt;refcnt), so we hold all dests too</span>
<span class="cm"> *  Protocols supported: TCP, UDP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
<span class="nf">ip_vs_sched_persist</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		    <span class="n">__be16</span> <span class="n">src_port</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">dst_port</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ignored</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">dport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* destination port to forward */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="n">param</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">fwmark</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">fwmark</span><span class="p">)</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">snet</span><span class="p">;</span>	<span class="cm">/* source network of the client,</span>
<span class="cm">					   after masking */</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>

	<span class="cm">/* Mask saddr with the netmask to adjust template granularity */</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="n">ipv6_addr_prefix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snet</span><span class="p">.</span><span class="n">in6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">.</span><span class="n">in6</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">netmask</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">snet</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">.</span><span class="n">ip</span> <span class="o">&amp;</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">netmask</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_BUF</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">&quot;p-schedule: src %s:%u dest %s:%u &quot;</span>
		      <span class="s">&quot;mnet %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">src_port</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">dst_port</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snet</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * As far as we know, FTP is a very complicated network protocol, and</span>
<span class="cm">	 * it uses control connection and data connections. For active FTP,</span>
<span class="cm">	 * FTP server initialize data connection to the client, its source port</span>
<span class="cm">	 * is often 20. For passive FTP, FTP server tells the clients the port</span>
<span class="cm">	 * that it passively listens to,  and the client issues the data</span>
<span class="cm">	 * connection. In the tunneling or direct routing mode, the load</span>
<span class="cm">	 * balancer is on the client-to-server half of connection, the port</span>
<span class="cm">	 * number is unknown to the load balancer. So, a conn template like</span>
<span class="cm">	 * &lt;caddr, 0, vaddr, 0, daddr, 0&gt; is created for persistent FTP</span>
<span class="cm">	 * service, and a template like &lt;caddr, 0, vaddr, vport, daddr, dport&gt;</span>
<span class="cm">	 * is created for other persistent services.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
		<span class="n">__be16</span> <span class="n">vport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dst_port</span> <span class="o">==</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* non-FTP template:</span>
<span class="cm">			 * &lt;protocol, caddr, 0, vaddr, vport, daddr, dport&gt;</span>
<span class="cm">			 * FTP template:</span>
<span class="cm">			 * &lt;protocol, caddr, 0, vaddr, 0, daddr, 0&gt;</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">FTPPORT</span><span class="p">)</span>
				<span class="n">vport</span> <span class="o">=</span> <span class="n">dst_port</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Note: persistent fwmark-based services and</span>
<span class="cm">			 * persistent port zero service are handled here.</span>
<span class="cm">			 * fwmark template:</span>
<span class="cm">			 * &lt;IPPROTO_IP,caddr,0,fwmark,0,daddr,0&gt;</span>
<span class="cm">			 * port zero template:</span>
<span class="cm">			 * &lt;protocol,caddr,0,vaddr,0,daddr,0&gt;</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">fwmark</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">protocol</span> <span class="o">=</span> <span class="n">IPPROTO_IP</span><span class="p">;</span>
				<span class="n">vaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fwmark</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* return *ignored = -1 so NF_DROP can be used */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_conn_fill_param_persist</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						  <span class="n">vaddr</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check if a template already exists */</span>
	<span class="n">ct</span> <span class="o">=</span> <span class="n">ip_vs_ct_in_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ct</span> <span class="o">||</span> <span class="o">!</span><span class="n">ip_vs_check_template</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No template found or the dest of the connection</span>
<span class="cm">		 * template is not available.</span>
<span class="cm">		 * return *ignored=0 i.e. ICMP and NF_DROP</span>
<span class="cm">		 */</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">scheduler</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;p-schedule: no dest found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">pe_data</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dst_port</span> <span class="o">==</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">&amp;&amp;</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">FTPPORT</span><span class="p">)</span>
			<span class="n">dport</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

		<span class="cm">/* Create a template</span>
<span class="cm">		 * This adds param.pe_data to the template,</span>
<span class="cm">		 * and thus param.pe_data will be destroyed</span>
<span class="cm">		 * when the template expires */</span>
		<span class="n">ct</span> <span class="o">=</span> <span class="n">ip_vs_conn_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">dport</span><span class="p">,</span>
				    <span class="n">IP_VS_CONN_F_TEMPLATE</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">pe_data</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* set destination with the found template */</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">pe_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dport</span> <span class="o">=</span> <span class="n">dst_port</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dport</span> <span class="o">==</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">&amp;&amp;</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span>
		<span class="n">dport</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_SVC_F_ONEPACKET</span>
		 <span class="o">&amp;&amp;</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span><span class="o">?</span>
		<span class="n">IP_VS_CONN_F_ONE_PACKET</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Create a new connection according to the template</span>
<span class="cm">	 */</span>
	<span class="n">ip_vs_conn_fill_param</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span>
			      <span class="n">src_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="n">dst_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">ip_vs_conn_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">dport</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Add its control</span>
<span class="cm">	 */</span>
	<span class="n">ip_vs_control_add</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="n">ip_vs_conn_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">svc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  IPVS main scheduling function</span>
<span class="cm"> *  It selects a server according to the virtual service, and</span>
<span class="cm"> *  creates a connection entry.</span>
<span class="cm"> *  Protocols supported: TCP, UDP</span>
<span class="cm"> *</span>
<span class="cm"> *  Usage of *ignored</span>
<span class="cm"> *</span>
<span class="cm"> * 1 :   protocol tried to schedule (eg. on SYN), found svc but the</span>
<span class="cm"> *       svc/scheduler decides that this packet should be accepted with</span>
<span class="cm"> *       NF_ACCEPT because it must not be scheduled.</span>
<span class="cm"> *</span>
<span class="cm"> * 0 :   scheduler can not find destination, so try bypass or</span>
<span class="cm"> *       return ICMP and then NF_DROP (ip_vs_leave).</span>
<span class="cm"> *</span>
<span class="cm"> * -1 :  scheduler tried to schedule but fatal error occurred, eg.</span>
<span class="cm"> *       ip_vs_conn_new failure (ENOMEM) or ip_vs_sip_fill_param</span>
<span class="cm"> *       failure such as missing Call-ID, ENOMEM on skb_linearize</span>
<span class="cm"> *       or pe_data. In this case we should return NF_DROP without</span>
<span class="cm"> *       any attempts to send ICMP with ip_vs_leave.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
<span class="nf">ip_vs_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ignored</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">pptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
	<span class="n">pptr</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ports</span><span class="p">),</span> <span class="n">_ports</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FTPDATA needs this check when using local real server.</span>
<span class="cm">	 * Never schedule Active FTPDATA connections from real server.</span>
<span class="cm">	 * For LVS-NAT they must be already created. For other methods</span>
<span class="cm">	 * with persistence the connection is created on SYN+ACK.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">FTPDATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="s">&quot;Not scheduling FTPDATA&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Do not schedule replies from local real server.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_in_get</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="s">&quot;Not scheduling reply for existing connection&quot;</span><span class="p">);</span>
		<span class="n">__ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Persistent service</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_SVC_F_PERSISTENT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ip_vs_sched_persist</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ignored</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Non-persistent service</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">fwmark</span> <span class="o">&amp;&amp;</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Schedule: port zero only supported &quot;</span>
			       <span class="s">&quot;in persistent services, &quot;</span>
			       <span class="s">&quot;check your ipvs configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dest</span> <span class="o">=</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">scheduler</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Schedule: no dest found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_SVC_F_ONEPACKET</span>
		 <span class="o">&amp;&amp;</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span><span class="o">?</span>
		<span class="n">IP_VS_CONN_F_ONE_PACKET</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Create a connection entry.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="n">p</span><span class="p">;</span>

		<span class="n">ip_vs_conn_fill_param</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				      <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">ip_vs_conn_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				    <span class="n">dest</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">?</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">:</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				    <span class="n">flags</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ignored</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">IP_VS_DBG_BUF</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">&quot;Schedule fwd:%c c:%s:%u v:%s:%u &quot;</span>
		      <span class="s">&quot;d:%s:%u conn-&gt;flags:%X conn-&gt;refcnt:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">ip_vs_fwd_tag</span><span class="p">(</span><span class="n">cp</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dport</span><span class="p">),</span>
		      <span class="n">cp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">));</span>

	<span class="n">ip_vs_conn_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">svc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  Pass or drop the packet.</span>
<span class="cm"> *  Called by ip_vs_in, when the virtual service is available but</span>
<span class="cm"> *  no destination is available for a new connection.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ip_vs_leave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be16</span> <span class="n">_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">pptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">iph</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unicast</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>

	<span class="n">pptr</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ports</span><span class="p">),</span> <span class="n">_ports</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip_vs_service_put</span><span class="p">(</span><span class="n">svc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="n">unicast</span> <span class="o">=</span> <span class="n">ipv6_addr_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">.</span><span class="n">in6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IPV6_ADDR_UNICAST</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">unicast</span> <span class="o">=</span> <span class="p">(</span><span class="n">inet_addr_type</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">.</span><span class="n">ip</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTN_UNICAST</span><span class="p">);</span>

	<span class="cm">/* if it is fwmark-based service, the cache_bypass sysctl is up</span>
<span class="cm">	   and the destination is a non-local unicast, then create</span>
<span class="cm">	   a cache_bypass connection entry */</span>
	<span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_cache_bypass</span> <span class="o">&amp;&amp;</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">fwmark</span> <span class="o">&amp;&amp;</span> <span class="n">unicast</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_SVC_F_ONEPACKET</span> <span class="o">&amp;&amp;</span>
				      <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span><span class="o">?</span>
				      <span class="n">IP_VS_CONN_F_ONE_PACKET</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">daddr</span> <span class="o">=</span>  <span class="p">{</span> <span class="p">.</span><span class="n">all</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>

		<span class="n">ip_vs_service_put</span><span class="p">(</span><span class="n">svc</span><span class="p">);</span>

		<span class="cm">/* create a new connection entry */</span>
		<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">&quot;%s(): create a cache_bypass entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">ip_vs_conn_fill_param</span><span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					      <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="n">pptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">ip_vs_conn_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">IP_VS_CONN_F_BYPASS</span> <span class="o">|</span> <span class="n">flags</span><span class="p">,</span>
					    <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* statistics */</span>
		<span class="n">ip_vs_in_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* set state */</span>
		<span class="n">ip_vs_set_state</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">IP_VS_DIR_INPUT</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>

		<span class="cm">/* transmit the first SYN packet */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">);</span>
		<span class="cm">/* do not touch skb anymore */</span>

		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">in_pkts</span><span class="p">);</span>
		<span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the virtual ftp service is presented, packets destined</span>
<span class="cm">	 * for other services on the VIP may get here (except services</span>
<span class="cm">	 * listed in the ipvs table), pass the packets, because it is</span>
<span class="cm">	 * not ipvs job to decide to drop the packets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">FTPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">FTPPORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ip_vs_service_put</span><span class="p">(</span><span class="n">svc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ip_vs_service_put</span><span class="p">(</span><span class="n">svc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Notify the client that the destination is unreachable, and</span>
<span class="cm">	 * release the socket buffer.</span>
<span class="cm">	 * Since it is in IP layer, the TCP socket is not actually</span>
<span class="cm">	 * created, the TCP RST packet cannot be sent, instead that</span>
<span class="cm">	 * ICMP_PORT_UNREACH is sent here no matter it is TCP/UDP. --WZ</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">loopback_dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">icmpv6_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ICMPV6_DEST_UNREACH</span><span class="p">,</span> <span class="n">ICMPV6_PORT_UNREACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">icmp_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ICMP_DEST_UNREACH</span><span class="p">,</span> <span class="n">ICMP_PORT_UNREACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysctl_snat_reroute</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_snat_reroute</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysctl_nat_icmp_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_nat_icmp_send</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysctl_expire_nodest_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_expire_nodest_conn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysctl_snat_reroute</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysctl_nat_icmp_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysctl_expire_nodest_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif</span>

<span class="n">__sum16</span> <span class="nf">ip_vs_checksum_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">csum_fold</span><span class="p">(</span><span class="n">skb_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">ip_defrag_users</span> <span class="nf">ip_vs_defrag_user</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NF_INET_LOCAL_IN</span> <span class="o">==</span> <span class="n">hooknum</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IP_DEFRAG_VS_IN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NF_INET_FORWARD</span> <span class="o">==</span> <span class="n">hooknum</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IP_DEFRAG_VS_FWD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">IP_DEFRAG_VS_OUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_gather_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u_int32_t</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ip_defrag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ip_send_check</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_gather_frags_v6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u_int32_t</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TODO IPv6: Find out what to do here for IPv6 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ip_vs_route_me_harder</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_snat_reroute</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip6_route_me_harder</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sysctl_snat_reroute</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">skb_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_flags</span> <span class="o">&amp;</span> <span class="n">RTCF_LOCAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ip_route_me_harder</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RTN_LOCAL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Packet has been made sufficiently writable in caller</span>
<span class="cm"> * - inout: 1=in-&gt;out, 0=out-&gt;in</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ip_vs_nat_icmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span>	 <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icmp_offset</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmphdr</span> <span class="o">*</span><span class="n">icmph</span>	 <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span>
						      <span class="n">icmp_offset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ciph</span>	 <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">icmph</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">.</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">ip_send_check</span><span class="p">(</span><span class="n">iph</span><span class="p">);</span>
		<span class="n">ciph</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">.</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">ip_send_check</span><span class="p">(</span><span class="n">ciph</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">ip_send_check</span><span class="p">(</span><span class="n">iph</span><span class="p">);</span>
		<span class="n">ciph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">ip_send_check</span><span class="p">(</span><span class="n">ciph</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* the TCP/UDP/SCTP port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IPPROTO_TCP</span> <span class="o">==</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">||</span> <span class="n">IPPROTO_UDP</span> <span class="o">==</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">||</span>
	    <span class="n">IPPROTO_SCTP</span> <span class="o">==</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__be16</span> <span class="o">*</span><span class="n">ports</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ciph</span> <span class="o">+</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
			<span class="n">ports</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dport</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* And finally the ICMP checksum */</span>
	<span class="n">icmph</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icmph</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">ip_vs_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">icmp_offset</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ciph</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span>
			<span class="s">&quot;Forwarding altered outgoing ICMP&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ciph</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span>
			<span class="s">&quot;Forwarding altered incoming ICMP&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="kt">void</span> <span class="nf">ip_vs_nat_icmp_v6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">iph</span>	 <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icmp_offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">icmp6hdr</span> <span class="o">*</span><span class="n">icmph</span>	 <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmp6hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span>
						      <span class="n">icmp_offset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">ciph</span>	 <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">icmph</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">.</span><span class="n">in6</span><span class="p">;</span>
		<span class="n">ciph</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">.</span><span class="n">in6</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">in6</span><span class="p">;</span>
		<span class="n">ciph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">in6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the TCP/UDP/SCTP port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IPPROTO_TCP</span> <span class="o">==</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">||</span> <span class="n">IPPROTO_UDP</span> <span class="o">==</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">||</span>
	    <span class="n">IPPROTO_SCTP</span> <span class="o">==</span> <span class="n">ciph</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__be16</span> <span class="o">*</span><span class="n">ports</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ciph</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
			<span class="n">ports</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dport</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* And finally the ICMP checksum */</span>
	<span class="n">icmph</span><span class="o">-&gt;</span><span class="n">icmp6_cksum</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
					      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">icmp_offset</span><span class="p">,</span>
					      <span class="n">IPPROTO_ICMPV6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">icmp_offset</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmp6hdr</span><span class="p">,</span> <span class="n">icmp6_cksum</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ciph</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span>
			      <span class="s">&quot;Forwarding altered outgoing ICMPv6&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ciph</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span>
			      <span class="s">&quot;Forwarding altered incoming ICMPv6&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Handle relevant response ICMP messages - forward to the right</span>
<span class="cm"> * destination host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_response_icmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">snet</span><span class="p">,</span>
				<span class="n">__u8</span> <span class="n">protocol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ihl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verdict</span> <span class="o">=</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VS_FWD_METHOD</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;shouldn&#39;t reach here, because the box is on the &quot;</span>
		       <span class="s">&quot;half connection in the tun/dr module.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Ensure the checksum is correct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip_vs_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ihl</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Failed checksum! */</span>
		<span class="n">IP_VS_DBG_BUF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Forward ICMP: failed checksum from %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">snet</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IPPROTO_TCP</span> <span class="o">==</span> <span class="n">protocol</span> <span class="o">||</span> <span class="n">IPPROTO_UDP</span> <span class="o">==</span> <span class="n">protocol</span> <span class="o">||</span>
	    <span class="n">IPPROTO_SCTP</span> <span class="o">==</span> <span class="n">protocol</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_make_writable</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="n">ip_vs_nat_icmp_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">ip_vs_nat_icmp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_route_me_harder</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* do the statistics and put it back */</span>
	<span class="n">ip_vs_out_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ipvs_property</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_CONN_F_NFCT</span><span class="p">))</span>
		<span class="n">ip_vs_notrack</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ip_vs_update_conntrack</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">__ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Handle ICMP messages in the inside-to-outside direction (outgoing).</span>
<span class="cm"> *	Find any that might be relevant, check against existing connections.</span>
<span class="cm"> *	Currently handles error types - unreachable, quench, ttl exceeded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ip_vs_out_icmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">related</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmphdr</span>	<span class="n">_icmph</span><span class="p">,</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span>	<span class="n">_ciph</span><span class="p">,</span> <span class="o">*</span><span class="n">cih</span><span class="p">;</span>	<span class="cm">/* The ip header contained within the ICMP */</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">ciph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ihl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">snet</span><span class="p">;</span>

	<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* reassemble IP fragments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_is_fragment</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_gather_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ip_vs_defrag_user</span><span class="p">(</span><span class="n">hooknum</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">ihl</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">ic</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;Outgoing ICMP (%d,%d) %pI4-&gt;%pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">icmp_id</span><span class="p">(</span><span class="n">ic</span><span class="p">)),</span>
		  <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work through seeing if this is for us.</span>
<span class="cm">	 * These checks are supposed to be in an order that means easy</span>
<span class="cm">	 * things are checked first to speed up processing.... however</span>
<span class="cm">	 * this means that some packets will manage to get a long way</span>
<span class="cm">	 * down this stack and then be rejected, but that&#39;s life.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_DEST_UNREACH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_SOURCE_QUENCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_TIME_EXCEEDED</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now find the contained IP header */</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="n">cih</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ciph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_ciph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cih</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span> <span class="cm">/* The packet looks wrong, ignore */</span>

	<span class="n">pp</span> <span class="o">=</span> <span class="n">ip_vs_proto_get</span><span class="p">(</span><span class="n">cih</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* Is the embedded protocol header present? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cih</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">&amp;</span> <span class="n">htons</span><span class="p">(</span><span class="n">IP_OFFSET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">pp</span><span class="o">-&gt;</span><span class="n">dont_defrag</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="s">&quot;Checking outgoing ICMP for&quot;</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">cih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">);</span>
	<span class="cm">/* The embedded headers contain source and dest in reverse order */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_out_get</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">snet</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">handle_response_icmp</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snet</span><span class="p">,</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span>
				    <span class="n">pp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ihl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ip_vs_out_icmp_v6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">related</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmp6hdr</span>	<span class="n">_icmph</span><span class="p">,</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span>	<span class="n">_ciph</span><span class="p">,</span> <span class="o">*</span><span class="n">cih</span><span class="p">;</span>	<span class="cm">/* The ip header contained</span>
<span class="cm">					   within the ICMP */</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">ciph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">snet</span><span class="p">;</span>

	<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* reassemble IP fragments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_FRAGMENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_gather_frags_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ip_vs_defrag_user</span><span class="p">(</span><span class="n">hooknum</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>
	<span class="n">ic</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;Outgoing ICMPv6 (%d,%d) %pI6-&gt;%pI6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">icmpv6_id</span><span class="p">(</span><span class="n">ic</span><span class="p">)),</span>
		  <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work through seeing if this is for us.</span>
<span class="cm">	 * These checks are supposed to be in an order that means easy</span>
<span class="cm">	 * things are checked first to speed up processing.... however</span>
<span class="cm">	 * this means that some packets will manage to get a long way</span>
<span class="cm">	 * down this stack and then be rejected, but that&#39;s life.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span> <span class="o">!=</span> <span class="n">ICMPV6_DEST_UNREACH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span> <span class="o">!=</span> <span class="n">ICMPV6_PKT_TOOBIG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span> <span class="o">!=</span> <span class="n">ICMPV6_TIME_EXCEED</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now find the contained IP header */</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="n">cih</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ciph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_ciph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cih</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span> <span class="cm">/* The packet looks wrong, ignore */</span>

	<span class="n">pp</span> <span class="o">=</span> <span class="n">ip_vs_proto_get</span><span class="p">(</span><span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* Is the embedded protocol header present? */</span>
	<span class="cm">/* TODO: we don&#39;t support fragmentation at the moment anyways */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_FRAGMENT</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">dont_defrag</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="s">&quot;Checking outgoing ICMPv6 for&quot;</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">cih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">);</span>
	<span class="cm">/* The embedded headers contain source and dest in reverse order */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_out_get</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">snet</span><span class="p">.</span><span class="n">in6</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">handle_response_icmp</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snet</span><span class="p">,</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span>
				    <span class="n">pp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Check if sctp chunc is ABORT chunk</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_sctp_abort</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nh_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sctp_chunkhdr_t</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="n">schunk</span><span class="p">;</span>
	<span class="n">sch</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nh_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_sctphdr_t</span><span class="p">),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">schunk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">schunk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sch</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SCTP_CID_ABORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_tcp_reset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nh_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="n">_tcph</span><span class="p">,</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>

	<span class="n">th</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nh_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_tcph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_tcph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle response packets: rewrite addresses and send away...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">handle_response</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ihl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Outgoing packet&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_make_writable</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ihl</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* mangle the packet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">snat_handler</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">snat_handler</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">cp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">.</span><span class="n">in6</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">.</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">ip_send_check</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * nf_iterate does not expect change in the skb-&gt;dst-&gt;dev.</span>
<span class="cm">	 * It looks like it is not fatal to enable this code for hooks</span>
<span class="cm">	 * where our handlers are at the end of the chain list and</span>
<span class="cm">	 * when all next handlers use skb-&gt;dst-&gt;dev and not outdev.</span>
<span class="cm">	 * It will definitely route properly the inout NAT traffic</span>
<span class="cm">	 * when multiple paths are used.</span>
<span class="cm">	 */</span>

	<span class="cm">/* For policy routing, packets originating from this</span>
<span class="cm">	 * machine itself may be routed differently to packets</span>
<span class="cm">	 * passing through.  We want this packet to be routed as</span>
<span class="cm">	 * if it came from this machine itself.  So re-compute</span>
<span class="cm">	 * the routing information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_route_me_harder</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;After SNAT&quot;</span><span class="p">);</span>

	<span class="n">ip_vs_out_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">ip_vs_set_state</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">IP_VS_DIR_OUTPUT</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ipvs_property</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_CONN_F_NFCT</span><span class="p">))</span>
		<span class="n">ip_vs_notrack</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ip_vs_update_conntrack</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="n">LeaveFunction</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">LeaveFunction</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Check if outgoing packet belongs to the established ip_vs_conn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_out</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">af</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">EnterFunction</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>

	<span class="cm">/* Already marked as IPVS request or reply? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ipvs_property</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* Bad... Do not break raw sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">hooknum</span> <span class="o">==</span> <span class="n">NF_INET_LOCAL_OUT</span> <span class="o">&amp;&amp;</span>
		     <span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inet</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">nodefrag</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_ICMPV6</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">related</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_out_icmp_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">related</span><span class="p">,</span>
							<span class="n">hooknum</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">related</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
			<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_ICMP</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">related</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_out_icmp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">related</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">related</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
			<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">ip_vs_proto_data_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">;</span>

	<span class="cm">/* reassemble IP fragments */</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_FRAGMENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_gather_frags_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						  <span class="n">ip_vs_defrag_user</span><span class="p">(</span><span class="n">hooknum</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ip_is_fragment</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">dont_defrag</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_gather_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					       <span class="n">ip_vs_defrag_user</span><span class="p">(</span><span class="n">hooknum</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>

			<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the packet belongs to an existing entry</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_out_get</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">handle_response</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_nat_icmp_send</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span> <span class="o">||</span>
	     <span class="n">pp</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span> <span class="o">||</span>
	     <span class="n">pp</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_SCTP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__be16</span> <span class="n">_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">pptr</span><span class="p">;</span>

		<span class="n">pptr</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="n">_ports</span><span class="p">),</span> <span class="n">_ports</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>	<span class="cm">/* Not for me */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_lookup_real_service</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span>
					      <span class="n">pptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Notify the real server: there is no</span>
<span class="cm">			 * existing entry if it is not RST</span>
<span class="cm">			 * packet or not TCP packet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span> <span class="o">&amp;&amp;</span>
			     <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_SCTP</span><span class="p">)</span>
			     <span class="o">||</span> <span class="p">((</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span>
				  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_tcp_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">))</span>
				 <span class="o">||</span> <span class="p">(</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_SCTP</span>
					<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_sctp_abort</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						<span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">))))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span>
						<span class="n">dev_net</span><span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
						<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">loopback_dev</span><span class="p">;</span>
					<span class="n">icmpv6_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						    <span class="n">ICMPV6_DEST_UNREACH</span><span class="p">,</span>
						    <span class="n">ICMPV6_PORT_UNREACH</span><span class="p">,</span>
						    <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
					<span class="n">icmp_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
						  <span class="n">ICMP_DEST_UNREACH</span><span class="p">,</span>
						  <span class="n">ICMP_PORT_UNREACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		      <span class="s">&quot;ip_vs_out: packet continues traversal as normal&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	It is hooked at the NF_INET_FORWARD and NF_INET_LOCAL_IN chain,</span>
<span class="cm"> *	used only for VS/NAT.</span>
<span class="cm"> *	Check if packet is reply for established ip_vs_conn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_reply4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ip_vs_out</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	It is hooked at the NF_INET_LOCAL_OUT chain, used only for VS/NAT.</span>
<span class="cm"> *	Check if packet is reply for established ip_vs_conn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_local_reply4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verdict</span><span class="p">;</span>

	<span class="cm">/* Disable BH in LOCAL_OUT until all places are fixed */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_out</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>

<span class="cm">/*</span>
<span class="cm"> *	It is hooked at the NF_INET_FORWARD and NF_INET_LOCAL_IN chain,</span>
<span class="cm"> *	used only for VS/NAT.</span>
<span class="cm"> *	Check if packet is reply for established ip_vs_conn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_reply6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ip_vs_out</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	It is hooked at the NF_INET_LOCAL_OUT chain, used only for VS/NAT.</span>
<span class="cm"> *	Check if packet is reply for established ip_vs_conn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_local_reply6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verdict</span><span class="p">;</span>

	<span class="cm">/* Disable BH in LOCAL_OUT until all places are fixed */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_out</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Handle ICMP messages in the outside-to-inside direction (incoming).</span>
<span class="cm"> *	Find any that might be relevant, check against existing connections,</span>
<span class="cm"> *	forward to the right destination host if relevant.</span>
<span class="cm"> *	Currently handles error types - unreachable, quench, ttl exceeded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ip_vs_in_icmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">related</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmphdr</span>	<span class="n">_icmph</span><span class="p">,</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span>	<span class="n">_ciph</span><span class="p">,</span> <span class="o">*</span><span class="n">cih</span><span class="p">;</span>	<span class="cm">/* The ip header contained within the ICMP */</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">ciph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ihl</span><span class="p">,</span> <span class="n">verdict</span><span class="p">;</span>

	<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* reassemble IP fragments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip_is_fragment</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_gather_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ip_vs_defrag_user</span><span class="p">(</span><span class="n">hooknum</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">ihl</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">ic</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;Incoming ICMP (%d,%d) %pI4-&gt;%pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">icmp_id</span><span class="p">(</span><span class="n">ic</span><span class="p">)),</span>
		  <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work through seeing if this is for us.</span>
<span class="cm">	 * These checks are supposed to be in an order that means easy</span>
<span class="cm">	 * things are checked first to speed up processing.... however</span>
<span class="cm">	 * this means that some packets will manage to get a long way</span>
<span class="cm">	 * down this stack and then be rejected, but that&#39;s life.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_DEST_UNREACH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_SOURCE_QUENCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_TIME_EXCEEDED</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now find the contained IP header */</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="n">cih</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ciph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_ciph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cih</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span> <span class="cm">/* The packet looks wrong, ignore */</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">ip_vs_proto_data_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">;</span>

	<span class="cm">/* Is the embedded protocol header present? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cih</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">&amp;</span> <span class="n">htons</span><span class="p">(</span><span class="n">IP_OFFSET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">pp</span><span class="o">-&gt;</span><span class="n">dont_defrag</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="s">&quot;Checking incoming ICMP for&quot;</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">cih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">);</span>
	<span class="cm">/* The embedded headers contain source and dest in reverse order */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_in_get</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">verdict</span> <span class="o">=</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="cm">/* Ensure the checksum is correct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip_vs_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ihl</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Failed checksum! */</span>
		<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Incoming ICMP: failed checksum from %pI4!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do the statistics and put it back */</span>
	<span class="n">ip_vs_in_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IPPROTO_TCP</span> <span class="o">==</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">||</span> <span class="n">IPPROTO_UDP</span> <span class="o">==</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">);</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_icmp_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">__ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ip_vs_in_icmp_v6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">related</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmp6hdr</span>	<span class="n">_icmph</span><span class="p">,</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span>	<span class="n">_ciph</span><span class="p">,</span> <span class="o">*</span><span class="n">cih</span><span class="p">;</span>	<span class="cm">/* The ip header contained</span>
<span class="cm">					   within the ICMP */</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">ciph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">verdict</span><span class="p">;</span>

	<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* reassemble IP fragments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_FRAGMENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_gather_frags_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ip_vs_defrag_user</span><span class="p">(</span><span class="n">hooknum</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">NF_STOLEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iph</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>
	<span class="n">ic</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;Incoming ICMPv6 (%d,%d) %pI6-&gt;%pI6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">icmpv6_id</span><span class="p">(</span><span class="n">ic</span><span class="p">)),</span>
		  <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work through seeing if this is for us.</span>
<span class="cm">	 * These checks are supposed to be in an order that means easy</span>
<span class="cm">	 * things are checked first to speed up processing.... however</span>
<span class="cm">	 * this means that some packets will manage to get a long way</span>
<span class="cm">	 * down this stack and then be rejected, but that&#39;s life.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span> <span class="o">!=</span> <span class="n">ICMPV6_DEST_UNREACH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span> <span class="o">!=</span> <span class="n">ICMPV6_PKT_TOOBIG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">icmp6_type</span> <span class="o">!=</span> <span class="n">ICMPV6_TIME_EXCEED</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">related</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now find the contained IP header */</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_icmph</span><span class="p">);</span>
	<span class="n">cih</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_ciph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_ciph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cih</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span> <span class="cm">/* The packet looks wrong, ignore */</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="n">ip_vs_proto_data_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">;</span>

	<span class="cm">/* Is the embedded protocol header present? */</span>
	<span class="cm">/* TODO: we don&#39;t support fragmentation at the moment anyways */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_FRAGMENT</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">dont_defrag</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="s">&quot;Checking incoming ICMPv6 for&quot;</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">cih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">);</span>
	<span class="cm">/* The embedded headers contain source and dest in reverse order */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_in_get</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ciph</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* do the statistics and put it back */</span>
	<span class="n">ip_vs_in_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IPPROTO_TCP</span> <span class="o">==</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">||</span> <span class="n">IPPROTO_UDP</span> <span class="o">==</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">||</span>
	    <span class="n">IPPROTO_SCTP</span> <span class="o">==</span> <span class="n">cih</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">);</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_icmp_xmit_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>

	<span class="n">__ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> *	Check if it&#39;s for virtual services, look it up,</span>
<span class="cm"> *	and send it on its way...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_in</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">af</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="n">iph</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">pkts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">;</span>

	<span class="cm">/* Already marked as IPVS request or reply? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ipvs_property</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Big tappo:</span>
<span class="cm">	 *	- remote client: only PACKET_HOST</span>
<span class="cm">	 *	- route: used for struct net when skb-&gt;dev is unset</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">!=</span> <span class="n">PACKET_HOST</span> <span class="o">&amp;&amp;</span>
		      <span class="n">hooknum</span> <span class="o">!=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">)</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
		<span class="n">IP_VS_DBG_BUF</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;packet type=%d proto=%d daddr=%s&quot;</span>
			      <span class="s">&quot; ignored in hook %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">.</span><span class="n">daddr</span><span class="p">),</span> <span class="n">hooknum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* ipvs enabled in this netns ? */</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>

	<span class="cm">/* Bad... Do not break raw sockets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">hooknum</span> <span class="o">==</span> <span class="n">NF_INET_LOCAL_OUT</span> <span class="o">&amp;&amp;</span>
		     <span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inet</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">nodefrag</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_ICMPV6</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">related</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_in_icmp_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">related</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">related</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
			<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iph</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_ICMP</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">related</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_in_icmp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">related</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">related</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
			<span class="n">ip_vs_fill_iphdr</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/* Protocol supported? */</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="n">ip_vs_proto_data_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">protocol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if the packet belongs to an existing connection entry</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_in_get</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">v</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">conn_schedule</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* sorry, all this trouble for a no-hit :) */</span>
		<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="s">&quot;ip_vs_in: packet continues traversal as normal&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IP_VS_DBG_PKT</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Incoming packet&quot;</span><span class="p">);</span>
	<span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="cm">/* Check the server status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_DEST_F_AVAILABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* the destination server is not available */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_expire_nodest_conn</span><span class="p">(</span><span class="n">ipvs</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* try to expire the connection immediately */</span>
			<span class="n">ip_vs_conn_expire_now</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* don&#39;t restart its timer, and silently</span>
<span class="cm">		   drop the packet. */</span>
		<span class="n">__ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ip_vs_in_stats</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">ip_vs_set_state</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">IP_VS_DIR_INPUT</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">packet_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">pp</span><span class="p">);</span>
		<span class="cm">/* do not touch skb anymore */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">IP_VS_DBG_RL</span><span class="p">(</span><span class="s">&quot;warning: packet_xmit is null&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Increase its packet counter and check if it is needed</span>
<span class="cm">	 * to be synchronized</span>
<span class="cm">	 *</span>
<span class="cm">	 * Sync connection if it is about to close to</span>
<span class="cm">	 * encorage the standby servers to update the connections timeout</span>
<span class="cm">	 *</span>
<span class="cm">	 * For ONE_PKT let ip_vs_sync_conn() do the filter work.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IP_VS_CONN_F_ONE_PACKET</span><span class="p">)</span>
		<span class="n">pkts</span> <span class="o">=</span> <span class="n">sysctl_sync_threshold</span><span class="p">(</span><span class="n">ipvs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pkts</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">in_pkts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sync_state</span> <span class="o">&amp;</span> <span class="n">IP_VS_STATE_MASTER</span><span class="p">)</span>
		<span class="n">ip_vs_sync_conn</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">pkts</span><span class="p">);</span>

	<span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	AF_INET handler in NF_INET_LOCAL_IN chain</span>
<span class="cm"> *	Schedule and forward packets from remote clients</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_remote_request4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ip_vs_in</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	AF_INET handler in NF_INET_LOCAL_OUT chain</span>
<span class="cm"> *	Schedule and forward packets from local clients</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_local_request4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verdict</span><span class="p">;</span>

	<span class="cm">/* Disable BH in LOCAL_OUT until all places are fixed */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_in</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>

<span class="cm">/*</span>
<span class="cm"> *	AF_INET6 handler in NF_INET_LOCAL_IN chain</span>
<span class="cm"> *	Schedule and forward packets from remote clients</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_remote_request6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ip_vs_in</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	AF_INET6 handler in NF_INET_LOCAL_OUT chain</span>
<span class="cm"> *	Schedule and forward packets from local clients</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_local_request6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verdict</span><span class="p">;</span>

	<span class="cm">/* Disable BH in LOCAL_OUT until all places are fixed */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">verdict</span> <span class="o">=</span> <span class="n">ip_vs_in</span><span class="p">(</span><span class="n">hooknum</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> *	It is hooked at the NF_INET_FORWARD chain, in order to catch ICMP</span>
<span class="cm"> *      related packets destined for 0.0.0.0/0.</span>
<span class="cm"> *      When fwmark-based virtual service is used, such as transparent</span>
<span class="cm"> *      cache cluster, TCP packets can be marked and routed to ip_vs_in,</span>
<span class="cm"> *      but ICMP destined for 0.0.0.0/0 cannot not be easily marked and</span>
<span class="cm"> *      sent to ip_vs_in_icmp. So, catch them at the NF_INET_FORWARD chain</span>
<span class="cm"> *      and send them to ip_vs_in_icmp.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_forward_icmp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_ICMP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* ipvs enabled in this netns ? */</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ip_vs_in_icmp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_forward_icmp_v6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">!=</span> <span class="n">IPPROTO_ICMPV6</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* ipvs enabled in this netns ? */</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">skb_net</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ip_vs_in_icmp_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">ip_vs_ops</span><span class="p">[]</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* After packet filtering, change source only for VS/NAT */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_reply4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP_PRI_NAT_SRC</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After packet filtering, forward packet through VS/DR, VS/TUN,</span>
<span class="cm">	 * or VS/NAT(change destination), so that filtering rules can be</span>
<span class="cm">	 * applied to IPVS. */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_remote_request4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP_PRI_NAT_SRC</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* Before ip_vs_in, change source only for VS/NAT */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_local_reply4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP_PRI_NAT_DST</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After mangle, schedule and forward local requests */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_local_request4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP_PRI_NAT_DST</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After packet filtering (but before ip_vs_out_icmp), catch icmp</span>
<span class="cm">	 * destined for 0.0.0.0/0, which is for incoming IPVS connections */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_forward_icmp</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="mi">99</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After packet filtering, change source only for VS/NAT */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_reply4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="cm">/* After packet filtering, change source only for VS/NAT */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_reply6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP6_PRI_NAT_SRC</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After packet filtering, forward packet through VS/DR, VS/TUN,</span>
<span class="cm">	 * or VS/NAT(change destination), so that filtering rules can be</span>
<span class="cm">	 * applied to IPVS. */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_remote_request6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP6_PRI_NAT_SRC</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* Before ip_vs_in, change source only for VS/NAT */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_local_reply6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP6_PRI_NAT_DST</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After mangle, schedule and forward local requests */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_local_request6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="n">NF_IP6_PRI_NAT_DST</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After packet filtering (but before ip_vs_out_icmp), catch icmp</span>
<span class="cm">	 * destined for 0.0.0.0/0, which is for incoming IPVS connections */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_forward_icmp_v6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="mi">99</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* After packet filtering, change source only for VS/NAT */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">hook</span>		<span class="o">=</span> <span class="n">ip_vs_reply6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pf</span>		<span class="o">=</span> <span class="n">PF_INET6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hooknum</span>	<span class="o">=</span> <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span>	<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> *	Initialize IP Virtual Server netns mem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">__ip_vs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">;</span>

	<span class="n">ipvs</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ip_vs_net_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipvs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Hold the beast until a service is registerd */</span>
	<span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="cm">/* Counters used for creating unique names */</span>
	<span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_netns_cnt</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_netns_cnt</span><span class="p">);</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ipvs</span> <span class="o">=</span> <span class="n">ipvs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_estimator_net_init</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">estimator_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_control_net_init</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">control_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_protocol_net_init</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">protocol_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_app_net_init</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">app_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_conn_net_init</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">conn_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_vs_sync_net_init</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sync_fail</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;IPVS: Creating netns size=%zu id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span><span class="p">),</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Error handling</span>
<span class="cm"> */</span>

<span class="nl">sync_fail:</span>
	<span class="n">ip_vs_conn_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">conn_fail:</span>
	<span class="n">ip_vs_app_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">app_fail:</span>
	<span class="n">ip_vs_protocol_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">protocol_fail:</span>
	<span class="n">ip_vs_control_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">control_fail:</span>
	<span class="n">ip_vs_estimator_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">estimator_fail:</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ipvs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">__ip_vs_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ip_vs_service_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>	<span class="cm">/* ip_vs_flush() with locks */</span>
	<span class="n">ip_vs_conn_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">ip_vs_app_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">ip_vs_protocol_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">ip_vs_control_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">ip_vs_estimator_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">IP_VS_DBG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;ipvs netns %d released</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ipvs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">__ip_vs_dev_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EnterFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">net_ipvs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Disable packet reception */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">ip_vs_sync_net_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">LeaveFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">ipvs_core_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">__ip_vs_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">__ip_vs_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">ip_vs_net_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">ipvs_core_dev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">__ip_vs_dev_cleanup</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Initialize IP Virtual Server</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ip_vs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ip_vs_control_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can&#39;t setup control.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ip_vs_protocol_init</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ip_vs_conn_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can&#39;t setup connection table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup_protocol</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_core_ops</span><span class="p">);</span>	<span class="cm">/* Alloc ip_vs struct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_conn</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_pernet_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_core_dev_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_sub</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_register_hooks</span><span class="p">(</span><span class="n">ip_vs_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ip_vs_ops</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can&#39;t register hooks.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ip_vs_register_nl_ioctl</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can&#39;t register netlink/ioctl.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup_hooks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ipvs loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">cleanup_hooks:</span>
	<span class="n">nf_unregister_hooks</span><span class="p">(</span><span class="n">ip_vs_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ip_vs_ops</span><span class="p">));</span>
<span class="nl">cleanup_dev:</span>
	<span class="n">unregister_pernet_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_core_dev_ops</span><span class="p">);</span>
<span class="nl">cleanup_sub:</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_core_ops</span><span class="p">);</span>
<span class="nl">cleanup_conn:</span>
	<span class="n">ip_vs_conn_cleanup</span><span class="p">();</span>
<span class="nl">cleanup_protocol:</span>
	<span class="n">ip_vs_protocol_cleanup</span><span class="p">();</span>
	<span class="n">ip_vs_control_cleanup</span><span class="p">();</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ip_vs_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ip_vs_unregister_nl_ioctl</span><span class="p">();</span>
	<span class="n">nf_unregister_hooks</span><span class="p">(</span><span class="n">ip_vs_ops</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ip_vs_ops</span><span class="p">));</span>
	<span class="n">unregister_pernet_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_core_dev_ops</span><span class="p">);</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipvs_core_ops</span><span class="p">);</span>	<span class="cm">/* free ip_vs struct */</span>
	<span class="n">ip_vs_conn_cleanup</span><span class="p">();</span>
	<span class="n">ip_vs_protocol_cleanup</span><span class="p">();</span>
	<span class="n">ip_vs_control_cleanup</span><span class="p">();</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ipvs unloaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ip_vs_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ip_vs_cleanup</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
