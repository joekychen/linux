<!DOCTYPE html>
<html><head><title>joekychen/linux » net › netfilter › nf_conntrack_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nf_conntrack_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Connection state tracking for netfilter.  This is separated from,</span>
<span class="cm">   but required by, the NAT layer; it can also be used by an iptables</span>
<span class="cm">   extension. */</span>

<span class="cm">/* (C) 1999-2001 Paul `Rusty&#39; Russell</span>
<span class="cm"> * (C) 2002-2006 Netfilter Core Team &lt;coreteam@netfilter.org&gt;</span>
<span class="cm"> * (C) 2003,2004 USAGI/WIDE Project &lt;http://www.linux-ipv6.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/rculist_nulls.h&gt;</span>

<span class="cp">#include &lt;net/netfilter/nf_conntrack.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_l3proto.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_l4proto.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_expect.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_helper.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_core.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_extend.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_acct.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_ecache.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_zones.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_timestamp.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_timeout.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_nat.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_nat_core.h&gt;</span>

<span class="cp">#define NF_CONNTRACK_VERSION	&quot;0.5.0&quot;</span>

<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nfnetlink_parse_nat_setup_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">nf_nat_manip_type</span> <span class="n">manip</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nfnetlink_parse_nat_setup_hook</span><span class="p">);</span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nf_conntrack_htable_size</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_htable_size</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nf_conntrack_max</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_max</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span><span class="p">,</span> <span class="n">nf_conntrack_untracked</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">nf_conntrack_untracked</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nf_conntrack_hash_rnd</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_hash_rnd</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_conntrack_raw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* The direction must be ignored, so we hash everything up to the</span>
<span class="cm">	 * destination ports (which is a multiple of 4) and treat the last</span>
<span class="cm">	 * three bytes manually.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">tuple</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tuple</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">u3</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jhash2</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">tuple</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">zone</span> <span class="o">^</span> <span class="n">nf_conntrack_hash_rnd</span> <span class="o">^</span>
		      <span class="p">(((</span><span class="n">__force</span> <span class="n">__u16</span><span class="p">)</span><span class="n">tuple</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">all</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		      <span class="n">tuple</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">__hash_bucket</span><span class="p">(</span><span class="n">u32</span> <span class="n">hash</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">hash</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hash_bucket</span><span class="p">(</span><span class="n">u32</span> <span class="n">hash</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__hash_bucket</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u_int32_t</span> <span class="nf">__hash_conntrack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__hash_bucket</span><span class="p">(</span><span class="n">hash_conntrack_raw</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="n">zone</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u_int32_t</span> <span class="nf">hash_conntrack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__hash_conntrack</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">nf_ct_get_tuple</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nhoff</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
		<span class="n">u_int16_t</span> <span class="n">l3num</span><span class="p">,</span>
		<span class="n">u_int8_t</span> <span class="n">protonum</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_l3proto</span> <span class="o">*</span><span class="n">l3proto</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tuple</span><span class="p">));</span>

	<span class="n">tuple</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">=</span> <span class="n">l3num</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l3proto</span><span class="o">-&gt;</span><span class="n">pkt_to_tuple</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nhoff</span><span class="p">,</span> <span class="n">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">tuple</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">=</span> <span class="n">protonum</span><span class="p">;</span>
	<span class="n">tuple</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">pkt_to_tuple</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">tuple</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_get_tuple</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">nf_ct_get_tuplepr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nhoff</span><span class="p">,</span>
		       <span class="n">u_int16_t</span> <span class="n">l3num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_l3proto</span> <span class="o">*</span><span class="n">l3proto</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protoff</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">protonum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">l3proto</span> <span class="o">=</span> <span class="n">__nf_ct_l3proto_find</span><span class="p">(</span><span class="n">l3num</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">l3proto</span><span class="o">-&gt;</span><span class="n">get_l4proto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nhoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">protoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">protonum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NF_ACCEPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">l4proto</span> <span class="o">=</span> <span class="n">__nf_ct_l4proto_find</span><span class="p">(</span><span class="n">l3num</span><span class="p">,</span> <span class="n">protonum</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_ct_get_tuple</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nhoff</span><span class="p">,</span> <span class="n">protoff</span><span class="p">,</span> <span class="n">l3num</span><span class="p">,</span> <span class="n">protonum</span><span class="p">,</span> <span class="n">tuple</span><span class="p">,</span>
			      <span class="n">l3proto</span><span class="p">,</span> <span class="n">l4proto</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_get_tuplepr</span><span class="p">);</span>

<span class="n">bool</span>
<span class="nf">nf_ct_invert_tuple</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">inverse</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_l3proto</span> <span class="o">*</span><span class="n">l3proto</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">inverse</span><span class="p">));</span>

	<span class="n">inverse</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l3proto</span><span class="o">-&gt;</span><span class="n">invert_tuple</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="n">orig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">inverse</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="o">!</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dir</span><span class="p">;</span>

	<span class="n">inverse</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">invert_tuple</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_invert_tuple</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">clean_from_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clean_from_lists(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="n">hlist_nulls_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">);</span>
	<span class="n">hlist_nulls_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">hnnode</span><span class="p">);</span>

	<span class="cm">/* Destroy all pending expectations */</span>
	<span class="n">nf_ct_remove_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">destroy_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack</span> <span class="o">*</span><span class="n">nfct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="p">)</span><span class="n">nfct</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;destroy_conntrack(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfct</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">));</span>

	<span class="cm">/* To make sure we don&#39;t get any weird locking issues here:</span>
<span class="cm">	 * destroy_conntrack() MUST NOT be called with a write lock</span>
<span class="cm">	 * to nf_conntrack_lock!!! -HW */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">l4proto</span> <span class="o">=</span> <span class="n">__nf_ct_l4proto_find</span><span class="p">(</span><span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span> <span class="n">nf_ct_protonum</span><span class="p">(</span><span class="n">ct</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l4proto</span> <span class="o">&amp;&amp;</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="cm">/* Expectations will have been removed in clean_from_lists,</span>
<span class="cm">	 * except TFTP can create an expectation on the first packet,</span>
<span class="cm">	 * before connection is in the list, so we need to clean here,</span>
<span class="cm">	 * too. */</span>
	<span class="n">nf_ct_remove_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="cm">/* We overload first tuple to link into unconfirmed list. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_ct_is_confirmed</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hlist_nulls_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">));</span>
		<span class="n">hlist_nulls_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">delete</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">)</span>
		<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;destroy_conntrack: returning ct=%p to slab</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="n">nf_conntrack_free</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nf_ct_delete_from_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="n">nf_ct_helper_destroy</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="cm">/* Inside lock so preempt is disabled on module removal path.</span>
<span class="cm">	 * Otherwise we can get spurious warnings. */</span>
	<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">delete_list</span><span class="p">);</span>
	<span class="n">clean_from_lists</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_delete_from_lists</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">death_by_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ul_conntrack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ul_conntrack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nf_conntrack_event</span><span class="p">(</span><span class="n">IPCT_DESTROY</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* bad luck, let&#39;s retry again */</span>
		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">sysctl_events_retry_timeout</span><span class="p">);</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* we&#39;ve got the event delivered, now it&#39;s dying */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IPS_DYING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">hlist_nulls_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nf_ct_insert_dying_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="cm">/* add this conntrack to the dying list */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">hlist_nulls_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">dying</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="cm">/* set a new timer to retry event delivery */</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">death_by_event</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">sysctl_events_retry_timeout</span><span class="p">);</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_insert_dying_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">death_by_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ul_conntrack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ul_conntrack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_tstamp</span> <span class="o">*</span><span class="n">tstamp</span><span class="p">;</span>

	<span class="n">tstamp</span> <span class="o">=</span> <span class="n">nf_conn_tstamp_find</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">tstamp</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tstamp</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPS_DYING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">nf_conntrack_event</span><span class="p">(</span><span class="n">IPCT_DESTROY</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* destroy event was not delivered */</span>
		<span class="n">nf_ct_delete_from_lists</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="n">nf_ct_insert_dying_list</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IPS_DYING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">nf_ct_delete_from_lists</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Warning :</span>
<span class="cm"> * - Caller must take a reference on returned object</span>
<span class="cm"> *   and recheck nf_ct_tuple_equal(tuple, &amp;h-&gt;tuple)</span>
<span class="cm"> * OR</span>
<span class="cm"> * - Caller must lock nf_conntrack_lock before calling this function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span>
<span class="nf">____nf_conntrack_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">hash_bucket</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>

	<span class="cm">/* Disable BHs the entire time since we normally need to disable them</span>
<span class="cm">	 * at least once for the stats anyway.</span>
<span class="cm">	 */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
<span class="nl">begin:</span>
	<span class="n">hlist_nulls_for_each_entry_rcu</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
			<span class="n">local_bh_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">h</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">searched</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the nulls value we got at the end of this lookup is</span>
<span class="cm">	 * not the expected one, we must restart lookup.</span>
<span class="cm">	 * We probably met an item that was moved to another chain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_nulls_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">search_restart</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">begin</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span>
<span class="nf">__nf_conntrack_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">____nf_conntrack_find</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tuple</span><span class="p">,</span>
				     <span class="n">hash_conntrack_raw</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="n">zone</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__nf_conntrack_find</span><span class="p">);</span>

<span class="cm">/* Find a connection corresponding to a tuple. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span>
<span class="nf">__nf_conntrack_find_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">begin:</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">____nf_conntrack_find</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nf_ct_is_dying</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">||</span>
			     <span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">)))</span>
			<span class="n">h</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">||</span>
				     <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">!=</span> <span class="n">zone</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">begin</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span>
<span class="nf">nf_conntrack_find_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__nf_conntrack_find_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tuple</span><span class="p">,</span>
				       <span class="n">hash_conntrack_raw</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="n">zone</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_find_get</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__nf_conntrack_hash_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">repl_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="n">hlist_nulls_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">hash</span><span class="p">]);</span>
	<span class="n">hlist_nulls_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">hnnode</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">repl_hash</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nf_conntrack_hash_check_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">repl_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">zone</span><span class="p">;</span>

	<span class="n">zone</span> <span class="o">=</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_conntrack</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">tuple</span><span class="p">);</span>
	<span class="n">repl_hash</span> <span class="o">=</span> <span class="n">hash_conntrack</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">tuple</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="cm">/* See if there&#39;s one in the list already, including reverse */</span>
	<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">tuple</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">zone</span> <span class="o">==</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">repl_hash</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">tuple</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">zone</span> <span class="o">==</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">nf_conntrack_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">);</span>
	<span class="n">__nf_conntrack_hash_insert</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">repl_hash</span><span class="p">);</span>
	<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">insert</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">insert_failed</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_hash_check_insert</span><span class="p">);</span>

<span class="cm">/* Confirm a connection given skb; places it in hash table */</span>
<span class="kt">int</span>
<span class="nf">__nf_conntrack_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="n">repl_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_tstamp</span> <span class="o">*</span><span class="n">tstamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">zone</span><span class="p">;</span>

	<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="cm">/* ipt_REJECT uses nf_conntrack_attach to attach related</span>
<span class="cm">	   ICMP/TCP RST packets in other direction.  Actual packet</span>
<span class="cm">	   which created connection will be IP_CT_NEW or for an</span>
<span class="cm">	   expected connection, IP_CT_RELATED. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">zone</span> <span class="o">=</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="cm">/* reuse the hash saved before */</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">hnnode</span><span class="p">.</span><span class="n">pprev</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_bucket</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">repl_hash</span> <span class="o">=</span> <span class="n">hash_conntrack</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">tuple</span><span class="p">);</span>

	<span class="cm">/* We&#39;re not in hash table, and we refuse to set up related</span>
<span class="cm">	   connections for unconfirmed conns.  But packet copies and</span>
<span class="cm">	   REJECT will give spurious warnings here. */</span>
	<span class="cm">/* NF_CT_ASSERT(atomic_read(&amp;ct-&gt;ct_general.use) == 1); */</span>

	<span class="cm">/* No external references means no one else could have</span>
<span class="cm">	   confirmed us. */</span>
	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">nf_ct_is_confirmed</span><span class="p">(</span><span class="n">ct</span><span class="p">));</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Confirming conntrack %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="cm">/* We have to check the DYING flag inside the lock to prevent</span>
<span class="cm">	   a race against nf_ct_get_next_corpse() possibly called from</span>
<span class="cm">	   user context, else we insert an already &#39;dead&#39; hash, blocking</span>
<span class="cm">	   further use of that particular connection -JM */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nf_ct_is_dying</span><span class="p">(</span><span class="n">ct</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* See if there&#39;s one in the list already, including reverse:</span>
<span class="cm">	   NAT could have grabbed it without realizing, since we&#39;re</span>
<span class="cm">	   not in the hash.  If there is, we lost race. */</span>
	<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">tuple</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">zone</span> <span class="o">==</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">repl_hash</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">tuple</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">zone</span> <span class="o">==</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Remove from unconfirmed list */</span>
	<span class="n">hlist_nulls_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">);</span>

	<span class="cm">/* Timer relative to confirmation time, not original</span>
<span class="cm">	   setting time, otherwise we&#39;d get timer wrap in</span>
<span class="cm">	   weird delay cases. */</span>
	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">+=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">);</span>
	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">IPS_CONFIRMED</span><span class="p">;</span>

	<span class="cm">/* set conntrack timestamp, if enabled. */</span>
	<span class="n">tstamp</span> <span class="o">=</span> <span class="n">nf_conn_tstamp_find</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">__net_timestamp</span><span class="p">((</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">tstamp</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Since the lookup is lockless, hash insertion must be done after</span>
<span class="cm">	 * starting the timer and setting the CONFIRMED bit. The RCU barriers</span>
<span class="cm">	 * guarantee that no other CPU can find the conntrack before the above</span>
<span class="cm">	 * stores are visible.</span>
<span class="cm">	 */</span>
	<span class="n">__nf_conntrack_hash_insert</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">repl_hash</span><span class="p">);</span>
	<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">insert</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">help</span> <span class="o">&amp;&amp;</span> <span class="n">help</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">)</span>
		<span class="n">nf_conntrack_event_cache</span><span class="p">(</span><span class="n">IPCT_HELPER</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>

	<span class="n">nf_conntrack_event_cache</span><span class="p">(</span><span class="n">master_ct</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">?</span>
				 <span class="n">IPCT_RELATED</span> <span class="o">:</span> <span class="n">IPCT_NEW</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">insert_failed</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__nf_conntrack_confirm</span><span class="p">);</span>

<span class="cm">/* Returns true if a connection correspondings to the tuple (required</span>
<span class="cm">   for NAT). */</span>
<span class="kt">int</span>
<span class="nf">nf_conntrack_tuple_taken</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ignored_conntrack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ignored_conntrack</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">zone</span> <span class="o">=</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ignored_conntrack</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_conntrack</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tuple</span><span class="p">);</span>

	<span class="cm">/* Disable BHs the entire time since we need to disable them at</span>
<span class="cm">	 * least once for the stats anyway.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">hlist_nulls_for_each_entry_rcu</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">!=</span> <span class="n">ignored_conntrack</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nf_ct_tuple_equal</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">==</span> <span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
			<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">searched</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_tuple_taken</span><span class="p">);</span>

<span class="cp">#define NF_CT_EVICTION_RANGE	8</span>

<span class="cm">/* There&#39;s a small race here where we may free a just-assured</span>
<span class="cm">   connection.  Too bad: we&#39;re in trouble anyway. */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">early_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Use oldest entry, which is roughly LRU */</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dropped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_nulls_for_each_entry_rcu</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span>
					 <span class="n">hnnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPS_ASSURED_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
				<span class="n">ct</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">nf_ct_is_dying</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">NF_CT_EVICTION_RANGE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ct</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dropped</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">death_by_timeout</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
		<span class="cm">/* Check if we indeed killed this entry. Reliable event</span>
<span class="cm">		   delivery may have inserted it into the dying list. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPS_DYING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dropped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">early_drop</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dropped</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_nf_conntrack_hash_rnd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rand</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Why not initialize nf_conntrack_rnd in a &quot;init()&quot; function ?</span>
<span class="cm">	 * Because there isn&#39;t enough entropy when system initializing,</span>
<span class="cm">	 * and we initialize it as late as possible.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rand</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">rand</span><span class="p">);</span>
	<span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_hash_rnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rand</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span>
<span class="nf">__nf_conntrack_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">repl</span><span class="p">,</span>
		     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nf_conntrack_hash_rnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init_nf_conntrack_hash_rnd</span><span class="p">();</span>
		<span class="cm">/* recompute the hash as nf_conntrack_hash_rnd is initialized */</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_conntrack_raw</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t want any race condition at early drop stage */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nf_conntrack_max</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nf_conntrack_max</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">early_drop</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hash_bucket</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">net</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
			<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;nf_conntrack: table full, dropping packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not use kmem_cache_zalloc(), as this cache uses</span>
<span class="cm">	 * SLAB_DESTROY_BY_RCU.</span>
<span class="cm">	 */</span>
	<span class="n">ct</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Let ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].hnnode.next</span>
<span class="cm">	 * and ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.next unchanged.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_MAX</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span> <span class="o">-</span>
	       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span><span class="p">,</span> <span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_MAX</span><span class="p">]));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">tuple</span> <span class="o">=</span> <span class="o">*</span><span class="n">orig</span><span class="p">;</span>
	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">.</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">tuple</span> <span class="o">=</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>
	<span class="cm">/* save hash for reusing when confirming */</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">hnnode</span><span class="p">.</span><span class="n">pprev</span><span class="p">)</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t set timer yet: wait for confirmation */</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">death_by_timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">write_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_net</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NF_CONNTRACK_ZONES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nf_conntrack_zone</span> <span class="o">*</span><span class="n">nf_ct_zone</span><span class="p">;</span>

		<span class="n">nf_ct_zone</span> <span class="o">=</span> <span class="n">nf_ct_ext_add</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">NF_CT_EXT_ZONE</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_ct_zone</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">nf_ct_zone</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">zone</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * changes to lookup keys must be done before setting refcnt to 1</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ct</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NF_CONNTRACK_ZONES</span>
<span class="nl">out_free:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="nf">nf_conntrack_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u16</span> <span class="n">zone</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">repl</span><span class="p">,</span>
				   <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__nf_conntrack_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_alloc</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">nf_conntrack_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="n">nf_ct_ext_destroy</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="n">nf_ct_ext_free</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_free</span><span class="p">);</span>

<span class="cm">/* Allocate a new conntrack: we return -ENOMEM if classification</span>
<span class="cm">   failed due to stress.  Otherwise it really is unclassifiable. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span>
<span class="nf">init_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span>
	       <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">nf_conntrack_l3proto</span> <span class="o">*</span><span class="n">l3proto</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="n">repl_tuple</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_ecache</span> <span class="o">*</span><span class="n">ecache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">zone</span> <span class="o">=</span> <span class="n">tmpl</span> <span class="o">?</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">tmpl</span><span class="p">)</span> <span class="o">:</span> <span class="n">NF_CT_DEFAULT_ZONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_timeout</span> <span class="o">*</span><span class="n">timeout_ext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">timeouts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_ct_invert_tuple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">repl_tuple</span><span class="p">,</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">l3proto</span><span class="p">,</span> <span class="n">l4proto</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Can&#39;t invert tuple.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ct</span> <span class="o">=</span> <span class="n">__nf_conntrack_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tuple</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repl_tuple</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span>
				  <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="p">)</span><span class="n">ct</span><span class="p">;</span>

	<span class="n">timeout_ext</span> <span class="o">=</span> <span class="n">tmpl</span> <span class="o">?</span> <span class="n">nf_ct_timeout_find</span><span class="p">(</span><span class="n">tmpl</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ext</span><span class="p">)</span>
		<span class="n">timeouts</span> <span class="o">=</span> <span class="n">NF_CT_TIMEOUT_EXT_DATA</span><span class="p">(</span><span class="n">timeout_ext</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">timeouts</span> <span class="o">=</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">get_timeouts</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">timeouts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nf_conntrack_free</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;init conntrack: can&#39;t track with proto module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ext</span><span class="p">)</span>
		<span class="n">nf_ct_timeout_ext_add</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">timeout_ext</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">nf_ct_acct_ext_add</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">nf_ct_tstamp_ext_add</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">ecache</span> <span class="o">=</span> <span class="n">tmpl</span> <span class="o">?</span> <span class="n">nf_ct_ecache_find</span><span class="p">(</span><span class="n">tmpl</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nf_ct_ecache_ext_add</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">ecache</span> <span class="o">?</span> <span class="n">ecache</span><span class="o">-&gt;</span><span class="n">ctmask</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="n">ecache</span> <span class="o">?</span> <span class="n">ecache</span><span class="o">-&gt;</span><span class="n">expmask</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">exp</span> <span class="o">=</span> <span class="n">nf_ct_find_expectation</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tuple</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;conntrack: expectation arrives ct=%p exp=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ct</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>
		<span class="cm">/* Welcome, Mr. Bond.  We&#39;ve been expecting you... */</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">IPS_EXPECTED_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">help</span> <span class="o">=</span> <span class="n">nf_ct_helper_ext_add</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">help</span><span class="p">)</span>
				<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">,</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NF_CONNTRACK_MARK</span>
		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NF_CONNTRACK_SECMARK</span>
		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">secmark</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">nf_conntrack_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">);</span>
		<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">expect_new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__nf_ct_try_assign_helper</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">NF_CT_STAT_INC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Overload tuple linked list to put us in unconfirmed list. */</span>
	<span class="n">hlist_nulls_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">].</span><span class="n">hnnode</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">unconfirmed</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">expectfn</span><span class="p">)</span>
			<span class="n">exp</span><span class="o">-&gt;</span><span class="n">expectfn</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>
		<span class="n">nf_ct_expect_put</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* On success, returns conntrack ptr, sets skb-&gt;nfct and ctinfo */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span>
<span class="nf">resolve_normal_ct</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
		  <span class="n">u_int16_t</span> <span class="n">l3num</span><span class="p">,</span>
		  <span class="n">u_int8_t</span> <span class="n">protonum</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">nf_conntrack_l3proto</span> <span class="o">*</span><span class="n">l3proto</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="o">*</span><span class="n">set_reply</span><span class="p">,</span>
		  <span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="o">*</span><span class="n">ctinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="n">tuple</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">zone</span> <span class="o">=</span> <span class="n">tmpl</span> <span class="o">?</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">tmpl</span><span class="p">)</span> <span class="o">:</span> <span class="n">NF_CT_DEFAULT_ZONE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_ct_get_tuple</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
			     <span class="n">dataoff</span><span class="p">,</span> <span class="n">l3num</span><span class="p">,</span> <span class="n">protonum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span> <span class="n">l3proto</span><span class="p">,</span>
			     <span class="n">l4proto</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;resolve_normal_ct: Can&#39;t get tuple</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* look for tuple match */</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_conntrack_raw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">__nf_conntrack_find_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">init_conntrack</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span> <span class="n">l3proto</span><span class="p">,</span> <span class="n">l4proto</span><span class="p">,</span>
				   <span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="cm">/* It exists; we have (non-exclusive) reference. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NF_CT_DIRECTION</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="n">IP_CT_DIR_REPLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ctinfo</span> <span class="o">=</span> <span class="n">IP_CT_ESTABLISHED_REPLY</span><span class="p">;</span>
		<span class="cm">/* Please set reply bit if this packet OK */</span>
		<span class="o">*</span><span class="n">set_reply</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Once we&#39;ve had two way comms, always ESTABLISHED. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPS_SEEN_REPLY_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;nf_conntrack_in: normal packet for %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ctinfo</span> <span class="o">=</span> <span class="n">IP_CT_ESTABLISHED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPS_EXPECTED_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;nf_conntrack_in: related packet for %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ct</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ctinfo</span> <span class="o">=</span> <span class="n">IP_CT_RELATED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;nf_conntrack_in: new packet for %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ctinfo</span> <span class="o">=</span> <span class="n">IP_CT_NEW</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">set_reply</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfctinfo</span> <span class="o">=</span> <span class="o">*</span><span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ct</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">nf_conntrack_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">tmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_l3proto</span> <span class="o">*</span><span class="n">l3proto</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_l4proto</span> <span class="o">*</span><span class="n">l4proto</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_timeout</span> <span class="o">*</span><span class="n">timeout_ext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">timeouts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">protonum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set_reply</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Previously seen (loopback or untracked)?  Ignore. */</span>
		<span class="n">tmpl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_ct_is_template</span><span class="p">(</span><span class="n">tmpl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ignore</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* rcu_read_lock()ed by nf_hook_slow */</span>
	<span class="n">l3proto</span> <span class="o">=</span> <span class="n">__nf_ct_l3proto_find</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">l3proto</span><span class="o">-&gt;</span><span class="n">get_l4proto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				   <span class="o">&amp;</span><span class="n">dataoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">protonum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;not prepared to track yet or error occurred</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">invalid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">l4proto</span> <span class="o">=</span> <span class="n">__nf_ct_l4proto_find</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">protonum</span><span class="p">);</span>

	<span class="cm">/* It may be an special packet, error, unclean...</span>
<span class="cm">	 * inverse of the return code tells to the netfilter</span>
<span class="cm">	 * core what to do with the packet. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">,</span>
				     <span class="n">pf</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">invalid</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* ICMP[v6] protocol trackers may assign one conntrack. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ct</span> <span class="o">=</span> <span class="n">resolve_normal_ct</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">protonum</span><span class="p">,</span>
			       <span class="n">l3proto</span><span class="p">,</span> <span class="n">l4proto</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set_reply</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ct</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not valid part of a connection */</span>
		<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">invalid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Too stressed to deal. */</span>
		<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">drop</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>

	<span class="cm">/* Decide what timeout policy we want to apply to this flow. */</span>
	<span class="n">timeout_ext</span> <span class="o">=</span> <span class="n">nf_ct_timeout_find</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_ext</span><span class="p">)</span>
		<span class="n">timeouts</span> <span class="o">=</span> <span class="n">NF_CT_TIMEOUT_EXT_DATA</span><span class="p">(</span><span class="n">timeout_ext</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">timeouts</span> <span class="o">=</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">get_timeouts</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">l4proto</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">ctinfo</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">hooknum</span><span class="p">,</span> <span class="n">timeouts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Invalid: inverse of the return code tells</span>
<span class="cm">		 * the netfilter core what to do */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;nf_conntrack_in: Can&#39;t track with proto module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nf_conntrack_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">invalid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">NF_DROP</span><span class="p">)</span>
			<span class="n">NF_CT_STAT_INC_ATOMIC</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">drop</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_reply</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">IPS_SEEN_REPLY_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
		<span class="n">nf_conntrack_event_cache</span><span class="p">(</span><span class="n">IPCT_REPLY</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmpl</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special case: we have to repeat this hook, assign the</span>
<span class="cm">		 * template again to this packet. We assume that this packet</span>
<span class="cm">		 * has no conntrack assigned. This is used by nf_ct_tcp. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NF_REPEAT</span><span class="p">)</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack</span> <span class="o">*</span><span class="p">)</span><span class="n">tmpl</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">tmpl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_in</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">nf_ct_invert_tuplepr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">inverse</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_ct_invert_tuple</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span>
				 <span class="n">__nf_ct_l3proto_find</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span><span class="p">),</span>
				 <span class="n">__nf_ct_l4proto_find</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span><span class="p">,</span>
						      <span class="n">orig</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_invert_tuplepr</span><span class="p">);</span>

<span class="cm">/* Alter reply tuple (maybe alter helper).  This is for NAT, and is</span>
<span class="cm">   implicitly racy: see __nf_conntrack_confirm */</span>
<span class="kt">void</span> <span class="nf">nf_conntrack_alter_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">newreply</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="cm">/* Should be unconfirmed, so not in hash table yet */</span>
	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">nf_ct_is_confirmed</span><span class="p">(</span><span class="n">ct</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Altering reply tuple of %p to &quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
	<span class="n">nf_ct_dump_tuple</span><span class="p">(</span><span class="n">newreply</span><span class="p">);</span>

	<span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">IP_CT_DIR_REPLY</span><span class="p">].</span><span class="n">tuple</span> <span class="o">=</span> <span class="o">*</span><span class="n">newreply</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">||</span> <span class="p">(</span><span class="n">help</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">expectations</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">__nf_ct_try_assign_helper</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_alter_reply</span><span class="p">);</span>

<span class="cm">/* Refresh conntrack for this many jiffies and do accounting if do_acct is 1 */</span>
<span class="kt">void</span> <span class="nf">__nf_ct_refresh_acct</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">extra_jiffies</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">do_acct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">NF_CT_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Only update if this is not a fixed timeout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPS_FIXED_TIMEOUT_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">acct</span><span class="p">;</span>

	<span class="cm">/* If not in hash table, timer will not be active yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_ct_is_confirmed</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">extra_jiffies</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newtime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">extra_jiffies</span><span class="p">;</span>

		<span class="cm">/* Only update the timeout if the new timeout is at least</span>
<span class="cm">		   HZ jiffies from the old timeout. Need del_timer for race</span>
<span class="cm">		   avoidance (may already be dying). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newtime</span> <span class="o">-</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">&gt;=</span> <span class="n">HZ</span><span class="p">)</span>
			<span class="n">mod_timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">newtime</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">acct:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_acct</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nf_conn_counter</span> <span class="o">*</span><span class="n">acct</span><span class="p">;</span>

		<span class="n">acct</span> <span class="o">=</span> <span class="n">nf_conn_acct_find</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acct</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic64_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acct</span><span class="p">[</span><span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">)].</span><span class="n">packets</span><span class="p">);</span>
			<span class="n">atomic64_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acct</span><span class="p">[</span><span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">)].</span><span class="n">bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__nf_ct_refresh_acct</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">__nf_ct_kill_acct</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">do_acct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_acct</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nf_conn_counter</span> <span class="o">*</span><span class="n">acct</span><span class="p">;</span>

		<span class="n">acct</span> <span class="o">=</span> <span class="n">nf_conn_acct_find</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acct</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic64_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acct</span><span class="p">[</span><span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">)].</span><span class="n">packets</span><span class="p">);</span>
			<span class="n">atomic64_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">acct</span><span class="p">[</span><span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">)].</span><span class="n">bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">function</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__nf_ct_kill_acct</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NF_CONNTRACK_ZONES</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_ct_ext_type</span> <span class="n">nf_ct_zone_extend</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">len</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack_zone</span><span class="p">),</span>
	<span class="p">.</span><span class="n">align</span>	<span class="o">=</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack_zone</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id</span>	<span class="o">=</span> <span class="n">NF_CT_EXT_ZONE</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#if IS_ENABLED(CONFIG_NF_CT_NETLINK)</span>

<span class="cp">#include &lt;linux/netfilter/nfnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter/nfnetlink_conntrack.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cm">/* Generic function for tcp/udp/sctp/dccp and alike. This needs to be</span>
<span class="cm"> * in ip_conntrack_core, since we don&#39;t want the protocols to autoload</span>
<span class="cm"> * or depend on ctnetlink */</span>
<span class="kt">int</span> <span class="nf">nf_ct_port_tuple_to_nlattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_be16</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">CTA_PROTO_SRC_PORT</span><span class="p">,</span> <span class="n">tuple</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">tcp</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">nla_put_be16</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">CTA_PROTO_DST_PORT</span><span class="p">,</span> <span class="n">tuple</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">tcp</span><span class="p">.</span><span class="n">port</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_port_tuple_to_nlattr</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">nf_ct_port_nla_policy</span><span class="p">[</span><span class="n">CTA_PROTO_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">CTA_PROTO_SRC_PORT</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U16</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">CTA_PROTO_DST_PORT</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_U16</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_port_nla_policy</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nf_ct_port_nlattr_to_tuple</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span>
			       <span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">CTA_PROTO_SRC_PORT</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">CTA_PROTO_DST_PORT</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">tcp</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">nla_get_be16</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">CTA_PROTO_SRC_PORT</span><span class="p">]);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">tcp</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">nla_get_be16</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">CTA_PROTO_DST_PORT</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_port_nlattr_to_tuple</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nf_ct_port_nlattr_tuple_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_policy_len</span><span class="p">(</span><span class="n">nf_ct_port_nla_policy</span><span class="p">,</span> <span class="n">CTA_PROTO_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_port_nlattr_tuple_size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Used by ipt_REJECT and ip6t_REJECT. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nf_conntrack_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>

	<span class="cm">/* This ICMP is in reverse direction to the packet which caused it */</span>
	<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">)</span> <span class="o">==</span> <span class="n">IP_CT_DIR_ORIGINAL</span><span class="p">)</span>
		<span class="n">ctinfo</span> <span class="o">=</span> <span class="n">IP_CT_RELATED_REPLY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ctinfo</span> <span class="o">=</span> <span class="n">IP_CT_RELATED</span><span class="p">;</span>

	<span class="cm">/* Attach to new skbuff, and increment count */</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">;</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">nfctinfo</span> <span class="o">=</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="n">nf_conntrack_get</span><span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Bring out ya dead! */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span>
<span class="nf">get_next_corpse</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bucket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">bucket</span> <span class="o">&lt;</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="n">bucket</span><span class="p">)</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="o">*</span><span class="n">bucket</span><span class="p">],</span> <span class="n">hnnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">unconfirmed</span><span class="p">,</span> <span class="n">hnnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">IPS_DYING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ct</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nf_ct_iterate_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">ct</span> <span class="o">=</span> <span class="n">get_next_corpse</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bucket</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Time to push up daises... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span>
			<span class="n">death_by_timeout</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
		<span class="cm">/* ... else the timer will get him soon. */</span>

		<span class="n">nf_ct_put</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_iterate_cleanup</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">__nf_ct_flush_report</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">report</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kill_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__nf_ct_flush_report</span> <span class="o">*</span><span class="n">fr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">__nf_ct_flush_report</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn_tstamp</span> <span class="o">*</span><span class="n">tstamp</span><span class="p">;</span>

	<span class="n">tstamp</span> <span class="o">=</span> <span class="n">nf_conn_tstamp_find</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">tstamp</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tstamp</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">());</span>

	<span class="cm">/* If we fail to deliver the event, death_by_timeout() will retry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nf_conntrack_event_report</span><span class="p">(</span><span class="n">IPCT_DESTROY</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				      <span class="n">fr</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">report</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Avoid the delivery of the destroy event in death_by_timeout(). */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IPS_DYING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kill_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nf_ct_free_hashtable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vmalloc_addr</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hash</span><span class="p">,</span>
			   <span class="n">get_order</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_free_hashtable</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">nf_conntrack_flush_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">report</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__nf_ct_flush_report</span> <span class="n">fr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pid</span> 	<span class="o">=</span> <span class="n">pid</span><span class="p">,</span>
		<span class="p">.</span><span class="n">report</span> <span class="o">=</span> <span class="n">report</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">nf_ct_iterate_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">kill_report</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_flush_report</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nf_ct_release_dying_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">hlist_nulls_for_each_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">dying</span><span class="p">,</span> <span class="n">hnnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="cm">/* never fails to remove them, no listeners at this point */</span>
		<span class="n">nf_ct_kill</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">untrack_refs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">nf_conntrack_untracked</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nf_conntrack_cleanup_init_net</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">untrack_refs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="n">nf_conntrack_proto_fini</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_NF_CONNTRACK_ZONES</span>
	<span class="n">nf_ct_extend_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_ct_zone_extend</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nf_conntrack_cleanup_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
 <span class="nl">i_see_dead_people:</span>
	<span class="n">nf_ct_iterate_cleanup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">kill_all</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">nf_ct_release_dying_list</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">i_see_dead_people</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nf_ct_free_hashtable</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">);</span>
	<span class="n">nf_conntrack_helper_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nf_conntrack_timeout_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nf_conntrack_ecache_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nf_conntrack_tstamp_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nf_conntrack_acct_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nf_conntrack_expect_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">slabname</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Mishearing the voices in his head, our hero wonders how he&#39;s</span>
<span class="cm">   supposed to kill the mall. */</span>
<span class="kt">void</span> <span class="nf">nf_conntrack_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">ip_ct_attach</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* This makes sure all current packets have passed through</span>
<span class="cm">	   netfilter framework.  Roll on, two-stage module</span>
<span class="cm">	   delete... */</span>
	<span class="n">synchronize_net</span><span class="p">();</span>

	<span class="n">nf_conntrack_cleanup_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">nf_ct_destroy</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">nf_conntrack_cleanup_init_net</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">nf_ct_alloc_hashtable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sizep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nulls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_slots</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_nulls_head</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">));</span>
	<span class="n">nr_slots</span> <span class="o">=</span> <span class="o">*</span><span class="n">sizep</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="o">*</span><span class="n">sizep</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_nulls_head</span><span class="p">));</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">nr_slots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_nulls_head</span><span class="p">);</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
					<span class="n">get_order</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;nf_conntrack: falling back to vmalloc.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">nulls</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">INIT_HLIST_NULLS_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_alloc_hashtable</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nf_conntrack_set_hashsize</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bucket</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashsize</span><span class="p">,</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span> <span class="o">*</span><span class="n">old_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* On boot, we can set this without any fancy locking. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_conntrack_htable_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">param_set_uint</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>

	<span class="n">hashsize</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashsize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">nf_ct_alloc_hashtable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Lookups in the old hash might happen in parallel, which means we</span>
<span class="cm">	 * might get false negatives during connection lookup. New connections</span>
<span class="cm">	 * created because of a false negative won&#39;t make it into the hash</span>
<span class="cm">	 * though since that required taking the lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_nulls_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">hlist_nulls_entry</span><span class="p">(</span><span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nf_conntrack_tuple_hash</span><span class="p">,</span> <span class="n">hnnode</span><span class="p">);</span>
			<span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_tuplehash_to_ctrack</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
			<span class="n">hlist_nulls_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hnnode</span><span class="p">);</span>
			<span class="n">bucket</span> <span class="o">=</span> <span class="n">__hash_conntrack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">,</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span>
						  <span class="n">hashsize</span><span class="p">);</span>
			<span class="n">hlist_nulls_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hnnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">[</span><span class="n">bucket</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">old_size</span> <span class="o">=</span> <span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">;</span>
	<span class="n">old_hash</span> <span class="o">=</span> <span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">;</span>

	<span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span> <span class="o">=</span> <span class="n">nf_conntrack_htable_size</span> <span class="o">=</span> <span class="n">hashsize</span><span class="p">;</span>
	<span class="n">init_net</span><span class="p">.</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>

	<span class="n">nf_ct_free_hashtable</span><span class="p">(</span><span class="n">old_hash</span><span class="p">,</span> <span class="n">old_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_conntrack_set_hashsize</span><span class="p">);</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">hashsize</span><span class="p">,</span> <span class="n">nf_conntrack_set_hashsize</span><span class="p">,</span> <span class="n">param_get_uint</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">nf_conntrack_htable_size</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">nf_ct_untracked_status_or</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">nf_conntrack_untracked</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">status</span> <span class="o">|=</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_untracked_status_or</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nf_conntrack_init_init_net</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_factor</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Idea from tcp.c: use 1/16384 of memory.  On i386: 32MB</span>
<span class="cm">	 * machine has 512 buckets. &gt;= 1GB machines have 16384 buckets. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_conntrack_htable_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nf_conntrack_htable_size</span>
			<span class="o">=</span> <span class="p">(((</span><span class="n">totalram_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16384</span><span class="p">)</span>
			   <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
			<span class="n">nf_conntrack_htable_size</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_conntrack_htable_size</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
			<span class="n">nf_conntrack_htable_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

		<span class="cm">/* Use a max. factor of four by default to get the same max as</span>
<span class="cm">		 * with the old struct list_heads. When a table size is given</span>
<span class="cm">		 * we use the old value of 8 to avoid reducing the max.</span>
<span class="cm">		 * entries. */</span>
		<span class="n">max_factor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nf_conntrack_max</span> <span class="o">=</span> <span class="n">max_factor</span> <span class="o">*</span> <span class="n">nf_conntrack_htable_size</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nf_conntrack version %s (%u buckets, %d max)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">NF_CONNTRACK_VERSION</span><span class="p">,</span> <span class="n">nf_conntrack_htable_size</span><span class="p">,</span>
	       <span class="n">nf_conntrack_max</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_proto_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_proto</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NF_CONNTRACK_ZONES</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_ct_extend_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_ct_zone_extend</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_extend</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Set up fake conntrack: to never be deleted, not in any hashes */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">nf_conntrack_untracked</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">write_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">.</span><span class="n">use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*  - and look it like as a confirmed connection */</span>
	<span class="n">nf_ct_untracked_status_or</span><span class="p">(</span><span class="n">IPS_CONFIRMED</span> <span class="o">|</span> <span class="n">IPS_UNTRACKED</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NF_CONNTRACK_ZONES</span>
<span class="nl">err_extend:</span>
	<span class="n">nf_conntrack_proto_fini</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="nl">err_proto:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to use special &quot;null&quot; values, not used in hash table</span>
<span class="cm"> */</span>
<span class="cp">#define UNCONFIRMED_NULLS_VAL	((1&lt;&lt;30)+0)</span>
<span class="cp">#define DYING_NULLS_VAL		((1&lt;&lt;30)+1)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nf_conntrack_init_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NULLS_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">unconfirmed</span><span class="p">,</span> <span class="n">UNCONFIRMED_NULLS_VAL</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NULLS_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">dying</span><span class="p">,</span> <span class="n">DYING_NULLS_VAL</span><span class="p">);</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">stat</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_conntrack_stat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">stat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_stat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">slabname</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;nf_conntrack_%p&quot;</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">slabname</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_slabname</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">slabname</span><span class="p">,</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
							<span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to create nf_conn slab cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span> <span class="o">=</span> <span class="n">nf_conntrack_htable_size</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">nf_ct_alloc_hashtable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to create nf_conntrack_hash</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_hash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_expect_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_expect</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_acct_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_acct</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_tstamp_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_tstamp</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_ecache_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ecache</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_timeout_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_timeout</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_helper_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_helper</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_helper:</span>
	<span class="n">nf_conntrack_timeout_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">err_timeout:</span>
	<span class="n">nf_conntrack_ecache_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">err_ecache:</span>
	<span class="n">nf_conntrack_tstamp_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">err_tstamp:</span>
	<span class="n">nf_conntrack_acct_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">err_acct:</span>
	<span class="n">nf_conntrack_expect_fini</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">err_expect:</span>
	<span class="n">nf_ct_free_hashtable</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">htable_size</span><span class="p">);</span>
<span class="nl">err_hash:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">nf_conntrack_cachep</span><span class="p">);</span>
<span class="nl">err_cache:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">slabname</span><span class="p">);</span>
<span class="nl">err_slabname:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ct</span><span class="p">.</span><span class="n">stat</span><span class="p">);</span>
<span class="nl">err_stat:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">s16</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_ct_nat_offset</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">ip_conntrack_dir</span> <span class="n">dir</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">seq</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_ct_nat_offset</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nf_conntrack_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_init_init_net</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_init_net</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_init_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_net</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* For use by REJECT target */</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">ip_ct_attach</span><span class="p">,</span> <span class="n">nf_conntrack_attach</span><span class="p">);</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">nf_ct_destroy</span><span class="p">,</span> <span class="n">destroy_conntrack</span><span class="p">);</span>

		<span class="cm">/* Howto get NAT offsets */</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">nf_ct_nat_offset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_net:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="n">nf_conntrack_cleanup_init_net</span><span class="p">();</span>
<span class="nl">out_init_net:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
