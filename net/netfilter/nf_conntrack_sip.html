<!DOCTYPE html>
<html><head><title>joekychen/linux » net › netfilter › nf_conntrack_sip.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nf_conntrack_sip.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SIP extension for IP connection tracking.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2005 by Christian Hentschel &lt;chentschel@arnet.com.ar&gt;</span>
<span class="cm"> * based on RR&#39;s ip_conntrack_ftp.c and other modules.</span>
<span class="cm"> * (C) 2007 United Security Providers</span>
<span class="cm"> * (C) 2007, 2008 Patrick McHardy &lt;kaber@trash.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter.h&gt;</span>

<span class="cp">#include &lt;net/netfilter/nf_conntrack.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_core.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_expect.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_helper.h&gt;</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack_zones.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter/nf_conntrack_sip.h&gt;</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Christian Hentschel &lt;chentschel@arnet.com.ar&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SIP connection tracking helper&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;ip_conntrack_sip&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_NFCT_HELPER</span><span class="p">(</span><span class="s">&quot;sip&quot;</span><span class="p">);</span>

<span class="cp">#define MAX_PORTS	8</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ports</span><span class="p">[</span><span class="n">MAX_PORTS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ports_c</span><span class="p">;</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ports_c</span><span class="p">,</span> <span class="mo">0400</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="s">&quot;port numbers of SIP servers&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sip_timeout</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">SIP_TIMEOUT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sip_timeout</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sip_timeout</span><span class="p">,</span> <span class="s">&quot;timeout for the master SIP session&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sip_direct_signalling</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sip_direct_signalling</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sip_direct_signalling</span><span class="p">,</span> <span class="s">&quot;expect incoming calls from registrar &quot;</span>
					<span class="s">&quot;only (default 1)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sip_direct_media</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sip_direct_media</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sip_direct_media</span><span class="p">,</span> <span class="s">&quot;Expect Media streams between signalling &quot;</span>
				   <span class="s">&quot;endpoints only (default 1)&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sip_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sip_hook</span><span class="p">);</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sip_seq_adjust_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">s16</span> <span class="n">off</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sip_seq_adjust_hook</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sip_expect_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">exp</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchlen</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sip_expect_hook</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sdp_addr_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sdpoff</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">type</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">term</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
				     <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sdp_addr_hook</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sdp_port_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchlen</span><span class="p">,</span>
				     <span class="n">u_int16_t</span> <span class="n">port</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sdp_port_hook</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sdp_session_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sdpoff</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
					<span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sdp_session_hook</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nf_nat_sdp_media_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">rtp_exp</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">rtcp_exp</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mediaoff</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">medialen</span><span class="p">,</span>
				      <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">rtp_addr</span><span class="p">)</span>
				      <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nf_nat_sdp_media_hook</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">string_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">isalpha</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">digits_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iswordc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;(&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;&lt;&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;&gt;&#39;</span> <span class="o">||</span>
	    <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;[&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;]&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;`&#39;</span> <span class="o">||</span>
	    <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;{&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;}&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;~&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">word_len</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">iswordc</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">callid_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">domain_len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">word_len</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="n">dptr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">dptr</span> <span class="o">==</span> <span class="n">limit</span> <span class="o">||</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">len</span><span class="o">++</span><span class="p">;</span>

	<span class="n">domain_len</span> <span class="o">=</span> <span class="n">word_len</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">domain_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">domain_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get media type + port length */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">media_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">string_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>

	<span class="n">dptr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span> <span class="o">||</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">digits_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">endp</span><span class="p">,</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ct</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">in4_pton</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">cp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">in6_pton</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">cp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ip6</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">end</span> <span class="o">==</span> <span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">endp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">endp</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* skip ip address. returns its length. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">epaddr_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">aux</span> <span class="o">=</span> <span class="n">dptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ip: %s parse failed.!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dptr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Port number */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dptr</span> <span class="o">+=</span> <span class="n">digits_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">aux</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get address length, skiping user info. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skp_epaddr_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="o">*</span><span class="n">shift</span><span class="p">;</span>

	<span class="cm">/* Search for @, but stop at the end of the line.</span>
<span class="cm">	 * We are inside a sip: URI, so we don&#39;t need to worry about</span>
<span class="cm">	 * continuation lines. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span>
	       <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;@&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">shift</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dptr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">shift</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dptr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="o">*</span><span class="n">shift</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">epaddr_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Parse a SIP request line of the form:</span>
<span class="cm"> *</span>
<span class="cm"> * Request-Line = Method SP Request-URI SP SIP-Version CRLF</span>
<span class="cm"> *</span>
<span class="cm"> * and return the offset and length of the address contained in the Request-URI.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ct_sip_parse_request</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">,</span>
			 <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">dptr</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Skip method and following whitespace */</span>
	<span class="n">mlen</span> <span class="o">=</span> <span class="n">string_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dptr</span> <span class="o">+=</span> <span class="n">mlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find SIP URI */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;sip:&quot;</span><span class="p">);</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="s">&quot;sip:&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;sip:&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;sip:&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skp_epaddr_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shift</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dptr</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">end</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span><span class="o">++</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SIP_PORT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">dptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ct_sip_parse_request</span><span class="p">);</span>

<span class="cm">/* SIP header parsing: SIP headers are located at the beginning of a line, but</span>
<span class="cm"> * may span several lines, in which case the continuation lines begin with a</span>
<span class="cm"> * whitespace character. RFC 2543 allows lines to be terminated with CR, LF or</span>
<span class="cm"> * CRLF, RFC 3261 allows only CRLF, we support both.</span>
<span class="cm"> *</span>
<span class="cm"> * Headers are followed by (optionally) whitespace, a colon, again (optionally)</span>
<span class="cm"> * whitespace and the values. Whitespace in this context means any amount of</span>
<span class="cm"> * tabs, spaces and continuation lines, which are treated as a single whitespace</span>
<span class="cm"> * character.</span>
<span class="cm"> *</span>
<span class="cm"> * Some headers may appear multiple times. A comma separated list of values is</span>
<span class="cm"> * equivalent to multiple headers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sip_header</span> <span class="n">ct_sip_hdrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SIP_HDR_CSEQ</span><span class="p">]</span>			<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;CSeq&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">digits_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_FROM</span><span class="p">]</span>			<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;From&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;sip:&quot;</span><span class="p">,</span> <span class="n">skp_epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_TO</span><span class="p">]</span>			<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;To&quot;</span><span class="p">,</span> <span class="s">&quot;t&quot;</span><span class="p">,</span> <span class="s">&quot;sip:&quot;</span><span class="p">,</span> <span class="n">skp_epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_CONTACT</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;Contact&quot;</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="s">&quot;sip:&quot;</span><span class="p">,</span> <span class="n">skp_epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_VIA_UDP</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;Via&quot;</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="s">&quot;UDP &quot;</span><span class="p">,</span> <span class="n">epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_VIA_TCP</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;Via&quot;</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="s">&quot;TCP &quot;</span><span class="p">,</span> <span class="n">epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_EXPIRES</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;Expires&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">digits_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_CONTENT_LENGTH</span><span class="p">]</span>	<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;Content-Length&quot;</span><span class="p">,</span> <span class="s">&quot;l&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">digits_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SIP_HDR_CALL_ID</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SIP_HDR</span><span class="p">(</span><span class="s">&quot;Call-Id&quot;</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">callid_len</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sip_follow_continuation</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Walk past newline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Skip &#39;\n&#39; in CR LF */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Continuation line? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* skip leading whitespace */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sip_skip_whitespace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dptr</span> <span class="o">=</span> <span class="n">sip_follow_continuation</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Search within a SIP header value, dealing with continuation lines */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ct_sip_header_search</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">needle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dptr</span> <span class="o">=</span> <span class="n">sip_follow_continuation</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ct_sip_get_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">sip_header_types</span> <span class="n">type</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sip_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct_sip_hdrs</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">dptr</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">+=</span> <span class="n">dataoff</span><span class="p">;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Find beginning of line */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Skip continuation lines */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Find header. Compact headers must be followed by a</span>
<span class="cm">		 * non-alphabetic character to avoid mismatches. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span>
		    <span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cname</span> <span class="o">&amp;&amp;</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">clen</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			 <span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cname</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">clen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			 <span class="o">!</span><span class="n">isalpha</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">clen</span><span class="p">)))</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">clen</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Find and skip colon */</span>
		<span class="n">dptr</span> <span class="o">=</span> <span class="n">sip_skip_whitespace</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Skip whitespace after colon */</span>
		<span class="n">dptr</span> <span class="o">=</span> <span class="n">sip_skip_whitespace</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">search</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dptr</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">search</span><span class="p">,</span>
						    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dptr</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slen</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">match_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shift</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">matchlen</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">shift</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ct_sip_get_header</span><span class="p">);</span>

<span class="cm">/* Get next header field in a list of comma separated values */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ct_sip_next_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">sip_header_types</span> <span class="n">type</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sip_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct_sip_hdrs</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">dptr</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dptr</span> <span class="o">+=</span> <span class="n">dataoff</span><span class="p">;</span>

	<span class="n">dptr</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dptr</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">search</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dptr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slen</span><span class="p">;</span>

	<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">match_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">matchlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchoff</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Walk through headers until a parsable one is found or no header of the</span>
<span class="cm"> * given type is left. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ct_sip_walk_headers</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">sip_header_types</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">in_header</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_header</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">in_header</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_next_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
						 <span class="n">type</span><span class="p">,</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">dataoff</span> <span class="o">+=</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">in_header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_get_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
					<span class="n">type</span><span class="p">,</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">dataoff</span> <span class="o">+=</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_header</span><span class="p">)</span>
		<span class="o">*</span><span class="n">in_header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Locate a SIP header, parse the URI and return the offset and length of</span>
<span class="cm"> * the address as well as the address and port themselves. A stream of</span>
<span class="cm"> * headers can be parsed by handing in a non-NULL datalen and in_header</span>
<span class="cm"> * pointer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ct_sip_parse_header_uri</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">sip_header_types</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">in_header</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">,</span>
			    <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_walk_headers</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">dataoff</span> <span class="o">?</span> <span class="o">*</span><span class="n">dataoff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
				  <span class="n">type</span><span class="p">,</span> <span class="n">in_header</span><span class="p">,</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span> <span class="o">+</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">++</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SIP_PORT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dataoff</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dataoff</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ct_sip_parse_header_uri</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ct_sip_parse_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="s">&quot;;&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;;&quot;</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">end</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>

	<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Parse address from header parameter and return address, offset and length */</span>
<span class="kt">int</span> <span class="nf">ct_sip_parse_address_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">,</span>
			       <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ct_sip_parse_address_param</span><span class="p">);</span>

<span class="cm">/* Parse numerical header parameter and return value, offset and length */</span>
<span class="kt">int</span> <span class="nf">ct_sip_parse_numerical_param</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">ct_sip_header_search</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">matchoff</span> <span class="o">&amp;&amp;</span> <span class="n">matchlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">dptr</span><span class="p">;</span>
		<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ct_sip_parse_numerical_param</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ct_sip_parse_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_parse_param</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="s">&quot;transport=&quot;</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="s">&quot;TCP&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;TCP&quot;</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="s">&quot;UDP&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;UDP&quot;</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">proto</span> <span class="o">!=</span> <span class="n">nf_ct_protonum</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">proto</span> <span class="o">=</span> <span class="n">nf_ct_protonum</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* SDP header parsing: a SDP session description contains an ordered set of</span>
<span class="cm"> * headers, starting with a section containing general session parameters,</span>
<span class="cm"> * optionally followed by multiple media descriptions.</span>
<span class="cm"> *</span>
<span class="cm"> * SDP headers always start at the beginning of a line. According to RFC 2327:</span>
<span class="cm"> * &quot;The sequence CRLF (0x0d0a) is used to end a record, although parsers should</span>
<span class="cm"> * be tolerant and also accept records terminated with a single newline</span>
<span class="cm"> * character&quot;. We handle both cases.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sip_header</span> <span class="n">ct_sdp_hdrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SDP_HDR_VERSION</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SDP_HDR</span><span class="p">(</span><span class="s">&quot;v=&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">digits_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SDP_HDR_OWNER_IP4</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SDP_HDR</span><span class="p">(</span><span class="s">&quot;o=&quot;</span><span class="p">,</span> <span class="s">&quot;IN IP4 &quot;</span><span class="p">,</span> <span class="n">epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SDP_HDR_CONNECTION_IP4</span><span class="p">]</span>	<span class="o">=</span> <span class="n">SDP_HDR</span><span class="p">(</span><span class="s">&quot;c=&quot;</span><span class="p">,</span> <span class="s">&quot;IN IP4 &quot;</span><span class="p">,</span> <span class="n">epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SDP_HDR_OWNER_IP6</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SDP_HDR</span><span class="p">(</span><span class="s">&quot;o=&quot;</span><span class="p">,</span> <span class="s">&quot;IN IP6 &quot;</span><span class="p">,</span> <span class="n">epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SDP_HDR_CONNECTION_IP6</span><span class="p">]</span>	<span class="o">=</span> <span class="n">SDP_HDR</span><span class="p">(</span><span class="s">&quot;c=&quot;</span><span class="p">,</span> <span class="s">&quot;IN IP6 &quot;</span><span class="p">,</span> <span class="n">epaddr_len</span><span class="p">),</span>
	<span class="p">[</span><span class="n">SDP_HDR_MEDIA</span><span class="p">]</span>			<span class="o">=</span> <span class="n">SDP_HDR</span><span class="p">(</span><span class="s">&quot;m=&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">media_len</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* Linear string search within SDP header values */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ct_sdp_header_search</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">needle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Locate a SDP header (optionally a substring within the header value),</span>
<span class="cm"> * optionally stopping at the first occurrence of the term header, parse</span>
<span class="cm"> * it and return the offset and length of the data we&#39;re interested in.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ct_sip_get_sdp_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">type</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">term</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sip_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct_sdp_hdrs</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sip_header</span> <span class="o">*</span><span class="n">thdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct_sdp_hdrs</span><span class="p">[</span><span class="n">term</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">dptr</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">+=</span> <span class="n">dataoff</span><span class="p">;</span> <span class="n">dptr</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">dptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Find beginning of line */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">term</span> <span class="o">!=</span> <span class="n">SDP_HDR_UNSPEC</span> <span class="o">&amp;&amp;</span>
		    <span class="n">limit</span> <span class="o">-</span> <span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">thdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span>
		    <span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">thdr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">thdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">dptr</span> <span class="o">&gt;=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span>
			 <span class="n">strnicmp</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">search</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dptr</span> <span class="o">=</span> <span class="n">ct_sdp_header_search</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">search</span><span class="p">,</span>
						    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dptr</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slen</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">matchlen</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">match_len</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shift</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">matchlen</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">matchoff</span> <span class="o">=</span> <span class="n">dptr</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">shift</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ct_sip_get_sdp_header</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ct_sip_parse_sdp_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datalen</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">type</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">term</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_get_sdp_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span>
				    <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span> <span class="o">+</span> <span class="o">*</span><span class="n">matchoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
			<span class="n">dptr</span> <span class="o">+</span> <span class="o">*</span><span class="n">matchoff</span> <span class="o">+</span> <span class="o">*</span><span class="n">matchlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">refresh_signalling_expectation</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
					  <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">expectations</span><span class="p">,</span> <span class="n">lnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">SIP_EXPECT_SIGNALLING</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">nf_inet_addr_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u3</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">exp</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">!=</span> <span class="n">proto</span> <span class="o">||</span>
		    <span class="n">exp</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span> <span class="o">!=</span> <span class="n">port</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">exp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NF_CT_EXPECT_INACTIVE</span><span class="p">;</span>
		<span class="n">exp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">expires</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_expectations</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="n">bool</span> <span class="n">media</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">expectations</span><span class="p">,</span> <span class="n">lnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">SIP_EXPECT_SIGNALLING</span><span class="p">)</span> <span class="o">^</span> <span class="n">media</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">nf_ct_unlink_expect</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>
		<span class="n">nf_ct_expect_put</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">media</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_conntrack_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_expected_rtp_rtcp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">sip_expectation_classes</span> <span class="n">class</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mediaoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">medialen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">exp</span><span class="p">,</span> <span class="o">*</span><span class="n">rtp_exp</span><span class="p">,</span> <span class="o">*</span><span class="n">rtcp_exp</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">nf_ct_net</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_dir</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_tuple</span> <span class="n">tuple</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">direct_rtp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skip_expect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="n">u_int16_t</span> <span class="n">base_port</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">rtp_port</span><span class="p">,</span> <span class="n">rtcp_port</span><span class="p">;</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sdp_port_hook</span><span class="p">)</span> <span class="n">nf_nat_sdp_port</span><span class="p">;</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sdp_media_hook</span><span class="p">)</span> <span class="n">nf_nat_sdp_media</span><span class="p">;</span>

	<span class="n">saddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sip_direct_media</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_inet_addr_cmp</span><span class="p">(</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">dir</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u3</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="n">saddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to check whether the registration exists before attempting</span>
<span class="cm">	 * to register it since we can see the same media description multiple</span>
<span class="cm">	 * times on different connections in case multiple endpoints receive</span>
<span class="cm">	 * the same call.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RTP optimization: if we find a matching media channel expectation</span>
<span class="cm">	 * and both the expectation and this connection are SNATed, we assume</span>
<span class="cm">	 * both sides can reach each other directly and use the final</span>
<span class="cm">	 * destination address from the expectation. We still need to keep</span>
<span class="cm">	 * the NATed expectations for media that might arrive from the</span>
<span class="cm">	 * outside, and additionally need to expect the direct RTP stream</span>
<span class="cm">	 * in case it passes through us even without NAT.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tuple</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">saddr</span><span class="p">)</span>
		<span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u3</span> <span class="o">=</span> <span class="o">*</span><span class="n">saddr</span><span class="p">;</span>
	<span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span>		<span class="o">=</span> <span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span>	<span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
	<span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u3</span>		<span class="o">=</span> <span class="o">*</span><span class="n">daddr</span><span class="p">;</span>
	<span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span>	<span class="o">=</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="n">__nf_ct_expect_find</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">nf_ct_zone</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tuple</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exp</span> <span class="o">||</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">==</span> <span class="n">ct</span> <span class="o">||</span>
		    <span class="n">nfct_help</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">!=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">||</span>
		    <span class="n">exp</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">class</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NF_NAT_NEEDED</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">==</span> <span class="n">AF_INET</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">direct_rtp</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">saved_ip</span> <span class="o">!=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u3</span><span class="p">.</span><span class="n">ip</span> <span class="o">||</span>
		     <span class="n">exp</span><span class="o">-&gt;</span><span class="n">saved_proto</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span> <span class="o">!=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">daddr</span><span class="o">-&gt;</span><span class="n">ip</span>		<span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">saved_ip</span><span class="p">;</span>
			<span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u3</span><span class="p">.</span><span class="n">ip</span>		<span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">saved_ip</span><span class="p">;</span>
			<span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span>	<span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">saved_proto</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
			<span class="n">direct_rtp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
			<span class="n">skip_expect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_expect</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">base_port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rtp_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">base_port</span><span class="p">);</span>
	<span class="n">rtcp_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">base_port</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direct_rtp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nf_nat_sdp_port</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sdp_port_hook</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_nat_sdp_port</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">nf_nat_sdp_port</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
				     <span class="n">mediaoff</span><span class="p">,</span> <span class="n">medialen</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">rtp_port</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skip_expect</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">rtp_exp</span> <span class="o">=</span> <span class="n">nf_ct_expect_alloc</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtp_exp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
	<span class="n">nf_ct_expect_init</span><span class="p">(</span><span class="n">rtp_exp</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span>
			  <span class="n">IPPROTO_UDP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtp_port</span><span class="p">);</span>

	<span class="n">rtcp_exp</span> <span class="o">=</span> <span class="n">nf_ct_expect_alloc</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtcp_exp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err2</span><span class="p">;</span>
	<span class="n">nf_ct_expect_init</span><span class="p">(</span><span class="n">rtcp_exp</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span>
			  <span class="n">IPPROTO_UDP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtcp_port</span><span class="p">);</span>

	<span class="n">nf_nat_sdp_media</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sdp_media_hook</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nf_nat_sdp_media</span> <span class="o">&amp;&amp;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">direct_rtp</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_nat_sdp_media</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
				       <span class="n">rtp_exp</span><span class="p">,</span> <span class="n">rtcp_exp</span><span class="p">,</span>
				       <span class="n">mediaoff</span><span class="p">,</span> <span class="n">medialen</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_expect_related</span><span class="p">(</span><span class="n">rtp_exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_expect_related</span><span class="p">(</span><span class="n">rtcp_exp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">nf_ct_unexpect_related</span><span class="p">(</span><span class="n">rtp_exp</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">nf_ct_expect_put</span><span class="p">(</span><span class="n">rtcp_exp</span><span class="p">);</span>
<span class="nl">err2:</span>
	<span class="n">nf_ct_expect_put</span><span class="p">(</span><span class="n">rtp_exp</span><span class="p">);</span>
<span class="nl">err1:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sdp_media_type</span> <span class="n">sdp_media_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SDP_MEDIA_TYPE</span><span class="p">(</span><span class="s">&quot;audio &quot;</span><span class="p">,</span> <span class="n">SIP_EXPECT_AUDIO</span><span class="p">),</span>
	<span class="n">SDP_MEDIA_TYPE</span><span class="p">(</span><span class="s">&quot;video &quot;</span><span class="p">,</span> <span class="n">SIP_EXPECT_VIDEO</span><span class="p">),</span>
	<span class="n">SDP_MEDIA_TYPE</span><span class="p">(</span><span class="s">&quot;image &quot;</span><span class="p">,</span> <span class="n">SIP_EXPECT_IMAGE</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sdp_media_type</span> <span class="o">*</span><span class="nf">sdp_media_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
						   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span>
						   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sdp_media_type</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sdp_media_types</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp_media_types</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">matchlen</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_sdp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mediaoff</span><span class="p">,</span> <span class="n">medialen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sdpoff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">caddr_len</span><span class="p">,</span> <span class="n">maddr_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">caddr</span><span class="p">,</span> <span class="n">maddr</span><span class="p">,</span> <span class="n">rtp_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sdp_header_types</span> <span class="n">c_hdr</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sdp_media_type</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sdp_addr_hook</span><span class="p">)</span> <span class="n">nf_nat_sdp_addr</span><span class="p">;</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sdp_session_hook</span><span class="p">)</span> <span class="n">nf_nat_sdp_session</span><span class="p">;</span>

	<span class="n">nf_nat_sdp_addr</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sdp_addr_hook</span><span class="p">);</span>
	<span class="n">c_hdr</span> <span class="o">=</span> <span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">==</span> <span class="n">AF_INET</span> <span class="o">?</span> <span class="n">SDP_HDR_CONNECTION_IP4</span> <span class="o">:</span>
					     <span class="n">SDP_HDR_CONNECTION_IP6</span><span class="p">;</span>

	<span class="cm">/* Find beginning of session description */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_sdp_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				  <span class="n">SDP_HDR_VERSION</span><span class="p">,</span> <span class="n">SDP_HDR_UNSPEC</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">sdpoff</span> <span class="o">=</span> <span class="n">matchoff</span><span class="p">;</span>

	<span class="cm">/* The connection information is contained in the session description</span>
<span class="cm">	 * and/or once per media description. The first media description marks</span>
<span class="cm">	 * the end of the session description. */</span>
	<span class="n">caddr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_parse_sdp_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">sdpoff</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				  <span class="n">c_hdr</span><span class="p">,</span> <span class="n">SDP_HDR_MEDIA</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">caddr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">caddr_len</span> <span class="o">=</span> <span class="n">matchlen</span><span class="p">;</span>

	<span class="n">mediaoff</span> <span class="o">=</span> <span class="n">sdpoff</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sdp_media_types</span><span class="p">);</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_sdp_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">mediaoff</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
					  <span class="n">SDP_HDR_MEDIA</span><span class="p">,</span> <span class="n">SDP_HDR_UNSPEC</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">mediaoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">medialen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Get media type and port number. A media port value of zero</span>
<span class="cm">		 * indicates an inactive stream. */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">sdp_media_type</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">mediaoff</span><span class="p">,</span> <span class="n">medialen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mediaoff</span> <span class="o">+=</span> <span class="n">medialen</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mediaoff</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">medialen</span> <span class="o">-=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="n">port</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">mediaoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">||</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

		<span class="cm">/* The media description overrides the session description. */</span>
		<span class="n">maddr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_parse_sdp_addr</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">mediaoff</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
					  <span class="n">c_hdr</span><span class="p">,</span> <span class="n">SDP_HDR_MEDIA</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maddr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">maddr_len</span> <span class="o">=</span> <span class="n">matchlen</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtp_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rtp_addr</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">caddr_len</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtp_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">caddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rtp_addr</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">set_expected_rtp_rtcp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">rtp_addr</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">port</span><span class="p">),</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span>
					    <span class="n">mediaoff</span><span class="p">,</span> <span class="n">medialen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NF_ACCEPT</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Update media connection address if present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maddr_len</span> <span class="o">&amp;&amp;</span> <span class="n">nf_nat_sdp_addr</span> <span class="o">&amp;&amp;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_nat_sdp_addr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
					      <span class="n">mediaoff</span><span class="p">,</span> <span class="n">c_hdr</span><span class="p">,</span> <span class="n">SDP_HDR_MEDIA</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">rtp_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NF_ACCEPT</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update session connection and owner addresses */</span>
	<span class="n">nf_nat_sdp_session</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sdp_session_hook</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nf_nat_sdp_session</span> <span class="o">&amp;&amp;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_nat_sdp_session</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">sdpoff</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">rtp_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_invite_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">199</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">299</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">process_sdp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">cseq</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">help</span><span class="p">.</span><span class="n">ct_sip_info</span><span class="p">.</span><span class="n">invite_cseq</span> <span class="o">==</span> <span class="n">cseq</span><span class="p">)</span>
		<span class="n">flush_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_update_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">199</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">299</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">process_sdp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">cseq</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">help</span><span class="p">.</span><span class="n">ct_sip_info</span><span class="p">.</span><span class="n">invite_cseq</span> <span class="o">==</span> <span class="n">cseq</span><span class="p">)</span>
		<span class="n">flush_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_prack_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">199</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">299</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">process_sdp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">cseq</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">help</span><span class="p">.</span><span class="n">ct_sip_info</span><span class="p">.</span><span class="n">invite_cseq</span> <span class="o">==</span> <span class="n">cseq</span><span class="p">)</span>
		<span class="n">flush_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_invite_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">flush_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">process_sdp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">cseq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NF_ACCEPT</span><span class="p">)</span>
		<span class="n">help</span><span class="o">-&gt;</span><span class="n">help</span><span class="p">.</span><span class="n">ct_sip_info</span><span class="p">.</span><span class="n">invite_cseq</span> <span class="o">=</span> <span class="n">cseq</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_bye_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>

	<span class="n">flush_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Parse a REGISTER request and create a permanent expectation for incoming</span>
<span class="cm"> * signalling connections. The expectation is marked inactive and is activated</span>
<span class="cm"> * when receiving a response indicating success from the registrar.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_register_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_dir</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conntrack_expect</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">proto</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sip_expect_hook</span><span class="p">)</span> <span class="n">nf_nat_sip_expect</span><span class="p">;</span>

	<span class="cm">/* Expected connections can not register again. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_EXPECTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* We must check the expiration time: a value of zero signals the</span>
<span class="cm">	 * registrar to release the binding. We&#39;ll remove our expectation</span>
<span class="cm">	 * when receiving the new bindings in the response, but we don&#39;t</span>
<span class="cm">	 * want to create new ones.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The expiration time may be contained in Expires: header, the</span>
<span class="cm">	 * Contact: header parameters or the URI parameters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span> <span class="n">SIP_HDR_EXPIRES</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">expires</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_parse_header_uri</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				      <span class="n">SIP_HDR_CONTACT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t support third-party registrations */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_inet_addr_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">dir</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_parse_transport</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">matchoff</span> <span class="o">+</span> <span class="n">matchlen</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">proto</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_parse_numerical_param</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
					 <span class="n">matchoff</span> <span class="o">+</span> <span class="n">matchlen</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
					 <span class="s">&quot;expires=&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">store_cseq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">exp</span> <span class="o">=</span> <span class="n">nf_ct_expect_alloc</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">saddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sip_direct_signalling</span><span class="p">)</span>
		<span class="n">saddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="o">!</span><span class="n">dir</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u3</span><span class="p">;</span>

	<span class="n">nf_ct_expect_init</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">SIP_EXPECT_SIGNALLING</span><span class="p">,</span> <span class="n">nf_ct_l3num</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span>
			  <span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">exp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">sip_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">exp</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">;</span>
	<span class="n">exp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">NF_CT_EXPECT_PERMANENT</span> <span class="o">|</span> <span class="n">NF_CT_EXPECT_INACTIVE</span><span class="p">;</span>

	<span class="n">nf_nat_sip_expect</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sip_expect_hook</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nf_nat_sip_expect</span> <span class="o">&amp;&amp;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_nat_sip_expect</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span>
					<span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_ct_expect_related</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nf_ct_expect_put</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>

<span class="nl">store_cseq:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NF_ACCEPT</span><span class="p">)</span>
		<span class="n">help</span><span class="o">-&gt;</span><span class="n">help</span><span class="p">.</span><span class="n">ct_sip_info</span><span class="p">.</span><span class="n">register_cseq</span> <span class="o">=</span> <span class="n">cseq</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_register_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nf_conn_help</span> <span class="o">*</span><span class="n">help</span> <span class="o">=</span> <span class="n">nfct_help</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_dir</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">CTINFO2DIR</span><span class="p">(</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">proto</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">,</span> <span class="n">coff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">in_contact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* According to RFC 3261, &quot;UAs MUST NOT send a new registration until</span>
<span class="cm">	 * they have received a final response from the registrar for the</span>
<span class="cm">	 * previous one or the previous REGISTER request has timed out&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, some servers fail to detect retransmissions and send late</span>
<span class="cm">	 * responses, so we store the sequence number of the last valid</span>
<span class="cm">	 * request and compare it here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">help</span><span class="o">-&gt;</span><span class="n">help</span><span class="p">.</span><span class="n">ct_sip_info</span><span class="p">.</span><span class="n">register_cseq</span> <span class="o">!=</span> <span class="n">cseq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">199</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&lt;</span> <span class="mi">200</span> <span class="o">||</span> <span class="n">code</span> <span class="o">&gt;</span> <span class="mi">299</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">flush</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span> <span class="n">SIP_HDR_EXPIRES</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">expires</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c_expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_parse_header_uri</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">coff</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span>
					      <span class="n">SIP_HDR_CONTACT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_contact</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* We don&#39;t support third-party registrations */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nf_inet_addr_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">tuplehash</span><span class="p">[</span><span class="n">dir</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_parse_transport</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">matchoff</span> <span class="o">+</span> <span class="n">matchlen</span><span class="p">,</span>
					   <span class="o">*</span><span class="n">datalen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ct_sip_parse_numerical_param</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span>
						   <span class="n">matchoff</span> <span class="o">+</span> <span class="n">matchlen</span><span class="p">,</span>
						   <span class="o">*</span><span class="n">datalen</span><span class="p">,</span> <span class="s">&quot;expires=&quot;</span><span class="p">,</span>
						   <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c_expires</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c_expires</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">refresh_signalling_expectation</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
						   <span class="n">c_expires</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">flush:</span>
	<span class="n">flush_expectations</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sip_handler</span> <span class="n">sip_handlers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SIP_HANDLER</span><span class="p">(</span><span class="s">&quot;INVITE&quot;</span><span class="p">,</span> <span class="n">process_invite_request</span><span class="p">,</span> <span class="n">process_invite_response</span><span class="p">),</span>
	<span class="n">SIP_HANDLER</span><span class="p">(</span><span class="s">&quot;UPDATE&quot;</span><span class="p">,</span> <span class="n">process_sdp</span><span class="p">,</span> <span class="n">process_update_response</span><span class="p">),</span>
	<span class="n">SIP_HANDLER</span><span class="p">(</span><span class="s">&quot;ACK&quot;</span><span class="p">,</span> <span class="n">process_sdp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">SIP_HANDLER</span><span class="p">(</span><span class="s">&quot;PRACK&quot;</span><span class="p">,</span> <span class="n">process_sdp</span><span class="p">,</span> <span class="n">process_prack_response</span><span class="p">),</span>
	<span class="n">SIP_HANDLER</span><span class="p">(</span><span class="s">&quot;BYE&quot;</span><span class="p">,</span> <span class="n">process_bye_request</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">SIP_HANDLER</span><span class="p">(</span><span class="s">&quot;REGISTER&quot;</span><span class="p">,</span> <span class="n">process_register_request</span><span class="p">,</span> <span class="n">process_register_response</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_sip_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">,</span> <span class="n">matchend</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="n">cseq</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;SIP/2.0 200&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">code</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;SIP/2.0 &quot;</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">code</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span> <span class="n">SIP_HDR_CSEQ</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="n">cseq</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cseq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="n">matchend</span> <span class="o">=</span> <span class="n">matchoff</span> <span class="o">+</span> <span class="n">matchlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sip_handlers</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sip_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>

		<span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sip_handlers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="n">matchend</span> <span class="o">+</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">||</span>
		    <span class="n">strnicmp</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchend</span><span class="p">,</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">,</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
					 <span class="n">cseq</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_sip_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cseq</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sip_handlers</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sip_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>

		<span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sip_handlers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">request</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">||</span>
		    <span class="n">strnicmp</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">,</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">datalen</span><span class="p">,</span> <span class="n">SIP_HDR_CSEQ</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
		<span class="n">cseq</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cseq</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">cseq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_sip_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dptr</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">datalen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sip_hook</span><span class="p">)</span> <span class="n">nf_nat_sip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strnicmp</span><span class="p">(</span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="s">&quot;SIP/2.0 &quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;SIP/2.0 &quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">process_sip_request</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">process_sip_response</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NF_ACCEPT</span> <span class="o">&amp;&amp;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nf_nat_sip</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sip_hook</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_nat_sip</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nf_nat_sip</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="n">datalen</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NF_DROP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sip_help_tcp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protoff</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="n">_tcph</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchoff</span><span class="p">,</span> <span class="n">matchlen</span><span class="p">,</span> <span class="n">clen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">origlen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">diff</span><span class="p">,</span> <span class="n">tdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">term</span><span class="p">;</span>
	<span class="n">typeof</span><span class="p">(</span><span class="n">nf_nat_sip_seq_adjust_hook</span><span class="p">)</span> <span class="n">nf_nat_sip_seq_adjust</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctinfo</span> <span class="o">!=</span> <span class="n">IP_CT_ESTABLISHED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ctinfo</span> <span class="o">!=</span> <span class="n">IP_CT_ESTABLISHED_REPLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="cm">/* No Data ? */</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">skb_header_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">protoff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_tcph</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_tcph</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
	<span class="n">dataoff</span> <span class="o">=</span> <span class="n">protoff</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dataoff</span> <span class="o">&gt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">nf_ct_refresh</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sip_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">dptr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">;</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">dataoff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;SIP/2.0 200&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct_sip_get_header</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">dptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span>
				      <span class="n">SIP_HDR_CONTENT_LENGTH</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">matchoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">matchlen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">clen</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dptr</span> <span class="o">+</span> <span class="n">matchoff</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">term</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">end</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n\r\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dptr</span> <span class="o">+</span> <span class="n">datalen</span><span class="p">;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span>
			    <span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">term</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">term</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n\r\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">clen</span><span class="p">;</span>

		<span class="n">msglen</span> <span class="o">=</span> <span class="n">origlen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">dptr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&gt;</span> <span class="n">datalen</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">process_sip_msg</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msglen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NF_ACCEPT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">diff</span>     <span class="o">=</span> <span class="n">msglen</span> <span class="o">-</span> <span class="n">origlen</span><span class="p">;</span>
		<span class="n">tdiff</span>   <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>

		<span class="n">dataoff</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span>
		<span class="n">dptr</span>    <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span>
		<span class="n">datalen</span>  <span class="o">=</span> <span class="n">datalen</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">-</span> <span class="n">msglen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NF_ACCEPT</span> <span class="o">&amp;&amp;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IPS_NAT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nf_nat_sip_seq_adjust</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nf_nat_sip_seq_adjust_hook</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf_nat_sip_seq_adjust</span><span class="p">)</span>
			<span class="n">nf_nat_sip_seq_adjust</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tdiff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sip_help_udp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protoff</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dptr</span><span class="p">;</span>

	<span class="cm">/* No Data ? */</span>
	<span class="n">dataoff</span> <span class="o">=</span> <span class="n">protoff</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dataoff</span> <span class="o">&gt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="n">nf_ct_refresh</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sip_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>

	<span class="n">dptr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">dataoff</span><span class="p">;</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">dataoff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;SIP/2.0 200&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">process_sip_msg</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">datalen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_conntrack_helper</span> <span class="n">sip</span><span class="p">[</span><span class="n">MAX_PORTS</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">sip_names</span><span class="p">[</span><span class="n">MAX_PORTS</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;sip-65535&quot;</span><span class="p">)]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_conntrack_expect_policy</span> <span class="n">sip_exp_policy</span><span class="p">[</span><span class="n">SIP_EXPECT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SIP_EXPECT_SIGNALLING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;signalling&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_expected</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timeout</span>	<span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SIP_EXPECT_AUDIO</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;audio&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_expected</span>	<span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">IP_CT_DIR_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timeout</span>	<span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SIP_EXPECT_VIDEO</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;video&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_expected</span>	<span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">IP_CT_DIR_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timeout</span>	<span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SIP_EXPECT_IMAGE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;image&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_expected</span>	<span class="o">=</span> <span class="n">IP_CT_DIR_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timeout</span>	<span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nf_conntrack_sip_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ports_c</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">me</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">nf_conntrack_helper_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nf_conntrack_sip_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpname</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ports_c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ports</span><span class="p">[</span><span class="n">ports_c</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIP_PORT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ports_c</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">help</span> <span class="o">=</span> <span class="n">sip_help_udp</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">].</span><span class="n">help</span> <span class="o">=</span> <span class="n">sip_help_tcp</span><span class="p">;</span>

		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">=</span> <span class="n">IPPROTO_UDP</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">].</span><span class="n">help</span> <span class="o">=</span> <span class="n">sip_help_udp</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">protonum</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
		<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">].</span><span class="n">help</span> <span class="o">=</span> <span class="n">sip_help_tcp</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">expect_policy</span> <span class="o">=</span> <span class="n">sip_exp_policy</span><span class="p">;</span>
			<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">expect_class_max</span> <span class="o">=</span> <span class="n">SIP_EXPECT_MAX</span><span class="p">;</span>
			<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">me</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

			<span class="n">tmpname</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sip_names</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">SIP_PORT</span><span class="p">)</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">tmpname</span><span class="p">,</span> <span class="s">&quot;sip&quot;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">tmpname</span><span class="p">,</span> <span class="s">&quot;sip-%u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">tmpname</span><span class="p">;</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;port #%u: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">nf_conntrack_helper_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nf_ct_sip: failed to register&quot;</span>
				       <span class="s">&quot; helper for pf: %u port: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">sip</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">tuple</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">l3num</span><span class="p">,</span> <span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">nf_conntrack_sip_fini</span><span class="p">();</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">nf_conntrack_sip_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">nf_conntrack_sip_fini</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
