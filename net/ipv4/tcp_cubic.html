<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › tcp_cubic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp_cubic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * TCP CUBIC: Binary Increase Congestion control for TCP v2.3</span>
<span class="cm"> * Home page:</span>
<span class="cm"> *      http://netsrv.csc.ncsu.edu/twiki/bin/view/Main/BIC</span>
<span class="cm"> * This is from the implementation of CUBIC TCP in</span>
<span class="cm"> * Sangtae Ha, Injong Rhee and Lisong Xu,</span>
<span class="cm"> *  &quot;CUBIC: A New TCP-Friendly High-Speed TCP Variant&quot;</span>
<span class="cm"> *  in ACM SIGOPS Operating System Review, July 2008.</span>
<span class="cm"> * Available from:</span>
<span class="cm"> *  http://netsrv.csc.ncsu.edu/export/cubic_a_new_tcp_2008.pdf</span>
<span class="cm"> *</span>
<span class="cm"> * CUBIC integrates a new slow start algorithm, called HyStart.</span>
<span class="cm"> * The details of HyStart are presented in</span>
<span class="cm"> *  Sangtae Ha and Injong Rhee,</span>
<span class="cm"> *  &quot;Taming the Elephants: New TCP Slow Start&quot;, NCSU TechReport 2008.</span>
<span class="cm"> * Available from:</span>
<span class="cm"> *  http://netsrv.csc.ncsu.edu/export/hystart_techreport_2008.pdf</span>
<span class="cm"> *</span>
<span class="cm"> * All testing results are available from:</span>
<span class="cm"> * http://netsrv.csc.ncsu.edu/wiki/index.php/TCP_Testing</span>
<span class="cm"> *</span>
<span class="cm"> * Unless CUBIC is enabled and congestion window is large</span>
<span class="cm"> * this behaves the same as the original Reno.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>

<span class="cp">#define BICTCP_BETA_SCALE    1024	</span><span class="cm">/* Scale factor beta calculation</span>
<span class="cm">					 * max_cwnd = snd_cwnd * beta</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define	BICTCP_HZ		10	</span><span class="cm">/* BIC HZ 2^10 = 1024 */</span><span class="cp"></span>

<span class="cm">/* Two methods of hybrid slow start */</span>
<span class="cp">#define HYSTART_ACK_TRAIN	0x1</span>
<span class="cp">#define HYSTART_DELAY		0x2</span>

<span class="cm">/* Number of delay samples for detecting the increase of delay */</span>
<span class="cp">#define HYSTART_MIN_SAMPLES	8</span>
<span class="cp">#define HYSTART_DELAY_MIN	(4U&lt;&lt;3)</span>
<span class="cp">#define HYSTART_DELAY_MAX	(16U&lt;&lt;3)</span>
<span class="cp">#define HYSTART_DELAY_THRESH(x)	clamp(x, HYSTART_DELAY_MIN, HYSTART_DELAY_MAX)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fast_convergence</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">beta</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">717</span><span class="p">;</span>	<span class="cm">/* = 717/1024 (BICTCP_BETA_SCALE) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">initial_ssthresh</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bic_scale</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tcp_friendliness</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hystart</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hystart_detect</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">HYSTART_ACK_TRAIN</span> <span class="o">|</span> <span class="n">HYSTART_DELAY</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hystart_low_window</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hystart_ack_delta</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">cube_rtt_scale</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">beta_scale</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">cube_factor</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Note parameters that are used for precomputing scale factors are read-only */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fast_convergence</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fast_convergence</span><span class="p">,</span> <span class="s">&quot;turn on/off fast convergence&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="s">&quot;beta for multiplicative increase&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">initial_ssthresh</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">initial_ssthresh</span><span class="p">,</span> <span class="s">&quot;initial value of slow start threshold&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">bic_scale</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">bic_scale</span><span class="p">,</span> <span class="s">&quot;scale (scaled by 1024) value for bic function (bic_scale/1024)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">tcp_friendliness</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">tcp_friendliness</span><span class="p">,</span> <span class="s">&quot;turn on/off tcp friendliness&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hystart</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hystart</span><span class="p">,</span> <span class="s">&quot;turn on/off hybrid slow start algorithm&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hystart_detect</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hystart_detect</span><span class="p">,</span> <span class="s">&quot;hyrbrid slow start detection mechanisms&quot;</span>
		 <span class="s">&quot; 1: packet-train 2: delay 3: both packet-train and delay&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hystart_low_window</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hystart_low_window</span><span class="p">,</span> <span class="s">&quot;lower bound cwnd for hybrid slow start&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hystart_ack_delta</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hystart_ack_delta</span><span class="p">,</span> <span class="s">&quot;spacing between ack&#39;s indicating train (msecs)&quot;</span><span class="p">);</span>

<span class="cm">/* BIC TCP Parameters */</span>
<span class="k">struct</span> <span class="n">bictcp</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">cnt</span><span class="p">;</span>		<span class="cm">/* increase cwnd by 1 after ACKs */</span>
	<span class="n">u32</span> 	<span class="n">last_max_cwnd</span><span class="p">;</span>	<span class="cm">/* last maximum snd_cwnd */</span>
	<span class="n">u32</span>	<span class="n">loss_cwnd</span><span class="p">;</span>	<span class="cm">/* congestion window at last loss */</span>
	<span class="n">u32</span>	<span class="n">last_cwnd</span><span class="p">;</span>	<span class="cm">/* the last snd_cwnd */</span>
	<span class="n">u32</span>	<span class="n">last_time</span><span class="p">;</span>	<span class="cm">/* time when updated last_cwnd */</span>
	<span class="n">u32</span>	<span class="n">bic_origin_point</span><span class="p">;</span><span class="cm">/* origin point of bic function */</span>
	<span class="n">u32</span>	<span class="n">bic_K</span><span class="p">;</span>		<span class="cm">/* time to origin point from the beginning of the current epoch */</span>
	<span class="n">u32</span>	<span class="n">delay_min</span><span class="p">;</span>	<span class="cm">/* min delay (msec &lt;&lt; 3) */</span>
	<span class="n">u32</span>	<span class="n">epoch_start</span><span class="p">;</span>	<span class="cm">/* beginning of an epoch */</span>
	<span class="n">u32</span>	<span class="n">ack_cnt</span><span class="p">;</span>	<span class="cm">/* number of acks */</span>
	<span class="n">u32</span>	<span class="n">tcp_cwnd</span><span class="p">;</span>	<span class="cm">/* estimated tcp cwnd */</span>
<span class="cp">#define ACK_RATIO_SHIFT	4</span>
<span class="cp">#define ACK_RATIO_LIMIT (32u &lt;&lt; ACK_RATIO_SHIFT)</span>
	<span class="n">u16</span>	<span class="n">delayed_ack</span><span class="p">;</span>	<span class="cm">/* estimate the ratio of Packets/ACKs &lt;&lt; 4 */</span>
	<span class="n">u8</span>	<span class="n">sample_cnt</span><span class="p">;</span>	<span class="cm">/* number of samples to decide curr_rtt */</span>
	<span class="n">u8</span>	<span class="n">found</span><span class="p">;</span>		<span class="cm">/* the exit point is found? */</span>
	<span class="n">u32</span>	<span class="n">round_start</span><span class="p">;</span>	<span class="cm">/* beginning of each round */</span>
	<span class="n">u32</span>	<span class="n">end_seq</span><span class="p">;</span>	<span class="cm">/* end_seq of the round */</span>
	<span class="n">u32</span>	<span class="n">last_ack</span><span class="p">;</span>	<span class="cm">/* last time when the ACK spacing is close */</span>
	<span class="n">u32</span>	<span class="n">curr_rtt</span><span class="p">;</span>	<span class="cm">/* the minimum rtt of current round */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bictcp_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_cwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_origin_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">epoch_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">delayed_ack</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">ACK_RATIO_SHIFT</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">ack_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">tcp_cwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">bictcp_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if HZ &lt; 1000</span>
	<span class="k">return</span> <span class="n">ktime_to_ms</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">());</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bictcp_hystart_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">round_start</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_ack</span> <span class="o">=</span> <span class="n">bictcp_clock</span><span class="p">();</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">curr_rtt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">sample_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bictcp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">bictcp_reset</span><span class="p">(</span><span class="n">ca</span><span class="p">);</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">loss_cwnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hystart</span><span class="p">)</span>
		<span class="n">bictcp_hystart_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hystart</span> <span class="o">&amp;&amp;</span> <span class="n">initial_ssthresh</span><span class="p">)</span>
		<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">initial_ssthresh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* calculate the cubic root of x using a table lookup followed by one</span>
<span class="cm"> * Newton-Raphson iteration.</span>
<span class="cm"> * Avg err ~= 0.195%</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">cubic_root</span><span class="p">(</span><span class="n">u64</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * cbrt(x) MSB values for x MSB values in [0..63].</span>
<span class="cm">	 * Precomputed then refined by hand - Willy Tarreau</span>
<span class="cm">	 *</span>
<span class="cm">	 * For x in [0..63],</span>
<span class="cm">	 *   v = cbrt(x &lt;&lt; 18) - 1</span>
<span class="cm">	 *   cbrt(x) = (v[x] + 10) &gt;&gt; 6</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">v</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* 0x00 */</span>    <span class="mi">0</span><span class="p">,</span>   <span class="mi">54</span><span class="p">,</span>   <span class="mi">54</span><span class="p">,</span>   <span class="mi">54</span><span class="p">,</span>  <span class="mi">118</span><span class="p">,</span>  <span class="mi">118</span><span class="p">,</span>  <span class="mi">118</span><span class="p">,</span>  <span class="mi">118</span><span class="p">,</span>
		<span class="cm">/* 0x08 */</span>  <span class="mi">123</span><span class="p">,</span>  <span class="mi">129</span><span class="p">,</span>  <span class="mi">134</span><span class="p">,</span>  <span class="mi">138</span><span class="p">,</span>  <span class="mi">143</span><span class="p">,</span>  <span class="mi">147</span><span class="p">,</span>  <span class="mi">151</span><span class="p">,</span>  <span class="mi">156</span><span class="p">,</span>
		<span class="cm">/* 0x10 */</span>  <span class="mi">157</span><span class="p">,</span>  <span class="mi">161</span><span class="p">,</span>  <span class="mi">164</span><span class="p">,</span>  <span class="mi">168</span><span class="p">,</span>  <span class="mi">170</span><span class="p">,</span>  <span class="mi">173</span><span class="p">,</span>  <span class="mi">176</span><span class="p">,</span>  <span class="mi">179</span><span class="p">,</span>
		<span class="cm">/* 0x18 */</span>  <span class="mi">181</span><span class="p">,</span>  <span class="mi">185</span><span class="p">,</span>  <span class="mi">187</span><span class="p">,</span>  <span class="mi">190</span><span class="p">,</span>  <span class="mi">192</span><span class="p">,</span>  <span class="mi">194</span><span class="p">,</span>  <span class="mi">197</span><span class="p">,</span>  <span class="mi">199</span><span class="p">,</span>
		<span class="cm">/* 0x20 */</span>  <span class="mi">200</span><span class="p">,</span>  <span class="mi">202</span><span class="p">,</span>  <span class="mi">204</span><span class="p">,</span>  <span class="mi">206</span><span class="p">,</span>  <span class="mi">209</span><span class="p">,</span>  <span class="mi">211</span><span class="p">,</span>  <span class="mi">213</span><span class="p">,</span>  <span class="mi">215</span><span class="p">,</span>
		<span class="cm">/* 0x28 */</span>  <span class="mi">217</span><span class="p">,</span>  <span class="mi">219</span><span class="p">,</span>  <span class="mi">221</span><span class="p">,</span>  <span class="mi">222</span><span class="p">,</span>  <span class="mi">224</span><span class="p">,</span>  <span class="mi">225</span><span class="p">,</span>  <span class="mi">227</span><span class="p">,</span>  <span class="mi">229</span><span class="p">,</span>
		<span class="cm">/* 0x30 */</span>  <span class="mi">231</span><span class="p">,</span>  <span class="mi">232</span><span class="p">,</span>  <span class="mi">234</span><span class="p">,</span>  <span class="mi">236</span><span class="p">,</span>  <span class="mi">237</span><span class="p">,</span>  <span class="mi">239</span><span class="p">,</span>  <span class="mi">240</span><span class="p">,</span>  <span class="mi">242</span><span class="p">,</span>
		<span class="cm">/* 0x38 */</span>  <span class="mi">244</span><span class="p">,</span>  <span class="mi">245</span><span class="p">,</span>  <span class="mi">246</span><span class="p">,</span>  <span class="mi">248</span><span class="p">,</span>  <span class="mi">250</span><span class="p">,</span>  <span class="mi">251</span><span class="p">,</span>  <span class="mi">252</span><span class="p">,</span>  <span class="mi">254</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">fls64</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* a in [0..63] */</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">v</span><span class="p">[(</span><span class="n">u32</span><span class="p">)</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="mi">35</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="n">b</span> <span class="o">*</span> <span class="mi">84</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="mi">3</span><span class="p">));</span>

	<span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(((</span><span class="n">u32</span><span class="p">)</span><span class="n">v</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Newton-Raphson iteration</span>
<span class="cm">	 *                         2</span>
<span class="cm">	 * x    = ( 2 * x  +  a / x  ) / 3</span>
<span class="cm">	 *  k+1          k         k</span>
<span class="cm">	 */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">div64_u64</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="mi">341</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute congestion window to use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bictcp_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cwnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delta</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">bic_target</span><span class="p">,</span> <span class="n">max_cnt</span><span class="p">;</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">ack_cnt</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* count the number of ACKs */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_cwnd</span> <span class="o">==</span> <span class="n">cwnd</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_time</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">32</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_cwnd</span> <span class="o">=</span> <span class="n">cwnd</span><span class="p">;</span>
	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_time</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">epoch_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">epoch_start</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>	<span class="cm">/* record the beginning of an epoch */</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">ack_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* start counting */</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">tcp_cwnd</span> <span class="o">=</span> <span class="n">cwnd</span><span class="p">;</span>			<span class="cm">/* syn with cubic */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">&lt;=</span> <span class="n">cwnd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_origin_point</span> <span class="o">=</span> <span class="n">cwnd</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Compute new K based on</span>
<span class="cm">			 * (wmax-cwnd) * (srtt&gt;&gt;3 / HZ) / c * 2^(3*bictcp_HZ)</span>
<span class="cm">			 */</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span> <span class="o">=</span> <span class="n">cubic_root</span><span class="p">(</span><span class="n">cube_factor</span>
					       <span class="o">*</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">-</span> <span class="n">cwnd</span><span class="p">));</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_origin_point</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* cubic function - calc*/</span>
	<span class="cm">/* calculate c * time^3 / rtt,</span>
<span class="cm">	 *  while considering overflow in calculation of time^3</span>
<span class="cm">	 * (so time^3 is done by using 64 bit)</span>
<span class="cm">	 * and without the support of division of 64bit numbers</span>
<span class="cm">	 * (so all divisions are done by using 32 bit)</span>
<span class="cm">	 *  also NOTE the unit of those veriables</span>
<span class="cm">	 *	  time  = (t - K) / 2^bictcp_HZ</span>
<span class="cm">	 *	  c = bic_scale &gt;&gt; 10</span>
<span class="cm">	 * rtt  = (srtt &gt;&gt; 3) / HZ</span>
<span class="cm">	 * !!! The following code does not have overflow problems,</span>
<span class="cm">	 * if the cwnd &lt; 1 million packets !!!</span>
<span class="cm">	 */</span>

	<span class="cm">/* change the unit from HZ to bictcp_HZ */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">((</span><span class="n">tcp_time_stamp</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">)</span>
	      <span class="o">-</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">epoch_start</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">BICTCP_HZ</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span><span class="p">)</span>		<span class="cm">/* t - K */</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span> <span class="o">-</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span><span class="p">;</span>

	<span class="cm">/* c/rtt * (t-K)^3 */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cube_rtt_scale</span> <span class="o">*</span> <span class="n">offs</span> <span class="o">*</span> <span class="n">offs</span> <span class="o">*</span> <span class="n">offs</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">BICTCP_HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_K</span><span class="p">)</span>                                	<span class="cm">/* below origin*/</span>
		<span class="n">bic_target</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_origin_point</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">else</span>                                                	<span class="cm">/* above origin*/</span>
		<span class="n">bic_target</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">bic_origin_point</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/* cubic function - calc bictcp_cnt*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bic_target</span> <span class="o">&gt;</span> <span class="n">cwnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">cwnd</span> <span class="o">/</span> <span class="p">(</span><span class="n">bic_target</span> <span class="o">-</span> <span class="n">cwnd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">cwnd</span><span class="p">;</span>              <span class="cm">/* very small increment*/</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The initial growth of cubic function may be too conservative</span>
<span class="cm">	 * when the available bandwidth is still unknown.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>	<span class="cm">/* increase cwnd 5% per RTT */</span>

	<span class="cm">/* TCP Friendly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_friendliness</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">beta_scale</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cwnd</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">ack_cnt</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* update tcp cwnd */</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">ack_cnt</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">tcp_cwnd</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">tcp_cwnd</span> <span class="o">&gt;</span> <span class="n">cwnd</span><span class="p">){</span>	<span class="cm">/* if bic is slower than tcp */</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">tcp_cwnd</span> <span class="o">-</span> <span class="n">cwnd</span><span class="p">;</span>
			<span class="n">max_cnt</span> <span class="o">=</span> <span class="n">cwnd</span> <span class="o">/</span> <span class="n">delta</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">max_cnt</span><span class="p">)</span>
				<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">max_cnt</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="n">ACK_RATIO_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">delayed_ack</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>			<span class="cm">/* cannot be zero */</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bictcp_cong_avoid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ack</span><span class="p">,</span> <span class="n">u32</span> <span class="n">in_flight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_is_cwnd_limited</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">in_flight</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hystart</span> <span class="o">&amp;&amp;</span> <span class="n">after</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span>
			<span class="n">bictcp_hystart_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_slow_start</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bictcp_update</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">);</span>
		<span class="n">tcp_cong_avoid_ai</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">bictcp_recalc_ssthresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">epoch_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* end of epoch */</span>

	<span class="cm">/* Wmax and fast convergence */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&lt;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">&amp;&amp;</span> <span class="n">fast_convergence</span><span class="p">)</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">*</span> <span class="p">(</span><span class="n">BICTCP_BETA_SCALE</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))</span>
			<span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">BICTCP_BETA_SCALE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_max_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>

	<span class="n">ca</span><span class="o">-&gt;</span><span class="n">loss_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">BICTCP_BETA_SCALE</span><span class="p">,</span> <span class="mi">2U</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">bictcp_undo_cwnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">loss_cwnd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bictcp_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">TCP_CA_Loss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bictcp_reset</span><span class="p">(</span><span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="n">bictcp_hystart_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hystart_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">&amp;</span> <span class="n">hystart_detect</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">now</span> <span class="o">=</span> <span class="n">bictcp_clock</span><span class="p">();</span>

		<span class="cm">/* first detection parameter - ack-train detection */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_ack</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">hystart_ack_delta</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">last_ack</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">round_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="n">ca</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">|=</span> <span class="n">HYSTART_ACK_TRAIN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* obtain the minimum delay of more than sampling packets */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">sample_cnt</span> <span class="o">&lt;</span> <span class="n">HYSTART_MIN_SAMPLES</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">curr_rtt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">curr_rtt</span> <span class="o">&gt;</span> <span class="n">delay</span><span class="p">)</span>
				<span class="n">ca</span><span class="o">-&gt;</span><span class="n">curr_rtt</span> <span class="o">=</span> <span class="n">delay</span><span class="p">;</span>

			<span class="n">ca</span><span class="o">-&gt;</span><span class="n">sample_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">curr_rtt</span> <span class="o">&gt;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span> <span class="o">+</span>
			    <span class="n">HYSTART_DELAY_THRESH</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">))</span>
				<span class="n">ca</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">|=</span> <span class="n">HYSTART_DELAY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either one of two conditions are met,</span>
<span class="cm">		 * we exit from slow start immediately.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">&amp;</span> <span class="n">hystart_detect</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Track delayed acknowledgment ratio using sliding window</span>
<span class="cm"> * ratio = (15*ratio + sample) / 16</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bictcp_acked</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">s32</span> <span class="n">rtt_us</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bictcp</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">delay</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Open</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">delayed_ack</span><span class="p">;</span>

		<span class="n">ratio</span> <span class="o">-=</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">delayed_ack</span> <span class="o">&gt;&gt;</span> <span class="n">ACK_RATIO_SHIFT</span><span class="p">;</span>
		<span class="n">ratio</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>

		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">delayed_ack</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">ACK_RATIO_LIMIT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Some calls are for duplicates without timetamps */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtt_us</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Discard delay samples right after fast recovery */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">epoch_start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">HZ</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">rtt_us</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">USEC_PER_MSEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* first time call or link delay decreases */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span> <span class="o">&gt;</span> <span class="n">delay</span><span class="p">)</span>
		<span class="n">ca</span><span class="o">-&gt;</span><span class="n">delay_min</span> <span class="o">=</span> <span class="n">delay</span><span class="p">;</span>

	<span class="cm">/* hystart triggers when cwnd is larger than some threshold */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hystart</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;=</span> <span class="n">hystart_low_window</span><span class="p">)</span>
		<span class="n">hystart_update</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="n">cubictcp</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">bictcp_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ssthresh</span>	<span class="o">=</span> <span class="n">bictcp_recalc_ssthresh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cong_avoid</span>	<span class="o">=</span> <span class="n">bictcp_cong_avoid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_state</span>	<span class="o">=</span> <span class="n">bictcp_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">undo_cwnd</span>	<span class="o">=</span> <span class="n">bictcp_undo_cwnd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pkts_acked</span>     <span class="o">=</span> <span class="n">bictcp_acked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;cubic&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cubictcp_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bictcp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ICSK_CA_PRIV_SIZE</span><span class="p">);</span>

	<span class="cm">/* Precompute a bunch of the scaling factors that are used per-packet</span>
<span class="cm">	 * based on SRTT of 100ms</span>
<span class="cm">	 */</span>

	<span class="n">beta_scale</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">BICTCP_BETA_SCALE</span><span class="o">+</span><span class="n">beta</span><span class="p">)</span><span class="o">/</span> <span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="n">BICTCP_BETA_SCALE</span> <span class="o">-</span> <span class="n">beta</span><span class="p">);</span>

	<span class="n">cube_rtt_scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">bic_scale</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>	<span class="cm">/* 1024*c/rtt */</span>

	<span class="cm">/* calculate the &quot;K&quot; for (wmax-cwnd) = c/rtt * K^3</span>
<span class="cm">	 *  so K = cubic_root( (wmax-cwnd)*rtt/c )</span>
<span class="cm">	 * the unit of K is bictcp_HZ=2^10, not HZ</span>
<span class="cm">	 *</span>
<span class="cm">	 *  c = bic_scale &gt;&gt; 10</span>
<span class="cm">	 *  rtt = 100ms</span>
<span class="cm">	 *</span>
<span class="cm">	 * the following code has been designed and tested for</span>
<span class="cm">	 * cwnd &lt; 1 million packets</span>
<span class="cm">	 * RTT &lt; 100 seconds</span>
<span class="cm">	 * HZ &lt; 1,000,00  (corresponding to 10 nano-second)</span>
<span class="cm">	 */</span>

	<span class="cm">/* 1/c * 2^2*bictcp_HZ * srtt */</span>
	<span class="n">cube_factor</span> <span class="o">=</span> <span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">BICTCP_HZ</span><span class="p">);</span> <span class="cm">/* 2^40 */</span>

	<span class="cm">/* divide by bic_scale and by constant Srtt (100ms) */</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">cube_factor</span><span class="p">,</span> <span class="n">bic_scale</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* hystart needs ms clock resolution */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hystart</span> <span class="o">&amp;&amp;</span> <span class="n">HZ</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="n">cubictcp</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TCP_CONG_RTT_STAMP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tcp_register_congestion_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cubictcp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cubictcp_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_unregister_congestion_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cubictcp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cubictcp_register</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cubictcp_unregister</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sangtae Ha, Stephen Hemminger&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;CUBIC TCP&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;2.3&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
