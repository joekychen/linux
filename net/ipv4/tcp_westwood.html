<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › tcp_westwood.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp_westwood.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * TCP Westwood+: end-to-end bandwidth estimation for TCP</span>
<span class="cm"> *</span>
<span class="cm"> *      Angelo Dell&#39;Aera: author of the first version of TCP Westwood+ in Linux 2.4</span>
<span class="cm"> *</span>
<span class="cm"> * Support at http://c3lab.poliba.it/index.php/Westwood</span>
<span class="cm"> * Main references in literature:</span>
<span class="cm"> *</span>
<span class="cm"> * - Mascolo S, Casetti, M. Gerla et al.</span>
<span class="cm"> *   &quot;TCP Westwood: bandwidth estimation for TCP&quot; Proc. ACM Mobicom 2001</span>
<span class="cm"> *</span>
<span class="cm"> * - A. Grieco, s. Mascolo</span>
<span class="cm"> *   &quot;Performance evaluation of New Reno, Vegas, Westwood+ TCP&quot; ACM Computer</span>
<span class="cm"> *     Comm. Review, 2004</span>
<span class="cm"> *</span>
<span class="cm"> * - A. Dell&#39;Aera, L. Grieco, S. Mascolo.</span>
<span class="cm"> *   &quot;Linux 2.4 Implementation of Westwood+ TCP with Rate-Halving :</span>
<span class="cm"> *    A Performance Evaluation Over the Internet&quot; (ICC 2004), Paris, June 2004</span>
<span class="cm"> *</span>
<span class="cm"> * Westwood+ employs end-to-end bandwidth measurement to set cwnd and</span>
<span class="cm"> * ssthresh after packet loss. The probing phase is as the original Reno.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/inet_diag.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>

<span class="cm">/* TCP Westwood structure */</span>
<span class="k">struct</span> <span class="n">westwood</span> <span class="p">{</span>
	<span class="n">u32</span>    <span class="n">bw_ns_est</span><span class="p">;</span>        <span class="cm">/* first bandwidth estimation..not too smoothed 8) */</span>
	<span class="n">u32</span>    <span class="n">bw_est</span><span class="p">;</span>           <span class="cm">/* bandwidth estimate */</span>
	<span class="n">u32</span>    <span class="n">rtt_win_sx</span><span class="p">;</span>       <span class="cm">/* here starts a new evaluation... */</span>
	<span class="n">u32</span>    <span class="n">bk</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">snd_una</span><span class="p">;</span>          <span class="cm">/* used for evaluating the number of acked bytes */</span>
	<span class="n">u32</span>    <span class="n">cumul_ack</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">accounted</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">rtt</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">rtt_min</span><span class="p">;</span>          <span class="cm">/* minimum observed RTT */</span>
	<span class="n">u8</span>     <span class="n">first_ack</span><span class="p">;</span>        <span class="cm">/* flag which infers that this is the first ack */</span>
	<span class="n">u8</span>     <span class="n">reset_rtt_min</span><span class="p">;</span>    <span class="cm">/* Reset RTT min to next RTT sample*/</span>
<span class="p">};</span>


<span class="cm">/* TCP Westwood functions and constants */</span>
<span class="cp">#define TCP_WESTWOOD_RTT_MIN   (HZ/20)	</span><span class="cm">/* 50ms */</span><span class="cp"></span>
<span class="cp">#define TCP_WESTWOOD_INIT_RTT  (20*HZ)	</span><span class="cm">/* maybe too conservative?! */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * @tcp_westwood_create</span>
<span class="cm"> * This function initializes fields used in TCP Westwood+,</span>
<span class="cm"> * it is called after the initial SYN, so the sequence numbers</span>
<span class="cm"> * are correct but new passive connections we have no</span>
<span class="cm"> * information about RTTmin at this time so we simply set it to</span>
<span class="cm"> * TCP_WESTWOOD_INIT_RTT. This value was chosen to be too conservative</span>
<span class="cm"> * since in this way we&#39;re sure it will be updated in a consistent</span>
<span class="cm"> * way as soon as possible. It will reasonably happen within the first</span>
<span class="cm"> * RTT period of the connection lifetime.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_westwood_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">w</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_est</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">accounted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">reset_rtt_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_min</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">TCP_WESTWOOD_INIT_RTT</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_win_sx</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">first_ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @westwood_do_filter</span>
<span class="cm"> * Low-pass filter. Implemented using constant coefficients.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">westwood_do_filter</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">,</span> <span class="n">u32</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="mi">7</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">westwood_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="n">u32</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If the filter is empty fill it with the first sample of bandwidth  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_est</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">/</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_est</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span> <span class="o">=</span> <span class="n">westwood_do_filter</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">/</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_est</span> <span class="o">=</span> <span class="n">westwood_do_filter</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_est</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_ns_est</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @westwood_pkts_acked</span>
<span class="cm"> * Called after processing group of packets.</span>
<span class="cm"> * but all westwood needs is the last sample of srtt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_westwood_pkts_acked</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">s32</span> <span class="n">rtt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">usecs_to_jiffies</span><span class="p">(</span><span class="n">rtt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @westwood_update_window</span>
<span class="cm"> * It updates RTT evaluation window if it is the right moment to do</span>
<span class="cm"> * it. If so it calls filter for evaluating bandwidth.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">westwood_update_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">s32</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_win_sx</span><span class="p">;</span>

	<span class="cm">/* Initialize w-&gt;snd_una with the first acked sequence number in order</span>
<span class="cm">	 * to fix mismatch between tp-&gt;snd_una and w-&gt;snd_una for the first</span>
<span class="cm">	 * bandwidth sample</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">first_ack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">first_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if a RTT-window has passed.</span>
<span class="cm">	 * Be careful since if RTT is less than</span>
<span class="cm">	 * 50ms we don&#39;t filter but we continue &#39;building the sample&#39;.</span>
<span class="cm">	 * This minimum limit was chosen since an estimation on small</span>
<span class="cm">	 * time intervals is better to avoid...</span>
<span class="cm">	 * Obviously on a LAN we reasonably will always have</span>
<span class="cm">	 * right_bound = left_bound + WESTWOOD_RTT_MIN</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt</span> <span class="o">&amp;&amp;</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt</span><span class="p">,</span> <span class="n">TCP_WESTWOOD_RTT_MIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">westwood_filter</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

		<span class="n">w</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_win_sx</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_rtt_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">reset_rtt_min</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_min</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt</span><span class="p">;</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">reset_rtt_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_min</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * @westwood_fast_bw</span>
<span class="cm"> * It is called when we are in fast path. In particular it is called when</span>
<span class="cm"> * header prediction is successful. In such case in fact update is</span>
<span class="cm"> * straight forward and doesn&#39;t need any particular care.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">westwood_fast_bw</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">westwood_update_window</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">w</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">+=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">-</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="n">w</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="n">update_rtt_min</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @westwood_acked_count</span>
<span class="cm"> * This function evaluates cumul_ack for evaluating bk in case of</span>
<span class="cm"> * delayed or partial acks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">westwood_acked_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">-</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>

	<span class="cm">/* If cumul_ack is 0 this is a dupack since it&#39;s not moving</span>
<span class="cm">	 * tp-&gt;snd_una.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">accounted</span> <span class="o">+=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Partial or delayed ack */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">accounted</span> <span class="o">&gt;=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">w</span><span class="o">-&gt;</span><span class="n">accounted</span> <span class="o">-=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span><span class="p">;</span>
			<span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span> <span class="o">-=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">accounted</span><span class="p">;</span>
			<span class="n">w</span><span class="o">-&gt;</span><span class="n">accounted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">w</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">cumul_ack</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * TCP Westwood</span>
<span class="cm"> * Here limit is evaluated as Bw estimation*RTTmin (for obtaining it</span>
<span class="cm"> * in packets we use mss_cache). Rttmin is guaranteed to be &gt;= 2</span>
<span class="cm"> * so avoids ever returning 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">tcp_westwood_bw_rttmin</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">bw_est</span> <span class="o">*</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">rtt_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_westwood_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">tcp_ca_event</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CA_EVENT_FAST_ACK</span>:
		<span class="n">westwood_fast_bw</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CA_EVENT_COMPLETE_CWR</span>:
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tcp_westwood_bw_rttmin</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CA_EVENT_FRTO</span>:
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tcp_westwood_bw_rttmin</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="cm">/* Update RTT_min when next ack arrives */</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">reset_rtt_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CA_EVENT_SLOW_ACK</span>:
		<span class="n">westwood_update_window</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">w</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">+=</span> <span class="n">westwood_acked_count</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">update_rtt_min</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* don&#39;t care */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Extract info for Tcp socket info provided via netlink. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_westwood_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ext</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">westwood</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="n">inet_csk_ca</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">INET_DIAG_VEGASINFO</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcpvegas_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">tcpv_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">tcpv_rtt</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">rtt</span><span class="p">),</span>
			<span class="p">.</span><span class="n">tcpv_minrtt</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">rtt_min</span><span class="p">),</span>
		<span class="p">};</span>

		<span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">INET_DIAG_VEGASINFO</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="n">tcp_westwood</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">tcp_westwood_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ssthresh</span>	<span class="o">=</span> <span class="n">tcp_reno_ssthresh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cong_avoid</span>	<span class="o">=</span> <span class="n">tcp_reno_cong_avoid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">min_cwnd</span>	<span class="o">=</span> <span class="n">tcp_westwood_bw_rttmin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cwnd_event</span>	<span class="o">=</span> <span class="n">tcp_westwood_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_info</span>	<span class="o">=</span> <span class="n">tcp_westwood_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pkts_acked</span>	<span class="o">=</span> <span class="n">tcp_westwood_pkts_acked</span><span class="p">,</span>

	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;westwood&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">tcp_westwood_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">westwood</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ICSK_CA_PRIV_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tcp_register_congestion_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_westwood</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">tcp_westwood_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_unregister_congestion_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_westwood</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">tcp_westwood_register</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">tcp_westwood_unregister</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Stephen Hemminger, Angelo Dell&#39;Aera&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;TCP Westwood+&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
