<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › arp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>arp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* linux/net/ipv4/arp.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1994 by Florian  La Roche</span>
<span class="cm"> *</span>
<span class="cm"> * This module implements the Address Resolution Protocol ARP (RFC 826),</span>
<span class="cm"> * which is used to convert IP addresses (or in the future maybe other</span>
<span class="cm"> * high-level addresses) into a low-level hardware address (like an Ethernet</span>
<span class="cm"> * address).</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes:</span>
<span class="cm"> *		Alan Cox	:	Removed the Ethernet assumptions in</span>
<span class="cm"> *					Florian&#39;s code</span>
<span class="cm"> *		Alan Cox	:	Fixed some small errors in the ARP</span>
<span class="cm"> *					logic</span>
<span class="cm"> *		Alan Cox	:	Allow &gt;4K in /proc</span>
<span class="cm"> *		Alan Cox	:	Make ARP add its own protocol entry</span>
<span class="cm"> *		Ross Martin     :       Rewrote arp_rcv() and arp_get_info()</span>
<span class="cm"> *		Stephen Henson	:	Add AX25 support to arp_get_info()</span>
<span class="cm"> *		Alan Cox	:	Drop data when a device is downed.</span>
<span class="cm"> *		Alan Cox	:	Use init_timer().</span>
<span class="cm"> *		Alan Cox	:	Double lock fixes.</span>
<span class="cm"> *		Martin Seine	:	Move the arphdr structure</span>
<span class="cm"> *					to if_arp.h for compatibility.</span>
<span class="cm"> *					with BSD based programs.</span>
<span class="cm"> *		Andrew Tridgell :       Added ARP netmask code and</span>
<span class="cm"> *					re-arranged proxy handling.</span>
<span class="cm"> *		Alan Cox	:	Changed to use notifiers.</span>
<span class="cm"> *		Niibe Yutaka	:	Reply for this device or proxies only.</span>
<span class="cm"> *		Alan Cox	:	Don&#39;t proxy across hardware types!</span>
<span class="cm"> *		Jonathan Naylor :	Added support for NET/ROM.</span>
<span class="cm"> *		Mike Shaver     :       RFC1122 checks.</span>
<span class="cm"> *		Jonathan Naylor :	Only lookup the hardware address for</span>
<span class="cm"> *					the correct hardware type.</span>
<span class="cm"> *		Germano Caronni	:	Assorted subtle races.</span>
<span class="cm"> *		Craig Schlenter :	Don&#39;t modify permanent entry</span>
<span class="cm"> *					during arp_rcv.</span>
<span class="cm"> *		Russ Nelson	:	Tidied up a few bits.</span>
<span class="cm"> *		Alexey Kuznetsov:	Major changes to caching and behaviour,</span>
<span class="cm"> *					eg intelligent arp probing and</span>
<span class="cm"> *					generation</span>
<span class="cm"> *					of host down events.</span>
<span class="cm"> *		Alan Cox	:	Missing unlock in device events.</span>
<span class="cm"> *		Eckes		:	ARP ioctl control errors.</span>
<span class="cm"> *		Alexey Kuznetsov:	Arp free fix.</span>
<span class="cm"> *		Manuel Rodriguez:	Gratuitous ARP.</span>
<span class="cm"> *              Jonathan Layes  :       Added arpd support through kerneld</span>
<span class="cm"> *                                      message queue (960314)</span>
<span class="cm"> *		Mike Shaver	:	/proc/sys/net/ipv4/arp_* support</span>
<span class="cm"> *		Mike McLagan    :	Routing by source</span>
<span class="cm"> *		Stuart Cheshire	:	Metricom and grat arp fixes</span>
<span class="cm"> *					*** FOR 2.1 clean this up ***</span>
<span class="cm"> *		Lawrence V. Stefani: (08/12/96) Added FDDI support.</span>
<span class="cm"> *		Alan Cox	:	Took the AP1000 nasty FDDI hack and</span>
<span class="cm"> *					folded into the mainstream FDDI code.</span>
<span class="cm"> *					Ack spit, Linus how did you allow that</span>
<span class="cm"> *					one in...</span>
<span class="cm"> *		Jes Sorensen	:	Make FDDI work again in 2.1.x and</span>
<span class="cm"> *					clean up the APFDDI &amp; gen. FDDI bits.</span>
<span class="cm"> *		Alexey Kuznetsov:	new arp state machine;</span>
<span class="cm"> *					now it is in net/core/neighbour.c.</span>
<span class="cm"> *		Krzysztof Halasa:	Added Frame Relay ARP support.</span>
<span class="cm"> *		Arnaldo C. Melo :	convert /proc/net/arp to seq_file</span>
<span class="cm"> *		Shmulik Hen:		Split arp_send to arp_create and</span>
<span class="cm"> *					arp_xmit so intermediate drivers like</span>
<span class="cm"> *					bonding can change the skb before</span>
<span class="cm"> *					sending (e.g. insert 8021q tag).</span>
<span class="cm"> *		Harald Welte	:	convert to make use of jenkins hash</span>
<span class="cm"> *		Jesper D. Brouer:       Proxy ARP PVLAN RFC 3069 support.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/fddidevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/icmp.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/protocol.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &lt;net/ax25.h&gt;</span>
<span class="cp">#include &lt;net/netrom.h&gt;</span>

<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/netfilter_arp.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *	Interface to generic neighbour cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">arp_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pkey</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">hash_rnd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arp_constructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">arp_solicit</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">arp_error_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">parp_redo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">arp_generic_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">solicit</span> <span class="o">=</span>		<span class="n">arp_solicit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_report</span> <span class="o">=</span>		<span class="n">arp_error_report</span><span class="p">,</span>
	<span class="p">.</span><span class="n">output</span> <span class="o">=</span>		<span class="n">neigh_resolve_output</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connected_output</span> <span class="o">=</span>	<span class="n">neigh_connected_output</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">arp_hh_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">solicit</span> <span class="o">=</span>		<span class="n">arp_solicit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_report</span> <span class="o">=</span>		<span class="n">arp_error_report</span><span class="p">,</span>
	<span class="p">.</span><span class="n">output</span> <span class="o">=</span>		<span class="n">neigh_resolve_output</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connected_output</span> <span class="o">=</span>	<span class="n">neigh_resolve_output</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">arp_direct_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">output</span> <span class="o">=</span>		<span class="n">neigh_direct_output</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connected_output</span> <span class="o">=</span>	<span class="n">neigh_direct_output</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">arp_broken_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">solicit</span> <span class="o">=</span>		<span class="n">arp_solicit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_report</span> <span class="o">=</span>		<span class="n">arp_error_report</span><span class="p">,</span>
	<span class="p">.</span><span class="n">output</span> <span class="o">=</span>		<span class="n">neigh_compat_output</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connected_output</span> <span class="o">=</span>	<span class="n">neigh_compat_output</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">neigh_table</span> <span class="n">arp_tbl</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">key_len</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hash</span>		<span class="o">=</span> <span class="n">arp_hash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">constructor</span>	<span class="o">=</span> <span class="n">arp_constructor</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proxy_redo</span>	<span class="o">=</span> <span class="n">parp_redo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>		<span class="o">=</span> <span class="s">&quot;arp_cache&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">parms</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tbl</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span>
		<span class="p">.</span><span class="n">base_reachable_time</span>	<span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">retrans_time</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gc_staletime</span>		<span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">reachable_time</span>		<span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">delay_probe_time</span>	<span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">queue_len_bytes</span>	<span class="o">=</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ucast_probes</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mcast_probes</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">anycast_delay</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proxy_delay</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proxy_qlen</span>		<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">locktime</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">gc_interval</span>	<span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="p">.</span><span class="n">gc_thresh1</span>	<span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
	<span class="p">.</span><span class="n">gc_thresh2</span>	<span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
	<span class="p">.</span><span class="n">gc_thresh3</span>	<span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arp_tbl</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">arp_mc_map</span><span class="p">(</span><span class="n">__be32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">haddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ARPHRD_ETHER</span>:
	<span class="k">case</span> <span class="n">ARPHRD_FDDI</span>:
	<span class="k">case</span> <span class="n">ARPHRD_IEEE802</span>:
		<span class="n">ip_eth_mc_map</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ARPHRD_INFINIBAND</span>:
		<span class="n">ip_ib_mc_map</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ARPHRD_IPGRE</span>:
		<span class="n">ip_ipgre_mc_map</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">haddr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u32</span> <span class="nf">arp_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pkey</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		    <span class="n">__u32</span> <span class="o">*</span><span class="n">hash_rnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">arp_hashfn</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">pkey</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">hash_rnd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_constructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_parms</span> <span class="o">*</span><span class="n">parms</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">inet_addr_type</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">parms</span> <span class="o">=</span> <span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">arp_parms</span><span class="p">;</span>
	<span class="n">__neigh_parms_put</span><span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">parms</span><span class="p">);</span>
	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">parms</span> <span class="o">=</span> <span class="n">neigh_parms_clone</span><span class="p">(</span><span class="n">parms</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">=</span> <span class="n">NUD_NOARP</span><span class="p">;</span>
		<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arp_direct_ops</span><span class="p">;</span>
		<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">neigh_direct_output</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Good devices (checked by reading texts, but only Ethernet is</span>
<span class="cm">		   tested)</span>

<span class="cm">		   ARPHRD_ETHER: (ethernet, apfddi)</span>
<span class="cm">		   ARPHRD_FDDI: (fddi)</span>
<span class="cm">		   ARPHRD_IEEE802: (tr)</span>
<span class="cm">		   ARPHRD_METRICOM: (strip)</span>
<span class="cm">		   ARPHRD_ARCNET:</span>
<span class="cm">		   etc. etc. etc.</span>

<span class="cm">		   ARPHRD_IPDDP will also work, if author repairs it.</span>
<span class="cm">		   I did not it, because this driver does not work even</span>
<span class="cm">		   in old paradigm.</span>
<span class="cm">		 */</span>

<span class="cp">#if 1</span>
		<span class="cm">/* So... these &quot;amateur&quot; devices are hopeless.</span>
<span class="cm">		   The only thing, that I can say now:</span>
<span class="cm">		   It is very sad that we need to keep ugly obsolete</span>
<span class="cm">		   code to make them happy.</span>

<span class="cm">		   They should be moved to more reasonable state, now</span>
<span class="cm">		   they use rebuild_header INSTEAD OF hard_start_xmit!!!</span>
<span class="cm">		   Besides that, they are sort of out of date</span>
<span class="cm">		   (a lot of redundant clones/copies, useless in 2.1),</span>
<span class="cm">		   I wonder why people believe that they work.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ARPHRD_ROSE</span>:
<span class="cp">#if IS_ENABLED(CONFIG_AX25)</span>
		<span class="k">case</span> <span class="n">ARPHRD_AX25</span>:
<span class="cp">#if IS_ENABLED(CONFIG_NETROM)</span>
		<span class="k">case</span> <span class="n">ARPHRD_NETROM</span>:
<span class="cp">#endif</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arp_broken_ops</span><span class="p">;</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RTN_MULTICAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">=</span> <span class="n">NUD_NOARP</span><span class="p">;</span>
			<span class="n">arp_mc_map</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IFF_NOARP</span> <span class="o">|</span> <span class="n">IFF_LOOPBACK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">=</span> <span class="n">NUD_NOARP</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RTN_BROADCAST</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_POINTOPOINT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">=</span> <span class="n">NUD_NOARP</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">)</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arp_hh_ops</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arp_generic_ops</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">&amp;</span> <span class="n">NUD_VALID</span><span class="p">)</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">connected_output</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arp_error_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dst_link_failure</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arp_solicit</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">saddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="o">*</span><span class="n">dst_ha</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probes</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">probes</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">IN_DEV_ARP_ANNOUNCE</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">0</span>:		<span class="cm">/* By default announce any local IP */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">inet_addr_type</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span>
					  <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTN_LOCAL</span><span class="p">)</span>
			<span class="n">saddr</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* Restrict announcements of saddr in same subnet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">saddr</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inet_addr_type</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">saddr</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTN_LOCAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* saddr should be known to target */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inet_addr_onlink</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">saddr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">saddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* Avoid secondary IPs, get a primary/preferred one */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">saddr</span><span class="p">)</span>
		<span class="n">saddr</span> <span class="o">=</span> <span class="n">inet_select_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">RT_SCOPE_LINK</span><span class="p">);</span>

	<span class="n">probes</span> <span class="o">-=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">ucast_probes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">&amp;</span> <span class="n">NUD_VALID</span><span class="p">))</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;trying to ucast probe in NUD_INVALID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dst_ha</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">;</span>
		<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">probes</span> <span class="o">-=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">app_probes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">probes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_ARPD</span>
			<span class="n">neigh_app_ns</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">arp_send</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span>
		 <span class="n">dst_ha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_ha</span><span class="p">)</span>
		<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_ignore</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">tip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">scope</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">IN_DEV_ARP_IGNORE</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* Reply, the tip is already validated */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* Reply only if tip is configured on the incoming interface */</span>
		<span class="n">sip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">scope</span> <span class="o">=</span> <span class="n">RT_SCOPE_HOST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/*</span>
<span class="cm">		 * Reply only if tip is configured on the incoming interface</span>
<span class="cm">		 * and is in same subnet as sip</span>
<span class="cm">		 */</span>
		<span class="n">scope</span> <span class="o">=</span> <span class="n">RT_SCOPE_HOST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:	<span class="cm">/* Do not reply for scope host addresses */</span>
		<span class="n">sip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">scope</span> <span class="o">=</span> <span class="n">RT_SCOPE_LINK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:	<span class="cm">/* Reserved */</span>
	<span class="k">case</span> <span class="mi">5</span>:
	<span class="k">case</span> <span class="mi">6</span>:
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:	<span class="cm">/* Do not reply */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">inet_confirm_addr</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_filter</span><span class="p">(</span><span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">tip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*unsigned long now; */</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_ARPFILTER</span><span class="p">);</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* OBSOLETE FUNCTIONS */</span>

<span class="cm">/*</span>
<span class="cm"> *	Find an arp mapping in the cache. If not found, post a request.</span>
<span class="cm"> *</span>
<span class="cm"> *	It is very UGLY routine: it DOES NOT use skb-&gt;dst-&gt;neighbour,</span>
<span class="cm"> *	even if it exists. It is supposed that skb-&gt;dev was mangled</span>
<span class="cm"> *	by a virtual device (eql, shaper). Nobody but broken devices</span>
<span class="cm"> *	is allowed to use this function, it is scheduled to be removed. --ANK</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_set_predefined</span><span class="p">(</span><span class="kt">int</span> <span class="n">addr_hint</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">,</span>
			      <span class="n">__be32</span> <span class="n">paddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">addr_hint</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RTN_LOCAL</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;arp called for own IP address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">haddr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RTN_MULTICAST</span>:
		<span class="n">arp_mc_map</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">haddr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RTN_BROADCAST</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">haddr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">arp_find</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;arp_find is called with dst==NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">skb_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_gateway</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp_set_predefined</span><span class="p">(</span><span class="n">inet_addr_type</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">paddr</span><span class="p">),</span> <span class="n">haddr</span><span class="p">,</span>
			       <span class="n">paddr</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">__neigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paddr</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">&amp;</span> <span class="n">NUD_VALID</span> <span class="o">||</span> <span class="n">neigh_event_send</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">neigh_ha_snapshot</span><span class="p">(</span><span class="n">haddr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">neigh_release</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">neigh_release</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arp_find</span><span class="p">);</span>

<span class="cm">/* END OF OBSOLETE FUNCTIONS */</span>

<span class="cm">/*</span>
<span class="cm"> * Check if we can use proxy ARP for this path</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">arp_fwd_proxy</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">out_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">imi</span><span class="p">,</span> <span class="n">omi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IN_DEV_PROXY_ARP</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">imi</span> <span class="o">=</span> <span class="n">IN_DEV_MEDIUM_ID</span><span class="p">(</span><span class="n">in_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imi</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* place to check for proxy_arp for routes */</span>

	<span class="n">out_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_dev</span><span class="p">)</span>
		<span class="n">omi</span> <span class="o">=</span> <span class="n">IN_DEV_MEDIUM_ID</span><span class="p">(</span><span class="n">out_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">omi</span> <span class="o">!=</span> <span class="n">imi</span> <span class="o">&amp;&amp;</span> <span class="n">omi</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for RFC3069 proxy arp private VLAN (allow to send back to same dev)</span>
<span class="cm"> *</span>
<span class="cm"> * RFC3069 supports proxy arp replies back to the same interface.  This</span>
<span class="cm"> * is done to support (ethernet) switch features, like RFC 3069, where</span>
<span class="cm"> * the individual ports are not allowed to communicate with each</span>
<span class="cm"> * other, BUT they are allowed to talk to the upstream router.  As</span>
<span class="cm"> * described in RFC 3069, it is possible to allow these hosts to</span>
<span class="cm"> * communicate through the upstream router, by proxy_arp&#39;ing.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 3069: &quot;VLAN Aggregation for Efficient IP Address Allocation&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *  This technology is known by different names:</span>
<span class="cm"> *    In RFC 3069 it is called VLAN Aggregation.</span>
<span class="cm"> *    Cisco and Allied Telesyn call it Private VLAN.</span>
<span class="cm"> *    Hewlett-Packard call it Source-Port filtering or port-isolation.</span>
<span class="cm"> *    Ericsson call it MAC-Forced Forwarding (RFC Draft).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">arp_fwd_pvlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span>
				<span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">tip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Private VLAN is only concerned about the same ethernet segment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t reply on self probes (often done by windowz boxes)*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sip</span> <span class="o">==</span> <span class="n">tip</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IN_DEV_PROXY_ARP_PVLAN</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Interface to link layer: send routine and receive handler.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Create an arp packet. If (dest_hw == NULL), we create a broadcast</span>
<span class="cm"> *	message.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">arp_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">dest_ip</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">src_ip</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest_hw</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src_hw</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target_hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="n">arp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arp_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hlen</span> <span class="o">=</span> <span class="n">LL_RESERVED_SPACE</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tlen</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">needed_tailroom</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Allocate a buffer</span>
<span class="cm">	 */</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">arp_hdr_len</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">hlen</span> <span class="o">+</span> <span class="n">tlen</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">arp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">arp_hdr_len</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src_hw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">src_hw</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dest_hw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dest_hw</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Fill the device header for the ARP frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_hard_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">dest_hw</span><span class="p">,</span> <span class="n">src_hw</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill out the arp protocol part.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The arp hardware type should match the device type, except for FDDI,</span>
<span class="cm">	 * which (according to RFC 1390) should always equal 1 (Ethernet).</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Exceptions everywhere. AX.25 uses the AX.25 PID value not the</span>
<span class="cm">	 *	DIX code for the protocol. Make these device structure fields.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#if IS_ENABLED(CONFIG_AX25)</span>
	<span class="k">case</span> <span class="n">ARPHRD_AX25</span>:
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_AX25</span><span class="p">);</span>
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">AX25_P_IP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#if IS_ENABLED(CONFIG_NETROM)</span>
	<span class="k">case</span> <span class="n">ARPHRD_NETROM</span>:
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_NETROM</span><span class="p">);</span>
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">AX25_P_IP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#if IS_ENABLED(CONFIG_FDDI)</span>
	<span class="k">case</span> <span class="n">ARPHRD_FDDI</span>:
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_ETHER</span><span class="p">);</span>
		<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hln</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pln</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="n">arp_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">arp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">arp_ptr</span><span class="p">,</span> <span class="n">src_hw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">arp_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_ip</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_hw</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">arp_ptr</span><span class="p">,</span> <span class="n">target_hw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">arp_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">arp_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest_ip</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arp_create</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Send an arp packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arp_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Send it off, maybe filter it using firewalling first.  */</span>
	<span class="n">NF_HOOK</span><span class="p">(</span><span class="n">NFPROTO_ARP</span><span class="p">,</span> <span class="n">NF_ARP_OUT</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_queue_xmit</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arp_xmit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Create and send an arp packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arp_send</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">dest_ip</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">src_ip</span><span class="p">,</span>
	      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest_hw</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src_hw</span><span class="p">,</span>
	      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target_hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	No arp on this interface.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">IFF_NOARP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">arp_create</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">dest_ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span>
			 <span class="n">dest_hw</span><span class="p">,</span> <span class="n">src_hw</span><span class="p">,</span> <span class="n">target_hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">arp_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arp_send</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Process an arp request.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="n">arp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arp_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sha</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dev_type</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* arp_rcv below verifies the ARP header and verifies the device</span>
<span class="cm">	 * is ARP&#39;able.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">arp</span> <span class="o">=</span> <span class="n">arp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">htons</span><span class="p">(</span><span class="n">dev_type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ARPHRD_ETHER</span>:
	<span class="k">case</span> <span class="n">ARPHRD_FDDI</span>:
	<span class="k">case</span> <span class="n">ARPHRD_IEEE802</span>:
		<span class="cm">/*</span>
<span class="cm">		 * ETHERNET, and Fibre Channel (which are IEEE 802</span>
<span class="cm">		 * devices, according to RFC 2625) devices will accept ARP</span>
<span class="cm">		 * hardware types of either 1 (Ethernet) or 6 (IEEE 802.2).</span>
<span class="cm">		 * This is the case also of FDDI, where the RFC 1390 says that</span>
<span class="cm">		 * FDDI devices should accept ARP hardware of (1) Ethernet,</span>
<span class="cm">		 * however, to be more robust, we&#39;ll accept both 1 (Ethernet)</span>
<span class="cm">		 * or 6 (IEEE 802.2)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_ETHER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_IEEE802</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ARPHRD_AX25</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">AX25_P_IP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_AX25</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ARPHRD_NETROM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">AX25_P_IP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_NETROM</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Understand only these message types */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Extract fields</span>
<span class="cm"> */</span>
	<span class="n">arp_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">arp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sha</span>	<span class="o">=</span> <span class="n">arp_ptr</span><span class="p">;</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">arp_ptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tip</span><span class="p">,</span> <span class="n">arp_ptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *	Check for bad requests for 127.x.x.x and requests for multicast</span>
<span class="cm"> *	addresses.  If this is one such, delete it.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipv4_is_loopback</span><span class="p">(</span><span class="n">tip</span><span class="p">)</span> <span class="o">||</span> <span class="n">ipv4_is_multicast</span><span class="p">(</span><span class="n">tip</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *     Special case: We must set Frame Relay source Q.922 address</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_type</span> <span class="o">==</span> <span class="n">ARPHRD_DLCI</span><span class="p">)</span>
		<span class="n">sha</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  Process entry.  The idea here is we want to send a reply if it is a</span>
<span class="cm"> *  request for us or if it is a request for someone else that we hold</span>
<span class="cm"> *  a proxy for.  We want to add an entry to our cache if it is a reply</span>
<span class="cm"> *  to us or if it is a request for our address.</span>
<span class="cm"> *  (The assumption for this last is that if someone is requesting our</span>
<span class="cm"> *  address, they are probably intending to talk to us, so it saves time</span>
<span class="cm"> *  if we cache their address.  Their address is also probably not in</span>
<span class="cm"> *  our cache, since ours is not in their cache.)</span>
<span class="cm"> *</span>
<span class="cm"> *  Putting this another way, we only care about replies if they are to</span>
<span class="cm"> *  us, in which case we add them to the cache.  For requests, we care</span>
<span class="cm"> *  about those for us and those for our proxies.  We reply to both,</span>
<span class="cm"> *  and in the case of requests for us we add the requester to the arp</span>
<span class="cm"> *  cache.</span>
<span class="cm"> */</span>

	<span class="cm">/* Special case: IPv4 duplicate address detection packet (RFC2131) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inet_addr_type</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">tip</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTN_LOCAL</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">arp_ignore</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">))</span>
			<span class="n">arp_send</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span>
				 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">sha</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ip_route_input_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">rt</span> <span class="o">=</span> <span class="n">skb_rtable</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">addr_type</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">RTN_LOCAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">dont_send</span><span class="p">;</span>

			<span class="n">dont_send</span> <span class="o">=</span> <span class="n">arp_ignore</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont_send</span> <span class="o">&amp;&amp;</span> <span class="n">IN_DEV_ARPFILTER</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span>
				<span class="n">dont_send</span> <span class="o">=</span> <span class="n">arp_filter</span><span class="p">(</span><span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont_send</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">neigh_event_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">arp_send</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span>
						 <span class="n">dev</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
						 <span class="n">sha</span><span class="p">);</span>
					<span class="n">neigh_release</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IN_DEV_FORWARD</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">RTN_UNICAST</span>  <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">arp_fwd_proxy</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">rt</span><span class="p">)</span> <span class="o">||</span>
			     <span class="n">arp_fwd_pvlan</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">)</span> <span class="o">||</span>
			     <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span>
			      <span class="n">pneigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span> <span class="p">{</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">neigh_event_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
					<span class="n">neigh_release</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">NEIGH_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOCALLY_ENQUEUED</span> <span class="o">||</span>
				    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_HOST</span> <span class="o">||</span>
				    <span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">arp_parms</span><span class="o">-&gt;</span><span class="n">proxy_delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">arp_send</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span>
						 <span class="n">dev</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
						 <span class="n">sha</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">pneigh_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span>
						       <span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">arp_parms</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Update our ARP tables */</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">__neigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IN_DEV_ARP_ACCEPT</span><span class="p">(</span><span class="n">in_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unsolicited ARP is not accepted by default.</span>
<span class="cm">		   It is possible, that this option should be enabled for some</span>
<span class="cm">		   devices (strip is candidate)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tip</span> <span class="o">==</span> <span class="n">sip</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inet_addr_type</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sip</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTN_UNICAST</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">__neigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">NUD_REACHABLE</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">override</span><span class="p">;</span>

		<span class="cm">/* If several different ARP replies follows back-to-back,</span>
<span class="cm">		   use the FIRST one. It is possible, if several proxy</span>
<span class="cm">		   agents are active. Taking the first reply prevents</span>
<span class="cm">		   arp trashing and chooses the fastest router.</span>
<span class="cm">		 */</span>
		<span class="n">override</span> <span class="o">=</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">updated</span> <span class="o">+</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">locktime</span><span class="p">);</span>

		<span class="cm">/* Broadcast replies and request packets</span>
<span class="cm">		   do not assert neighbour reachability.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_op</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">!=</span> <span class="n">PACKET_HOST</span><span class="p">)</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">NUD_STALE</span><span class="p">;</span>
		<span class="n">neigh_update</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sha</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
			     <span class="n">override</span> <span class="o">?</span> <span class="n">NEIGH_UPDATE_F_OVERRIDE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">neigh_release</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parp_redo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arp_process</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	Receive an arp request from the device layer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="n">arp</span><span class="p">;</span>

	<span class="cm">/* ARP header, plus 2 device addresses, plus 2 IP addresses.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">arp_hdr_len</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">freeskb</span><span class="p">;</span>

	<span class="n">arp</span> <span class="o">=</span> <span class="n">arp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hln</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">||</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_NOARP</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_OTHERHOST</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_LOOPBACK</span> <span class="o">||</span>
	    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pln</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">freeskb</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_share_check</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_of_mem</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">NEIGH_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour_cb</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">NF_HOOK</span><span class="p">(</span><span class="n">NFPROTO_ARP</span><span class="p">,</span> <span class="n">NF_ARP_IN</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">arp_process</span><span class="p">);</span>

<span class="nl">freeskb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out_of_mem:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	User level interface (ioctl)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Set (create) an ARP cache entry.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_req_set_proxy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IPV4_DEVCONF_ALL</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">PROXY_ARP</span><span class="p">)</span> <span class="o">=</span> <span class="n">on</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__in_dev_get_rtnl</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IN_DEV_CONF_SET</span><span class="p">(</span><span class="n">__in_dev_get_rtnl</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">PROXY_ARP</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_req_set_public</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arpreq</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">ip</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_pa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_netmask</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_COM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_getbyhwaddr_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span><span class="p">,</span>
				      <span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pneigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">arp_req_set_proxy</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_req_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arpreq</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_PUBL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">arp_req_set_public</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_pa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_PERM</span><span class="p">)</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">|=</span> <span class="n">ATF_COM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTO_ONLINK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if IS_ENABLED(CONFIG_FDDI)</span>
	<span class="k">case</span> <span class="n">ARPHRD_FDDI</span>:
		<span class="cm">/*</span>
<span class="cm">		 * According to RFC 1390, FDDI devices should accept ARP</span>
<span class="cm">		 * hardware types of 1 (Ethernet).  However, to be more</span>
<span class="cm">		 * robust, we&#39;ll accept hardware types of either 1 (Ethernet)</span>
<span class="cm">		 * or 6 (IEEE 802.2).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">ARPHRD_FDDI</span> <span class="o">&amp;&amp;</span>
		    <span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">ARPHRD_ETHER</span> <span class="o">&amp;&amp;</span>
		    <span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">ARPHRD_IEEE802</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">neigh</span> <span class="o">=</span> <span class="n">__neigh_lookup_errno</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">neigh</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">NUD_STALE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_PERM</span><span class="p">)</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">NUD_PERMANENT</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">neigh_update</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_COM</span><span class="p">)</span> <span class="o">?</span>
				   <span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_data</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
				   <span class="n">NEIGH_UPDATE_F_OVERRIDE</span> <span class="o">|</span>
				   <span class="n">NEIGH_UPDATE_F_ADMIN</span><span class="p">);</span>
		<span class="n">neigh_release</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">arp_state_to_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span><span class="o">&amp;</span><span class="n">NUD_PERMANENT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ATF_PERM</span> <span class="o">|</span> <span class="n">ATF_COM</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span><span class="o">&amp;</span><span class="n">NUD_VALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ATF_COM</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get an ARP cache entry.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_req_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">arpreq</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">ip</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_pa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">neigh</span> <span class="o">=</span> <span class="n">neigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">=</span> <span class="n">arp_state_to_flags</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
		<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_dev</span><span class="p">));</span>
		<span class="n">neigh_release</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">arp_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span> <span class="o">=</span> <span class="n">neigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NUD_NOARP</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">neigh_update</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NUD_FAILED</span><span class="p">,</span>
					   <span class="n">NEIGH_UPDATE_F_OVERRIDE</span><span class="o">|</span>
					   <span class="n">NEIGH_UPDATE_F_ADMIN</span><span class="p">);</span>
		<span class="n">neigh_release</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arp_invalidate</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_req_delete_public</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arpreq</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">ip</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_pa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_netmask</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pneigh_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">arp_req_set_proxy</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_req_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arpreq</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">ip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_PUBL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">arp_req_delete_public</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">arp_pa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTO_ONLINK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">arp_invalidate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Handle an ARP layer I/O control request.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">arp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arpreq</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCDARP</span>:
	<span class="k">case</span> <span class="n">SIOCSARP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGARP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arpreq</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">arp_pa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_INET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPFNOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_PUBL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATF_NETMASK</span> <span class="o">|</span> <span class="n">ATF_DONTPUB</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_NETMASK</span><span class="p">))</span>
		<span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">arp_netmask</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span>
							   <span class="n">htonl</span><span class="p">(</span><span class="mh">0xFFFFFFFFUL</span><span class="p">);</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">arp_dev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">__dev_get_by_name</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">arp_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Mmmm... It is wrong... ARPHRD_NETROM==0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">.</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span><span class="p">)</span>
			<span class="n">r</span><span class="p">.</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">r</span><span class="p">.</span><span class="n">arp_flags</span> <span class="o">&amp;</span> <span class="n">ATF_COM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">.</span><span class="n">arp_ha</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGARP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCDARP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">arp_req_delete</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSARP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">arp_req_set</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGARP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">arp_req_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGARP</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_netdev_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_CHANGEADDR</span>:
		<span class="n">neigh_changeaddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">rt_cache_flush</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">arp_netdev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">arp_netdev_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Note, that it is not on notifier chain.</span>
<span class="cm">   It is necessary, that this routine was called after route cache will be</span>
<span class="cm">   flushed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arp_ifdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">neigh_ifdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	Called once on startup.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="n">arp_packet_type</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span>	<span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">),</span>
	<span class="p">.</span><span class="n">func</span> <span class="o">=</span>	<span class="n">arp_rcv</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">arp_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">arp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">neigh_table_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">);</span>

	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_packet_type</span><span class="p">);</span>
	<span class="n">arp_proc_init</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="n">neigh_sysctl_register</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">.</span><span class="n">parms</span><span class="p">,</span> <span class="s">&quot;ipv4&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_netdev_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cp">#if IS_ENABLED(CONFIG_AX25)</span>

<span class="cm">/* ------------------------------------------------------------------------ */</span>
<span class="cm">/*</span>
<span class="cm"> *	ax25 -&gt; ASCII conversion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ax2asc2</span><span class="p">(</span><span class="n">ax25_address</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">ax25_call</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">ax25_call</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;*&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AX25 */</span><span class="cp"></span>

<span class="cp">#define HBUFFERLEN 30</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arp_format_neigh_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">hbuffer</span><span class="p">[</span><span class="n">HBUFFERLEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hatype</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Convert hardware address to XX:XX:XX:XX ... form. */</span>
<span class="cp">#if IS_ENABLED(CONFIG_AX25)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hatype</span> <span class="o">==</span> <span class="n">ARPHRD_AX25</span> <span class="o">||</span> <span class="n">hatype</span> <span class="o">==</span> <span class="n">ARPHRD_NETROM</span><span class="p">)</span>
		<span class="n">ax2asc2</span><span class="p">((</span><span class="n">ax25_address</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="n">hbuffer</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
<span class="cp">#endif</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">HBUFFERLEN</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hbuffer</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="n">hbuffer</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="n">hbuffer</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">--</span><span class="n">k</span><span class="p">;</span>
	<span class="n">hbuffer</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_AX25)</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="s">&quot;%pI4&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s 0x%-10x0x%-10x%s     *        %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">tbuf</span><span class="p">,</span> <span class="n">hatype</span><span class="p">,</span> <span class="n">arp_state_to_flags</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">hbuffer</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arp_format_pneigh_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pneigh_entry</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hatype</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="s">&quot;%pI4&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-16s 0x%-10x0x%-10x%s     *        %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">tbuf</span><span class="p">,</span> <span class="n">hatype</span><span class="p">,</span> <span class="n">ATF_PUBL</span> <span class="o">|</span> <span class="n">ATF_PERM</span><span class="p">,</span> <span class="s">&quot;00:00:00:00:00:00&quot;</span><span class="p">,</span>
		   <span class="n">dev</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;*&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;IP address       HW type     Flags       &quot;</span>
			      <span class="s">&quot;HW address            Mask     Device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">neigh_seq_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NEIGH_SEQ_IS_PNEIGH</span><span class="p">)</span>
			<span class="n">arp_format_pneigh_entry</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">arp_format_neigh_entry</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">arp_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t want to confuse &quot;arp -a&quot; w/ magic entries,</span>
<span class="cm">	 * so we tell the generic iterator to skip NUD_NOARP.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">neigh_seq_start</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">NEIGH_SEQ_SKIP_NOARP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------ */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">arp_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">arp_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">neigh_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">neigh_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">arp_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">neigh_seq_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">arp_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">arp_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">arp_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;arp&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_seq_fops</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">arp_net_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;arp&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">arp_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">arp_net_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">arp_net_exit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">arp_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_net_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">arp_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
