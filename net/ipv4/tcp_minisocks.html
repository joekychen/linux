<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › tcp_minisocks.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp_minisocks.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Implementation of the Transmission Control Protocol(TCP).</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;</span>
<span class="cm"> *		Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;</span>
<span class="cm"> *		Florian La Roche, &lt;flla@stud.uni-sb.de&gt;</span>
<span class="cm"> *		Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;</span>
<span class="cm"> *		Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;</span>
<span class="cm"> *		Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *		Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;</span>
<span class="cm"> *		Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;</span>
<span class="cm"> *		Jorge Cwik, &lt;jorge@laser.satlink.net&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;net/inet_common.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_syncookies</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_tcp_syncookies</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_abort_on_overflow</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">inet_timewait_death_row</span> <span class="n">tcp_death_row</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysctl_max_tw_buckets</span> <span class="o">=</span> <span class="n">NR_FILE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period</span>		<span class="o">=</span> <span class="n">TCP_TIMEWAIT_LEN</span> <span class="o">/</span> <span class="n">INET_TWDR_TWKILL_SLOTS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">death_lock</span>	<span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">death_lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">hashinfo</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tw_timer</span>	<span class="o">=</span> <span class="n">TIMER_INITIALIZER</span><span class="p">(</span><span class="n">inet_twdr_hangman</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">),</span>
	<span class="p">.</span><span class="n">twkill_work</span>	<span class="o">=</span> <span class="n">__WORK_INITIALIZER</span><span class="p">(</span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">twkill_work</span><span class="p">,</span>
					     <span class="n">inet_twdr_twkill_work</span><span class="p">),</span>
<span class="cm">/* Short-time timewait calendar */</span>

	<span class="p">.</span><span class="n">twcal_hand</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">twcal_timer</span>	<span class="o">=</span> <span class="n">TIMER_INITIALIZER</span><span class="p">(</span><span class="n">inet_twdr_twcal_tick</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tcp_death_row</span><span class="p">);</span>

<span class="cm">/* VJ&#39;s idea. Save last timestamp seen from this destination</span>
<span class="cm"> * and hold it at least for normal timewait interval to use for duplicate</span>
<span class="cm"> * segment detection in subsequent connections, before they enter synchronized</span>
<span class="cm"> * state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_remember_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_peer</span> <span class="o">*</span><span class="n">peer</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">release_it</span><span class="p">;</span>

	<span class="n">peer</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">get_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">release_it</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">get_seconds</span><span class="p">()</span> <span class="o">-</span> <span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts_stamp</span> <span class="o">&gt;</span> <span class="n">TCP_PAWS_MSL</span> <span class="o">&amp;&amp;</span>
		     <span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts_stamp</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts_stamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span><span class="p">;</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">release_it</span><span class="p">)</span>
			<span class="n">inet_putpeer</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_tw_remember_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">tw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span> <span class="n">tw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inet_peer</span> <span class="o">*</span><span class="n">peer</span><span class="p">;</span>

	<span class="n">peer</span> <span class="o">=</span> <span class="n">twsk_getpeer</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="o">*</span><span class="n">tcptw</span> <span class="o">=</span> <span class="n">tcp_twsk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts</span> <span class="o">-</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">get_seconds</span><span class="p">()</span> <span class="o">-</span> <span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts_stamp</span> <span class="o">&gt;</span> <span class="n">TCP_PAWS_MSL</span> <span class="o">&amp;&amp;</span>
		     <span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts_stamp</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts_stamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span><span class="p">;</span>
			<span class="n">peer</span><span class="o">-&gt;</span><span class="n">tcp_ts</span>	   <span class="o">=</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inet_putpeer</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_in_window</span><span class="p">(</span><span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">s_win</span><span class="p">,</span> <span class="n">u32</span> <span class="n">e_win</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="n">s_win</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">s_win</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">before</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">e_win</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">e_win</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">end_seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * * Main purpose of TIME-WAIT state is to close connection gracefully,</span>
<span class="cm"> *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN</span>
<span class="cm"> *   (and, probably, tail of data) and one or more our ACKs are lost.</span>
<span class="cm"> * * What is TIME-WAIT timeout? It is associated with maximal packet</span>
<span class="cm"> *   lifetime in the internet, which results in wrong conclusion, that</span>
<span class="cm"> *   it is set to catch &quot;old duplicate segments&quot; wandering out of their path.</span>
<span class="cm"> *   It is not quite correct. This timeout is calculated so that it exceeds</span>
<span class="cm"> *   maximal retransmission timeout enough to allow to lose one (or more)</span>
<span class="cm"> *   segments sent by peer and our ACKs. This time may be calculated from RTO.</span>
<span class="cm"> * * When TIME-WAIT socket receives RST, it means that another end</span>
<span class="cm"> *   finally closed and we are allowed to kill TIME-WAIT too.</span>
<span class="cm"> * * Second purpose of TIME-WAIT is catching old duplicate segments.</span>
<span class="cm"> *   Well, certainly it is pure paranoia, but if we load TIME-WAIT</span>
<span class="cm"> *   with this semantics, we MUST NOT kill TIME-WAIT state with RSTs.</span>
<span class="cm"> * * If we invented some more clever way to catch duplicates</span>
<span class="cm"> *   (f.e. based on PAWS), we could truncate TIME-WAIT to several RTOs.</span>
<span class="cm"> *</span>
<span class="cm"> * The algorithm below is based on FORMAL INTERPRETATION of RFCs.</span>
<span class="cm"> * When you compare it to RFCs, please, read section SEGMENT ARRIVES</span>
<span class="cm"> * from the very beginning.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE. With recycling (and later with fin-wait-2) TW bucket</span>
<span class="cm"> * is _not_ stateless. It means, that strictly speaking we must</span>
<span class="cm"> * spinlock it. I do not want! Well, probability of misbehaviour</span>
<span class="cm"> * is ridiculously low and, seems, we could use some mb() tricks</span>
<span class="cm"> * to avoid misread sequence numbers, states etc.  --ANK</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">tcp_tw_status</span>
<span class="nf">tcp_timewait_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">tw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="n">tmp_opt</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hash_location</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="o">*</span><span class="n">tcptw</span> <span class="o">=</span> <span class="n">tcp_twsk</span><span class="p">((</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">tw</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">paws_reject</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_parse_options</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_opt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash_location</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp_opt</span><span class="p">.</span><span class="n">ts_recent</span>	<span class="o">=</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span><span class="p">;</span>
			<span class="n">tmp_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span>	<span class="o">=</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span><span class="p">;</span>
			<span class="n">paws_reject</span> <span class="o">=</span> <span class="n">tcp_paws_reject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_opt</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_substate</span> <span class="o">==</span> <span class="n">TCP_FIN_WAIT2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Just repeat all the checks of tcp_rcv_state_process() */</span>

		<span class="cm">/* Out of window, send ACK */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">paws_reject</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">tcp_in_window</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span>
				   <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span><span class="p">,</span>
				   <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span> <span class="o">+</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_wnd</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">TCP_TW_ACK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">kill</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">kill_with_rst</span><span class="p">;</span>

		<span class="cm">/* Dup ACK? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">==</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inet_twsk_put</span><span class="p">(</span><span class="n">tw</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">TCP_TW_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* New data or FIN. If new data arrive after half-duplex close,</span>
<span class="cm">		 * reset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span> <span class="o">||</span>
		    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">!=</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">kill_with_rst:</span>
			<span class="n">inet_twsk_deschedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">);</span>
			<span class="n">inet_twsk_put</span><span class="p">(</span><span class="n">tw</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">TCP_TW_RST</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* FIN arrived, enter true time-wait state. */</span>
		<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_substate</span>	  <span class="o">=</span> <span class="n">TCP_TIME_WAIT</span><span class="p">;</span>
		<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
			<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span>	  <span class="o">=</span> <span class="n">tmp_opt</span><span class="p">.</span><span class="n">rcv_tsval</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">sysctl_tw_recycle</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tcp_tw_remember_stamp</span><span class="p">(</span><span class="n">tw</span><span class="p">))</span>
			<span class="n">inet_twsk_schedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">,</span> <span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_timeout</span><span class="p">,</span>
					   <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">inet_twsk_schedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">,</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">,</span>
					   <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">TCP_TW_ACK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Now real TIME-WAIT state.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	RFC 1122:</span>
<span class="cm">	 *	&quot;When a connection is [...] on TIME-WAIT state [...]</span>
<span class="cm">	 *	[a TCP] MAY accept a new SYN from the remote TCP to</span>
<span class="cm">	 *	reopen the connection directly, if it:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	(1)  assigns its initial sequence number for the new</span>
<span class="cm">	 *	connection to be larger than the largest sequence</span>
<span class="cm">	 *	number it used on the previous connection incarnation,</span>
<span class="cm">	 *	and</span>
<span class="cm">	 *</span>
<span class="cm">	 *	(2)  returns to TIME-WAIT state if the SYN turns out</span>
<span class="cm">	 *	to be an old duplicate&quot;.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paws_reject</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* In window segment, it may be only reset or bare ack. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is TIME_WAIT assassination, in two flavors.</span>
<span class="cm">			 * Oh well... nobody has a sufficient solution to this</span>
<span class="cm">			 * protocol bug yet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_rfc1337</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">kill:</span>
				<span class="n">inet_twsk_deschedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">);</span>
				<span class="n">inet_twsk_put</span><span class="p">(</span><span class="n">tw</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">TCP_TW_SUCCESS</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">inet_twsk_schedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">,</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">,</span>
				   <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span>	  <span class="o">=</span> <span class="n">tmp_opt</span><span class="p">.</span><span class="n">rcv_tsval</span><span class="p">;</span>
			<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">inet_twsk_put</span><span class="p">(</span><span class="n">tw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">TCP_TW_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Out of window segment.</span>

<span class="cm">	   All the segments are ACKed immediately.</span>

<span class="cm">	   The only exception is new SYN. We accept it, if it is</span>
<span class="cm">	   not old duplicate and we are not in danger to be killed</span>
<span class="cm">	   by delayed old duplicates. RFC check is that it has</span>
<span class="cm">	   newer sequence number works at rates &lt;40Mbit/sec.</span>
<span class="cm">	   However, if paws works, it is reliable AND even more,</span>
<span class="cm">	   we even may relax silly seq space cutoff.</span>

<span class="cm">	   RED-PEN: we violate main RFC requirement, if this SYN will appear</span>
<span class="cm">	   old duplicate (i.e. we receive RST in reply to SYN-ACK),</span>
<span class="cm">	   we must return socket to time-wait state. It is not good,</span>
<span class="cm">	   but not fatal yet.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">paws_reject</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span>
	      <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span> <span class="o">-</span> <span class="n">tmp_opt</span><span class="p">.</span><span class="n">rcv_tsval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">isn</span> <span class="o">=</span> <span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_snd_nxt</span> <span class="o">+</span> <span class="mi">65535</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">isn</span><span class="o">++</span><span class="p">;</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">isn</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">TCP_TW_SYN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paws_reject</span><span class="p">)</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">twsk_net</span><span class="p">(</span><span class="n">tw</span><span class="p">),</span> <span class="n">LINUX_MIB_PAWSESTABREJECTED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In this case we must reset the TIMEWAIT timer.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If it is ACKless SYN it may be both old duplicate</span>
<span class="cm">		 * and new good SYN with random sequence number &lt;rcv_nxt.</span>
<span class="cm">		 * Do not reschedule in the last case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">paws_reject</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">)</span>
			<span class="n">inet_twsk_schedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">,</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">,</span>
					   <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>

		<span class="cm">/* Send ACK. Note, we do not put the bucket,</span>
<span class="cm">		 * it will be released by caller.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">TCP_TW_ACK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inet_twsk_put</span><span class="p">(</span><span class="n">tw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TCP_TW_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_timewait_state_process</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Move a socket to time-wait or dead fin-wait-2 state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_time_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">tw</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">recycle_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">sysctl_tw_recycle</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span><span class="p">)</span>
		<span class="n">recycle_ok</span> <span class="o">=</span> <span class="n">tcp_remember_stamp</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">tw_count</span> <span class="o">&lt;</span> <span class="n">tcp_death_row</span><span class="p">.</span><span class="n">sysctl_max_tw_buckets</span><span class="p">)</span>
		<span class="n">tw</span> <span class="o">=</span> <span class="n">inet_twsk_alloc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tw</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="o">*</span><span class="n">tcptw</span> <span class="o">=</span> <span class="n">tcp_twsk</span><span class="p">((</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">tw</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">rto</span> <span class="o">=</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_transparent</span>	<span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">transparent</span><span class="p">;</span>
		<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_rcv_wscale</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">;</span>
		<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_nxt</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
		<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_snd_nxt</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
		<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_rcv_wnd</span>	<span class="o">=</span> <span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span><span class="p">;</span>
		<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_ts_recent_stamp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span><span class="p">;</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_family</span> <span class="o">==</span> <span class="n">PF_INET6</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ipv6_pinfo</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">inet6_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">inet6_timewait_sock</span> <span class="o">*</span><span class="n">tw6</span><span class="p">;</span>

			<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_ipv6_offset</span> <span class="o">=</span> <span class="n">inet6_tw_offset</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">);</span>
			<span class="n">tw6</span> <span class="o">=</span> <span class="n">inet6_twsk</span><span class="p">((</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">tw</span><span class="p">);</span>
			<span class="n">tw6</span><span class="o">-&gt;</span><span class="n">tw_v6_daddr</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
			<span class="n">tw6</span><span class="o">-&gt;</span><span class="n">tw_v6_rcv_saddr</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rcv_saddr</span><span class="p">;</span>
			<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_tclass</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">tclass</span><span class="p">;</span>
			<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_ipv6only</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ipv6only</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
		<span class="cm">/*</span>
<span class="cm">		 * The timewait bucket does not have the key DB from the</span>
<span class="cm">		 * sock structure. We just make a quick copy of the</span>
<span class="cm">		 * md5 key being used (if indeed we are using one)</span>
<span class="cm">		 * so the timewait ack generating code has the key.</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
			<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_md5_key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">key</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_lookup</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_md5_key</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tcptw</span><span class="o">-&gt;</span><span class="n">tw_md5_key</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_alloc_md5sig_pool</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* Linkage updates. */</span>
		<span class="n">__inet_twsk_hashdance</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">);</span>

		<span class="cm">/* Get the TIME_WAIT timeout firing. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeo</span> <span class="o">&lt;</span> <span class="n">rto</span><span class="p">)</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">rto</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">recycle_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_timeout</span> <span class="o">=</span> <span class="n">rto</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tw</span><span class="o">-&gt;</span><span class="n">tw_timeout</span> <span class="o">=</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TCP_TIME_WAIT</span><span class="p">)</span>
				<span class="n">timeo</span> <span class="o">=</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inet_twsk_schedule</span><span class="p">(</span><span class="n">tw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_death_row</span><span class="p">,</span> <span class="n">timeo</span><span class="p">,</span>
				   <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>
		<span class="n">inet_twsk_put</span><span class="p">(</span><span class="n">tw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Sorry, if we&#39;re out of memory, just CLOSE this</span>
<span class="cm">		 * socket up.  We&#39;ve got bigger problems than</span>
<span class="cm">		 * non-graceful socket closings.</span>
<span class="cm">		 */</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPTIMEWAITOVERFLOW</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tcp_update_metrics</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_done</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tcp_twsk_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="o">*</span><span class="n">twsk</span> <span class="o">=</span> <span class="n">tcp_twsk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">twsk</span><span class="o">-&gt;</span><span class="n">tw_md5_key</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_free_md5sig_pool</span><span class="p">();</span>
		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">twsk</span><span class="o">-&gt;</span><span class="n">tw_md5_key</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tcp_twsk_destructor</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_openreq_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ecn_ok</span> <span class="o">?</span> <span class="n">TCP_ECN_OK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is not only more efficient than what we used to do, it eliminates</span>
<span class="cm"> * a lot of code duplication between IPv4/IPv6 SYN recv processing. -DaveM</span>
<span class="cm"> *</span>
<span class="cm"> * Actually, we could lots of memory writes here. tp of listening</span>
<span class="cm"> * socket contains all necessary default parameters.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">tcp_create_openreq_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span> <span class="o">=</span> <span class="n">inet_csk_clone_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_request_sock</span> <span class="o">*</span><span class="n">ireq</span> <span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tcp_request_sock</span> <span class="o">*</span><span class="n">treq</span> <span class="o">=</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">newicsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">newtp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">oldtp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">oldcvp</span> <span class="o">=</span> <span class="n">oldtp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">;</span>

		<span class="cm">/* TCP Cookie Transactions require space for the cookie pair,</span>
<span class="cm">		 * as it differs for each connection.  There is no need to</span>
<span class="cm">		 * copy any s_data_payload stored at the original socket.</span>
<span class="cm">		 * Failure will prevent resuming the connection.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Presumed copied, in order of appearance:</span>
<span class="cm">		 *	cookie_in_always, cookie_out_never</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldcvp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">newcvp</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">),</span>
					<span class="n">GFP_ATOMIC</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">newcvp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcvp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
				<span class="n">newcvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span> <span class="o">=</span>
						<span class="n">oldcvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span><span class="p">;</span>
				<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">=</span> <span class="n">newcvp</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Not Yet Implemented */</span>
				<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Now setup tcp_sock */</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">=</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">=</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">treq</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_sml</span> <span class="o">=</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">=</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_up</span> <span class="o">=</span>
			<span class="n">treq</span><span class="o">-&gt;</span><span class="n">snt_isn</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tcp_s_data_size</span><span class="p">(</span><span class="n">oldtp</span><span class="p">);</span>

		<span class="n">tcp_prequeue_init</span><span class="p">(</span><span class="n">newtp</span><span class="p">);</span>

		<span class="n">tcp_init_wl</span><span class="p">(</span><span class="n">newtp</span><span class="p">,</span> <span class="n">treq</span><span class="o">-&gt;</span><span class="n">rcv_isn</span><span class="p">);</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_INIT</span><span class="p">;</span>
		<span class="n">newicsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_INIT</span><span class="p">;</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">TCP_INFINITE_SSTHRESH</span><span class="p">;</span>
		<span class="n">tcp_enable_early_retrans</span><span class="p">(</span><span class="n">newtp</span><span class="p">);</span>

		<span class="cm">/* So many TCP implementations out there (incorrectly) count the</span>
<span class="cm">		 * initial SYN frame in their delayed-ACK and congestion control</span>
<span class="cm">		 * algorithms that we must have the following bandaid to talk</span>
<span class="cm">		 * efficiently to them.  -DaveM</span>
<span class="cm">		 */</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">TCP_INIT_CWND</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newicsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">tcp_init_congestion_ops</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">newicsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
			<span class="n">newicsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_init_congestion_ops</span><span class="p">;</span>

		<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">TCP_CA_Open</span><span class="p">);</span>
		<span class="n">tcp_init_xmit_timers</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">=</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">pushed_seq</span> <span class="o">=</span>
			<span class="n">treq</span><span class="o">-&gt;</span><span class="n">snt_isn</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tcp_s_data_size</span><span class="p">(</span><span class="n">oldtp</span><span class="p">);</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">SOCK_KEEPOPEN</span><span class="p">))</span>
			<span class="n">inet_csk_reset_keepalive_timer</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span>
						       <span class="n">keepalive_time_when</span><span class="p">(</span><span class="n">newtp</span><span class="p">));</span>

		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">sack_ok</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_fack</span><span class="p">)</span>
				<span class="n">tcp_enable_fack</span><span class="p">(</span><span class="n">newtp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">wscale_ok</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">wscale_ok</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">wscale_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">snd_wscale</span><span class="p">;</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">rcv_wscale</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">,</span> <span class="mi">65535U</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
				  <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">);</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">=</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ts_recent</span><span class="p">;</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">md5sig_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/*XXX*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newtp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_lookup</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">newsk</span><span class="p">))</span>
			<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">+=</span> <span class="n">TCPOLEN_MD5SIG_ALIGNED</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">TCP_MSS_DEFAULT</span> <span class="o">+</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">)</span>
			<span class="n">newicsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">last_seg_size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">newtp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">;</span>
		<span class="n">newtp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">mss</span><span class="p">;</span>
		<span class="n">TCP_ECN_openreq_child</span><span class="p">(</span><span class="n">newtp</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

		<span class="n">TCP_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_PASSIVEOPENS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">newsk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_create_openreq_child</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Process an incoming packet for SYN_RECV sockets represented</span>
<span class="cm"> *	as a request_sock.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">tcp_check_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">**</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="n">tmp_opt</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hash_location</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">__be32</span> <span class="n">flg</span> <span class="o">=</span> <span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCP_FLAG_RST</span><span class="o">|</span><span class="n">TCP_FLAG_SYN</span><span class="o">|</span><span class="n">TCP_FLAG_ACK</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">paws_reject</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_parse_options</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_opt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash_location</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp_opt</span><span class="p">.</span><span class="n">ts_recent</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ts_recent</span><span class="p">;</span>
			<span class="cm">/* We do not store true stamp, but it is not required,</span>
<span class="cm">			 * it can be estimated (approximately)</span>
<span class="cm">			 * from another data.</span>
<span class="cm">			 */</span>
			<span class="n">tmp_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">()</span> <span class="o">-</span> <span class="p">((</span><span class="n">TCP_TIMEOUT_INIT</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">retrans</span><span class="p">);</span>
			<span class="n">paws_reject</span> <span class="o">=</span> <span class="n">tcp_paws_reject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_opt</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check for pure retransmitted SYN. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">&amp;&amp;</span>
	    <span class="n">flg</span> <span class="o">==</span> <span class="n">TCP_FLAG_SYN</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">paws_reject</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * RFC793 draws (Incorrectly! It was fixed in RFC1122)</span>
<span class="cm">		 * this case on figure 6 and figure 8, but formal</span>
<span class="cm">		 * protocol description says NOTHING.</span>
<span class="cm">		 * To be more exact, it says that we should send ACK,</span>
<span class="cm">		 * because this segment (at least, if it has no data)</span>
<span class="cm">		 * is out of window.</span>
<span class="cm">		 *</span>
<span class="cm">		 *  CONCLUSION: RFC793 (even with RFC1122) DOES NOT</span>
<span class="cm">		 *  describe SYN-RECV state. All the description</span>
<span class="cm">		 *  is wrong, we cannot believe to it and should</span>
<span class="cm">		 *  rely only on common sense and implementation</span>
<span class="cm">		 *  experience.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Enforce &quot;SYN-ACK&quot; according to figure 8, figure 6</span>
<span class="cm">		 * of RFC793, fixed by RFC1122.</span>
<span class="cm">		 */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rsk_ops</span><span class="o">-&gt;</span><span class="n">rtx_syn_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Further reproduces section &quot;SEGMENT ARRIVES&quot;</span>
<span class="cm">	   for state SYN-RECEIVED of RFC793.</span>
<span class="cm">	   It is broken, however, it does not work only</span>
<span class="cm">	   when SYNs are crossed.</span>

<span class="cm">	   You would think that SYN crossing is impossible here, since</span>
<span class="cm">	   we should have a SYN_SENT socket (from connect()) on our end,</span>
<span class="cm">	   but this is not true if the crossed SYNs were sent to both</span>
<span class="cm">	   ends by a malicious third party.  We must defend against this,</span>
<span class="cm">	   and to do that we first verify the ACK (as per RFC793, page</span>
<span class="cm">	   36) and reset if it is invalid.  Is this a true full defense?</span>
<span class="cm">	   To convince ourselves, let us consider a way in which the ACK</span>
<span class="cm">	   test can still pass in this &#39;malicious crossed SYNs&#39; case.</span>
<span class="cm">	   Malicious sender sends identical SYNs (and thus identical sequence</span>
<span class="cm">	   numbers) to both A and B:</span>

<span class="cm">		A: gets SYN, seq=7</span>
<span class="cm">		B: gets SYN, seq=7</span>

<span class="cm">	   By our good fortune, both A and B select the same initial</span>
<span class="cm">	   send sequence number of seven :-)</span>

<span class="cm">		A: sends SYN|ACK, seq=7, ack_seq=8</span>
<span class="cm">		B: sends SYN|ACK, seq=7, ack_seq=8</span>

<span class="cm">	   So we are now A eating this SYN|ACK, ACK test passes.  So</span>
<span class="cm">	   does sequence test, SYN is truncated, and thus we consider</span>
<span class="cm">	   it a bare ACK.</span>

<span class="cm">	   If icsk-&gt;icsk_accept_queue.rskq_defer_accept, we silently drop this</span>
<span class="cm">	   bare ACK.  Otherwise, we create an established connection.  Both</span>
<span class="cm">	   ends (listening sockets) accept the new incoming connection and try</span>
<span class="cm">	   to talk to each other. 8-)</span>

<span class="cm">	   Note: This case is both harmless, and rare.  Possibility is about the</span>
<span class="cm">	   same as us discovering intelligent life on another plant tomorrow.</span>

<span class="cm">	   But generally, we should (RFC lies!) to accept ACK</span>
<span class="cm">	   from SYNACK both here and in tcp_rcv_state_process().</span>
<span class="cm">	   tcp_rcv_state_process() does not, hence, we do not too.</span>

<span class="cm">	   Note that the case is absolutely generic:</span>
<span class="cm">	   we cannot optimize anything here without</span>
<span class="cm">	   violating protocol. All the checks must be made</span>
<span class="cm">	   before attempt to create socket.</span>
<span class="cm">	 */</span>

	<span class="cm">/* RFC793 page 36: &quot;If the connection is in any non-synchronized state ...</span>
<span class="cm">	 *                  and the incoming segment acknowledges something not yet</span>
<span class="cm">	 *                  sent (the segment carries an unacceptable ACK) ...</span>
<span class="cm">	 *                  a reset is sent.&quot;</span>
<span class="cm">	 *</span>
<span class="cm">	 * Invalid ACK: reset will be sent by listening socket</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flg</span> <span class="o">&amp;</span> <span class="n">TCP_FLAG_ACK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">!=</span>
	     <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snt_isn</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tcp_s_data_size</span><span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">))))</span>
		<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* Also, it would be not so bad idea to check rcv_tsecr, which</span>
<span class="cm">	 * is essentially ACK extension and too early or too late values</span>
<span class="cm">	 * should cause reset in unsynchronized states.</span>
<span class="cm">	 */</span>

	<span class="cm">/* RFC793: &quot;first check sequence number&quot;. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paws_reject</span> <span class="o">||</span> <span class="o">!</span><span class="n">tcp_in_window</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span>
					  <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Out of window: send ACK and drop. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flg</span> <span class="o">&amp;</span> <span class="n">TCP_FLAG_RST</span><span class="p">))</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">rsk_ops</span><span class="o">-&gt;</span><span class="n">send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">paws_reject</span><span class="p">)</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_PAWSESTABREJECTED</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In sequence, PAWS is OK. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">ts_recent</span> <span class="o">=</span> <span class="n">tmp_opt</span><span class="p">.</span><span class="n">rcv_tsval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Truncate SYN, it is out of window starting</span>
<span class="cm">		   at tcp_rsk(req)-&gt;rcv_isn + 1. */</span>
		<span class="n">flg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_FLAG_SYN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* RFC793: &quot;second check the RST bit&quot; and</span>
<span class="cm">	 *	   &quot;fourth, check the SYN bit&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCP_FLAG_RST</span><span class="o">|</span><span class="n">TCP_FLAG_SYN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">TCP_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_ATTEMPTFAILS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">embryonic_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ACK sequence verified above, just make sure ACK is</span>
<span class="cm">	 * set.  If ACK not set, just silently drop the packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flg</span> <span class="o">&amp;</span> <span class="n">TCP_FLAG_ACK</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* While TCP_DEFER_ACCEPT is active, drop bare ACK. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">retrans</span> <span class="o">&lt;</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">.</span><span class="n">rskq_defer_accept</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">==</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">acked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPDEFERACCEPTDROP</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">)</span>
		<span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snt_synack</span> <span class="o">=</span> <span class="n">tmp_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">retrans</span><span class="p">)</span> <span class="cm">/* don&#39;t take RTT sample if retrans &amp;&amp; ~TS */</span>
		<span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snt_synack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* OK, ACK is valid, create big socket and</span>
<span class="cm">	 * feed this segment to it. It will repeat all</span>
<span class="cm">	 * the tests. THIS SEGMENT MUST MOVE SOCKET TO</span>
<span class="cm">	 * ESTABLISHED STATE. If it will be dropped after</span>
<span class="cm">	 * socket is created, wait for troubles.</span>
<span class="cm">	 */</span>
	<span class="n">child</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">syn_recv_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">listen_overflow</span><span class="p">;</span>

	<span class="n">inet_csk_reqsk_queue_unlink</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="n">inet_csk_reqsk_queue_removed</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="n">inet_csk_reqsk_queue_add</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">child</span><span class="p">;</span>

<span class="nl">listen_overflow:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_abort_on_overflow</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">acked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">embryonic_reset:</span>
	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_EMBRYONICRSTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flg</span> <span class="o">&amp;</span> <span class="n">TCP_FLAG_RST</span><span class="p">))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">rsk_ops</span><span class="o">-&gt;</span><span class="n">send_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">inet_csk_reqsk_queue_drop</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_check_req</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Queue segment on the new socket if the new socket is active,</span>
<span class="cm"> * otherwise we just shortcircuit this and continue with</span>
<span class="cm"> * the new socket.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tcp_child_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tcp_rcv_state_process</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
					    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="cm">/* Wakeup parent, send SIGIO */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TCP_SYN_RECV</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">state</span><span class="p">)</span>
			<span class="n">parent</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Alas, it is possible again, because we do lookup</span>
<span class="cm">		 * in main socket hash table and lock on listening</span>
<span class="cm">		 * socket does not protect us more.</span>
<span class="cm">		 */</span>
		<span class="n">__sk_add_backlog</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_child_process</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
